<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023测试</title>
    <url>/2023/03/08/test/2023%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>以下内容基于Typora软件使用Markdown语言编写</p>
</blockquote>
<h3 id="mermaid测试">mermaid测试</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br></pre></td></tr></table></figure>
<h3 id="数学公式测试">数学公式测试<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3>
<p>\frac{m \% c_3}{c_2} & =\frac{c_0 \times b_1+c_1 \times b_2+c_2 \times b_3 } {c_2}=\frac{c_0 \times b_1+c_1 \times b_2 \\}{c_2}+b_3
</p>
<h3 id="选项卡测试">选项卡测试</h3>
<div class="tab">
  <button class="tab-button" onclick="showTab('tab1')">Tab 1</button>
  <button class="tab-button" onclick="showTab('tab2')">Tab 2</button>
  <button class="tab-button" onclick="showTab('tab3')">Tab 3</button>
  <div id="tab1" class="tab-content">
    <pre><code>这是选项卡1的内容</code></pre>
  </div>
  <div id="tab2" class="tab-content">
    <pre><code>这是选项卡2的内容</code></pre>
  </div>
  <div id="tab3" class="tab-content">
    <pre><code>这是选项卡3的内容</code></pre>
  </div>
</div>
<style>
.tab-button {
  background-color: #f1f1f1;
  border: none;
  color: #333;
  padding: 8px 16px;
  cursor: pointer;
}
.tab-button:hover {
  background-color: #ddd;
}
.tab-content {
  display: none;
  padding: 16px;
}
.tab-content code {
  /* 样式设定 */
}
</style>
<script>
function showTab(tabName) {
  var tabs = document.getElementsByClassName("tab-content");
  for (var i = 0; i < tabs.length; i++) {
    tabs[i].style.display = "none";
  }
  var tab = document.getElementById(tabName);
  if (tab) {
    tab.style.display = "block";
  }
}
</script>
<h6 id="示例：">示例：</h6>
<div class="tab">
  <button class="tab-button" onclick="showTab('tab11')">0-1背包问题</button>
  <button class="tab-button" onclick="showTab('tab21')">完全背包问题</button>
  <button class="tab-button" onclick="showTab('tab31')">多重背包问题</button>
  <div id="tab11" class="tab-content">
    <pre><code>for (int i = 1; i <= n; i++)
  for (int l = W; l >= w[i]; l--)
    f[l] = max(f[l], f[l - w[i]] + v[i]);</code></pre>
  </div>
  <div id="tab21" class="tab-content">
    <pre><code>for (int i = 1; i <= n; i++)
  for (int l = w[i]; l <= W; l++)
    f[l] = max(f[l], f[l - w[i]] + v[i]);</code></pre>
  </div>
  <div id="tab31" class="tab-content">
    <pre><code>for(int i=1;i<=n;++i)&#123;
    for(int j=W;j>=w[i];--j)&#123; // 基于0-1背包核心代码基础 
        for(int k=0;k*w[i]<=j&&k<=m[i];++k)&#123;
            dp[j] = max(dp[j], dp[j-k*w[i]]+k*v[i]);
        &#125;
    &#125;
&#125;</code></pre>
  </div>
</div>
<style>
.tab-button {
  background-color: #f1f1f1;
  border: none;
  color: #333;
  padding: 8px 16px;
  cursor: pointer;
}
.tab-button:hover {
  background-color: #ddd;
}
.tab-content {
  display: none;
  padding: 16px;
}
.tab-content code {
  /* 样式设定 */
}
</style>
<script>
function showTab(tabName) {
  var tabs = document.getElementsByClassName("tab-content");
  for (var i = 0; i < tabs.length; i++) {
    tabs[i].style.display = "none";
  }
  var tab = document.getElementById(tabName);
  if (tab) {
    tab.style.display = "block";
  }
}
</script>
<h3 id="pdf在线阅读测试">PDF在线阅读测试</h3>
<iframe src="/file-pdf/mytore-course-list(test).pdf" width="100%" height="100%">  This browser does not support PDFs. Please download the PDF to view it: <a href="/file-pdf/mytore-course-list(test).pdf">Download PDF</a>  </iframe>


	<div class="row">
    <embed src="/file-pdf/mytore-course-list(test).pdf" width="100%" height="550" type="application/pdf">
	</div>



<h3 id="视频测试">视频测试</h3>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=975879338&bvid=BV1H44y1t75x&cid=423711758&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> 
    </iframe>
</div>
<blockquote>
<p><span style="color: red;">注意：</span>以上视频html代码块无法直接在Typora中显示，但是上传到博客之后可以正常显示。</p>
</blockquote>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.wgj.ink/">Wgj’s blog</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>My New Post</title>
    <url>/2023/03/01/test/My-New-Post/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="这是一个测试">这是一个测试！！！</h2>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/01/test/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>SVG测试</title>
    <url>/2023/05/19/test/SVG%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>SVG（可缩放矢量图形）与 PNG 和 JPG（位图格式）相比具有以下优势：</p>
<ol>
<li class="lvl-3"><u><strong>可无损缩放</strong></u>：SVG 是矢量图形格式，它使用数学描述图形而不是像素点。这意味着 SVG 图形可以在任何尺寸下无损缩放，而不会导致图像质量的损失。相反，PNG 和 JPG 是基于像素的位图格式，缩放时会导致图像失真和模糊。</li>
<li class="lvl-3"><u><strong>小文件大小</strong></u>：由于 SVG 使用数学描述图形，它的文件大小通常比位图格式（如 PNG 和 JPG）要小很多。这在网络传输和加载时间方面有优势，特别是对于复杂图形或需要在不同分辨率下使用的图像。</li>
<li class="lvl-3"><u><strong>可编辑性</strong></u>：SVG 文件可以在文本编辑器中轻松编辑和修改。你可以通过添加、删除或修改 SVG 元素和属性来调整图形的外观和行为。相比之下，PNG 和 JPG 是静态图像，无法直接编辑。</li>
<li class="lvl-3"><u><strong>良好的文本和图形混合性</strong></u>：由于 SVG 使用文本和矢量图形描述，它非常适合于与文本和其他图形元素混合使用。你可以在 SVG 图形中嵌入文本，并对其进行样式和布局调整，这在创建数据可视化、图表和图标等场景下非常有用。</li>
<li class="lvl-3"><u><strong>动画和交互性</strong></u>：SVG 支持动画和交互性。你可以使用 SVG 的内置动画功能（如 <code>&lt;animate&gt;</code> 元素）创建简单的动画效果，也可以使用 JavaScript 和 CSS 来控制和操作 SVG 元素，实现更复杂的交互功能。相比之下，PNG 和 JPG 是静态图像，无法直接添加动画和交互性。</li>
</ol>
</blockquote>
<h1><center>百面千相</center></h1>
<blockquote>
<p>官网：<a href="https://bmqx.papegames.com/home">https://bmqx.papegames.com/home</a></p>
</blockquote>
<h2 id="一戏之面">一戏之面</h2>
<p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 103 132" width="103" height="132" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: 100%; transform: translate3d(0px, 0px, 0px); content-visibility: visible;"><defs><clipPath id="__lottie_element_227"><rect width="103" height="132" x="0" y="0"></rect></clipPath><image xlink:href="https://assets.papegames.com/nikkiweb/bmqx/bmqxhome/_next/static/media/img_0.65e61168.png"></image><clipPath id="__lottie_element_229"><path d="M0,0 L692,0 L692,924 L0,924z"></path></clipPath><mask id="__lottie_element_232" mask-type="alpha"><g transform="matrix(2.998891592025757,0,0,2.998891592025757,-1031.4945068359375,635.91796875)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,456,-74)"><path fill="rgb(254,61,61)" fill-opacity="1" d=" M0,-74 C40.840599060058594,-74 74,-40.840599060058594 74,0 C74,40.840599060058594 40.840599060058594,74 0,74 C-40.840599060058594,74 -74,40.840599060058594 -74,0 C-74,-40.840599060058594 -40.840599060058594,-74 0,-74z"></path></g></g></mask></defs><g clip-path="url(#__lottie_element_227)"><g clip-path="url(#__lottie_element_229)" transform="matrix(0.17499999701976776,0,0,0.17499999701976776,-6.424999237060547,-11.349998474121094)" opacity="1" style="display: block;"><g transform="matrix(1,0,0,1,346,462)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,0,0)"><path stroke-linecap="butt" stroke-linejoin="miter" fill-opacity="0" stroke-miterlimit="4" stroke="rgb(254,61,61)" stroke-opacity="1" stroke-width="6" d=" M-4.416999816894531,-298.8970031738281 C-16.148000717163086,-299.1570129394531 -28.06999969482422,-298.14801025390625 -40,-295.5 C-40,-295.5 -40,-295.5 -40,-295.5 C-153.59500122070312,-270.2900085449219 -209.25,-179.75 -212.25,-171.25 C-215.25,-162.75 -217.25,-122.75 -217.25,-122.75 C-217.25,-122.75 -207.625,-106.875 -207.625,-106.875 C-207.625,-106.875 -215,-105 -215,-96.9990005493164 C-215,192.00100708007812 -33,292 -33,292 C-33,292 8.211000442504883,296.1409912109375 19,289.75 C222,169.5 202,-102.25 202,-102.25 C202,-102.25 196.25,-111.75 196.25,-111.75 C196.25,-111.75 202.5,-118 202.5,-118 C202.5,-118 205,-161.75 202.75,-166.75 C191.1479949951172,-192.53199768066406 151,-232.5 151,-232.5 C151,-232.5 78.00599670410156,-297.0639953613281 -4.416999816894531,-298.8970031738281"></path></g></g><g mask="url(#__lottie_element_232)" style="display: block;"><g transform="matrix(1,0,0,1,127,266)" opacity="1"><image width="423px" height="278px" preserveAspectRatio="xMidYMid slice" xlink:href="https://assets.papegames.com/nikkiweb/bmqx/bmqxhome/_next/static/media/img_0.65e61168.png"></image></g></g></g></g></svg></p>
<hr>
<h2 id="晦羽之面">晦羽之面</h2>
<p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 98 125" width="98" height="125" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: 100%; transform: translate3d(0px, 0px, 0px); content-visibility: visible;"><defs><clipPath id="__lottie_element_209"><rect width="98" height="125" x="0" y="0"></rect></clipPath><image xlink:href="https://assets.papegames.com/nikkiweb/bmqx/bmqxhome/_next/static/media/img_0.82328887.png"></image><clipPath id="__lottie_element_211"><path d="M0,0 L1920,0 L1920,1080 L0,1080z"></path></clipPath><mask id="__lottie_element_220" mask-type="alpha"><g transform="matrix(4.230000019073486,0,0,4.230000019073486,1686.75,685.3499755859375)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,-225,-45)"><path fill="rgb(253,61,61)" fill-opacity="1" d=" M0,-81 C44.70389938354492,-81 81,-44.70389938354492 81,0 C81,44.70389938354492 44.70389938354492,81 0,81 C-44.70389938354492,81 -81,44.70389938354492 -81,0 C-81,-44.70389938354492 -44.70389938354492,-81 0,-81z"></path></g></g></mask></defs><g clip-path="url(#__lottie_element_209)"><g clip-path="url(#__lottie_element_211)" transform="matrix(0.15299999713897705,0,0,0.15299999713897705,-62.8800048828125,-15.1199951171875)" opacity="1" style="display: block;"><g mask="url(#__lottie_element_220)" style="display: block;"><g transform="matrix(1,0,0,1,479.5,166.5)" opacity="1"><image width="496px" height="671px" preserveAspectRatio="xMidYMid slice" xlink:href="https://assets.papegames.com/nikkiweb/bmqx/bmqxhome/_next/static/media/img_0.82328887.png"></image></g></g><g transform="matrix(1,0,0,1,960,540)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,0,0)"><path stroke-linecap="butt" stroke-linejoin="miter" fill-opacity="0" stroke-miterlimit="4" stroke="rgb(254,61,61)" stroke-opacity="1" stroke-width="5" d=" M-235.1269989013672,294.36700439453125 C-233.33700561523438,294.6570129394531 -232.25,294.75 -232.25,294.75 C-232.25,294.75 -207.75,293.375 -197.625,274.375 C-187.5,255.375 -175.875,240.25 -159.375,240.75 C-151.2689971923828,240.9949951171875 -120.80000305175781,203.67599487304688 -89.7770004272461,161.53199768066406 C-57.65299987792969,117.89099884033203 -32.75,91.5 -22.5,47 C-21.82699966430664,44.07699966430664 -23.5,52.75 -29.25,57.25 C-30,57.75 -53.058998107910156,76.36000061035156 -70,61.5 C-84.25,49 -117.75,101 -120.25,112 C-121.58200073242188,117.86100006103516 -146.25,168.5 -164,168 C-181.75,167.5 -185.75,152.25 -182,147.25 C-178.25,142.25 -176.89700317382812,168.60299682617188 -154.75,155.25 C-137.75,145 -135.5,106.5 -108.75,71 C-94.24299621582031,51.74800109863281 -70,51.5 -68,54.75 C-66,58 -77,24 -46,26.25 C-36.62699890136719,26.93000030517578 -41.25,43.5 -41.25,43.5 C-41.25,43.5 -51.202999114990234,46.404998779296875 -47,38 C-45.5,35 -64.83999633789062,37.10300064086914 -55.25,52.75 C-50.5,60.5 -31.5,41.25 -31.5,41.25 C-31.5,41.25 -31.75,37 -31.75,37 C-31.75,37 -21.5,24.25 -15.5,25.5 C-9.5,26.75 -7.701000213623047,0.9789999723434448 -2.25,-8.5 C9.25,-28.5 -19.25,11.5 -17.25,-7 C-15.25,-25.5 -13.276000022888184,-21.913999557495117 -14.25,-34.25 C-15,-43.75 -26.381999969482422,-18.336000442504883 -41.5,-34.25 C-46.25,-39.25 -31.211999893188477,-25.295000076293945 -17.5,-48.5 C-1.25,-76 1.5,-97.25 1.5,-97.25 C1.5,-97.25 2,-97.75 11.25,-143.25 C12.10099983215332,-147.43600463867188 5,-139.5 4.25,-139.25 C3.5,-139 -5.5,-133 -8.5,-138.5 C-11.5,-144 -1.1759999990463257,-159.0030059814453 2.75,-164.5 C6.5,-169.75 15.82699966430664,-221.39500427246094 7,-226 C1.25,-229 -47.75,-286.75 -49.75,-306.75 C-51.75,-326.75 -103.66500091552734,-368.24700927734375 -98.25,-358.5 C-97,-356.25 -124.0719985961914,-326.8179931640625 -157.25,-323.5 C-175.5030059814453,-321.67498779296875 -194.79800415039062,-298.8169860839844 -198.5989990234375,-293.3179931640625 C-198.96299743652344,-292.7919921875 -198.18499755859375,-288.67498779296875 -198.25,-288.5 C-199,-286.5 -190,-235.75 -208,-202 C-209.8820037841797,-198.4709930419922 -206.75,-193.75 -206.75,-193.75 C-206.75,-193.75 -181.25,-145.75 -179.5,-143 C-177.75,-140.25 -177,-138.5 -174.5,-138.25 C-172,-138 -156.44500732421875,-126.6989974975586 -159,-116 C-161,-107.625 -151.875,-129 -151.875,-129 C-151.875,-129 -165.30499267578125,-131.12399291992188 -152.875,-138.125 C-142,-144.25 -140,-107.25 -158.75,-94.25 C-177.5,-81.25 -176.75,-56.5 -176.75,-52.75 C-176.75,-49 -173.58099365234375,-15.16100025177002 -155.75,-13 C-147.5,-12 -171.75,-23 -142.5,-75 C-138.5989990234375,-81.93499755859375 -132.75,-85.5 -129.75,-85.5 C-126.75,-85.5 -109.25,-102 -106.5,-113.75 C-103.75,-125.5 -105.71900177001953,-130.18299865722656 -82.5,-129.5 C-74,-129.25 -73,-116.25 -74,-114 C-75,-111.75 -47.36800003051758,-120.87100219726562 -38.375,-138 C-35.75,-143 -34,-135 -33.25,-133.5 C-32.5,-132 -19.5,-138 -8.5,-156 M-455.625,-155.625 C-453.67498779296875,-151.26499938964844 -451.4549865722656,-147.73199462890625 -449.1679992675781,-144.8820037841797"></path></g></g><g transform="matrix(1,0,0,1,960,540)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,0,0)"><path stroke-linecap="butt" stroke-linejoin="miter" fill-opacity="0" stroke-miterlimit="4" stroke="rgb(254,61,61)" stroke-opacity="1" stroke-width="5" d=" M-449.1679992675781,-144.8820037841797 C-440.8970031738281,-134.5749969482422 -431.739990234375,-133.19000244140625 -431.25,-133.875 C-430.625,-134.75 -430,-144 -426.5,-138.5 C-411.2460021972656,-114.52999877929688 -392.75,-115 -392.75,-115 C-392.75,-115 -389.75,-111 -388.25,-121.75 C-386.0220031738281,-137.72000122070312 -360.8269958496094,-130.8159942626953 -360.25,-125.75 C-358,-106 -347.25,-96.25 -344,-93 C-340.75,-89.75 -325.75,-88.25 -316,-64.5 C-303.23199462890625,-33.39899826049805 -306.75,-16 -312,-12.75 C-317.25,-9.5 -301.25,-13.5 -294.75,-22.25 C-288.25,-31 -281.5,-71 -298.25,-87.25 C-322.62298583984375,-110.8949966430664 -322.25,-128.5 -319,-134.5 C-315.75,-140.5 -305.75,-140.25 -306.5,-133 C-307.25,-125.75 -315.5,-134.25 -312.5,-128 C-309.5,-121.75 -303.5,-108.75 -306,-118.75 C-307.82000732421875,-126.02999877929688 -304.25,-122.5 -304.25,-123.75 C-304.25,-125 -289.5,-138.75 -287.25,-140.25 C-285,-141.75 -282.75,-146 -282.75,-146 C-282.75,-146 -263.75,-183.75 -263.75,-183.75 C-263.75,-183.75 -251.53599548339844,-192.43499755859375 -259.75,-208.75 C-278,-245 -263.5,-283.5 -265.5,-290.25 C-267.5,-297 -284.25,-318 -317.5,-326.5 C-350.75,-335 -366,-357 -366,-357 C-366,-357 -356.75,-368.25 -386.5,-343 C-408.1719970703125,-324.6059875488281 -401,-330.25 -421,-293.75 C-441,-257.25 -466.5,-227.75 -471,-226 C-475.5,-224.25 -471,-233.75 -473.5,-209 C-476,-184.25 -469.25,-166 -457.25,-153.5 C-445.7850036621094,-141.55799865722656 -462.25,-134.75 -463,-135.75 C-463.75,-136.75 -459.5,-137.625 -468.625,-139.25 C-477.75,-140.875 -474.375,-149.25 -476.125,-143.75 C-477.875,-138.25 -464,-67.75 -446.25,-47 C-428.5,-26.25 -416.75,-44 -422,-33.75 C-429.02301025390625,-20.038999557495117 -446.75,-36.5 -448.75,-35.5 C-452.47198486328125,-33.638999938964844 -449,-19 -449,-16.5 C-449,-3.497999906539917 -443,0.5 -447,0.25 C-461.3009948730469,-0.6439999938011169 -465,-26 -462.75,-9.75 C-458.70098876953125,19.493000030517578 -450.5,16 -450.5,16.75 C-448.00201416015625,26.740999221801758 -445.5,26 -445.5,26.25 C-445.5,26.5 -441.75,28 -435,33.25 C-428.25,38.5 -434.5,36.25 -431.25,41.25 C-428,46.25 -413.7560119628906,57.88399887084961 -409.25,54.75 C-397.75,46.75 -410.75,32.5 -415.25,38.75 C-417.7720031738281,42.25199890136719 -412.75,42.5 -414,43.25 C-424.41900634765625,49.500999450683594 -428.25,26.75 -414,26 C-383.93798828125,24.417999267578125 -397.9309997558594,54.582000732421875 -395.5,54 C-360,45.5 -334.5,97.5 -315.5,146 C-304.97601318359375,172.86500549316406 -279,145.5 -279,148 C-279,158.197998046875 -294.3869934082031,181.43299865722656 -315.5,159 C-331.5,142 -351.5,79.5 -377.5,65.625 C-396.5679931640625,55.44900131225586 -387.9880065917969,64.29900360107422 -399.875,67.125 C-433,75 -445.75,31.5 -442,46 C-434.8299865722656,73.7239990234375 -424,83 -422.5,93.5 C-421,104 -329.5,218 -323.5,227 C-318.5849914550781,234.3719940185547 -302.5,244 -296.5,242 C-290.5,240 -272.5,259 -265.5,275.75 C-259.92401123046875,289.0920104980469 -242.13600158691406,293.2340087890625 -235.1269989013672,294.36700439453125"></path></g></g></g></g></svg></p>
<hr>
<p>以上svg文件由于命名空间声明未充分定义，因此无法直接通过创建svg文件进行访问，所以经过ChatGPT修复之后的svg代码：</p>
<h3 id="一戏之面">一戏之面</h3>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 103 132" width="103" height="132" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: 100%; transform: translate3d(0px, 0px, 0px); content-visibility: visible;">
  <defs>
    <clipPath id="__lottie_element_227">
      <rect width="103" height="132" x="0" y="0"></rect>
    </clipPath>
    <image xlink:href="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/avatar/The%20face%20of%20yixi.png"></image>
    <clipPath id="__lottie_element_229">
      <path d="M0,0 L692,0 L692,924 L0,924z"></path>
    </clipPath>
    <mask id="__lottie_element_232" mask-type="alpha">
      <g transform="matrix(2.998891592025757,0,0,2.998891592025757,-1031.4945068359375,635.91796875)" opacity="1" style="display: block;">
        <g opacity="1" transform="matrix(1,0,0,1,456,-74)">
          <path fill="rgb(254,61,61)" fill-opacity="1" d=" M0,-74 C40.840599060058594,-74 74,-40.840599060058594 74,0 C74,40.840599060058594 40.840599060058594,74 0,74 C-40.840599060058594,74 -74,40.840599060058594 -74,0 C-74,-40.840599060058594 -40.840599060058594,-74 0,-74z"></path>
        </g>
      </g>
    </mask>
  </defs>
  <g clip-path="url(#__lottie_element_227)">
    <g clip-path="url(#__lottie_element_229)" transform="matrix(0.17499999701976776,0,0,0.17499999701976776,-6.424999237060547,-11.349998474121094)" opacity="1" style="display: block;">
      <g transform="matrix(1,0,0,1,346,462)" opacity="1" style="display: block;">
        <g opacity="1" transform="matrix(1,0,0,1,0,0)">
          <path stroke-linecap="butt" stroke-linejoin="miter" fill-opacity="0" stroke-miterlimit="4" stroke="rgb(254,61,61)" stroke-opacity="1" stroke-width="6" d=" M-4.416999816894531,-298.8970031738281 C-16.148000717163086,-299.1570129394531 -28.06999969482422,-298.14801025390625 -40,-295.5 C-40,-295.5 -40,-295.5 -40,-295.5 C-153.59500122070312,-270.2900085449219 -209.25,-179.75 -212.25,-171.25 C-215.25,-162.75 -217.25,-122.75 -217.25,-122.75 C-217.25,-122.75 -207.625,-106.875 -207.625,-106.875 C-207.625,-106.875 -215,-105 -215,-96.9990005493164 C-215,192.00100708007812 -33,292 -33,292 C-33,292 8.211000442504883,296.1409912109375 19,289.75 C222,169.5 202,-102.25 202,-102.25 C202,-102.25 196.25,-111.75 196.25,-111.75 C196.25,-111.75 202.5,-118 202.5,-118 C202.5,-118 205,-161.75 202.75,-166.75 C191.1479949951172,-192.53199768066406 151,-232.5 151,-232.5 C151,-232.5 78.00599670410156,-297.0639953613281 -4.416999816894531,-298.8970031738281"></path>
        </g>
      </g>
      <g mask="url(#__lottie_element_232)" style="display: block;">
        <g transform="matrix(1,0,0,1,127,266)" opacity="1">
          <image width="423px" height="278px" preserveAspectRatio="xMidYMid slice" xlink:href="https://assets.papegames.com/nikkiweb/bmqx/bmqxhome/_next/static/media/img_0.65e61168.png"></image>
        </g>
      </g>
    </g>
  </g>
</svg>
<blockquote>
<p><em><strong><u>晦羽之面的修复也相似处理即可</u></strong></em></p>
</blockquote>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>front-matter编写教程</title>
    <url>/2023/03/02/tutorials/front-matter%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="front-matter编写教程">front-matter编写教程</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_42252518/article/details/99550466">(98条消息) front-matter使用详解_front matter_略略略～的博客-CSDN博客</a></p>
<p>Hexo官方参考：<a href="https://hexo.io/zh-cn/docs/front-matter.html">https://hexo.io/zh-cn/docs/front-matter.html</a></p>
</blockquote>
<p>编写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">type: tags		# 帮助脚本识别这是一个用来创建tags的文档</span><br><span class="line">layout: tag 	# 我的tags模版标签叫tag你可以根据你的模版名称输入对应的名称</span><br><span class="line">categories: # 分类（严格的顺序结构）</span><br><span class="line">- first		# 第一级</span><br><span class="line">- second	# 第二级</span><br><span class="line">- third		# 第三级</span><br><span class="line">- fourth	# 第四级</span><br><span class="line">- ……</span><br><span class="line">tags: # 标签（多个标签均为并列关系，不存在父子关系）</span><br><span class="line">- math</span><br><span class="line">- games</span><br><span class="line">- physics</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="front-matter包含的内容">front-matter包含的内容</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302004708972.png" alt="参数list"></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>front-matter</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建流程</title>
    <url>/2023/03/01/tutorials/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>个人博客搭建</h1>
<blockquote>
<p>⭐ayer主题官方中文参考：<a href="https://shen-yu.gitee.io/2019/ayer/">https://shen-yu.gitee.io/2019/ayer/</a></p>
<p>⭐ayer主题 GitHub仓库：<a href="https://github.com/shen-yu/hexo-theme-ayer">https://github.com/shen-yu/hexo-theme-ayer</a></p>
</blockquote>
<blockquote>
<p>博客地址：<a href="https://wangguijiepedeval.github.io/">wangguijie.github.io | wangguijiepedeval.github.io</a></p>
<p>域名地址：<a href="https://www.wgj.ink/">https://www.wgj.ink/</a></p>
<p>hexo官方文档：<a href="https://hexo.io/zh-cn/docs/index.html">文档 | Hexo</a></p>
<p>（主要）参考：<a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p>更换Markdown渲染器：<a href="https://blog.csdn.net/qq_42951560/article/details/123596899">(99条消息) 【Hexo】选择更高级的Markdown渲染器_hexo markdown_Xavier Jiezou的博客-CSDN博客</a></p>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-a193a47cf70fe6ecf156e5f3d34920ea_r.jpg" alt="img"></p>
<h1>博客主题以及博客主题切换</h1>
<p>本博客采用的是<a href="https://github.com/shen-yu">shen-yu (Eric Shen) </a>的Ayer主题，Ayer在马来语中是“水”的意思，在西班牙语中是“昨天”的意思。</p>
<p>Ayer是一个干净且优雅的Hexo主题，自带响应式，加载速度很快，该有的功能都有（比如：文章发布和管理、评论和互动、文章归档和搜索等），可配置项多（包括：<em>封面配置</em>、<em>文章配置</em>、<em>是否启用搜索配置</em>、<em>访问量统计配置</em>等），非常适合作为上传学习笔记的博客主题。</p>
<p>另一主题：<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak#demo">https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak#demo</a></p>
<p><code>tranquilpeak</code></p>
<ol>
<li class="lvl-3">
<p>Download the latest <a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/archive/main.zip">version</a></p>
</li>
<li class="lvl-3">
<p>Rename the folder in <code>tranquilpeak</code> and place it in the <code>themes</code> folder of your Hexo blog</p>
</li>
<li class="lvl-3">
<p>Modify the theme in Hexo configuration file (<code>_config.yml</code>) by setting <code>theme</code> variable to <code>tranquilpeak</code></p>
</li>
<li class="lvl-3">
<p>Go to the <code>tranquilpeak</code> folder and run <code>npm install &amp;&amp; npm run prod</code></p>
</li>
<li class="lvl-3">
<p>Read <a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/main/DOCUMENTATION.md">documentation</a> to configure the theme.</p>
</li>
</ol>
<blockquote>
<p>⭐注意使用Windows的Terminal时需要使用<strong>管理员运行</strong>打开，不然会有权限限制问题。</p>
</blockquote>
<p>不同的主题对于<strong>hexo的配置文件</strong><code>_config.xml</code>中的参数格式会有不同的要求，因此切换不同主题时注意甄别修改。</p>
<p>比如<strong>tranquilpeak主题</strong>的keywords要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keywords:</span><br><span class="line">- hexo</span><br><span class="line">- javascript</span><br></pre></td></tr></table></figure>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231016211044507.png" alt="image-20231016211044507"></p>
<h1>博客页面布局及其设计思路</h1>
<h3 id="1、主界面">1、主界面</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710013922215.png" alt="image-20230710013922215"></p>
<p>封面显示博客网站名称，下方通过“打字特效”的方式呈现设定好的文本内容；</p>
<p>网站左侧边栏显示菜单可选项，包括：主页、归档、分类、标签……。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710014747540.png" alt="image-20230710014747540"></p>
<p>网站主页下方显示的是最新上传的文章精简信息（包括置顶文章：红色标签“sticky”标记），点击即可进入对应的文章界面。</p>
<h3 id="2、归档界面">2、归档界面</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710015003143.png" alt="image-20230710015003143"></p>
<p>根据时间日期降序显示上传文章。</p>
<h3 id="3、分类界面">3、分类界面</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710015121079.png" alt="image-20230710015121079"></p>
<p>根据<code>.md</code>文件中<code>Front-matter</code>中的目录结构生成对应的分类结构。</p>
<h3 id="4、标签界面">4、标签界面</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710015229533.png" alt="image-20230710015229533"></p>
<p>根据<code>.md</code>文件中<code>Front-matter</code>中的<code>tag</code>结构生成对应的标签。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 个人博客搭建流程</span><br><span class="line">author: Guijie Wang</span><br><span class="line">categories: # 分类</span><br><span class="line">- 教程</span><br><span class="line">tags: # 标签</span><br><span class="line">- 博客搭建</span><br><span class="line">- hexo</span><br><span class="line">description: &quot;本文介绍如何使用 Hexo 快速搭建个人博客，并分享一些实用的主题和插件。&quot;</span><br><span class="line">top: True # 文章置顶（需要安装相关插件）</span><br></pre></td></tr></table></figure>
<h3 id="5、文档界面">5、文档界面</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710015333186.png" alt="image-20230710015333186"></p>
<p>文档界面嵌入了PDF阅读器，可以在线阅读上传的PDF文件。</p>
<h3 id="6、播放器界面">6、播放器界面</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710015436038.png" alt="image-20230710015436038"></p>
<p>播放界面嵌入了音乐播放器和视频播放器：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>音乐播放器：实现了音乐播放的基本功能（播放、暂停、循环、随机播放等）。</p>
</li>
<li class="lvl-2">
<p>视频播放器：嵌入固定的视频代码，实现视频的播放。</p>
</li>
</ul>
<h3 id="7、个人信息界面">7、个人信息界面</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230710015629863.png" alt="image-20230710015629863"></p>
<p>个人信息界面主要是展示博客作者的相关信息。</p>
<h1>博客功能实现及其技术选择</h1>
<h2 id="Git与Nodejs的相关配置">Git与Nodejs的相关配置</h2>
<h4 id="Windows下配置与GitHub的连接">Windows下配置与GitHub的连接</h4>
<p>首先在windows上产生公钥私钥对：</p>
<ol>
<li class="lvl-3">
<p>用Git Bash工具产生（需要安装git）：</p>
<ol>
<li class="lvl-6">打开 Git Bash工具 输入命令 <code>ssh-keygen</code></li>
<li class="lvl-6">输入完命令一直按回车即可</li>
<li class="lvl-6">在 <code>C:\Users\wgj\.ssh</code> 的目录中生成了两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥</li>
<li class="lvl-6">将id_rsa.pub中的信息写入GitHub中的SSH and GPG keys中：
<ul class="lvl-4">
<li class="lvl-8"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230301164653254.png" alt="image-20230301164653254"></li>
<li class="lvl-8"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230301164725171.png" alt="image-20230301164725171"></li>
</ul>
</li>
<li class="lvl-6">最后在GitBash中验证即可：
<ul class="lvl-4">
<li class="lvl-8"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230301164804006.png" alt="image-20230301164804006"></li>
<li class="lvl-8">验证成功！</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="npm的相关配置">npm的相关配置</h3>
<blockquote>
<p>修改npm的config文件：npm config edit</p>
<ul class="lvl-1">
<li class="lvl-2"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230301214142053.png" alt="image-20230301214142053"></li>
</ul>
<p>直接设置npm的config文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认global安装的目录</span></span><br><span class="line">npm config set prefix &quot;C:\D\downLoad\node\node_global&quot;   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认的cache文件目录</span></span><br><span class="line">npm config set cache &quot;C:\D\downLoad\node\node_cache&quot;</span><br><span class="line">              </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PS：新安装的nodejs最好设置以上两个默认路径，否则会默认安装到C盘下</span></span><br><span class="line">              </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置镜像</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前使用的镜像地址命令</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="front-matter使用教程">front-matter使用教程</h3>
<blockquote>
<p>网络参考：<a href="https://blog.csdn.net/weixin_42252518/article/details/99550466">(98条消息) front-matter使用详解_front matter_略略略～的博客-CSDN博客</a></p>
<p>Hexo官方参考：<a href="https://hexo.io/zh-cn/docs/front-matter.html">https://hexo.io/zh-cn/docs/front-matter.html</a></p>
</blockquote>
<h2 id="Hexo">Hexo</h2>
<h3 id="1、常用命令">1、常用命令</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>
<h3 id="2、日常推送">2、日常推送</h3>
<p>写好文章之后在博客目录下执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br></pre></td></tr></table></figure>
<h2 id="文章置顶">文章置顶</h2>
<p>下载如下插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<h3 id="置顶方法">置顶方法</h3>
<p>在front-matter中加入<code>top: True</code> 即可</p>
<h3 id="（可选）文章排序规则">（可选）文章排序规则</h3>
<p>在root config.yml文件中添加或修改以下部分：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>path</strong>: Root path for your blogs index page. (default = ‘’)</p>
</li>
<li class="lvl-2">
<p><strong>per_page</strong>: Posts displayed per page. (0 = disable pagination)</p>
</li>
<li class="lvl-2">
<p><strong>order_by</strong>: Posts order. (Order by date descending by default)</p>
</li>
</ul>
<h2 id="插件-可选">插件(可选)</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a> 用于文章置顶</p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a> 用于文章加密</p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer</a> 用于播放音乐</p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/MoePlayer/hexo-tag-dplayer">hexo-tag-dplayer</a> 用于播放视频</p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">hexo-helper-live2d</a> 二次元看板娘</p>
</li>
</ul>
<p>更多插件请见 <a href="https://hexo.io/plugins/">hexo 插件市场</a></p>
<h2 id="valine文章评论功能">valine文章评论功能</h2>
<h4 id="1、获取APP-ID-和-APP-Key">1、获取APP ID 和 APP Key</h4>
<p>登录LeanCloud创建应用获取APP ID 和 APP Key</p>
<blockquote>
<p>参考：<a href="https://valine.js.org/quickstart.html">快速开始 | Valine 一款快速、简洁且高效的无后端评论系统。</a></p>
<p>LeanCloud官网：<a href="https://console.leancloud.cn/apps">LeanCloud</a></p>
</blockquote>
<h4 id="2、启用评论功能">2、启用评论功能</h4>
<p>在博客主题Ayer文件下的_config.yml文件中添加app_id、app_key以及启用相应的功能</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230418223521043.png" alt="image-20230418223521043"></p>
<h2 id="gitalk文章评论功能">gitalk文章评论功能</h2>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/ayuayue/article/details/109198490">为hexo增加gitalk评论系统-CSDN博客</a></p>
</blockquote>
<h4 id="1、创建评论仓库wgj-blog-talk">1、创建评论仓库<code>wgj_blog_talk</code></h4>
<h4 id="2、创建OAuth-Apps">2、创建<code>OAuth Apps</code></h4>
<p>在github的个人settings中左边栏最下main的<code>Developer settings</code>中找到<code>OAuth Apps</code>，填写如下信息进行注册，获得id和secret。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231016214654587.png" alt="image-20231016214654587" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/20200925170806924.png" alt="image" style="zoom:50%;" />
<p>填写相关信息，完成设置：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231016213353796.png" alt="image-20231016213353796" style="zoom:50%;" />
<h2 id="博客实现pdf在线预览">博客实现pdf在线预览</h2>
<h3 id="PDF文件准备">PDF文件准备</h3>
<ol>
<li class="lvl-3">
<p>在<code>wgj-Hexo-Blog\source\</code>目录下新增文件夹用于存储和管理PDF文件：<code>file-pdf/</code></p>
</li>
<li class="lvl-3">
<p>将PDF存放到<code>file-pdf/</code>文件夹之后，再通过以下<mark>方法</mark>在<code>_post/</code>目录下的<code>.md</code>文件中引用即可</p>
<ul class="lvl-2">
<li class="lvl-5">⭐<mark>引用路径格式</mark>：<code>/file-pdf/mytore-course-list(test).pdf</code></li>
</ul>
</li>
</ol>
<h3 id="方法一-hexo-pdf插件渲染">方法一:hexo-pdf插件渲染</h3>
<blockquote>
<p>特点：</p>
<ul class="lvl-1">
<li class="lvl-2">专门为hexo博客开发，具有丰富的功能（推荐）</li>
<li class="lvl-2"><mark>不支持文件名有空格</mark>
<ul class="lvl-3">
<li class="lvl-4">（eg:<code>mytore course list(test).pdf</code>❌ | <code>mytore-course-list(test).pdf</code>✔️）</li>
</ul>
</li>
</ul>
</blockquote>
<p>下载hexo-pdf插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure>
<p>在<code>.md</code>文件中引用：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% pdf /file-pdf/mytore-course-list(test).pdf %&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将以上引用代码插入到<code>.md</code>文件中想要插入的位置即可。</p>
</blockquote>
<h3 id="方法二-HTML的iframe标签">方法二:HTML的iframe标签</h3>
<blockquote>
<p>特点：</p>
<ul class="lvl-1">
<li class="lvl-2">可以支持文件名有空格（eg:<code>mytore course list(test).pdf</code>）</li>
<li class="lvl-2"><mark>不好控制显示的pdf的高度</mark></li>
</ul>
</blockquote>
<p>基于Typora(Markdown)支持部分HTML的条件下，采用如下HTML语句实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;/file-pdf/mytore-course-list(test).pdf&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span>  </span><br><span class="line">    This browser does not support PDFs. Please download the PDF to view it: </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/file-pdf/mytore-course-list(test).pdf&quot;</span>&gt;</span>Download PDF<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><u><em><strong>以下参考内容部分有用，部分没用（需仔细甄别）</strong></em></u></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_43827595/article/details/104574959">(113条消息) 【如何在网页中实现pdf在线预览】10分钟学会如何利用Hexo博客上传本地pdf文件并在线预览pdf_博客可以直接看pdf吗_捡起一束光的博客-CSDN博客</a></p>
<p>参考2：<a href="https://cloud.tencent.com/developer/article/2065822">Hexo -18- 添加 PDF 阅读功能-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>基于PDFjs参考：<a href="https://blog.csdn.net/m0_59464010/article/details/123361053">(113条消息) 如何在hexo博客中在线阅读pdf_hexo的pdf插件_冰山一树Sankey的博客-CSDN博客</a></p>
</blockquote>
<h3 id="新建book导航栏">新建book导航栏</h3>
<p>（1）新建book导航栏</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page book</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之后在index.md文件中设置front-matter</span></span><br></pre></td></tr></table></figure>
<p>（2）在主题配置文件<code>_config.yml</code>中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Book:</span></span><br><span class="line">   <span class="attr">url:</span> <span class="string">/book</span></span><br><span class="line">   <span class="comment"># icon: fas fa-book</span></span><br></pre></td></tr></table></figure>
<p>（3）然后在book文件夹中的index.md中添加生成的pdf文件链接即可</p>
<h2 id="博客引入音视频播放器">博客引入音视频播放器</h2>
<h3 id="使用iframe标签加载视频">使用<code>iframe</code>标签加载视频</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=975879338&amp;bvid=BV1H44y1t75x&amp;cid=423711758&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;</span> <span class="attr">autoplay</span>=<span class="string">&quot;false&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更换视频只需要在（以bilibili为例）视频下方的<u><strong>分享</strong></u>处点击<mark>嵌入代码</mark>获取视频的链接，然后将链接替换掉以上代码中的<code>src</code>的链接即可。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>以上代码已经完善了设备布局的<strong>自适应</strong></p>
</li>
</ul>
<blockquote>
<p>新建<code>播放器</code>导航栏：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page player</span><br></pre></td></tr></table></figure>
<p>之后在index.md文件中设置front-matter即可</p>
</blockquote>
<h3 id="使用aplayer插件加载音乐播放器">使用<code>aplayer</code>插件加载音乐播放器</h3>
<p>1、安装aplayer插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure>
<p>2、在本插件中使用 MetingJS，Hexo配置文件<code>_config.yml</code>中设置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/metowolf/MetingJS">MetingJS</a> 是基于<a href="https://github.com/metowolf/Meting">Meting API</a> 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。</p>
</blockquote>
<p>3、按照如下格式在.md文件中插入即可</p>
<p>（1）单个歌曲插入：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% meting &quot;3986040&quot; &quot;netease&quot; &quot;song&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure>
<p>（2）歌单插入：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% meting &quot;627070825&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PS：获取歌曲或者歌单的id">PS：获取歌曲或者歌单的id</h5>
<p>登录网页版的音乐网站，点击进入一个歌单便可在URL中看到id：7489569642</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518204910597.png" alt="image-20230518204910597"></p>
<p>或者点击<u><strong>分享</strong></u>，复制链接：</p>
<p><a href="https://i.y.qq.com/n2/m/share/details/taoge.html?id=7489569642&amp;hosteuin=">https://i.y.qq.com/n2/m/share/details/taoge.html?id=7489569642&amp;hosteuin=</a></p>
<blockquote>
<p>注意如果要修改歌曲或者歌单</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>data-id</strong>：单曲ID / 歌单ID</li>
<li class="lvl-2"><strong>data-server</strong>：音乐平台</li>
</ul>
</blockquote>
<h5 id="参数表">参数表</h5>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">是否必须</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述&amp;可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">data-id</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
<td style="text-align:left">单曲ID / 歌单ID / 专辑ID / 搜索关键词</td>
</tr>
<tr>
<td style="text-align:left">data-server</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
<td style="text-align:left">音乐平台：<code>netease</code>,<code>tencent</code>,<code>kugou</code>,<code>xiami</code>,<code>baidu</code></td>
</tr>
<tr>
<td style="text-align:left">data-type</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
<td style="text-align:left">音乐类型：<code>song</code>,<code>playlist</code>,<code>album</code>,<code>search</code>,<code>artist</code></td>
</tr>
<tr>
<td style="text-align:left">data-mode</td>
<td style="text-align:left"><strong>已弃用</strong></td>
<td style="text-align:left"><code>circulation</code></td>
<td style="text-align:left">播放模式：<code>circulation</code>,<code>random</code>,<code>single</code>,<code>order</code> 使用 <code>data-loop</code> <code>data-order</code> 字段代替</td>
</tr>
<tr>
<td style="text-align:left">data-autoplay</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left">是否自动播放，移动端浏览器不支持该选项</td>
</tr>
<tr>
<td style="text-align:left">data-mutex</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">播放时是否暂停其他<code>APlayer</code>对象</td>
</tr>
<tr>
<td style="text-align:left">data-listmaxheight</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>340px</code></td>
<td style="text-align:left">播放列表最高高度</td>
</tr>
<tr>
<td style="text-align:left">data-preload</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>auto</code></td>
<td style="text-align:left">音乐预加载模式：<code>none</code>, <code>metadata</code>, <code>auto</code></td>
</tr>
<tr>
<td style="text-align:left">data-theme</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>#2980b9</code></td>
<td style="text-align:left">主题色</td>
</tr>
<tr>
<td style="text-align:left">data-mini</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left">是否开启迷你模式</td>
</tr>
<tr>
<td style="text-align:left">data-loop</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>all</code></td>
<td style="text-align:left">循环方式：<code>all</code>, <code>one</code>, <code>none</code></td>
</tr>
<tr>
<td style="text-align:left">data-order</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>list</code></td>
<td style="text-align:left">播放顺序：<code>list</code>, <code>random</code></td>
</tr>
<tr>
<td style="text-align:left">data-lrc</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">data-list-folded</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left">歌单列表初始时是否折叠</td>
</tr>
<tr>
<td style="text-align:left">data-volume</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>0.7</code></td>
<td style="text-align:left">用户未自定义前的默认初始化音量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_44093867/article/details/104166514">(113条消息) hexo博客插入图片与视频方法_可以插入视频的 博客_多才coder的博客-CSDN博客</a></p>
<p>参考：<a href="https://blog.csdn.net/hushhw/article/details/88092728">(113条消息) Hexo主题插入音乐之aplayer音乐播放器_hexo-tag-aplayer_hushhw的博客-CSDN博客</a></p>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://tianma8023.github.io/post/hexo-embed-aplayer/">Hexo 折腾：音乐播放 | Tianma (tianma8023.github.io)</a></p>
</li>
</ul>
</blockquote>
<h2 id="Gravatar全球通用头像">Gravatar全球通用头像</h2>
<blockquote>
<p>Gravatar官网：<a href="https://en.gravatar.com/">Gravatar - Globally Recognized Avatars</a></p>
</blockquote>
<h3 id="简述：">简述：</h3>
<p>Gravatar的概念首先是在国外的独立WordPress博客中兴起的，当你到任何一个支持Gravatar的网站留言时，这个网站都会根据你所提供的Email地址为你显示出匹配的头像。当然，这个头像，是需要你事先到Gravatar的网站注册并上传的，否则，在这个网站上，就只会显示成一个默认的头像。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/Cappuccino_jay/article/details/105466276">(109条消息) Gravatar了解与学习_Cappuccino-jay的博客-CSDN博客</a></p>
</blockquote>
<h3 id="头像配置">头像配置</h3>
<p>登录或注册<a href="http://cn.gravatar.com/">Gravatar</a>，然后修改自己的头像。</p>
<p>评论的时候，留下在<a href="http://cn.gravatar.com/">Gravatar</a>注册时所使用的邮箱即可显示自己设置的头像。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{注意：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：</span></span></span></span>如果你修改了头像后发现没有更新，请不要慌张，因为<code>gravatar.cat.net</code> 有七天的缓存期，安静的等待吧~</p>
</blockquote>
<blockquote>
<p>参考：<a href="https://valine.js.org/avatar.html">头像配置 | Valine 一款快速、简洁且高效的无后端评论系统。</a></p>
</blockquote>
<h1>博客制作过程中遇到的问题及其解决方法</h1>
<h2 id="遇到的问题">遇到的问题</h2>
<h4 id="1、关于Git-Bash无法打开的错误（闪退）">1、关于Git Bash无法打开的错误（闪退）</h4>
<p>解决：</p>
<ol>
<li class="lvl-3">
<p>配置环境变量：<code>C:\Program Files\Git\bin</code></p>
</li>
<li class="lvl-3">
<p>在Windows Terminal中配置C:\Program Files\Git\bin目录下的bash.exe快捷启动方式;</p>
<ul class="lvl-2">
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230301162808194.png" alt="image-20230301162808194"></li>
</ul>
</li>
</ol>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/u012724595/article/details/114740935">(98条消息) windows下git bash安装与环境变量设置_git bash 环境变量_sning999的博客-CSDN博客</a></p>
</blockquote>
<h4 id="2、Hexo部署出现错误err-Spawn-failed">2、Hexo部署出现错误err: Spawn failed</h4>
<p>解决一：</p>
<ol>
<li class="lvl-3">
<p>删去博客目录下的.deploy_git文件</p>
</li>
<li class="lvl-3">
<p>再次运行<code>npm install hexo-deployer-git</code>命令下载发布插件</p>
<ul class="lvl-2">
<li class="lvl-5">如果npm需要更新则现将npm进行更新</li>
</ul>
</li>
<li class="lvl-3">
<p>最后<code>hexo g &amp;&amp; hexo d</code>即可</p>
</li>
</ol>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_41256398/article/details/117994899?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117994899-blog-106876940.235%5Ev32%5Epc_relevant_default_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117994899-blog-106876940.235%5Ev32%5Epc_relevant_default_base3&amp;utm_relevant_index=2">(113条消息) Hexo部署出现错误err: Error: Spawn failed解决方式_wei-xiansen的博客-CSDN博客</a></p>
</blockquote>
<p>若以上方法无法解决，并且出现错误：<span style="color: red;">fatal: bad config line 1 in file C:/Users/wgj/.gitconfig</span></p>
<p>解决二：</p>
<ol>
<li class="lvl-3">
<p>删去<code>C:/Users/wgj/</code>目录下的<code>.gitconfig</code>文件；</p>
</li>
<li class="lvl-3">
<p>重新配置用户名和邮箱，输入下面的命令：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>git config --global user.name &quot;用户名&quot;</code></li>
<li class="lvl-5"><code>git config --global user.email &quot;邮箱&quot;</code></li>
</ul>
</li>
<li class="lvl-3">
<p>之后会生成新的<code>.gitconfig</code>文件。</p>
</li>
<li class="lvl-3">
<p>最后继续解决问题：<span style="color: red;">err: Spawn failed</span></p>
<ol>
<li class="lvl-6">删除 <code>.deploy_git</code> 文件夹；</li>
<li class="lvl-6">输入 <code>git config --global core.autocrlf false</code>；</li>
<li class="lvl-6">最后，依次执行：<code>hexo clean</code>，<code>hexo g</code>，<code>hexo s</code>，<code>hexo d</code>。</li>
</ol>
</li>
</ol>
<blockquote>
<p>参考：</p>
<ul class="lvl-1">
<li class="lvl-2">git错误参考：<a href="https://www.cnblogs.com/dotnet261010/p/10844090.html">https://www.cnblogs.com/dotnet261010/p/10844090.html</a></li>
<li class="lvl-2">Spawn failed参考：<a href="https://blog.csdn.net/qq_28919533/article/details/124338891">https://blog.csdn.net/qq_28919533/article/details/124338891</a></li>
</ul>
</blockquote>
<h2 id="注意事项">注意事项</h2>
<ol>
<li class="lvl-3">
<p>编写md文件时注意不要在代码块前设置排序，否则部署上去后会出现文本格式混乱</p>
</li>
</ol>
<h2 id="博客搭建相关资源">博客搭建相关资源</h2>
<h3 id="LOGO设计">LOGO设计</h3>
<blockquote>
<p>参考：<a href="https://www.logosc.cn/">LOGO设计神器；公司logo在线设计生成器 - 标小智LOGO神器 (logosc.cn)</a></p>
<p>链接：<a href="https://www.logosc.cn/logo/monogram?s=w">w字母图标生成器 | 汉字徽章图标一键生成 - 标小智LOGO神器 (logosc.cn)</a></p>
</blockquote>
<h3 id="iconfinder：丰富的图标库">iconfinder：丰富的图标库</h3>
<blockquote>
<p>参考：<a href="https://www.iconfinder.com/">7,400,000+ free and premium vector icons, illustrations and 3D illustrations (iconfinder.com)</a></p>
</blockquote>
<h3 id="获取网站Logo">获取网站Logo</h3>
<blockquote>
<p>参考：<a href="https://juejin.cn/post/6987258296881119262">下载网站 favicon 图标的 3 种方法 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>最常用的方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>格式为 <code>域名/favicon.ico</code>，比如：<code>https://www.google.com/favicon.ico</code></p>
</li>
</ul>
<h3 id="front-matter编写教程">front-matter编写教程</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_42252518/article/details/99550466">(98条消息) front-matter使用详解_front matter_略略略～的博客-CSDN博客</a></p>
<p>Hexo官方参考：<a href="https://hexo.io/zh-cn/docs/front-matter.html">https://hexo.io/zh-cn/docs/front-matter.html</a></p>
</blockquote>
<p>编写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">type: tags		# 帮助脚本识别这是一个用来创建tags的文档</span><br><span class="line">layout: tag 	# 我的tags模版标签叫tag你可以根据你的模版名称输入对应的名称</span><br><span class="line">categories: # 分类（严格的顺序结构）</span><br><span class="line">- first		# 第一级</span><br><span class="line">- second	# 第二级</span><br><span class="line">- third		# 第三级</span><br><span class="line">- fourth	# 第四级</span><br><span class="line">- ……</span><br><span class="line">tags: # 标签（多个标签均为并列关系，不存在父子关系）</span><br><span class="line">- math</span><br><span class="line">- games</span><br><span class="line">- physics</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h4 id="front-matter包含的内容">front-matter包含的内容</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302004708972.png" alt="参数list"></p>
<h1>总结</h1>
<p>本次博客搭建目的是为了方便本人分享大学课程知识、科研内容以及编程笔记等计算机相关内容，目的是为了方便总结归纳所学知识以及为有需要的“同志”提供个人的学习心得作为参考，充分体现互联网的共享互助精神。</p>
<p>通过搭建个人博客，</p>
<p>对<u><strong>域名注册</strong></u>、<u><strong>网站建设</strong></u>、<u><strong>前端设计</strong></u>、<u><strong>搜索引擎优化</strong></u>等有了一定的了解和掌握；</p>
<p>对<u><strong>网站开发技术</strong></u>，如HTML、CSS、JavaScript等技术进一步熟悉并运用；</p>
<p>对<u><strong>一定阶段内的自我学习成果</strong></u>进行总结和归纳。</p>
<blockquote>
<h5 id="1、SEO相关术语。">1、SEO相关术语。</h5>
<p>SEO (Search Engine Optimization)，译为<mark>搜索引擎优化</mark></p>
<p>SEO相关术语：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>PV (Page View)：<u><em>PV是用户访问网站时所浏览的总网页数</em></u></p>
</li>
<li class="lvl-2">
<p>百度快照：<u><em>百度蜘蛛在爬取网页内容时，将网页文本内容独立创建一个文本文件，保存在百度数据库中的网页的“照片”。</em></u></p>
</li>
<li class="lvl-2">
<p>SEO黑帽（SEO black hat）：<u><em>简单来说，SEO黑帽就是采用了搜索引擎所禁止的方法（作弊），对网站在搜索引擎的排名进行优化，在短时间内排到搜索引擎前列。</em></u></p>
</li>
<li class="lvl-2">
<p>SEO白帽（SEO white hat）：<u><em>白帽所指的是采用合理的SEO行为优化网站，提高用户的体验，合理与其他网站互联，从而达到网站在搜索引擎排名的稳步提升。</em></u></p>
</li>
<li class="lvl-2">
<p>跳出率：<u><em>是指来到网站只浏览了一个页面就离开的用户占网站总浏览用户的百分比。</em></u></p>
</li>
<li class="lvl-2">
<p>沙盒效应(Sandbox)：<u><em>指一个新建立的网站在刚上线的一个或几个月内，在搜索引擎上很难有好的排名，甚至没有排名。</em></u></p>
</li>
<li class="lvl-2">
<p>SPAM(Specially Processed Assorted Meat): <u><em>指专门针对那些欺骗搜索引擎的技术。搜索引擎垃圾技术是利用不道德的技巧去提高自己搜索引擎上的排名</em></u></p>
</li>
</ul>
<h5 id="2、SEO常用的技术。">2、SEO常用的技术。</h5>
<ol>
<li class="lvl-3">
<p>网页title的优化</p>
</li>
<li class="lvl-3">
<p>关键词的选取</p>
</li>
<li class="lvl-3">
<p>关键词的优化</p>
</li>
<li class="lvl-3">
<p>元标签及网页描述的优化</p>
</li>
<li class="lvl-3">
<p>网站结构和URL优化</p>
</li>
<li class="lvl-3">
<p>robots.txt文件</p>
</li>
<li class="lvl-3">
<p>网页链接的优化</p>
</li>
<li class="lvl-3">
<p>Heading标签的优化</p>
</li>
<li class="lvl-3">
<p>图片优化</p>
</li>
<li class="lvl-4">
<p>网页减肥</p>
</li>
</ol>
<p>SEO常用作弊方法：</p>
<ol>
<li class="lvl-3">
<p>桥页(Doorway Pages)</p>
</li>
<li class="lvl-3">
<p>关键词堆砌(Keyword Stuffing)</p>
</li>
<li class="lvl-3">
<p>隐藏文字(Hidden Text)</p>
</li>
<li class="lvl-3">
<p>隐藏链接(Hidden Link)</p>
</li>
<li class="lvl-3">
<p>隐藏页面(Cloaked Page)</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>个人旅行</title>
    <url>/2023/03/02/Personal%20life/travel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="个人旅行">个人旅行</h2>
<p><strong>《秋浦歌》</strong></p>
<p>唐·李白</p>
<p>逻人横鸟道，江祖出鱼梁。</p>
<p>水急客舟疾，山花拂面香。</p>
]]></content>
      <categories>
        <category>个人</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>排序进阶</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/11-%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>排序进阶</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/535/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=535">统计数字 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/205/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=205">错误票据 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/531/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=531">奖学金 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h2 id="排序">排序</h2>
<p>基于比较的低效算法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>选择排序、插入排序、冒泡排序。时间复杂度0(n<sup>2</sup>)。</p>
</li>
</ul>
<p>基于比较的高效算法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>归并排序、快速排序、堆排序。时间复杂度0(n*logn)。</p>
</li>
</ul>
<p>基于数值划分的高效算法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>计数排序、基数排序、桶排序。时间复杂度0(n)。</p>
</li>
</ul>
<h4 id="c-的sort-函数">C++的sort()函数</h4>
<p>复杂度：O(nlogn)</p>
<p>sort()自带4种排序：less、greater、less_equal、greater_equal。缺省情况下，程序是按从小到大的顺序排序的，less可以不写。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>     </span>&#123;<span class="keyword">return</span> (i &lt; j);&#125;  <span class="comment">//自定义小于</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_greater</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>  </span>&#123;<span class="keyword">return</span> (i &gt; j);&#125;  <span class="comment">//自定义大于</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">4</span>);                          <span class="comment">//对前4个排序，结果：2 3 5 7 6 8 5 4</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;   <span class="comment">//下面可以复制这一行打印</span></span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">8</span>,<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());              <span class="comment">//结果：2 3 4 5 5 6 7 8</span></span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">8</span>,my_less); 	       <span class="comment">//自定义排序，结果：2 3 4 5 5 6 7 8</span></span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">8</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());           <span class="comment">//从大到小排序，结果：8 7 6 5 5 4 3 2</span></span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">8</span>,my_greater);               <span class="comment">//结果：8 7 6 5 5 4 3 2</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),my_greater);   <span class="comment">//结果：8 7 6 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;c.<span class="built_in">size</span>(); i++)  cout&lt;&lt;c[i]&lt;&lt;<span class="string">&quot; &quot;</span>;cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    string s=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;s;                              <span class="comment">//输出 dehllloorw      注意第一个是空格</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计数排序">计数排序</h3>
<p>例：{9, 3, 5, 4, 9, 1, 2, 7, 8, 1, 3, 6, 5, 3, 4, 0, 10, 9, 7, 9}。</p>
<p>先找出最大值 10 和最小值为 0，<u>对应计数范围是0 ~ 10</u>。</p>
<p>然后每一个整数按照其值对号入座。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个整数是9：a[9]加1</p>
</li>
<li class="lvl-2">
<p>第二个整数是3：a[3]加1</p>
</li>
<li class="lvl-2">
<p>第三个整数是5：a[5]加1</p>
</li>
<li class="lvl-2">
<p>每个数字对号入座，a[i]的值等于数字i出现的次数</p>
</li>
<li class="lvl-2">
<p>输出：遍历数组a[]，a[i]的值是几，就输出i几次</p>
</li>
<li class="lvl-2">
<p>计算复杂度：O(n+k)  n是数字的个数，k是数字的范围</p>
</li>
<li class="lvl-2">
<p>空间复杂度：O(k)</p>
</li>
<li class="lvl-2">
<p>当n和k接近时，计数排序很好</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406012652849.png" alt="image-20230406012652849" style="zoom: 25%;" />
<h5 id="局限性：">局限性：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>数列最大最小值差距过大时，不适用于计数排序。例如20个随机整数，范围在 0 到 1 亿之间，如果使用计数排序的话，就需要创建长度为 1 亿的数组，严重浪费了空间，而且时间复杂度也随之升高。</p>
</li>
<li class="lvl-2">
<p>当数列元素不是整数时，并不适用于计数排序。</p>
</li>
</ul>
<h3 id="快速排序">快速排序</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>把序列分成左右两部分，使得左边所有的数都比右边的数小；</p>
</li>
<li class="lvl-2">
<p>递归这个过程，直到不能再分为止。</p>
</li>
<li class="lvl-2">
<p>如何把序列分成左右两部分？最简单的办法是设定两个临时空间X、Y和一个基准数t；检查序列中所有的元素，比t小的放在X中，比t大的放在Y中。</p>
</li>
<li class="lvl-2">
<p>不过，其实不用这么麻烦，直接在原序列上操作就行了，不需要使用临时空间X、Y。</p>
</li>
</ul>
<h5 id="复杂度：">复杂度：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>每一次划分，都把序列分成了左右两部分，在这个过程中，需要比较所有的元素，有O(n)次。</p>
</li>
<li class="lvl-2">
<p>如果每次划分是对称的，左右两部分的长度差不多，那么一共需要划分O(logn)次。</p>
</li>
<li class="lvl-2">
<p>总复杂度O(nlogn)。</p>
</li>
</ul>
<h5 id="优点：">优点：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>一般情况下快速排序效率很高，比稳定的归并排序更好。</p>
</li>
<li class="lvl-2">
<p>可以观察到，快速排序的代码比归并排序的代码简洁，代码中的比较、交换、拷贝操作很少。</p>
</li>
<li class="lvl-2">
<p>快速排序几乎是目前所有排序法中速度最快的方法。</p>
</li>
</ul>
<h5 id="缺点：">缺点：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果划分不是对称的，左部分和右部分的数量差别很大。在极端情况下，例如左部分只有1个数，剩下的全部都在右部分，那么最多可能划分n次，总复杂度是O(n<sup>2</sup>)。</p>
</li>
<li class="lvl-2">
<p>所以，快速排序是不稳定的。</p>
</li>
</ul>
<h3 id="归并排序">归并排序</h3>
<p>归并排序是由递归实现的，主要是<mark>分而治之的思想</mark>，也就是通过将问题分解成多个容易求解的局部性小问题来解开原本的问题的技巧。</p>
<p>归并排序在<mark>合并两个已排序数组时</mark>，如果遇到了相同的元素，只要保证前半部分数组优先于后半部分数组， 相同元素的顺序就不会颠倒。所以归并排序属于<mark>稳定的排序算法</mark>。</p>
<p>每次分别排左半边和右半边，不断递归调用自己，直到只有一个元素递归结束，开始回溯，调用 merge 函数，合并两个有序序列，再合并的时候每次给末尾追上一个最大 int 这样就不怕最后一位的数字不会被排序。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406013233578.png" alt="image-20230406013233578" style="zoom: 25%;" />
<p>示例：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407001335483.png" alt="image-20230407001335483"></p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/10-%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>图论</h1>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_43627118/article/details/99542485">(107条消息) 疯子的算法总结(八) 最短路算法+模板_风骨散人Chiam的博客-CSDN博客</a></p>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1121">蓝桥公园- 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1122">蓝桥王国 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1366">随机数据下的最短路问题 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h3 id="图论的基本概念">图论的基本概念</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>图：由点(node，或者vertex)和连接点的边(edge)组成。</p>
</li>
<li class="lvl-2">
<p>图是点和边构成的网。</p>
</li>
</ul>
<h4 id="图的应用背景">图的应用背景</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>地图：路口、道路、过路费…</p>
</li>
<li class="lvl-2">
<p>计算机网络：路由协议</p>
</li>
<li class="lvl-2">
<p>人际关系：“六度空间理论”。世界上任意两个人，最多通过五个中间人就能联系到。把人看成点，人和人之间的关系看成边，这就是一个图的连通性问题。</p>
</li>
</ul>
<h3 id="树：特殊的图">树：特殊的图</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>树，即连通无环图</p>
</li>
<li class="lvl-2">
<p>树的结点从根开始，层层扩展子树，是一种层次关系，这种层次关系，保证了树上不会出现环路。</p>
</li>
<li class="lvl-2">
<p>两点之间的路径：有且仅有一条路径。</p>
</li>
<li class="lvl-2">
<p>最近公共祖先。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405154346945.png" alt="image-20230405154346945" style="zoom: 25%;" />
<h4 id="图的种类">图的种类</h4>
<p>（1）无向无权图，边没有权值、没有方向；</p>
<p>（2）有向无权图，边有方向、无权值；</p>
<p>（3）加权无向图，边有权值，但没有方向；</p>
<p>（4）加权有向图；</p>
<p>（5）有向无环图（Directed Acyclic Graph，DAG）。</p>
<h3 id="图算法的复杂度">图算法的复杂度</h3>
<p>和边的数量E、点的数量V相关：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>O(V+E)：几乎是图问题中能达到的最好程度。</p>
</li>
<li class="lvl-2">
<p>O(VlogE)、O(ElogV)：很好的算法。</p>
</li>
<li class="lvl-2">
<p>O(V2)、O(E2)或更高：不算是好的算法。</p>
</li>
</ul>
<h2 id="图的存储">图的存储</h2>
<p>能快速访问：图的存储，能让程序很快定位结点u和v的边(u, v) 。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数组存边：简单、空间使用最少；无法快递定位</p>
</li>
<li class="lvl-2">
<p>邻接矩阵：简单、空间使用最大；定位最快 <code>dis[a][b]</code></p>
</li>
<li class="lvl-2">
<p>邻接表：空间很少，定位较快</p>
</li>
<li class="lvl-2">
<p>链式前向星：空间更少，定位较快</p>
</li>
</ul>
<h3 id="数组存边">数组存边</h3>
<p>优点：简单、最省空间。</p>
<p>缺点：无法定位某条边。</p>
<p>应用：bellman-ford算法、最小生成树的kruskal算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123; <span class="type">int</span> from,to,dis;&#125;e[M]; <span class="comment">//结构体数组存边</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)        </span><br><span class="line">	cin&gt;&gt;e[i].from&gt;&gt;e[i].to&gt;&gt;e[i].dis;</span><br></pre></td></tr></table></figure>
<h3 id="邻接矩阵">邻接矩阵</h3>
<p>二维数组： <code>graph[NUM ][NUM ]</code></p>
<p>无向图：<code>graph[i][j] = graph[j][i]</code>。</p>
<p>有向图：<code>graph[i][j] != graph[j][i]</code>。</p>
<p>权值：<code>graph[i][j]</code>存结点i到j的边的权值。例如<code>graph[1][2] = 3</code>，<code>graph[2][1] = 5</code>等等。用<code>graph[i][j] = INF</code>表示i，j之间无边。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405155024177.png" alt="image-20230405155024177" style="zoom: 33%;" />
<blockquote>
<p>优点：</p>
<ul class="lvl-1">
<li class="lvl-2">适合稠密图；</li>
<li class="lvl-2">编码非常简短；</li>
<li class="lvl-2">对边的存储、查询、更新等操作又快又简单。</li>
</ul>
<p>缺点：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>存储复杂度O(V<sup>2</sup>)太高。V=10000时，空间100M。</p>
</li>
<li class="lvl-2">
<p>不能存储重边。</p>
</li>
</ul>
</blockquote>
<h3 id="邻接表和链式前向星">邻接表和链式前向星</h3>
<p>应用场景：大稀疏图。</p>
<p>优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>存储效率非常高，存储复杂度O(V+E)；</p>
</li>
<li class="lvl-2">
<p>能存储重边。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405155451788.png" alt="image-20230405155451788" style="zoom: 33%;" />
<h4 id="1-最短路问题">1、最短路问题</h4>
<table>
<thead>
<tr>
<th>问题</th>
<th>边权</th>
<th>算法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><mark>一个起点，一个终点</mark></td>
<td>非负数；  无边权（或边权为1）</td>
<td>A*</td>
<td>&lt; O((m+n)logn)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>双向广搜</td>
<td>&lt; O((m+n)logn)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>贪心最优搜索</td>
<td>&lt; O(m+n)</td>
</tr>
<tr>
<td><mark>一个起点到其他所有点</mark></td>
<td>无边权（或边权为1）</td>
<td>BFS</td>
<td>O(m+n)</td>
</tr>
<tr>
<td></td>
<td>非负数</td>
<td>Dijkstra(堆优化优先队列)</td>
<td>O((m+n)logn)</td>
</tr>
<tr>
<td></td>
<td>允许有负数</td>
<td>SPFA</td>
<td>&lt; O(mn)</td>
</tr>
<tr>
<td><mark>所有点对之间</mark></td>
<td>允许有负数</td>
<td>Floyd-Warshall</td>
<td>O(n<sup>3</sup>)</td>
</tr>
</tbody>
</table>
<h1>Floyd算法（多源、负权值，能判负圈）</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>最简单的最短路径算法，代码仅有4行</p>
</li>
<li class="lvl-2">
<p>存图：最简单的矩阵存图</p>
</li>
<li class="lvl-2">
<p>易懂，比暴力的搜索更简单易懂。</p>
</li>
<li class="lvl-2">
<p>效率不高，不能用于大图</p>
</li>
<li class="lvl-2">
<p>在某些场景下有自己的优势，难以替代。能做传递闭包问题（离散数学)</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)         <span class="comment">//floyd的三重循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)      <span class="comment">// k循环在i、j循环外面</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j]); </span><br></pre></td></tr></table></figure>
<h4 id="floyd的特点">Floyd的特点</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Floyd算法：“多源”最短路算法，一次计算能得到图中每一对结点之间（多对多）的最短路径。</p>
</li>
<li class="lvl-2">
<p>Dijkstra、Bellman-Ford、SPFA算法：“单源”最短路径算法（Single source shortest path algorithm），一次计算能得到一个起点到其他所有点（一对多）的最短路径。</p>
</li>
<li class="lvl-2">
<p>在截止目前的蓝桥杯大赛中，Floyd算法是最常见的最短路径算法。</p>
</li>
</ul>
<h4 id="floyd算法思想：动态规划">Floyd算法思想：动态规划</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>动态规划：求图上两点i、j之间的最短距离，按“从小图到全图”的步骤，在逐步扩大图的过程中计算和更新最短路。</p>
</li>
<li class="lvl-2">
<p>定义状态：<code>dp[k][i][j]</code>，i、j、k是点的编号，范围1 ~ n。状态<code>dp[k][i][j]</code>表示在包含1 ~ k点的子图上，点对i、j之间的最短路。</p>
</li>
<li class="lvl-2">
<p>状态转移方程：从子图1 ~ k-1扩展到子图1 ~ k</p>
<ul class="lvl-2">
<li class="lvl-5"><code>dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>计算过程：</p>
<p><code>dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])</code></p>
<ol>
<li class="lvl-3">
<p>虚线圆圈：包含1 ~ k-1点的子图。</p>
</li>
<li class="lvl-3">
<p><code>dp[k-1][i][j]</code>：虚线子图内的点对i、j的最短路；</p>
</li>
<li class="lvl-3">
<p><code>dp[k-1][i][k] + dp[k-1][k][j]</code>：经过k点的新路径的长度，即这条路径从i出发，先到k，再从k到终点j。</p>
</li>
<li class="lvl-3">
<p>比较：不经过k的最短路径<code>dp[k-1][i][j]</code>和经过k的新路径，较小者就是新的<code>dp[k][i][j]</code>。</p>
</li>
<li class="lvl-3">
<p>k从1逐步扩展到n：最后得到的<code>dp[n][i][j]</code>是点对i、j之间的最短路径长度。</p>
</li>
<li class="lvl-3">
<p>初值<code>dp[0][i][j]</code>：若i、j是直连的，就是它们的边长；若不直连，赋值为无穷大。</p>
</li>
<li class="lvl-3">
<p>i、j是任意点对：计算结束后得到了所有点对之间的最短路。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405160942577.png" alt="image-20230405160942577" style="zoom:33%;" />
</blockquote>
<h5 id="floyd方程简化">Floyd方程简化</h5>
<p>原方程：<code>dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])</code></p>
<p>用<mark>滚动数组</mark>简化： <code>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)         <span class="comment">//floyd的三重循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="comment">// k循环在i、j循环外面</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">                  <span class="comment">//比较：不经过k、经过k</span></span><br></pre></td></tr></table></figure>
<h4 id="floyd算法总结">Floyd算法总结</h4>
<p>（1）在一次计算后求得所有结点之间的最短距离。</p>
<p>（2）代码极其简单，是最简单的最短路算法。</p>
<p>（3）效率低下，计算复杂度是O(n<sup>3</sup>)，只能用于n &lt; 300的小规模的图。</p>
<p>（4）存图用邻接矩阵<code>dp[][]</code>。因为Floyd算法计算的结果是所有点对之间的最短路，本身就需要n<sup>2</sup>的空间，用矩阵存储最合适。</p>
<p>（5）能判断负圈。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>负圈：若图中有权值为负的边，某个经过这个负边的环路，所有边长相加的总长度也是负数，这就是负圈。在这个负圈上每绕一圈，总长度就更小，从而陷入在负圈上兜圈子的死循环。</p>
</li>
<li class="lvl-2">
<p>Floyd算法很容易判断负圈，只要在算法运行过程出现任意一个<code>dp[i][i] &lt; 0</code>就说明有负圈。因为<code>dp[i][i]</code>是从i出发，经过其他中转点绕一圈回到自己的最短路径，如果小于零，就存在负圈。</p>
</li>
</ul>
<h1>Dijkstra算法（单源、权值为非负）</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>Dijkstra：单源最短路径问题。</p>
</li>
<li class="lvl-2">
<p>优点：非常高效而且稳定。</p>
</li>
<li class="lvl-2">
<p>缺点：只能处理不含有负权边的图。</p>
</li>
<li class="lvl-2">
<p>思路：贪心思想+优先队列。</p>
</li>
</ul>
<h4 id="dijkstra算法思想">Dijkstra算法思想</h4>
<ol>
<li class="lvl-3">
<p>Dijkstra算法算是<strong>贪心思想</strong>实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的<mark>松弛</mark>操作就是，<u><em><strong>遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离</strong></em></u>，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。</p>
</li>
<li class="lvl-3">
<p>为什么是每次都是找最小的？</p>
<ul class="lvl-2">
<li class="lvl-5">因为最小边的不会被其它的点松弛，只有可能最小边去松弛别人。</li>
<li class="lvl-5">如果存在一个点K能够松弛ab的话那么一定有ak距离加上kb的距离小于ab,已知ab最短，所以不存在ak+kb&lt;ab。</li>
</ul>
</li>
</ol>
<h4 id="dijkstra算法特点">Dijkstra算法特点</h4>
<ol>
<li class="lvl-3">
<p>Dijkstra算法应用了<mark>贪心法的思想</mark>，即“抄近路走，肯定能找到最短路径”。</p>
</li>
<li class="lvl-3">
<p>算法高效稳定：</p>
<ul class="lvl-2">
<li class="lvl-5">Dijkstra的每次迭代，只需要检查上次已经确定最短路径的那些结点的邻居，检查范围很小，算法是高效的；</li>
<li class="lvl-5">每次迭代，都能得到至少一个结点的最短路径，算法是稳定的</li>
</ul>
</li>
</ol>
<h5 id="使用优先队列">使用优先队列</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>每次往队列中放新数据时，按从小到大的顺序放，<mark>采用小顶堆的方式</mark>，复杂度是O(logn)，保证最小的数总在最前面；</p>
</li>
<li class="lvl-2">
<p>找最小值，直接取B的第一个数，复杂度是O(1)。</p>
</li>
<li class="lvl-2">
<p>复杂度：用优先队列时，Dijkstra算法的复杂度是O(m*logn)，是最高效的最短路算法。</p>
</li>
</ul>
<h4 id="dijkstra算法实现流程">Dijkstra算法实现流程</h4>
<p>维护两个集合：已确定最短路径的结点集合A、这些结点向外扩散的邻居结点集合B。</p>
<p>（1）把起点s放到A中，把s所有的邻居放到B中。此时，邻居到s的距离就是直连距离。</p>
<p>（2）从B中找出距离起点s最短的结点u，放到A中。</p>
<p>（3）把u所有的新邻居放到B中。显然，u的每一条边都连接了一个邻居，每个新邻居都要加进去。其中u的一个新邻居v，它到s的距离dis(s, v)等于dis(s, u) + dis(u, v)。</p>
<p>（4）重复(2)、(3)，直到B为空时，结束。</p>
<h5 id="边权不能为负">边权不能为负</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Dijkstra的局限性是边的权值不能为负数</p>
</li>
<li class="lvl-2">
<p>Dijkstra基于BFS，计算过程是从起点s逐步往外扩散的过程，每扩散一次就用贪心得到到一个点的最短路。</p>
</li>
<li class="lvl-2">
<p>扩散要求路径越来越长，如果遇到一个负权边，会导致路径变短，使扩散失效。</p>
</li>
</ul>
<h4 id="dijkstra模板算法：">Dijkstra模板算法：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL; </span><br><span class="line"><span class="comment">//这样定义INF的好处是: INF &lt;= INF+x</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N= <span class="number">3e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from, to; <span class="type">long</span> <span class="type">long</span> w; <span class="comment">//起点，终点，权值。起点from并没有用到，e[i]的i就是from</span></span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">long</span> <span class="type">long</span> c)&#123;from=a; to=b; w=c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;e[N];          <span class="comment">//用于存储图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id; <span class="type">long</span> <span class="type">long</span> n_dis;   <span class="comment">//id：结点；n_dis：这个结点到起点的距离</span></span><br><span class="line">    <span class="built_in">s_node</span>(<span class="type">int</span> b,<span class="type">long</span> <span class="type">long</span> c)&#123;id=b; n_dis=c;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> s_node &amp; a) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> n_dis &gt; a.n_dis;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> pre[N];                                <span class="comment">//记录前驱结点，用于生成路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_path</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;            <span class="comment">//打印从s到t的最短路</span></span><br><span class="line">    <span class="keyword">if</span>(s==t)&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s); <span class="keyword">return</span>; &#125;  <span class="comment">//打印起点</span></span><br><span class="line">    <span class="built_in">print_path</span>(s, pre[t]);                 <span class="comment">//先打印前一个点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t);                      <span class="comment">//后打印当前点。最后打印的是终点t</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>  dis[N];         <span class="comment">//记录所有结点到起点的距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">1</span>;             <span class="comment">//起点s是1</span></span><br><span class="line">    <span class="type">bool</span> done[N]; <span class="comment">//done[i]=true表示到结点i的最短路径已经找到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;dis[i]=INF; done[i]=<span class="literal">false</span>; &#125;    <span class="comment">//初始化</span></span><br><span class="line">    dis[s]=<span class="number">0</span>;                           <span class="comment">//起点到自己的距离是0</span></span><br><span class="line">    priority_queue &lt;s_node&gt; Q;          <span class="comment">//优先队列，存结点信息</span></span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">s_node</span>(s, dis[s]));          <span class="comment">//起点进队列</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())   &#123;</span><br><span class="line">        s_node u = Q.<span class="built_in">top</span>();             <span class="comment">//pop出距起点s距离最小的结点u</span></span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(done[u.id])  <span class="keyword">continue</span>;       <span class="comment">//丢弃已经找到最短路径的结点。即集合A中的结点            </span></span><br><span class="line">        done[u.id]= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;e[u.id].<span class="built_in">size</span>(); i++) &#123;  <span class="comment">//检查结点u的所有邻居</span></span><br><span class="line">            edge y = e[u.id][i];         <span class="comment">//u.id的第i个邻居是y.to</span></span><br><span class="line">            <span class="keyword">if</span>(done[y.to])  <span class="keyword">continue</span>;    <span class="comment">//丢弃已经找到最短路径的邻居结点                </span></span><br><span class="line">            <span class="keyword">if</span> (dis[y.to] &gt; y.w + u.n_dis) &#123;</span><br><span class="line">                dis[y.to] = y.w + u.n_dis;</span><br><span class="line">                Q.<span class="built_in">push</span>(<span class="built_in">s_node</span>(y.to, dis[y.to]));  <span class="comment">//扩展新的邻居，放到优先队列中</span></span><br><span class="line">                pre[y.to]=u.id;  <span class="comment">//如果有需要，记录路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print_path(s,n);          //如果有需要，打印路径: 起点1，终点n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    e[i].<span class="built_in">clear</span>();<span class="comment">// 清除可能存在的元素</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(u,v,w));</span><br><span class="line">     <span class="comment">// e[v].push_back(edge(v,u,w));    //本题是单向道路</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i]&gt;=INF)  cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>   <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Bellman-ford算法（负权值、负圈）</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>单源最短路径问题：给定一个起点s，求它到图中所有n个结点的最短路径。</p>
</li>
</ul>
<h4 id="bellman-ford算法思想">Bellman-ford算法思想</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>图中每个点上站着一个“警察”。</p>
</li>
<li class="lvl-2">
<p>每个警察问邻居：走你这条路能到s吗？有多远？</p>
</li>
<li class="lvl-2">
<p>反复问多次，最后所有警察都能得到最短路。</p>
</li>
</ul>
<h5 id="问路-流程：">“问路”流程：</h5>
<p>-第1轮，给所有n个人每人一次机会，问他的邻居，到s的最短距离是多少？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>更新每人到s的最短距离。</p>
</li>
<li class="lvl-2">
<p>特别地，在s的直连邻居中，有个t，得到了到s的最短距离。（注意，算法并没有查找是哪个t）</p>
</li>
</ul>
<p>-第2轮，重复第1轮的操作。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>更新每人到s的最短距离。</p>
</li>
<li class="lvl-2">
<p>特别地，在s和t的直连邻居中，有个v，得到了到s的最短距离。</p>
</li>
</ul>
<p>-第3轮，……</p>
<h4 id="bellman-ford算法复杂度">Bellman-ford算法复杂度</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>一共需要几轮操作？每一轮操作，都至少有一个新的结点得到了到s的最短路径。所以，最多只需要n轮操作，就能完成n个结点。</p>
</li>
<li class="lvl-2">
<p>在每一轮操作中，需要检查所有m个边，更新最短距离。</p>
</li>
<li class="lvl-2">
<p>Bellman-Ford算法的复杂度：O(n*m)。</p>
</li>
</ul>
<h5 id="判断负圈">判断负圈</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Bellman-Ford能判断负圈。</p>
</li>
<li class="lvl-2">
<p>没有负圈时，只需要n轮就结束。</p>
</li>
<li class="lvl-2">
<p>如果超过n轮，最短路径还有变化，那么肯定有负圈。</p>
</li>
</ul>
<h1>SPFA算法：改进的Bellman-Ford（负权值、无负圈）</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>SPFA = 队列处理+Bellman-Ford。</p>
</li>
<li class="lvl-2">
<p>Bellman-Ford算法有很多低效或无效的操作。其核心内容，是在每一轮操作中，更新所有结点到起点s的最短距离。</p>
</li>
<li class="lvl-2">
<p>计算和调整一个结点u到s的最短距离后，如果紧接着调整u的邻居结点，这些邻居肯定有新的计算结果；而如果漫无目的地计算不与u相邻的结点，很可能毫无变化，所以这些操作是低效的。</p>
</li>
<li class="lvl-2">
<p><mark>改进</mark>：计算结点u之后，下一步只计算和调整它的邻居，能加快收敛的过程。</p>
</li>
<li class="lvl-2">
<p>这些步骤用队列进行操作，这就是SPFA。</p>
</li>
</ul>
<h4 id="spfa算法步骤">SPFA算法步骤</h4>
<p>（1）起点s入队，计算它所有邻居到s的最短距离。把s出队，状态有更新的邻居入队，没更新的不入队。</p>
<p>（2）现在队列的头部是s的一个邻居u。弹出u，更新它所有邻居的状态，把其中有状态变化的邻居入队列。</p>
<p>（3）继续以上过程，直到队列空。这也意味着，所有结点的状态都不再更新。最后的状态就是到起点s的最短路径。</p>
<h5 id="spfa算法复杂度是不稳定的">SPFA算法复杂度是不稳定的</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>弹出u之后，在后面的计算中，u可能会再次更新状态（后来发现，u借道别的结点去s，路更近）。所以，u可能需要重新入队列。</p>
</li>
<li class="lvl-2">
<p>有可能只有很少结点重新进入队列，也有可能很多。这取决于图的特征。</p>
</li>
<li class="lvl-2">
<p>所以，SPFA是不稳定的。</p>
</li>
</ul>
<h4 id="spfa模板算法：">SPFA模板算法：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> tt,<span class="type">long</span> <span class="type">long</span> ww) &#123;to = tt; w = ww;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist[N];</span><br><span class="line"><span class="type">int</span> inq[N];<span class="comment">// 标记点i在队列中</span></span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;<span class="comment">// s为起点</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">// 0x3f等价于INF</span></span><br><span class="line">    dist[s] = <span class="number">0</span>;      <span class="comment">//起点到自己的距离是0</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);        <span class="comment">//从s开始，s进队列</span></span><br><span class="line">    inq[s] = <span class="number">1</span>;       <span class="comment">//起点在队列中</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[u] = <span class="number">0</span>;   <span class="comment">//u已经不在队列中</span></span><br><span class="line">        <span class="keyword">if</span>(dist[u] == INF)     <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; e[u].<span class="built_in">size</span>();i++) &#123;   <span class="comment">//遍历u的邻居</span></span><br><span class="line">            <span class="type">int</span> v = e[u][i].to;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> w = e[u][i].w;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u]+w) &#123;         <span class="comment">//u的第i个邻居v，它借道u，到s更近</span></span><br><span class="line">                dist[v] = dist[u]+w;          <span class="comment">//更新邻居v到s的距离</span></span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;      <span class="comment">//邻居v更新状态了，但v不在队列中，放进队列</span></span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,s;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)    &#123;</span><br><span class="line">        <span class="type">int</span> u,v; <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(v,w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==INF)  cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>              cout &lt;&lt; dist[i];</span><br><span class="line">        <span class="keyword">if</span>(i != n)        cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>              cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结☀">总结☀️</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Dijkstra</strong>：适用于<mark>权值为非负</mark>的图的单源最短路径，用斐波那契堆的复杂度O(E+VlgV)</p>
</li>
<li class="lvl-2">
<p><strong>BellmanFord</strong>：适用于<mark>权值有负值</mark>的图的单源最短路径，并且能够<mark>检测负圈</mark>，复杂度O(VE)</p>
</li>
<li class="lvl-2">
<p><strong>SPFA</strong>：适用于<mark>权值有负值</mark>，且<mark>没有负圈</mark>的图的单源最短路径，论文中的复杂度O(kE)，k为每个节点进入Queue的次数，且k一般&lt;=2，但此处的复杂度证明是有问题的，其实SPFA的最坏情况应该是O(VE).</p>
</li>
<li class="lvl-2">
<p><strong>Floyd</strong>：<mark>每对节点之间</mark>的最短路径，<u>负权值</u>，能<u>判断负圈</u>。</p>
</li>
</ul>
<p>单源最短路使用：</p>
<p>(1)当权值为非负时，用Dijkstra。</p>
<p>(2)当权值有负值，且没有负圈，则用SPFA。SPFA能检测负圈，但是不能输出负圈。</p>
<p>(3)当权值有负值，而且可能存在负圈需要输出，则用BellmanFord。能够检测并输出负圈。</p>
<p>多源最短路使用：Floyd（<mark>负权值，能判断负圈</mark>）</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405192831217.png" alt="image-20230405192831217"></p>
<h1>最小生成树</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>在无向图中，连通而且不含有圈（环路）的图，称为树。</p>
</li>
<li class="lvl-2">
<p><mark>最小生成树MST</mark>：一个有 n 个结点的连通图的生成树是原图的极小连通子图，<mark>包含</mark>原图中的<mark>所有 n 个结点</mark>，并且<mark>边的权值之和最小</mark>。</p>
</li>
</ul>
<h3 id="基于贪心的两种算法">基于贪心的两种算法</h3>
<p>（1）<mark>Prim算法</mark>。<u>对点进行贪心操作：“最近的邻居一定在MST上”。</u></p>
<p>从任意一个点u开始，把距离它最近的点v加入到MST中；下一步，把距离{u, v}最近的点w加入到MST中；继续这个过程，直到所有点都在MST中。</p>
<p>（2）<mark>kruskal算法</mark>。<u>对边进行贪心操作：“最短的边一定在MST上”。</u></p>
<p>从最短的边开始，把它加入到MST中；在剩下的边中找最短的边，加入到MST中；继续这个过程，直到所有点都在MST中。</p>
<h3 id="kruskal算法">kruskal算法</h3>
<p>kruskal算法的2个关键技术：</p>
<p>（1）对边进行排序。</p>
<p>（2）判断圈，即处理连通性问题。这个问题用<mark>并查集</mark>简单而高效，并查集是kruskal算法的绝配。</p>
<h4 id="kruskal算法步骤">kruskal算法步骤</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406014006760.png" alt="image-20230406014006760"></p>
<p>（1）初始时最小生成树T为空。令S是以结点i为元素的并查集，开始的时候，每个点属于独立的集。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406013849527.png" alt="image-20230406013849527" style="zoom: 25%;" />
<p>（2）加入第一个最短边(1-2)：T={1-2}。并查集S中，把结点2合并到结点1，也就是把结点2的集2改成结点1的集1。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406013905703.png" alt="image-20230406013905703" style="zoom:25%;" />
<p>（3）加入第二个最短边(3-4)：T={1-2, 3-4}。并查集S中，结点4合并到结点3。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406013917773.png" alt="image-20230406013917773" style="zoom:25%;" />
<p>（4）加入第三个最短边(2-5)：T={1-2, 3-4, 2-5}。并查集S中，把结点5合并到结点2，也就是把结点5的集5改成结点2的集1。在集1中，所有结点都指向了根结点，这样做能避免并查集的长链问题。即使用了“路径压缩”的方法。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406013929952.png" alt="image-20230406013929952" style="zoom:25%;" />
<p>（5）第四个最短边(1-5)。检查并查集S，发现5已经属于集1，丢弃这个边。这一步实际上是发现了一个圈。并查集的作用就体现在这里。</p>
<p>（6）加入第五个最短边(2-4)。并查集S中，把结点4的集并到结点2的集。注意这里结点4原来属于集3，实际上修改的是：把结点3的集3改成1。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406013948403.png" alt="image-20230406013948403" style="zoom:25%;" />
<h4 id="kruskal算法复杂度">kruskal算法复杂度</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>kruskal算法的复杂度包括两部分：对边的排序O(ElogE)，并查集的操作O(E)，一共是O(ElogE + E)，约等于O(ElogE)，时间主要花在排序上。</p>
</li>
<li class="lvl-2">
<p>如果图的边很多，kruskal的复杂度要差一些。</p>
</li>
<li class="lvl-2">
<p><mark>kruskal适用于稀疏图，prim适合稠密图</mark>。</p>
</li>
</ul>
<h5 id="kruskal算法结合并查集代码：-以下代码能通过示例-但是无法ac-可能存在问题">Kruskal算法结合并查集代码：（以下代码能通过示例，但是无法AC，可能存在问题）</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 聪明的猴子——Kruskal算法与并查集得到最小生成树 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u, v;<span class="comment">// 起点与终点 </span></span><br><span class="line">	<span class="type">double</span> w;<span class="comment">// 两点之间的距离 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">edge eg[N];</span><br><span class="line"><span class="type">int</span> monkey[NN], x[N], y[N];<span class="comment">// 分别为猴子的跳跃能力、树的x坐标与y坐标(方便求两树之间的距离w) </span></span><br><span class="line"><span class="type">int</span> parent[N];<span class="comment">// 存储结点的父节点，并查集</span></span><br><span class="line"><span class="type">int</span> m, n; <span class="comment">// 猴子的个数、树的棵树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(edge a, edge b)</span></span>&#123;<span class="comment">// 根据w升序排序 </span></span><br><span class="line">	<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 查找根节点 </span></span><br><span class="line">	<span class="keyword">if</span>(x!=parent[x])&#123;</span><br><span class="line">		parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parent[x];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">// 合并集合——连接x与y的根节点 </span></span><br><span class="line">	<span class="type">int</span> xx = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> yy = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(xx!=yy)parent[yy] = xx;<span class="comment">// yy为新的根节点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)cin&gt;&gt;monkey[i];</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 构建图结构</span></span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)&#123;<span class="comment">// 避免重复计算距离 </span></span><br><span class="line">			<span class="type">double</span> w = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((x[i]-x[j]), <span class="number">2</span>)+<span class="built_in">pow</span>((y[i]-y[j]), <span class="number">2</span>));<span class="comment">// 计算距离</span></span><br><span class="line">			eg[++cnt] = &#123;i, j, w&#125;;<span class="comment">// 初始化边数组 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">sort</span>(eg+<span class="number">1</span>, eg+<span class="number">1</span>+cnt, comp);<span class="comment">// 按照边权重升序排序 </span></span><br><span class="line">	<span class="comment">// 计算最小生成树以及MST中的最大边权重 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		parent[i] = i;<span class="comment">// 初始化根节点为本身 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;<span class="comment">// 存储最小生成树中结点的个数 </span></span><br><span class="line">	<span class="type">double</span> maxE = <span class="number">0.0</span>;<span class="comment">// 存储MST中边权重的最大值 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;<span class="comment">// 遍历所有的边edge </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(eg[i].u)!=<span class="built_in">find</span>(eg[i].v))&#123;<span class="comment">// 两个结点不具有相同的根节点 </span></span><br><span class="line">			<span class="built_in">merge</span>(eg[i].u, eg[i].v);<span class="comment">// 合并</span></span><br><span class="line">			num++;<span class="comment">// 结点数量增加</span></span><br><span class="line">			maxE = maxE&gt;=eg[i].w?maxE:eg[i].w;<span class="comment">// 更新MST中边的最大权重 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(num==n<span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">// n个结点组成MST之后只有n-1条边 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(monkey[i]&gt;=maxE)ans++;<span class="comment">// 满足要求的猴子数量+1 </span></span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编码提示">⭐️编码提示</h2>
<h3 id="0x3f">0x3f</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在代码中，0x3f经常被用作一个特殊的数值，比如在动态规划中，可以将dp数组初始化为0x3f，表示还没有任何状态值被更新过，相当于无限大的意思。(0x3f的十进制数为63)</p>
</li>
<li class="lvl-2">
<p><code>memset(dp, 0x3f, sizeof(dp));//初始化</code></p>
</li>
</ul>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>对于八进制数，前缀通常是“0o”或“0”，但后者已经很少使用了。这个前缀中的“o”代表“octal”，意思是“八进制”的意思。</p>
</li>
<li class="lvl-2">
<p>而对于十六进制数，前缀通常是“0x”。这个前缀中的“x”代表“hexadecimal”，意思是“十六进制”的意思。</p>
</li>
</ul>
</blockquote>
<h3 id="inf">INF</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义无穷大</p>
</li>
<li class="lvl-2">
<p><code>const long long INF = 0x3f3f3f3f3f3f3f3fLL;  //这样定义INF的好处是: INF &lt;= INF+x 防止溢出</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/12-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>组合数学</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1620">分割立方体 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1621">挑选子串 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1622">糊涂人装信 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1623">战斗吧N皇后 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/1457/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1457">杨辉三角形 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h3 id="计数原理：加法原理">计数原理：加法原理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>加法原理：集合S被分成两两不相交的部分S1、S2、S3、…、Sm，那么S的对象数目等于：|S| = |S1| + |S2| + |S3| + … |Sm|</p>
</li>
<li class="lvl-2">
<p>例：一个学生想学一门数学课，一门文化课，但不能同时选，现在从4门数学课和4门文化课中选，一共有4 + 4=8种方法选一门课。</p>
</li>
<li class="lvl-2">
<p>加法原理的关键是将计数分解为若干个独立（不相容）的部分，保证既不重复也不遗漏地进行计数。</p>
</li>
</ul>
<h3 id="计数原理：乘法原理">计数原理：乘法原理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>令S是对象的有序对(a, b)的集合，其中第一个对象a来自大小为p的一个集合，对于对象a的每个选择，对象b有q个选择，那么S的大小：|S| = p×q</p>
</li>
<li class="lvl-2">
<p>例：中性笔的长度有3种，颜色有4种，直径有5种。不同种类的中性笔有：3×4×5=60种。</p>
</li>
<li class="lvl-2">
<p>例：3<sup>4</sup>×5<sup>5</sup>×7<sup>2</sup>×11<sup>3</sup>的正整数因子有多少？答：这是算数基本定理的概念。3有<mark>0~4这5种选择</mark>，5有6个选择，7有3个选择，11有4个选择，因子总数是5×6×3×4=360种。</p>
</li>
</ul>
<h3 id="排列数">排列数</h3>
<p>排列是有序的。</p>
<p>不可重复排列数：从n个不同的物品中取出r个，排列数为：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407005642021.png" alt="image-20230407005642021" style="zoom:33%;" />
<p>可重复排列数，从n个不同的物品中可重复地取出r个的排列数为：n<sup>r</sup>。</p>
<h3 id="组合数">组合数</h3>
<p>排列是有序的，组合是无序的。</p>
<p>如果S中的元素都不相同，组合数：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407005535470.png" alt="image-20230407005535470" style="zoom:25%;" />
<h3 id="鸽巢原理">鸽巢原理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>鸽巢原理，又称抽屉原理。</p>
</li>
<li class="lvl-2">
<p>鸽巢原理：把n+1个物体放进n个盒子，至少有一个盒子包含2个或更多的物体。</p>
</li>
<li class="lvl-2">
<p>例：在370人中，至少有2人生日相同；</p>
<ul class="lvl-2">
<li class="lvl-4">把365天看成365个抽屉。把365人放进365个抽屉，不管怎么放，抽屉里面都有人了。</li>
</ul>
</li>
<li class="lvl-2">
<p>例：n个人互相握手，一定有2个人握手次数相同。</p>
</li>
</ul>
<h3 id="二项式定理和杨辉三角">二项式定理和杨辉三角</h3>
<p>求杨辉三角第n行的数字，可以模拟这个推导过程，逐级递推，复杂度O(n<sup>2</sup>)。</p>
<p>用数学公式计算，可以直接得到结果，这个公式是(1 + x)<sup>n</sup>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407104653057.png" alt="image-20230407104653057" style="zoom: 33%;" />
<blockquote>
<p>⭐️10亿以内且在前44723行中没有出现的数都只能在第44723行以后的每一行的第二个数上出现。对于给定的N就是第N+1行的第2个数。（比如：N=5，第一次出现在了（5+1）行的第二个数，也就推导出了：<mark>N * (N + 1) / 2 + 2</mark>，其中N * (N + 1) / 2计算的是前N行所有的元素个数——简单的等差数列求和，第一行有1个元素，第二行有2个元素……）</p>
<p><span style="color: red;">以上公式可以在编程过程中作为一个防止溢出的保险!</span></p>
</blockquote>
<h4 id="二项式系数">二项式系数</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407104815921.png" alt="image-20230407104815921"></p>
<h5 id="二项式系数有两种计算方法：">二项式系数有两种计算方法：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407105137267.png" alt="image-20230407105137267"></p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>差分与前缀和</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/13-%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>差分与前缀和</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/269/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=269">排列序数 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/174/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=174">付账问题 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/1457/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1457">杨辉三角形 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/1388/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1388">寒假作业 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/642/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=642">跳蚱蜢 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/595/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=595">七段码 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h2 id="差分法">差分法</h2>
<h3 id="差分法的特点：">差分法的特点：</h3>
<ol>
<li class="lvl-3">
<p>将对于区间的加减操作转化为对于端点的操作；</p>
</li>
<li class="lvl-3">
<p>时间复杂度为O(n):</p>
</li>
<li class="lvl-3">
<p>用于维护区间的增减但不能维护乘除：</p>
</li>
<li class="lvl-3">
<p>差分后的序列比原来的数组序列多一个数。</p>
</li>
</ol>
<h5 id="定义：">定义：</h5>
<p>对于已知有n个元素得离线数列d，我们可以建立记录它与每项与前一项得差值得差分数组f；显然，f[1] = d[1] - 0 = d[1]; 对于整数 i∈[2,n]，我们让f[i]=d[i]-d[i-1]。将对d的一些操作转移至f数列，最终合并f得到d的一种操作，叫做差分法。</p>
<h4 id="差分法原理解释：">差分法原理解释：</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/20201223214525561.png" alt="img"></p>
<h5 id="例题：">例题：</h5>
<p>首先假设有一个数组：</p>
<p><code>1 2 3 4 5 7 2</code></p>
<p>•从第二个元素到第五个元素每个+3</p>
<p>•从第二个元素到第四个元素每个-2</p>
<p>•从第一个元素到第三个元素每个+1</p>
<p>利用差分法解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 差分法 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">//int a[N];</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">7</span>, m;<span class="comment">// n = 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line"><span class="comment">//	a[0] = 0;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="comment">//		cin&gt;&gt;a[i];</span></span><br><span class="line">		f[i] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line">		sum1 += a[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l, r, val;<span class="comment">// l, r 指的是下标 </span></span><br><span class="line">		cin&gt;&gt;l&gt;&gt;r&gt;&gt;val;</span><br><span class="line">		l++;</span><br><span class="line">		r++;</span><br><span class="line">		f[l] += val;<span class="comment">// 差分 </span></span><br><span class="line">		f[r+<span class="number">1</span>] -= val;<span class="comment">// 差分 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		a[i] = f[i] + a[i<span class="number">-1</span>];</span><br><span class="line">		sum2 += a[i];<span class="comment">// 求数组中所有元素的和 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;数组元素和(处理前)：&quot;</span>&lt;&lt;sum1&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;数组元素和(处理后)：&quot;</span>&lt;&lt;sum2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406225625869.png" alt="image-20230406225625869"></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_41054844/article/details/111592532">(108条消息) 差分法~超详细（公式+原理+例题）_Blind-Stab的博客-CSDN博客</a></p>
</blockquote>
<h2 id="前缀和">前缀和</h2>
<h3 id="前缀和的特点：">前缀和的特点：</h3>
<ol>
<li class="lvl-3">
<p>将对于区间的求和操作转化为对于端点值的减法的操作；</p>
</li>
<li class="lvl-3">
<p>区间求和操作的时间复杂度为0(1)；</p>
</li>
<li class="lvl-3">
<p>数组存放时要从1开始；</p>
</li>
<li class="lvl-3">
<p>前缀和数组比原来的数组序列多一个数，第0个。</p>
</li>
</ol>
<h3 id="前缀和算法解题的基本思路：">前缀和算法解题的基本思路：</h3>
<ol>
<li class="lvl-3">
<p>利用sum[i]=a[i]+sum[i-1]差分式；</p>
</li>
<li class="lvl-3">
<p>从第1项到n项，且第0项无数据默认为0；</p>
</li>
<li class="lvl-3">
<p>对于区间求和的操作转化为端点值相减。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406155113547.png" alt="image-20230406155113547" style="zoom:25%;" />
<p><mark>差分与前缀和恰好是一对互逆的操作</mark></p>
<h5 id="例题：">例题：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406155240573.png" alt="image-20230406155240573"></p>
<p>解法代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 前缀和的应用——树木维护开销 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> sum[N], a[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">// 计算前缀和 </span></span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		sum[i] = sum[i<span class="number">-1</span>] + a[i];<span class="comment">// sum[0]=0 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">		cout&lt;&lt;(sum[R]-sum[L<span class="number">-1</span>])&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举与尺取法</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/2-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>枚举与尺取法</h1>
<blockquote>
<p>（练习）更多题目：</p>
<ul class="lvl-1">
<li class="lvl-2">枚举：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;tags=%E6%9E%9A%E4%B8%BE">题库 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2">尺取：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;tags=%E5%B0%BA%E5%8F%96%E6%B3%95,%E5%B0%BA%E5%8F%96">题库 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h2 id="枚举法">枚举法</h2>
<blockquote>
<p>题目：</p>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/613/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E7%AC%AC%E5%87%A0%E4%B8%AA%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97">第几个幸运数字 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/269/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E6%8E%92%E5%88%97%E5%BA%8F">排列序数 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/572/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E7%81%AB%E6%98%9F%E4%BA%BA">火星人 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h3 id="枚举的基本概念">枚举的基本概念</h3>
<p>**枚举的思想：**将问题的所有可能成为答案的解一一列举，然后根据问题所给出的条件判断此解是否合适，如果合适就保留，反之则舍弃。</p>
<p><strong>枚举解题的要素：</strong></p>
<p>1.确定枚举解的范围，以及判断条件</p>
<p>2.选取合适枚举方法，进行逐一枚举，此时应注意能否覆盖所有的可能的解</p>
<p>3.在枚举时使用判断条件检验，留下所有符合要求的解。</p>
<p><strong>枚举的步骤：</strong></p>
<p>1.根据题目确定枚举的范围，并选取合适的枚举方式，不能遗漏任何一个真正解，同时避免重复。</p>
<p>2.为了提高解决问题的效率，看题目是否存在优化，将可能成为解的答案范围尽可能缩小。</p>
<p>3.根据问题找到合理、准确描述、易编码的验证条件。</p>
<p>4.枚举并判断是否符合第3步确定的的条件，并保存符合条件的解。</p>
<p>5.按要求输出枚举过程中留下的符合条件的解。</p>
<p><strong>枚举技术：排列、组合</strong></p>
<h3 id="组合型枚举">组合型枚举</h3>
<p>算法模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//共计N个数</span></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//选m个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; chosen;</span><br><span class="line">string s[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chosen.<span class="built_in">size</span>() &gt; m || chosen.<span class="built_in">size</span>() + (n - x + <span class="number">1</span>) &lt; m) <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == n + <span class="number">1</span>) &#123; <span class="comment">//选够了m个数输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chosen.<span class="built_in">size</span>(); i++)</span><br><span class="line">            cout&lt;&lt; s[chosen[i]]&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//也可以不输出，存放起来也是可以的，主要是看题目。</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chosen.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="built_in">calc</span>(x + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    chosen.<span class="built_in">pop_back</span>();<span class="comment">//消除痕迹</span></span><br><span class="line">    <span class="built_in">calc</span>(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- chosen.size() + (n - x + 1) &lt; m的意思是已经选择的个数和剩下可以选的元素个数的和小于m（期望选择的个数），如果提上条件语句为true，那么就不能够实现目的，直接返回退出</span></span><br><span class="line"><span class="comment">- chosen.push_back(x)是指选择当前x元素；chosen.pop_back()则是不选择当前元素并直接往后面遍历</span></span><br><span class="line"><span class="comment">- x == n + 1的含义是x的最大取值为n，当x=n+1时表明已经遍历完所有的元素，现在需要进行结束操作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="排列型枚举">排列型枚举</h3>
<p>算法模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">//共计N个数</span></span><br><span class="line"><span class="type">int</span> order[<span class="number">20</span>];</span><br><span class="line"><span class="type">bool</span> chosen[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == n + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			cout &lt;&lt; order[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">// puts(&quot;&quot;)直接输出空字符然后自动换行</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (chosen[i])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		order[x] = i;</span><br><span class="line">		chosen[i] = <span class="number">1</span>;<span class="comment">// 标记被选</span></span><br><span class="line">		<span class="built_in">calc</span>(x + <span class="number">1</span>);</span><br><span class="line">		chosen[i] = <span class="number">0</span>;<span class="comment">// 恢复初始状态，这样方便后面的转换顺序 </span></span><br><span class="line">		order[x] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 分析：假设n = 5，当第一次排列时从第一层直接往下递归，直到最后输出1 2 3 4 5；之后恢复chosen[5]的状态回到第4层，当前层继续恢复chosen[4]的状态，然后继续for循环，此时i = 5，并将5选入order数组，然后进入calc(x+1)中，重新进入第5层，由于1 2 3 5都已经被选择，所以当前层的for循环只有当i = 4时才能将i加入到order数组中，由此得到1 2 3 5 4的序列，之后重复以上过程恢复状态并返回到第3层，……，最终得到1 2 4 3 5，……</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="组合枚举-二进制法">组合枚举——二进制法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_subset</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">// 通过二进制法的方式打印子集 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123; <span class="comment">// i：0~2^n，每个i的二进制数对应一个子集。一次打印一个子集，最后得到所有子集</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">// 打印一个子集，即打印i的二进制数中所有的1</span></span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j))<span class="comment">// 从i的最低位开始，逐个检查每一位，如果是1，打印</span></span><br><span class="line">				cout&lt;&lt;a[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">3</span>;  <span class="comment">// 打印前n个元素a[0]~a[n-1]的所有子集</span></span><br><span class="line">	<span class="built_in">print_subset</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设数组a中前3个元素是{1, 2, 3}，即n=3。下面是打印所有子集的详细过程：</p>
<ol>
<li class="lvl-3">
<p>i=0，二进制为000，表示空集，不包含任何元素。</p>
</li>
<li class="lvl-3">
<p>i=1，二进制为001，表示只包含a[0]，即{1}。</p>
</li>
<li class="lvl-3">
<p>i=2，二进制为010，表示只包含a[1]，即{2}。</p>
</li>
<li class="lvl-3">
<p>i=3，二进制为011，表示包含a[0]和a[1]，即{1, 2}。</p>
</li>
<li class="lvl-3">
<p>i=4，二进制为100，表示只包含a[2]，即{3}。</p>
</li>
<li class="lvl-3">
<p>i=5，二进制为101，表示包含a[0]和a[2]，即{1, 3}。</p>
</li>
<li class="lvl-3">
<p>i=6，二进制为110，表示包含a[1]和a[2]，即{2, 3}。</p>
</li>
<li class="lvl-3">
<p>i=7，二进制为111，表示包含a[0]、a[1]和a[2]，即{1, 2, 3}。</p>
</li>
</ol>
<p>在每次循环时，我们都检查i的二进制数中是否有某一位值为1，如果是，则输出相应的元素。例如，在第3次循环中，当j=1时，i的二进制数表示为011，它的第2位为1，因此打印出a[1]=2。</p>
<p>最终输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">1 2 </span><br><span class="line">3 </span><br><span class="line">1 3 </span><br><span class="line">2 3 </span><br><span class="line">1 2 3 </span><br></pre></td></tr></table></figure>
<h2 id="尺取法">尺取法</h2>
<blockquote>
<p>题目：</p>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/1371/learning/">回文判定 - 蓝桥云课 (lanqiao.cn)</a>
<ul class="lvl-3">
<li class="lvl-4"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230329142020847.png" alt="image-20230329142020847"></li>
</ul>
</li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/1372/learning/">美丽的区间 - 蓝桥云课 (lanqiao.cn)</a>
<ul class="lvl-3">
<li class="lvl-4"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230329143125938.png" alt="image-20230329143125938"></li>
</ul>
</li>
</ul>
</blockquote>
<p>尺取法（双指针、two pointers）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个常用的优化技巧</p>
</li>
<li class="lvl-2">
<p>解决序列的区间问题</p>
</li>
<li class="lvl-2">
<p>操作简单、容易编程</p>
</li>
</ul>
<p>尺取法是一种<mark>线性的高效率算法</mark>。记 (L, R ) 为一个序列内以L为起点的最短合法区间，如果R随L的增大而增大的，就可以使用尺取法。具体的做法是不断的枚举 L，同时求出R。因为 R 随 L增大而增大，所以总时间复杂度为 O(n)</p>
<p><strong>反向扫描</strong>：i、j方向相反，i从头到尾，j从尾到头，在中间相会。“左右指针”</p>
<p><strong>同向扫描</strong>：i、j方向相同，都从头到尾，速度不同，例如让j跑在i前面。“快慢指针”</p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/4-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>搜索算法</h1>
<blockquote>
<p>练习题目：</p>
<ul class="lvl-1">
<li class="lvl-2">
</li>
</ul>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330190414480.png" alt="image-20230330190414480" style="zoom:25%;" />
<p>搜索：“暴力法”算法思想的具体实现。</p>
<p>搜索：“通用”的方法。一个问题，如果比较难，那么先尝试一下搜索，或许能启发出更好的算法。</p>
<p>技巧：竞赛时遇到不会的难题，用搜索提交一下，说不定部分判题数据很弱，得分了！</p>
<p>暴力法（Brute force，又译为蛮力法）。</p>
<h3 id="搜索的基本思路：">搜索的基本思路：</h3>
<ol>
<li class="lvl-3">
<p>【BFS】Breadth-First Search，宽度优先搜索，或称为广度优先搜索。</p>
</li>
<li class="lvl-3">
<p>【DFS】Depth-First Search，深度优先搜索。</p>
</li>
</ol>
<h5 id="bfs：一群老鼠走迷宫">BFS：一群老鼠走迷宫</h5>
<ol>
<li class="lvl-3">
<p>老鼠无限多；</p>
</li>
<li class="lvl-3">
<p>在每个路口，都派出部分老鼠探索所有没走过的路；</p>
</li>
<li class="lvl-3">
<p>走某条路的老鼠，如果碰壁无法前行，就停下；</p>
</li>
<li class="lvl-3">
<p>如果到达的路口已经有别的老鼠探索过了，也停下；</p>
</li>
<li class="lvl-3">
<p>所有的道路都会走到，而且不会重复。</p>
</li>
</ol>
<blockquote>
<p>全面扩散、逐层递进</p>
</blockquote>
<h5 id="dfs：一只老鼠走迷宫">DFS：一只老鼠走迷宫</h5>
<ol>
<li class="lvl-3">
<p>只有一只老鼠；</p>
</li>
<li class="lvl-3">
<p>在每个路口，都选择先走右边（当然，选择先走左边也可以），能走多远就走多远；</p>
</li>
<li class="lvl-3">
<p>碰壁无法再继续往前走，回退一步，这一次走左边，然后继续往下走；</p>
</li>
<li class="lvl-3">
<p>能走遍所有的路，而且不会重复（回退不算重复）。</p>
</li>
</ol>
<blockquote>
<p>一路到底、逐层回退</p>
</blockquote>
<h2 id="dfs">DFS</h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>N皇后问题 ：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=886392&amp;compatibility=false">N 皇后问题 - 蓝桥云课 (lanqiao.cn)</a></p>
</li>
<li class="lvl-2">
<p>路径之谜 ：<a href="https://www.lanqiao.cn/problems/89/learning/">路径之谜 - 蓝桥云课 (lanqiao.cn)</a></p>
</li>
</ul>
</blockquote>
<h3 id="dfs基础">DFS基础</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>形式上，递归函数是“自己调用自己”，是一个不断“重复”的过程。</p>
</li>
<li class="lvl-2">
<p>递归的思想，是把大问题逐步缩小，直到变成最小的同类问题的过程，而最后的小问题的解是已知的，一般是给定的初始条件。</p>
</li>
<li class="lvl-2">
<p>到达最小问题后，再“回溯”，把小问题的解逐个带回给更大的问题，最终最大问题也得到了解决。</p>
</li>
<li class="lvl-2">
<p>递归有两个过程：<mark>递归前进、递归返回（回溯）</mark>。</p>
</li>
<li class="lvl-2">
<p>在递归的过程中，由于大问题和小问题的解决方法完全一样，那么大问题的代码和小问题的代码可以写成一样。</p>
</li>
<li class="lvl-2">
<p>一个递归函数，直接调用自己，实现了程序的复用。</p>
</li>
</ul>
<h5 id="模版伪码：">模版伪码：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(满足条件)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    相应操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span>&#123;</span><br><span class="line">    判断边界<span class="built_in">pd</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        不在边界内，即回溯</span><br><span class="line">    &#125;</span><br><span class="line">    尝试每一种可能</span><br><span class="line">    &#123;</span><br><span class="line">        满足check条件</span><br><span class="line">        标记</span><br><span class="line">        继续下一步<span class="built_in">dfs</span>(step+<span class="number">1</span>)</span><br><span class="line">        恢复初始状态（回溯的时候要用到）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dfs剪枝">DFS剪枝</h5>
<blockquote>
<p>剪枝：把不会产生答案的，或不必要的枝条“剪掉”。</p>
<p>剪枝的关键：剪什么枝、在哪里减。</p>
<p>剪枝是搜索常用的优化手段，常常能把指数级的复杂度，优化到近似多项式的复杂度。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>**可行性剪枝：**对当前状态进行检查，如果当前条件不合法就不再继续，直接返回。</p>
</li>
<li class="lvl-2">
<p>**搜索顺序剪枝：**搜索树有多个层次和分支，不同的搜索顺序会产生不同的搜索树形态。</p>
</li>
<li class="lvl-2">
<p>**最优性剪枝：**在最优化问题的搜索过程中，如果当前花费的代价已超过前面搜索到的最优解，那么本次搜索已经没有继续进行下去的意义，停止对当前分支的搜索。</p>
</li>
<li class="lvl-2">
<p>**排除等效冗余：**搜索的不同分支，最后的结果是一样的，那么只搜一个分支就够了。</p>
</li>
<li class="lvl-2">
<p>**记忆化搜索：**在递归的过程中，有许多分支被反复计算，会大大降低算法的执行效率。将已经计算出来的结果保存起来，以后需要用到的时候直接取出结果，避免重复运算，从而提高了算法的效率。</p>
</li>
</ul>
<h2 id="bfs-求最短路径">BFS（求最短路径）</h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>长草：<a href="https://www.lanqiao.cn/problems/149/learning/">长草 - 蓝桥云课 (lanqiao.cn)</a></p>
</li>
</ul>
</blockquote>
<h3 id="bfs基础">BFS基础</h3>
<p>BFS搜索的原理：“逐层扩散”。从起点出发，按层次从近到远，<mark>逐层先后搜索</mark>。</p>
<p>编码：用<mark>队列实现</mark>。</p>
<p>应用：<u><strong>BFS一般用于求最短路径问题</strong></u>，BFS的特点是逐层搜索，先搜到的层离起点更近。</p>
<h4 id="最短路径：bfs法">最短路径：BFS法</h4>
<p>BFS的特点：逐层扩散。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>往BFS的队列中加入邻居结点时，按距离起点远近的顺序加入：先加入距离起点为1的邻居结点，加完之后，再加入距离为2的邻居结点，等等</p>
</li>
<li class="lvl-2">
<p>搜完一层，才会继续搜下一层。</p>
</li>
</ul>
<p>最短路径：从起点开始，沿着每一层逐步往外走，每多一层，路径长度就增加1。</p>
<p>所有长度相同的最短路径都是从相同的层次扩散出去的。</p>
<p>搜到第一个到达终点的路径，就是最短路径。</p>
<h5 id="模版伪码：">模版伪码：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">	相应操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="number">1.</span>把根节点放入队列尾端;</span><br><span class="line">    <span class="number">2.</span>每次从队列中取出一个节点;</span><br><span class="line">    <span class="number">3.</span>Check判断是不是答案，如果是结束算法<span class="keyword">return</span>;</span><br><span class="line">    <span class="number">4.</span>把当前取出的节点扩展，如果扩展后的节点经<span class="built_in">Pd</span>()后符合要求，就放入队列，不符合就不放;</span><br><span class="line">    <span class="number">5.</span>转到步骤<span class="number">2</span>，循环执行。</span><br><span class="line">&#125;</span><br><span class="line">如果所有节点被扩展完了，没有找到答案就无解。</span><br></pre></td></tr></table></figure>
<h4 id="bfs判重">BFS判重</h4>
<h5 id="set判重">set判重</h5>
<h5 id="map判重">map判重</h5>
<h2 id="搜索相关习题">搜索相关习题</h2>
<blockquote>
<p><strong><u>蓝桥云课习题集：</u></strong></p>
<p>青蛙跳杯子102，发现环108，合根植物110，填字母游戏113，机器人塔118，</p>
<p>四平方和122，取球博弈123，卡片换位125、生命之树131，穿越雷区141、</p>
<p>长草149、小朋友崇拜圈182，剪格子211，版本分支223，迷宫与陷阱229，</p>
<p>调手表230，分考场237，最长子序列244，九宫重排261，网络寻路263，</p>
<p>危险系数264，约数倍数选卡片265，字母阵列621，魔方状态643，算式649，</p>
<p>凑平方数653，方格填数664，完美正方形685，五星填数687，生成回文数691，</p>
<p>走迷宫1216，N皇后问题1508，最少操作数1509。</p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与递推</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/3-%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>递归与递推</h1>
<blockquote>
<p>题目练习：</p>
<ul class="lvl-1">
<li class="lvl-2">递推：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;tags=%E9%80%92%E6%8E%A8">题库 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2">递归：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;tags=%E9%80%92%E5%BD%92">题库 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h2 id="递推">递推</h2>
<h3 id="递推算法的基本概念">递推算法的基本概念</h3>
<h5 id="递推算法的特点">递推算法的特点</h5>
<p>一个问题的求解需要大量重复计算，在已知的条件和所求问题之间总存在着某种相互联系的关系，在计算时，我们需要找到这种关系，进行计算（递推关系式）。</p>
<p>即递推法的关键，就是找到递推关系式，这种处理方式能够将复杂的计算过程，转化为若干步骤的简单重复运送，充分利用计算机运行程序时的时间局部性和空间局部性。</p>
<h5 id="递推算法的思想：">递推算法的思想：</h5>
<p>1.首要问题是先找到各个相邻数据项之间的递推关系；</p>
<p>2.递推关系避开了求通项公式的麻烦，且有些题目的通项公式很难求，或者不能进行求解；</p>
<p>3.将复杂问题分解为若干步骤的简单运算；</p>
<p>4.一般来说递推算法就是一种特殊的迭代算法。</p>
<h5 id="递推算法的一般步骤：">递推算法的一般步骤：</h5>
<p>1.根据题目确定数据项，并找到符合要求的递推关系式；</p>
<p>2.根据递推关系式设计递推程序；</p>
<p>3.根据题目找到递推的终点；</p>
<p>4.单次查询可以不进行存储，多次查询都要进行存储；</p>
<p>5.按要求输出答案即可。</p>
<h3 id="递推法的推广-42点问题">递推法的推广-42点问题</h3>
<blockquote>
<p>lanqiao1537：<a href="https://www.lanqiao.cn/problems/1537/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=7">42点问题 - 蓝桥云课 (lanqiao.cn)</a></p>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330003833306.png" alt="image-20230330003833306"></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330005729709.png" alt="image-20230330005729709"></p>
</li>
<li class="lvl-3">
<p>创建 5 个 Vector ，分别用来存放 1-5 次的运算结果；</p>
</li>
<li class="lvl-3">
<p>ans中运算的结果逐步的增多，避免了很多重复的运算。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 递推法的推广 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">7</span>]; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans[<span class="number">10</span>];<span class="comment">// 采用5个vector来存储经过5步运算之后得到的值，如：经过第一次运算之后的值存储在ans[1]中，ans[0]存储的是第一个操作数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;++i)&#123;<span class="comment">// 输入6个字符 </span></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;A&#x27;</span>)a[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;J&#x27;</span>)a[i] = <span class="number">11</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;Q&#x27;</span>)a[i] = <span class="number">12</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;K&#x27;</span>)a[i] = <span class="number">13</span>;</span><br><span class="line">		<span class="keyword">else</span> a[i] = ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[<span class="number">0</span>].<span class="built_in">push_back</span>(a[<span class="number">0</span>]);<span class="comment">// 初始化第一个操作数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)&#123;<span class="comment">// 控制每步运算之后存储在 ans中的值 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ans[i<span class="number">-1</span>].<span class="built_in">size</span>();++j)&#123;<span class="comment">// 将第i-1步运算得到的结果分别与当前字符进行运算，并将结果存储到第i步结果ans[i]中 </span></span><br><span class="line">			ans[i].<span class="built_in">push_back</span>(ans[i<span class="number">-1</span>][j]+a[i]);</span><br><span class="line">			ans[i].<span class="built_in">push_back</span>(ans[i<span class="number">-1</span>][j]-a[i]);</span><br><span class="line">			ans[i].<span class="built_in">push_back</span>(ans[i<span class="number">-1</span>][j]*a[i]);</span><br><span class="line">			ans[i].<span class="built_in">push_back</span>(ans[i<span class="number">-1</span>][j]/a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ans[<span class="number">5</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[<span class="number">5</span>][j]==<span class="number">42</span>)&#123;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归">递归</h2>
<h3 id="递归算法的基本概念">递归算法的基本概念</h3>
<h5 id="递归算法：">递归算法：</h5>
<p>递归算法是一种从自顶向下的算法，实际上是通过不停的直接调用或者间接的调用自身的函数，通过每次改变变量完成多个过程的重复计算，直到到达边界之后，结束调用。</p>
<p>与递推法相似的是，递归与递推都是将一个复杂过程分解为几个简单重复步骤进行计算。</p>
<p>递归算法的实现的核心是分治策略，即分而治之，将复杂过程分解为规模较小的同类问题，通过解决若干个小问题，进而解决整个复杂问题。</p>
<h5 id="递归算法的思想：">递归算法的思想：</h5>
<p>1.将复杂计算过程转换为简单重复子过程；</p>
<p>2.找到递归公式，即能够将大问题转化为小问题的公式；</p>
<p>3.自上而下计算，在返回完成递归过程。</p>
<h5 id="递归算法设计的一般步骤：">递归算法设计的一般步骤：</h5>
<p>1.根据题目设计递归函数中的运算部分；</p>
<p>2.根据题目找到递归公式，题目可能会隐含给出，也可能需要自己进行推导；</p>
<p>3.找到递归出口，即递归的终止条件。</p>
<h3 id="斐波那契数列">斐波那契数列</h3>
<p>递推式：f(n) = f(n-1) + f(n-2)；</p>
<h5 id="递推算法：">递推算法：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> fib[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fib[<span class="number">1</span>]=fib[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">20</span>;i++)  fib[i]= fib[i<span class="number">-1</span>]+fib[i<span class="number">-2</span>];</span><br><span class="line">    cout &lt;&lt;fib[<span class="number">20</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="递归算法：">递归算法：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;                   <span class="comment">//统计执行了多少次递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span> <span class="params">(<span class="type">int</span> n)</span></span>&#123;             <span class="comment">//递归函数</span></span><br><span class="line">    cnt ++;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//到达终止条件，即最小问题        </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span> (n<span class="number">-1</span>) + <span class="built_in">fib</span> (n<span class="number">-2</span>); <span class="comment">//递归调用自己2次，复杂度O(2n)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fib</span>(<span class="number">20</span>);         <span class="comment">//计算第20个斐波那契数</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot; cnt=&quot;</span>&lt;&lt;cnt;     <span class="comment">//递归了cnt=13529次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>递推和递归两种代码，结果一样，计算量差别巨大：</p>
</li>
<li class="lvl-2">
<p>递推代码：一个for循环，计算20次。</p>
</li>
<li class="lvl-2">
<p>递归代码：计算第20个斐波那契数，共计算cnt = 13529次。</p>
</li>
<li class="lvl-2">
<p>为什么斐波那契的递归代码如此低效？——因为递归算法存在很多的重复计算</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330010508466.png" alt="image-20230330010508466" style="zoom: 33%;" />
<h5 id="改进：记忆化-递归算法">改进：记忆化（递归算法）</h5>
<ol>
<li class="lvl-3">
<p>递归的过程中做了重复工作，例如fib(3)计算了2次，其实只算1次就够了。</p>
</li>
<li class="lvl-3">
<p>为避免递归时重复计算，可以在子问题得到解决时，就保存结果，再次需要这个结果时，直接返回保存的结果就行了，不继续递归下去。</p>
</li>
<li class="lvl-3">
<p>这种存储已经解决的子问题结果的技术称为“记忆化（Memoization）”。</p>
</li>
<li class="lvl-3">
<p>记忆化是递归的常用优化技术。</p>
</li>
<li class="lvl-3">
<p>动态规划也常常用递归写代码，记忆化也是动态规划的关键技术。</p>
</li>
</ol>
<h5 id="改进算法：">改进算法：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;         <span class="comment">//统计执行了多少次递归</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">25</span>];      <span class="comment">//存储斐波那契数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span> <span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span>(data[n]!=<span class="number">0</span>) <span class="keyword">return</span> data[n]; <span class="comment">//记忆化搜索：已经算过，不用再算，直接返回结果    </span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123; data[n]=<span class="number">1</span>; <span class="keyword">return</span> data[n]; &#125;    </span><br><span class="line">    data[n] = <span class="built_in">fib</span> (n<span class="number">-1</span>) + <span class="built_in">fib</span> (n<span class="number">-2</span>);    <span class="comment">//继续递归</span></span><br><span class="line">    <span class="keyword">return</span> data[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fib</span>(<span class="number">20</span>);       <span class="comment">//计算第20个斐波那契数</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot; cnt=&quot;</span>&lt;&lt;cnt;   <span class="comment">//递归了cnt=37次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集与二分算法</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/5-%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>并查集与二分算法</h1>
<h2 id="并查集">并查集</h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>合根植物：<a href="https://www.lanqiao.cn/problems/110/learning/">合根植物 - 蓝桥云课 (lanqiao.cn)</a></p>
</li>
</ul>
</blockquote>
<h3 id="并查集的基本概念">并查集的基本概念</h3>
<p>并查集（Disjoint Set）是一种非常常用的数据结构，主要用来处理一些不相交集合（Disjoint Set）的合并及查询问题。它支持以下两种操作：</p>
<ol>
<li class="lvl-3">
<p>查找（Find）：确定某个元素属于哪个子集。它可以被用来确定两个元素是否属于同一个子集。</p>
</li>
<li class="lvl-3">
<p>合并（Union）：将两个子集合并成同一个集合。</p>
</li>
</ol>
<p>并查集可以使用数组或者树实现，其中<mark>数组实现较为简单</mark>，但是效率稍低；树实现较为复杂，但是效率较高。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>并查集是大量的树（单个节点也，算是树）经过合并生成一系列家族森林的过程。</p>
</li>
<li class="lvl-2">
<p>每个集合也就是每棵树都是由根节点确定，也可以理解为每个家族的族长就是根节点。</p>
</li>
</ul>
<blockquote>
<p>我们维护一个parent数组，每个元素初始化为对应的数组下标，代表自己是独立的一棵树，且是树根。以第一棵树为例，在后续数据处理过程中，我们把与所有与&quot;2&quot;同属一个连通分量的元素都连到&quot;2&quot;上，并把数组对应下标的元素赋值为2，其中&quot;5&quot;先连接到了&quot;1&quot;上，&quot;1&quot;又连接到了&quot;2&quot;上。最后，数组每个元素都代表其指向的父节点。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/2021011323472737.png" alt="img" style="zoom: 50%;" />
</blockquote>
<h5 id="并查集的存储：">并查集的存储：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">parent.<span class="built_in">resize</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    parent[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="并查集的查询：">并查集的查询：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x] == x)</span><br><span class="line">    	<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">find</span>(parent[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="并查集的路径压缩：">并查集的路径压缩：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 彻底的路径压缩</span></span><br><span class="line"><span class="comment">// 查找元素x所在的集合编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图解：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/2021011323505828.png" alt="img"></p>
<h5 id="并查集的集合合并：">并查集的集合合并：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并元素x和元素y所在的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        parent[rootX] = rootY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图解：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/20210113234942677.png" alt="img"></p>
<p>以下是使用C++数组实现的并查集存储，查询和合并操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，传入集合中元素数量n</span></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素x所在的集合编号</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并元素x和元素y所在的集合</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent; <span class="comment">// 存储每个元素所在的集合编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>parent</code> 数组用来存储每个元素所在的集合编号。初始化时，每个元素的父节点都是自己。查询操作使用了路径压缩优化，将树高度降低，加速后续查询操作。合并操作只需要将元素 x 所在的集合的根节点指向元素 y 所在集合的根节点即可。</p>
<p>使用该并查集类可以进行以下操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建一个包含10个元素的并查集</span></span><br><span class="line"></span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    uf.<span class="built_in">unionSet</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; uf.<span class="built_in">find</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 输出：2</span></span><br><span class="line">    cout &lt;&lt; uf.<span class="built_in">find</span>(<span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 输出：6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了一个包含10个元素的并查集，先将几个元素单独构成集合，然后再将一些集合合并起来。最后输出了两个元素属于哪个集合。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>主要参考：ChatGPT</p>
</li>
<li class="lvl-2">
<p>部分参考：<a href="https://blog.csdn.net/qq_25933249/article/details/112597361">(107条消息) 图解并查集_1加一的博客-CSDN博客</a></p>
</li>
</ul>
</blockquote>
<h2 id="二分算法">二分算法</h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>跳石头：<a href="https://www.lanqiao.cn/problems/364/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E8%B7%B3%E7%9F%B3%E5%A4%B4">跳石头 - 蓝桥云课 (lanqiao.cn)</a></p>
</li>
</ul>
</blockquote>
<h3 id="二分的基本思想">二分的基本思想</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230401231716660.png" alt="image-20230401231716660"></p>
<p>图解：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230401231758840.png" alt="image-20230401231758840" style="zoom: 25%;" />
<h5 id="二分法的两种实现代码：">二分法的两种实现代码：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继） </span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">    <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;=x)&#123;</span><br><span class="line">        high = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前趋）</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">    <span class="type">int</span> mid = (low + high + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;=x)&#123;</span><br><span class="line">        low = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230401233132876.png" alt="image-20230401233132876" style="zoom:25%;" />
</blockquote>
<h4 id="实数二分">实数二分</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230402001352903.png" alt="image-20230402001352903"></p>
<blockquote>
<p>根据前面的知识，我们要找到一个具有单调性的数列，去二分。这个题的关键是我们要去二分什么，这里可以二分的是 a^M 中的 a ，所以我们要先想办法设计出用于处理实数二分的代码。——也就是判断 N 与 a^M 的大小关系</p>
</blockquote>
<p>实数二分的算法模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模版一：实数域二分，设置eps法</span></span><br><span class="line"><span class="comment">// 令eps为小于题目精度一个数即可。比如题目说保留4位小数，0.0001这种的。那么eps就可以设置为五位小数的任意一个数0.00001-0.00009等等都可以。</span></span><br><span class="line"><span class="comment">// 一般为了保证精度我们选取精度/100的那个小数，即设置eps=0.0001/100=1e-6</span></span><br><span class="line"><span class="keyword">while</span> (l+eps&lt;r)&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pd</span>(mid))</span><br><span class="line">    	r = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	l = mid;<span class="comment">// 注意这里和传统的二分法不同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版二：实数域二分，规定循环次数法</span></span><br><span class="line"><span class="comment">// 通过循环一定次数达到精度要求，这个一般1og2N&lt;精度即可。N为循环次数，在不超过时间复杂度的情况下，可以选择给N乘一个系数使得精度更高。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pd</span>(mid))</span><br><span class="line">    	r = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	l = mid;<span class="comment">// 注意这里和传统的二分法不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心pd算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = c*a;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c&gt;=n)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 实数二分题 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">// 分别为实数n与m次根号下，即求m次根号下的n的值为多少？ </span></span><br><span class="line"><span class="type">double</span> eps = <span class="number">1e-8</span>; <span class="comment">// 因为题目中要求保留7位小数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> m)</span></span>&#123;<span class="comment">// 用 a^m 与 n 进行比较</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		c = c*a;</span><br><span class="line">		m--;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(c&gt;=n)<span class="comment">// a^m大于n，那么表明a大了，应该减小一点 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">double</span> L = <span class="number">0</span>, R = n;</span><br><span class="line">	<span class="keyword">while</span>(L + eps &lt; R)&#123;<span class="comment">// 以eps精度进行二分处理 </span></span><br><span class="line">		<span class="type">double</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">pd</span>(mid, m))&#123;</span><br><span class="line">			R = mid;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			L = mid;<span class="comment">// 注意这里和传统的二分法不同</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.7f&quot;</span>, L);<span class="comment">// 涉及到输入输出精度的使用C的标准输入输出更好 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分法习题"><mark>二分法习题</mark></h3>
<table>
<thead>
<tr>
<th>题目+编号</th>
<th>题目+编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>扫地机器人   199</td>
<td>区间移位      111</td>
</tr>
<tr>
<td>求立方根    1217</td>
<td>高精度开根    909</td>
</tr>
<tr>
<td>“123”       1591</td>
<td>二分法查找数组元素  1389</td>
</tr>
<tr>
<td>A  Careful Approach   1390</td>
<td>求阶乘       2145</td>
</tr>
<tr>
<td>最少刷题数    2143</td>
<td>最大子矩阵   2147</td>
</tr>
<tr>
<td>青蛙过河      2097</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>动态规划</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/courses/18397/learning/?id=893781&amp;compatibility=false">第十四届蓝桥杯省赛冲刺营【第二期】 - 【课后练习】小明的背包 1 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h3 id="dp的两个特征">DP的两个特征</h3>
<p>（1）重叠子问题。子问题是原大问题的小版本，计算步骤完全一样；计算大问题的时候，需要多次重复计算小问题。一个子问题的多次计算，耗费了大量时间。用DP处理重叠子问题，每个子问题只需要计算一次，从而避免了重复计算，这就是DP效率高的原因。</p>
<p>（2）最优子结构。首先，大问题的最优解包含小问题的最优解；其次，可以通过小问题的最优解推导出大问题的最优解。</p>
<h3 id="能采用动态规划求解的问题的性质">能采用动态规划求解的问题的性质</h3>
<h5 id="最优化原理：">最优化原理：</h5>
<p>如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<h5 id="无后效性：">无后效性：</h5>
<p>即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<h5 id="有重叠子问题：">有重叠子问题：</h5>
<p>即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势)</p>
<h3 id="dp：记忆化">DP：记忆化</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果各个子问题不是独立的，如果能够保存已经解决的子问题的答案，在需要的时候再找出已求得的答案，可以避免大量的重复计算。</p>
</li>
<li class="lvl-2">
<p>基本思路：用一个表记录所有已解决的子问题的答案，不管该问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
</li>
<li class="lvl-2">
<p>记忆化</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230403213829618.png" alt="image-20230403213829618" style="zoom: 25%;" />
<h4 id="dp解题步骤">DP解题步骤</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>拆分问题</p>
</li>
<li class="lvl-2">
<p>定义状态（并找出初状态）</p>
</li>
<li class="lvl-2">
<p>状态转移方程</p>
</li>
</ul>
<h4 id="一般的模型方法">一般的模型方法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>递归搜索法</p>
</li>
<li class="lvl-2">
<p>记忆化搜索（记忆化暴力）</p>
</li>
<li class="lvl-2">
<p>递推式法</p>
</li>
</ul>
<h4 id="空间优化：滚动数组">空间优化：滚动数组</h4>
<p>滚动数组：即只需要定义<code>dp[2][j]</code>：用<code>dp[0][]和dp[1][]</code>交替滚动。</p>
<h4 id="空间优化：自我滚动">空间优化：自我滚动</h4>
<p>自我滚动：dp[j]=dp[j-c[i]]+w[i]即可。</p>
<h5 id="根据背包是否要装满的初始化细节">根据背包是否要装满的初始化细节</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>装满：<code>dp[0] = 0</code>， 其余赋值为-INF；</p>
</li>
<li class="lvl-2">
<p>不装满：<code>memset(dp, 0, sizeof(dp))</code>，全部初始化为0；</p>
</li>
</ul>
<blockquote>
<p>若一定要求装满:</p>
<p>•则必有n=sum(c[i]) i∈(已选集合)</p>
<p>•所以dp[n-sum(c[i])]= dp[0]</p>
<p>•所以只有从dp[0]出发才合法，那就把其他的设成无穷小。</p>
</blockquote>
<h2 id="动规练习题">动规练习题</h2>
<blockquote>
<p>李白打酒加强版2114    数组切分2148      积木画2110</p>
<p>分果果1459        括号序列1456       采药563</p>
<p>开心的金明554      传球游戏525       摆花389</p>
<p>最优包含239        画廊1032        蓝肽子序列1030</p>
<p>质数行者1027       游园安排1024       矩阵计数246</p>
<p>货币系统331       凑硬币1082        方格取数803</p>
<p>合唱队形742       纪念品786。</p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>思维训练</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/9-%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>思维训练</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/1461/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1461">最少砝码 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/2117/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=2117">砍竹子 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/546/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=546">排列小球 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1190">LCIS - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数论</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/8-%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>简单数论</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/2098/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E5%88%B7%E9%A2%98%E7%BB%9F%E8%AE%A1">刷题统计 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/courses/18397/learning/?id=886970&amp;compatibility=false">快速幂 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/603/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=RSA%E8%A7%A3%E5%AF%86">RSA解密 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/210/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E6%A0%B8%E6%A1%83%E7%9A%84%E6%95%B0%E9%87%8F">核桃的数量 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/520/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=520">Hankson 的趣味题 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/2131/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=2131">寻找整数 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/527/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=527">笨小猴 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/courses/18397/learning/?id=894709&amp;compatibility=false">最大最小公倍数 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/problems/1557/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1557">质数 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2"><a href="https://www.lanqiao.cn/courses/18397/learning/?id=894710&amp;compatibility=false">分解质因数 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<h3 id="模运算">模运算</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义：模运算为a除以m的余数，记为a mod m，有a mod m = a % m。</p>
</li>
<li class="lvl-2">
<p>模运算是大数运算中的常用操作。</p>
</li>
<li class="lvl-2">
<p>如果一个数太大，无法直接输出，或者不需要直接输出，可以把它取模后，缩小数值再输出。</p>
</li>
<li class="lvl-2">
<p>Python虽然能直接计算大数，不用担心数据溢出，但是大数乘法太耗时，所以也常用取模来缩小数值。</p>
</li>
<li class="lvl-2">
<p>一个简单应用，判断奇偶：a%2 == 0，a是偶数；a%2 == 1，a是奇数</p>
</li>
</ul>
<h6 id="刷题统计解法代码：">刷题统计解法代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 刷题统计 </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll a, b, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;</span><br><span class="line">	ll sum = a*<span class="number">5</span>+<span class="number">2</span>*b;</span><br><span class="line">	ll ans = (n/sum)*<span class="number">7</span>;</span><br><span class="line">	ll r = n%sum;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=a*<span class="number">5</span>)&#123;</span><br><span class="line">		ans += r/a+(r%a?<span class="number">1</span>:<span class="number">0</span>);<span class="comment">// 多的部分也要用1天来完成 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ans += (r-a*<span class="number">5</span>)/b+((r-a*<span class="number">5</span>)%b?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">		ans += <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂">快速幂</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>幂运算a<sup>n</sup>，当n很大时，如果一个个地乘，时间是O(n)的，速度很慢，此时可以用快速幂，在O(logn)的时间内算出来。</p>
</li>
<li class="lvl-2">
<p>快速幂的一个解法：分治法，算a<sup>2</sup>，然后再算(a<sup>2</sup>) <sup>2</sup>，…，一直算到a<sup>n</sup>，代码也容易写。</p>
</li>
<li class="lvl-2">
<p>标准的快速幂：用位运算实现。</p>
</li>
<li class="lvl-2">
<p>基于位运算的快速幂，原理是倍增。</p>
</li>
</ul>
<h5 id="快速幂原理">快速幂原理</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230404191246938.png" alt="image-20230404191246938"></p>
<h6 id="快速幂解法代码：">快速幂解法代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll b, p, k;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fastPow</span><span class="params">(ll b, ll p, ll k)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	b %= k; <span class="comment">// 防止下方res*b越界 </span></span><br><span class="line">	<span class="keyword">while</span>(p)&#123;<span class="comment">// p为次数 </span></span><br><span class="line">		<span class="keyword">if</span>(p&amp;<span class="number">1</span>)res = (res*b)%k;</span><br><span class="line">		b = b*b%k;<span class="comment">// 对应于a^1,a^2,a^3…… 其中的指数代表的是n二进制中第几位的1（如：1011）</span></span><br><span class="line">		p = p&gt;&gt;<span class="number">1</span>;<span class="comment">// 右移一位 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;b&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">fastPow</span>(b, p, k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rsa解密">RSA解密</h3>
<blockquote>
<p>实质就是快速幂的计算——由于数据太大，因此建议使用Python处理，思路都是一致的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lanqiao-603-附</span></span><br><span class="line">n = <span class="number">1001733993063167141</span></span><br><span class="line">d = <span class="number">212353</span></span><br><span class="line">c = <span class="number">20190324</span></span><br><span class="line">p = <span class="number">891234941</span></span><br><span class="line">q = <span class="number">1123984201</span></span><br><span class="line">temp = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">now = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">    now = i*temp+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(now%d==<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(now//d)<span class="comment"># 输出e</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速幂计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fastPow</span>(<span class="params">a, n, mod</span>):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    a %= mod</span><br><span class="line">    <span class="keyword">while</span>(n):</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>):res = (res*a)%mod</span><br><span class="line">        a = a*a%mod</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="built_in">print</span>(fastPow(c, now//d, n))</span><br></pre></td></tr></table></figure>
<h3 id="gcd：定义-性质">GCD：定义、性质</h3>
<p>1、最大公约数Greatest Common Divisor(GCD)：整数a和b的GCD是指能同时整除a和b的最大整数，记为gcd(a, b)。由于-a的因子和a的因子相同，因此gcd(a, b) = gcd(|a|, |b|)。编码时只关注正整数的最大公约数。</p>
<p>2、性质：</p>
<p>（1）gcd(a, b) = gcd(a, a+b) = gcd(a, k·a+b)</p>
<p>（2）gcd(ka, kb) = k·gcd(a, b)</p>
<p>（3）定义多个整数的最大公约数：gcd(a, b, c) = gcd(gcd(a, b), c)。</p>
<p>（4）若gcd(a, b) = d，则gcd(a/d, b/d) = 1，即a/d与b/d互素。<strong><u>这个定理很重要</u></strong>。</p>
<p>（5）gcd(a+cb, b) = gcd(a, b)</p>
<h4 id="手写gcd代码">手写gcd代码</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>手写gcd函数，常用<u>欧几里得算法</u>。</p>
</li>
<li class="lvl-2">
<p><mark>辗转相除法</mark>求gcd：<code>gcd(a, b) = gcd(b, a mod b)</code></p>
</li>
<li class="lvl-2">
<p>这是最常用的方法，极为高效。</p>
</li>
<li class="lvl-2">
<p>设a &gt; b，辗转相除法的计算复杂度为O((log<sub>2</sub>a)<sup>3</sup>)。</p>
</li>
</ul>
<h6 id="示例代码：">示例代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; 	<span class="keyword">return</span> b? <span class="built_in">gcd</span>(b, a%b):a; &#125;<span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(<span class="number">15</span>, <span class="number">81</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;    <span class="comment">// 输出  3</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(<span class="number">0</span>, <span class="number">44</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;     <span class="comment">// 输出  44</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(<span class="number">0</span>, <span class="number">0</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;      <span class="comment">// 输出  0</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(<span class="number">-6</span>, <span class="number">-15</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;   <span class="comment">// 输出  -3</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(<span class="number">-17</span>,<span class="number">289</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;   <span class="comment">// 输出  -17</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(<span class="number">17</span>,<span class="number">-289</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;   <span class="comment">// 输出  17</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lcm：定义-性质">LCM：定义、性质</h3>
<p>1、最小公倍数LCM（the Least Common Multiple）。</p>
<p>2、<em>a</em>和<em>b</em>的最小公倍数lcm(<em>a</em>, <em>b</em>)，从算术基本定理推理得到。</p>
<p>3、<strong>算术基本定理</strong>：任何大于1的正整数n都可以唯一分解为有限个素数的乘积：n = p1c1p2c2…pmcm，其中ci都是正整数，pi都是素数且从小到大。</p>
<p>4、推导LCM：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230404225810555.png" alt="image-20230404225810555"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">设：a = p1^c1*p2^c2...pm^cm，b = p1^f1*p2^f2...pm^fm</span><br><span class="line">    </span><br><span class="line">那么：<span class="built_in">gcd</span>(a, b) = p1^min&#123;c1,f1&#125;*p2^min&#123;c2,f2&#125;...pm^min&#123;cm,fm&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lcm</span>(a, b) = p1^max&#123;c1,f1&#125;*p2^max&#123;c2,f2&#125;...pm^max&#123;cm,fm&#125;</span><br><span class="line"></span><br><span class="line">推出：<span class="built_in">gcd</span>(a, b)*<span class="built_in">lcm</span>(a, b) = a*b</span><br><span class="line"></span><br><span class="line">即：  <span class="built_in">lcm</span>(a, b) = a*b/<span class="built_in">gcd</span>(a, b) = a/<span class="built_in">gcd</span>(a, b)*b。</span><br></pre></td></tr></table></figure>
<h4 id="lcm-手写代码">lcm()手写代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;    <span class="comment">//需要的时候把int改成long long  </span></span><br><span class="line">   <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;  <span class="comment">//先做除法再做乘法，防止先做乘法溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="素数的判断">素数的判断</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>素数定义：只能被1和自己整除的正整数。注：1不是素数，最小素数是2。</p>
</li>
<li class="lvl-2">
<p>判断一个数n是不是素数：当n ≤ 10<sup>14</sup>时，用试除法；n &gt; 10<sup>14</sup>时，试除法不够用，需要用高级算法，例如Miller_Rabin算法。</p>
</li>
</ul>
<h5 id="试除法">试除法</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">false</span>;         <span class="comment">//1不是素数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)  </span><br><span class="line">         <span class="keyword">if</span>(n % i == <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//能整除，不是素数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;          <span class="comment">//n=2时返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范围[2,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>]内有多少个素数？在1百万以内，约有7.8万个素数；在1亿以内，约有576万个素数。</p>
</blockquote>
<h2 id="素数筛">素数筛</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>素数的筛选：给定n，求2~n内所有的素数。</p>
</li>
<li class="lvl-2">
<p>一个个地判断很慢，所以用“筛子”筛所有的整数，把非素数筛掉，剩下的就是素数。</p>
</li>
<li class="lvl-2">
<p>常用两种筛法：<strong><u>埃氏筛、欧拉筛</u></strong>。</p>
</li>
</ul>
<h3 id="埃氏筛">埃氏筛</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405011722403.png" alt="image-20230405011722403"></p>
<h5 id="解法代码：">解法代码：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 埃氏筛</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> prime[N];<span class="comment">// 存储质数 </span></span><br><span class="line"><span class="type">bool</span> bprime[N];<span class="comment">// true标记不是质数 </span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(bprime, <span class="literal">false</span>, <span class="built_in">sizeof</span>(bprime));</span><br><span class="line">	bprime[<span class="number">0</span>] = bprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!bprime[i])&#123;<span class="comment">// 为质数 </span></span><br><span class="line">			prime[cnt++] = i; <span class="comment">// 存储质数 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=n;j+=i)&#123;<span class="comment">// 去除质数i的倍数 </span></span><br><span class="line">				bprime[j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">// 测试 </span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">getPrime</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;++i)&#123;</span><br><span class="line">		cout&lt;&lt;prime[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉筛">欧拉筛</h3>
<p>但是埃氏筛法的缺点：例如6会被3整除，6会被2整除，会被筛两次，所以我们再给出<mark>欧氏线性筛法</mark>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 欧拉筛 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> bprime[N];<span class="comment">// true标记不是质数,表示被筛掉 </span></span><br><span class="line"><span class="type">int</span> cnt; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(bprime, <span class="literal">false</span>, <span class="built_in">sizeof</span>(bprime));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!bprime[i])&#123;<span class="comment">// 是质数 </span></span><br><span class="line">			prime[cnt++] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;++j)&#123;<span class="comment">// 根据当前的prime数组线性地去除非质数 </span></span><br><span class="line">			bprime[i*prime[j]] = <span class="literal">true</span>;<span class="comment">// 标记不是质数,表示被筛掉</span></span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">getPrime</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;++i)&#123;</span><br><span class="line">		cout&lt;&lt;prime[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分解质因子">分解质因子</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405021119535.png" alt="image-20230405021119535"></p>
<h3 id="唯一分解定理与约数定理">唯一分解定理与约数定理</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405102524542.png" alt="image-20230405102524542"></p>
<h3 id="分类乘法计数原理">分类乘法计数原理</h3>
<p>分类乘法计数原理是指：如果一个任务可以分解为多个独立的子任务，且每个子任务都有m种不同的方式完成，那么完成整个任务的总方式数就是每个子任务方式数的乘积（即m的n次方，其中n为子任务的数量）。这个原理也叫做乘法原理。</p>
<p>例如，假设有两个任务A和B，完成任务A有3种不同的方式，完成任务B有4种不同的方式。那么完成这两个任务的总方式数就是3 x 4 = 12种。如果还有一个任务C，完成任务C有2种不同的方式，那么完成这三个任务的总方式数就是3 x 4 x 2 = 24种。</p>
<p>这个原理常常用于计算排列和组合问题，求解方法通常是将任务分解为子任务，并根据问题要求进行分类。</p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2023/10/18/University/Algorithm/Topic%20learning/6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>贪心算法</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">翻硬币：<a href="https://www.lanqiao.cn/problems/209/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E7%BF%BB%E7%A1%AC%E5%B8%81">翻硬币 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2">快乐司机（lanqiao-1513）：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=886638&amp;compatibility=false">【课后练习】快乐司机 - 蓝桥云课 (lanqiao.cn)</a></li>
<li class="lvl-2">防御力：<a href="https://www.lanqiao.cn/problems/226/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E9%98%B2%E5%BE%A1%E5%8A%9B">防御力 - 蓝桥云课 (lanqiao.cn)</a></li>
</ul>
</blockquote>
<p>【算法优点】</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>容易理解：生活常见</p>
</li>
<li class="lvl-2">
<p>操作简单：在每一步都选局部最优</p>
</li>
<li class="lvl-2">
<p>效率高：复杂度常常是O(1)的</p>
</li>
</ul>
<p>【算法缺点】</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>缺点：局部最优不一定是全局最优</p>
</li>
</ul>
<h3 id="贪心算法的基本概念">贪心算法的基本概念</h3>
<p>贪心算法与枚举法的不同之处在于每个子问题都选择最优的情况，然后向下继续进行，且不能回溯，枚举法是将所有情况都考虑然后选出最优的情况。</p>
<p>贪心算法，在对问题求解时，不从整体考虑，而是采用一叶障目的选择方式，只选择某种意义上的局部最优解。并且，贪心算法是没有固定的模板可以遵循的，每个题日都有不同的贪心策略，所以算法设计的关键就是贪心策略的选择。</p>
<p>贪心算法有一个必须要注意的事情。贪心算法对于问题的要求是，所有的选择必须是无后效性的，即当前的选择，不能影响后续选择对于结果的影响。</p>
<p>贪心算法主要适用于最优化问题，如：MST问题。有时候贪心算法并不能得到最优答案，但是能得到精确答案的近似答案。有时可以铺助其他算法得到不是那么精确的结果。</p>
<h5 id="符合贪心策略-贪心选择性质-：">符合贪心策略（贪心选择性质）：</h5>
<p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规算法的主要区别。所谓的贪心选择性质就是，该问题的每一步选择都在选择最优的情况下能够导致最终问题的答案也是最优。或者说是无后效性，如果该问题的每一步选择都对后续的选择没有影响，就可以是应用贪心算法。</p>
<h5 id="贪心法求解的问题满足以下特征：">贪心法求解的问题满足以下特征：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>最优子结构性质。当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质，也称此问题满足最优性原理。从局部最优能扩展到全局最优。</p>
</li>
<li class="lvl-2">
<p>贪心选择性质。问题的整体最优解可以通过一系列局部最优的选择来得到。</p>
</li>
</ul>
<h5 id="动态规划问题的特征：">动态规划问题的特征：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>重叠子问题：子问题是原大问题的小版本；计算大问题的时候，需要多次重复计算小问题。</p>
</li>
<li class="lvl-2">
<p>最优子结构：大问题的最优解包含小问题的最优解；可以通过小问题的最优解推导出大问题的最优解。</p>
</li>
</ul>
<h6 id="例子：最少硬币问题">例子：最少硬币问题</h6>
<blockquote>
<p>正解：使用动态规划解决</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230403102524891.png" alt="image-20230403102524891" style="zoom: 25%;" />
<h4 id="贪心算法的设计步骤">贪心算法的设计步骤</h4>
<p>按照定义设计：</p>
<ol>
<li class="lvl-3">
<p>证明原问题的最优解之一可以由贪心选择得到；</p>
</li>
<li class="lvl-3">
<p>将最优化问题转化为这样一个问题，即先做出选择，再解决剩下的一个子问题；</p>
</li>
<li class="lvl-3">
<p>对每一子问题一一求解，得到子问题的局部最优解；</p>
</li>
<li class="lvl-3">
<p>把子问题的解局部最优解合成原来解问题的一个解。</p>
</li>
</ol>
<h6 id="例子：活动安排问题-区间调度问题">例子：活动安排问题（区间调度问题）</h6>
<blockquote>
<p>题目：有很多电视节目，给出它们的起止时间。有些节目时间冲突。问能完整看完的电视节目最多有多少？</p>
</blockquote>
<h6 id="例子：区间覆盖问题">例子：区间覆盖问题</h6>
<h6 id="例子：最优装载问题">例子：最优装载问题</h6>
<h6 id="例子：多机调度问题">例子：多机调度问题</h6>
<blockquote>
<p>贪心策略：最长处理时间的作业优先，即把处理时间最长的作业分配给最先空闲的机器。让处理时间长的作业得到优先处理，从而在整体上获得尽可能短的处理时间。</p>
</blockquote>
<h3 id="贪心习题">贪心习题</h3>
<blockquote>
<p>练习题目：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;tags=%E8%B4%AA%E5%BF%83">贪心- 蓝桥云课 (lanqiao.cn)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>专题学习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数的进制</title>
    <url>/2023/06/11/University/Algorithm/Basic%20knowledge%20of%20C++/%E6%95%B0%E7%9A%84%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>数的进制</h1>
<h2 id="二进制">二进制</h2>
<h4 id="计算机只能进行加法运算-其它复杂的运算都是在加法的基础上构建的">计算机只能进行加法运算，其它复杂的运算都是在加法的基础上构建的</h4>
<h3 id="运算相关：">运算相关：</h3>
<h6 id="原码">原码</h6>
<h6 id="反码">反码</h6>
<h6 id="补码">补码</h6>
<p>正数的补码是原码；负数的补码是<code>原码符号位不变</code>，而其它位<code>按位取反末尾加1</code>。</p>
<blockquote>
<p>负数的补码的另一种求法：</p>
<p>先对负数的二进制求绝对值，再将绝对值的<code>每一位都按位取反</code>后再末尾加1。</p>
</blockquote>
<p>特别地：二进制的负数补码转换为原码也是通过符号位不变其它位按位取反末尾加1；或者是先对补码减1再符号位不变，其它位按位取反，即是原码转补码的逆过程（当然前面的方法更通用点）。</p>
<h5 id="比较：">比较：</h5>
<p>1.先取反再加一；</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mn>3</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-3+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>2.先减一再取反。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mtext>（</mtext><mn>3</mn><mo>−</mo><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">-（3-1）
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord cjk_fallback">（</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span></span></p>
<p>两种方法得到的结果相同：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo>=</mo><mo>−</mo><mtext>（</mtext><mn>3</mn><mo>−</mo><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">-3+1=-（3-1）
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord cjk_fallback">（</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span></span></p>
<h4 id="二进制数进行运算时：">二进制数进行运算时：</h4>
<p><strong>注意：补码之间运算得到的结果仍然为补码，要转换为原码才是最终的真值。</strong></p>
<p><a href="https://so.csdn.net/so/search?q=%E8%A1%A5%E7%A0%81&amp;spm=1001.2101.3001.7020">补码</a> 的运算</p>
<h5 id="补码的算术运算">补码的算术运算</h5>
<h6 id="补码运算要注意的问题：">补码运算要注意的问题：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>1.补码运算时，其符号位与数值部分一起参加运算。</p>
</li>
<li class="lvl-2">
<p>2.补码的符号位相加后，如果有进位出现，要把这个进位舍去（自然丢失）。</p>
</li>
<li class="lvl-2">
<p>3.用补码运算，其运算结果亦为补码。在转换为真值时，若符号位为0，数位不变；若符号位为1，应将结果求补才是其真值。</p>
</li>
<li class="lvl-2">
<p>正数转换为负数时，所有位取反末位加1；</p>
</li>
</ul>
<h6 id="例题">[例题]</h6>
<p>[例3] 已知X = + 1101 , Y = + 0110 , 用补码计算Z = X-Y。解： [X]补 = 01101，[-Y]补 = 11010，则[Z]补 =[X]补+[-Y]补 = 01101+11010<br>
= 100111 , 其真值为Z = + 0111。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>α</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;color:red;">α</span></span></span></span>[例3] 已知X = 01101 , Y = 00110 , 用补码计算Z = X-Y。解： [X]补 = 01101，[-Y]补 = 11010，则[Z]补 =[X]补+[-Y]补 = 01101+11010<br>
= 100111 , 其真值为Z = 00111。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>01101</mn><mspace linebreak="newline"></mspace><mn>11010</mn><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><msub><mn>1</mn><mo>−</mo></msub><mn>00111</mn></mrow><annotation encoding="application/x-tex">01101\\11010\\ \\ 1_-00111
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">01101</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11010</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8528em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">00111</span></span></span></span></span></p>
<p>[例4] 已知X = + 0110 , Y = + 1101 , 用补码计算Z = X-Y。解： [X]补 = 00110，[-Y]补 = 10011，则[Z]补 =[X]补+[-Y]补 = 00110 + 10011<br>
= 11001 , 其真值为Z = - 0111。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>β</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;color:red;">β</span></span></span></span>[例4] 已知X = 00110 , Y = 01101 , 用补码计算Z = X-Y。解： [X]补 = 00110，[-Y]补 = 10011，则[Z]补 =[X]补+[-Y]补 = 00110 + 10011<br>
= 11001 , 其真值为Z = 10111。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>c</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>y</mi><mtext>进位是对无符号数运算有意义的标志位，而</mtext><mi>o</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>f</mi><mi>l</mi><mi>o</mi><mi>w</mi><mtext>是对有符号数运算有意义的标志位</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{carry进位是对无符号数运算有意义的标志位，而overflow是对有符号数运算有意义的标志位}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="color:red;">c</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">rry</span><span class="mord cjk_fallback" style="color:red;">进位是对无符号数运算有意义的标志位，而</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">v</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">er</span><span class="mord mathnormal" style="margin-right:0.10764em;color:red;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="margin-right:0.02691em;color:red;">w</span><span class="mord cjk_fallback" style="color:red;">是对有符号数运算有意义的标志位</span></span></span></span></p>
<p>溢出及补码溢出的判断无论采用何种机器数，只要运算的结果大于数值设备所能表示数的范围，就会产生溢出。 溢出现象应当作一种故障来处理，因为它使结果数发生错误。异号两数相加时，实际是两数的绝对值相减，不可能产生溢出，但有可能出现正常进位；同号两数相加时，实际上是两数的绝对值相加，既可能产生溢出，也可能出现正常进位。由于补码运算存在符号位进位自然丢失而运算结果正确的问题，因此，应区分补码的溢出与正常进位。<br>
[例5] 某数字设备用五位二进制表示数，计算（1）9+3 （2）-9-3 （3）9+12 （4）-9-12<br>
解：</p>
<p>​	 （1）[+9]补+[+3]补= 01001+ 00011 = 01100 = +12 正确；​     （2）[-9]补+[-3]补= 10111+ 11101 = 110100 = 10100（<strong>符号位进位自然丢失</strong>），      其真值为11100=-1100 = -12正确；</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>10111</mn><mspace linebreak="newline"></mspace><mn>11101</mn><mspace linebreak="newline"></mspace><mn>110100</mn></mrow><annotation encoding="application/x-tex">10111\\11101\\110100
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10111</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11101</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">110100</span></span></span></span></span></p>
<p>​     （3）[+9]补+[12]补= 01001 + 01100 = 10101 其真值为11011=-1011 =-11错误，产生了溢出；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>01001</mn><mspace linebreak="newline"></mspace><mn>01100</mn></mrow><annotation encoding="application/x-tex">01001\\01100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">01001</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">01100</span></span></span></span>​     （4）[-9]补+[-12]补 = 10111+10100 = 101011 其真值为01011= +11 错误，产生了溢出。（1）、（2）两题结果均正确，查其最高位和次高位的进位位，不是均无进位产生，就是均产生进位；（3）、（4）两题结果均错误，查其最高位和次高位的进位位，只有一位产生了进位。此即为判断机器是正常进位还是溢出的基本依据，在微型机中可用异或电路来实现上述的判断。</p>
<p>负数的减法运算也要设法化为加法来做,其所以使用这种方法而不使用直接减法,是因为它可以和常规的加法运算使用同一加法器电路,从而简化了计算机的设计。</p>
<h4 id="关于有符号数的溢出判断">关于有符号数的溢出判断</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/2019112419182369.png" alt="img"></p>
<blockquote>
<p>详解参考：<a href="https://blog.csdn.net/qq_42264877/article/details/103227523">(64条消息) 有符号数溢出判断–超详细，新手进_九十度转角9的博客-CSDN博客_有符号数溢出</a></p>
</blockquote>
<h4 id="二进制正数与负数的转换：">二进制正数与负数的转换：</h4>
<h6 id="u-正数转换为负数：所有位取反末位加1；-u"><u>正数转换为负数：所有位取反末位加1；</u></h6>
<p>比如：00000001取反加1后为11111111，11111111表示的是补码，所以要转换为原码为10000001，而10000001表示的是-1。</p>
<h6 id="负数转为正数：最高位置0即可-相当于求绝对值">负数转为正数：最高位置0即可，相当于求绝对值。</h6>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>数的进制</tag>
        <tag>原码、反码、补码</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF算法笔记</title>
    <url>/2023/04/16/University/Algorithm/Basic%20knowledge%20of%20C++/CCF%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>CCF算法笔记</h1>
<blockquote>
<p>本篇笔记是本人复习CCF-CSP考试的过程中编写的，方便复习与巩固。</p>
</blockquote>
<h2 id="c-c-算法">C/C++算法</h2>
<h3 id="c-string判断大小写以及数字">C++string判断大小写以及数字</h3>
<p>可以使用C++中的isupper()、islower()和isdigit()函数来判断字符串中的大小写字母和数字。</p>
<p>可以使用<code>isalpha()</code>函数判断是否为字母。</p>
<p>isalpha()、isupper()、islower()和isdigit()函数的返回值都是bool型。</p>
<h3 id="c-erase-函数">C++ erase()函数</h3>
<p><u><em><strong>erase()函数</strong></em></u>可以用于以下类型的容器：<code>string</code>、<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>等。</p>
<p><code>std::vector</code> 的 <code>erase</code> 函数可以用来从向量中删除一个或多个元素。该函数有两种重载形式：</p>
<ol>
<li class="lvl-3">
<p>通过位置删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iterator erase (const_iterator position);</span><br><span class="line">iterator erase (const_iterator first, const_iterator last);</span><br></pre></td></tr></table></figure>
<p>第一种形式用于删除一个单独的元素，该元素由迭代器 <code>position</code> 指定。这将使其后面的所有元素向前移动一个位置，并且向量的大小会减小1。</p>
<p>第二种形式用于删除一系列连续的元素，这些元素被迭代器对 <code>[first, last)</code> 区间指定。这将使所有在删除范围之后的元素向前移动，并且向量的大小会减小删除的元素数量。</p>
</li>
<li class="lvl-3">
<p>通过值删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iterator erase (const T&amp; value);</span><br></pre></td></tr></table></figure>
<p>这个版本的 <code>erase</code> 用于删除向量中的所有等于给定值 <code>value</code> 的元素。它返回一个迭代器，指向被删除元素的下一个位置。</p>
</li>
</ol>
<p>需要注意的是，这些函数只适用于可变的（即非常量）向量。</p>
<h3 id="c-unique-函数">C++ unique()函数</h3>
<p>C++ STL中的<code>unique()</code>函数是一个常用的算法，用于删除容器中相邻的重复元素。它接受两个迭代器表示容器范围，并<mark>返回一个指向新末尾的迭代器（也就是最后一个不重复元素的下一个位置）</mark>，该迭代器之前的所有元素都是唯一的。</p>
<p><code>unique()</code>函数的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt</span>&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">(ForwardIt first, ForwardIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">(ForwardIt first, ForwardIt last, BinaryPredicate p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，参数<code>first</code>和<code>last</code>指定了要处理的容器中的元素范围；<code>p</code>是一个可选的二元谓词，用于比较两个元素是否相等。如果省略了第二个参数，则默认使用<code>operator==</code>进行比较。</p>
<p><code>unique()</code>函数的基本思想是：遍历容器中的每一个元素，将它与前一个元素进行比较。如果它们相等，就将后一个元素删除，并继续往后比较，直到找到不相等的元素为止。这样遍历整个容器，最后得到的就是一个没有相邻重复元素的新容器。</p>
<h3 id="c-equel-range-函数">C++ equel_range()函数</h3>
<p>equel_range() 函数定义在<code>&lt;algorithm&gt;</code>头文件中，用于在指定范围内查找等于目标值的所有元素。</p>
<h6 id="返回值">返回值</h6>
<p>该函数会返回一个 pair 类型值，其包含 2 个正向迭代器。</p>
<p>当<mark>查找成功</mark>时：</p>
<ol>
<li class="lvl-3">
<p>第 1 个迭代器指向的是 [first, last) 区域中第一个等于 val 的元素；</p>
</li>
<li class="lvl-3">
<p>第 2 个迭代器指向的是 [first, last) 区域中第一个大于 val 的元素。</p>
</li>
</ol>
<p>反之如果<mark>查找失败</mark>，则这 2 个迭代器要么都指向大于 val 的第一个元素（如果有），要么都和 last 迭代器指向相同。</p>
<h6 id="特点">特点</h6>
<ol>
<li class="lvl-3">
<p>map、multimap、unordered_map的equel_range()都是查找的<code>key</code>，或者说是<code>.first</code>;</p>
</li>
</ol>
<blockquote>
<p>注：</p>
<ul class="lvl-1">
<li class="lvl-2">equal_range.first和lower_bound返回值是一样的，都是指向第一个相等元素（可以这样认为）的迭代器，无论最后找到或者找不到匹配的关键字，它们都相等。</li>
<li class="lvl-2">同理，equal_range.second和upper_bound的返回值一样，都是指向最后一个相等元素的后一个元素的迭代器，如果找不到关键字，那么将会得到一个安全的关键字插入位置。</li>
</ul>
</blockquote>
<h3 id="c-迭代器-stl迭代器-iterator">C++迭代器（STL迭代器）iterator</h3>
<h6 id="定义">定义</h6>
<p>迭代器按照定义方式分成以下四种。</p>
<p>\1) 正向迭代器，定义方法如下：</p>
<p>容器类名::iterator 迭代器名;</p>
<p>\2) 常量正向迭代器，定义方法如下：</p>
<p>容器类名::const_iterator 迭代器名;</p>
<p>\3) 反向迭代器，定义方法如下：</p>
<p>容器类名::reverse_iterator 迭代器名;</p>
<p>\4) 常量反向迭代器，定义方法如下：</p>
<p>容器类名::const_reverse_iterator 迭代器名;</p>
<h6 id="用法">用法</h6>
<p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p>
<p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</p>
</li>
<li class="lvl-2">
<p>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.<span class="built_in">push_back</span>(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) &#123;  <span class="comment">//用迭代器遍历容器——end成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator j = v.<span class="built_in">rbegin</span>(); j != v.<span class="built_in">rend</span>(); ++j)</span><br><span class="line">        cout &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rbegin成员函数返回指向容器中最后一个元素的迭代器，rend成员函数返回指向容器中第一个元素前面的位置的迭代器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序的输出结果是：</span><br><span class="line">0 1 2 3 4</span><br><span class="line">8 6 4 2 0</span><br></pre></td></tr></table></figure>
<h3 id="c-begin-和end-容器">C++begin()和end()容器⭐️</h3>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7376.html">C++ STL begin()和end()函数用法 (biancheng.net)</a></p>
</blockquote>
<p><u><em><strong>begin()和end()容器：</strong></em></u></p>
<ol>
<li class="lvl-3">
<p>可以对向量、集合、map……等有用；</p>
</li>
<li class="lvl-3">
<p>也对数组有相同的作用；</p>
<ul class="lvl-2">
<li class="lvl-5">将指定数组传给 begin() 函数，其会返回一个指向该数组<mark>首个元素的指针</mark>；将指定数组传给 end() 函数，其会返回一个指向数组中<mark>最后一个元素之后位置的指针</mark>。</li>
</ul>
</li>
</ol>
<h3 id="c-set容器">C++set容器</h3>
<h4 id="set-count-type-target">set.count(type target)</h4>
<p>计算目标值的个数</p>
<h3 id="c-数组">C++数组</h3>
<h4 id="定义数组作形参的函数">定义数组作形参的函数</h4>
<h6 id="静态数组作参数：">静态数组作参数：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种——对数组的引用</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">convert_matrix</span><span class="params">(<span class="type">double</span> (&amp;M)[<span class="number">8</span>][<span class="number">8</span>],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种——数组传值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">convert_matrix</span><span class="params">(<span class="type">double</span> M[][<span class="number">8</span>],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种——数组传值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">convert_matrix</span><span class="params">(<span class="type">double</span> M[<span class="number">8</span>][<span class="number">8</span>],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态数组作参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> counts = <span class="number">0</span>;<span class="comment">// 计数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">N_queens</span><span class="params">(<span class="type">int</span> i, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;M, <span class="type">int</span> col[], <span class="type">int</span> L[], <span class="type">int</span> R[])</span></span>&#123;<span class="comment">// 动态数组作参数</span></span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">	<span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">M</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N, <span class="number">0</span>));<span class="comment">// 采用int M[N][N]，不方便给函数传参，这里要用vector动态数组 </span></span><br><span class="line">	<span class="type">int</span> col[N]=&#123;<span class="number">0</span>&#125;, L[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;, R[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;;<span class="comment">// 1则表明存储皇后 </span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">N_queens</span>(<span class="number">0</span>, M, col, L, R);</span><br><span class="line">	cout&lt;&lt;n;<span class="comment">// 可行解数量 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="c-获取数组长度-元素个数">C++获取数组长度（元素个数）</h4>
<p>在 C++ 中，可以通过以下两种方式来获取数组的长度：</p>
<ol>
<li class="lvl-3">
<p>使用 sizeof 操作符</p>
</li>
</ol>
<p>使用 sizeof 操作符可以返回数组所占用的总字节数，除以每个元素所占用的字节数即可得到数组的长度。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>其中，sizeof(arr) 返回整个数组占用的字节数，sizeof(arr[0]) 返回数组中第一个元素所占用的字节数。因此，sizeof(arr) / sizeof(arr[0]) 即为数组的长度。</p>
<ol start="2">
<li class="lvl-3">
<p>使用模板函数</p>
</li>
</ol>
<p>C++11 引入了 std::extent 模板函数，可以直接获取数组的长度。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = std::extent&lt;<span class="keyword">decltype</span>(arr)&gt;::value;</span><br></pre></td></tr></table></figure>
<p>其中，decltype(arr) 返回数组类型，std::extent&lt;decltype(arr)&gt;::value 返回数组的长度。</p>
<h2 id="数学算法">数学算法</h2>
<h3 id="向量的内积和叉乘">向量的内积和叉乘</h3>
<h5 id="内积">内积</h5>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000752499.png" alt="image-20230312000752499"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000632698.png" alt="image-20230312000632698"></p>
</blockquote>
<h5 id="叉乘">叉乘</h5>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000739739.png" alt="image-20230312000739739"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000659502.png" alt="image-20230312000659502"></p>
</blockquote>
<h3 id="欧几里得算法">欧几里得算法</h3>
<p><strong>gcd(a,b) = gcd(b,a mod b)</strong></p>
<p>形象记忆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a % b = c</span><br><span class="line">	b % c = d</span><br><span class="line">		c % d = e</span><br><span class="line">			d % e = f</span><br><span class="line">				......</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>欧几里得算法拓展：</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_43872728/article/details/107289833">(77条消息) 扩展欧几里得算法超详解_Aloof__的博客-CSDN博客_扩展欧几里得原理</a></p>
</blockquote>
<p><strong>给予二整数 a 与 b, 必存在有整数 x 与 y 使得ax + by = gcd(a,b)</strong></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011195717705.png" alt="image-20221011195717705" style="zoom: 67%;" />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=(-7)*47+(11)*30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gcd(a,b)可以表示为a,b的整洗数线性组合，例如：gcd(6,14)=2,而2=(-2)*6+1*14.</span><br></pre></td></tr></table></figure>
<h3 id="绝对值函数abs"><mark>绝对值</mark>函数abs()</h3>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span><span class="comment">//C语言是math.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">10</span>;</span><br><span class="line">	<span class="type">float</span> c=<span class="number">1</span>,d=<span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> e=<span class="number">1</span>,f=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;b-a=&quot;</span>&lt;&lt;<span class="built_in">abs</span>(b-a)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;c-d=&quot;</span>&lt;&lt;<span class="built_in">abs</span>(c-d)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;e-f=&quot;</span>&lt;&lt;<span class="built_in">abs</span>(e-f)&lt;&lt;endl;</span><br><span class="line">	cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">b-a=<span class="number">9</span></span><br><span class="line">c-d=<span class="number">9</span></span><br><span class="line">e-f=<span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="c-实现四舍五入的几种方法">C++实现<mark>四舍五入</mark>的几种方法</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/Xavier_97/article/details/126931927">(101条消息) C<ins>实现四舍五入的几种方法_c</ins>四舍五入_Xaiver_97的博客-CSDN博客</a></p>
<ol>
<li class="lvl-3">函数round()实现四舍五入</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> a = <span class="number">1.4999999</span>;</span><br><span class="line">  <span class="type">double</span> b = <span class="number">1.5000001</span>;</span><br><span class="line">  <span class="type">double</span> n_a = <span class="number">-1.4999999</span>;    </span><br><span class="line">  <span class="type">double</span> n_b = <span class="number">-1.5000001</span>; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(a) &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(b) &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(n_a) &lt;&lt; endl;    <span class="comment">// -1</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(n_b) &lt;&lt; endl;    <span class="comment">// -2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>round()函数原理为：<code>x=(int)(x+0.5)</code>公式，故可以自己写出round()函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">round</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)(x+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="fisher-yates-洗牌算法">Fisher-Yates 洗牌算法</h4>
<blockquote>
<p>可以参考：<a href="https://zhuanlan.zhihu.com/p/334553072">Fisher-Yates洗牌算法！来自算法理论的创始人！ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h6 id="正向洗牌与反向洗牌算法：">正向洗牌与反向洗牌算法：</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffled</span><span class="params">(origin)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = origin.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 可以使用反向或者正向洗牌，效果相同。</span></span><br><span class="line"><span class="comment">// 反向洗牌：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(shuffled[i], shuffled[<span class="built_in">rand</span>() % (i + <span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 正向洗牌：</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line"><span class="comment">// int pos = rand() % (n - i);</span></span><br><span class="line"><span class="comment">// swap(shuffled[i], shuffled[i+pos]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">return</span> shuffled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="knuth-morris-pratt-kmp-算法">Knuth-Morris-Pratt（KMP）算法</h4>
<blockquote>
<p>参考：<a href="https://zh.wikipedia.org/wiki/KMP%E7%AE%97%E6%B3%95">KMP算法 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
</blockquote>
<h2 id="c-位运算及其应用">C++位运算及其应用</h2>
<h3 id="c-异或运算及其应用">C++ 异或运算及其应用</h3>
<h4 id="前置知识：">前置知识：</h4>
<p><strong>1.一个整数自己跟自己异或，结果为0。//因为异或的法则为，相同为0，不同为1，注意这里所说的都是二进制位。</strong></p>
<p><strong>2.任意一个整数跟0异或，结果为本身。//因为1异或0得1,0异或0,得0，所以1还是1,0还是0，没发生变化。</strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/1685178-20191127204008258-1599418865.png" alt="img"></p>
<blockquote>
<p>通过异或运算不用临时变量的情况下进行两个变量的值交换。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1>C++编程技巧</h1>
<h4 id="关闭c-与c之间标准输入输出之间的同步-提升效率">关闭C++与C之间标准输入输出之间的同步，提升效率</h4>
<p>在C<ins>中，<code>ios::sync_with_stdio(false);</code>是一条语句，用于关闭C</ins>标准库输入输出与C标准库输入输出之间的同步，从而提高程序的输入输出效率。默认情况下，C++标准库与C标准库之间会进行缓冲区同步，这会导致程序在读入或输出数据时的速度较慢。</p>
<p>当你需要在C<ins>中进行大量的输入输出操作时，特别是对时间敏感的代码，使用该语句可以显著提升程序的运行速度。但是要注意的是，在关闭同步后，就不能再同时使用cin和scanf等函数了，因为它们分别属于不同的输入输出流，并且不同输入输出流之间可能会发生数据竞争问题。所以在关闭同步之后，应该只使用C</ins>标准库的输入输出函数，比如cout和cin。</p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>C++</tag>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计竞赛笔记</title>
    <url>/2023/04/16/University/Algorithm/Basic%20knowledge%20of%20C++/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>程序设计竞赛笔记</h1>
<h2 id="c-c-基础">C/C++基础</h2>
<h3 id="std">std</h3>
<p>std：命名空间标识符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>一般在调用c++标准库中的函数或是对象时需要在函数或是对象前面怎加std。</p>
<h4 id="size-t-类型">size_t 类型</h4>
<p>size_t 类型表示C中任何对象所能达到的最大长度，它是<mark>无符号整数</mark>。</p>
<h3 id="c-索引-切片">C++索引（切片）</h3>
<p>C++中的切片方式一般为：(begin_pos,size)</p>
<h3 id="关于comp方法">关于comp方法⭐️</h3>
<h6 id="comp实现的源码：">comp实现的源码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator, <span class="keyword">typename</span> _Value&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Iterator __it, _Value&amp; __val)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">bool</span>(_M_comp(*__it, __val)); &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由源码可以看出comp的第一个参数是迭代器，而第二个元素是value值</p>
</blockquote>
<hr>
<h4 id="std-lambda-匿名函数">std::lambda 匿名函数</h4>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲 (biancheng.net)</a></p>
</blockquote>
<p><mark>lambda指的是匿名函数</mark></p>
<p>lambda 表达式的语法形式可简单归纳如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>) &lt;&lt; std::endl;  <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda 表达式在没有参数列表时，参数列表是可以省略的</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = []&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;  <span class="comment">// 省略空参数表</span></span><br></pre></td></tr></table></figure>
<p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>[] 不捕获任何变量。</p>
</li>
<li class="lvl-2">
<p>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（<mark>按引用捕获</mark>）。</p>
</li>
<li class="lvl-2">
<p>[=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（<mark>按值捕获</mark>）。</p>
</li>
<li class="lvl-2">
<p>[=，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</p>
</li>
<li class="lvl-2">
<p>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</p>
</li>
<li class="lvl-2">
<p>[this] 捕获当前类中的 this <a href="">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</p>
</li>
</ul>
<p>基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_ = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = []&#123; <span class="keyword">return</span> i_; &#125;;                    <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_; &#125;;                <span class="comment">// OK，捕获this指针</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">// error，没有捕获x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;  <span class="comment">// OK，捕获this指针、x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_++; &#125;;              <span class="comment">// OK，捕获this指针，并修改成员的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = []&#123; <span class="keyword">return</span> a; &#125;;               <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// OK，捕获所有外部变量，并对a执行自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a; &#125;;              <span class="comment">// OK，捕获所有外部变量，并返回a</span></span><br><span class="line"><span class="keyword">auto</span> f4 = [=]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// error，a是以复制方式捕获的，无法修改</span></span><br><span class="line"><span class="keyword">auto</span> f5 = [a]&#123; <span class="keyword">return</span> a + b; &#125;;          <span class="comment">// error，没有捕获变量b</span></span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获a和b的引用，并对b做自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获所有外部变量和b的引用，并对b做自加运算</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="std-sort">std::sort</h4>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7457.html">C++ sort()排序函数用法详解 (biancheng.net)</a></p>
</blockquote>
<p>sort(first,last,Comp)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(first, last, Comp);</span><br><span class="line"><span class="comment">//根据Comp返回的值为true或false判断是否执行交换，如果为true则证明符合排序标准，不交换；否则，交换位置</span></span><br><span class="line"><span class="comment">//一般Comp写成一个匿名函数</span></span><br></pre></td></tr></table></figure>
<h6 id="sort的comp方法">sort的comp方法⭐️</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>sort默认按照升序排序</p>
</li>
<li class="lvl-2">
<p>sort设置comp实现降序排序：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//a是迭代器，a会往后移动？</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;<span class="comment">//如果前面的元素a比后面的元素b大则符合我们的降序排序标准，因此不用进行位置交换，如果a&gt;b为false，则需要进行a，b位置的交换。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;a,<span class="type">const</span> <span class="type">int</span>&amp;b)</span></span>&#123;       </span><br><span class="line"> 	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">c</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		cin&gt;&gt;c[i];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">sort</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),comp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		cout&lt;&lt;c[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输入</span><br><span class="line">1 5 2 3 4</span><br><span class="line">//输出</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="关于c-中vector-vector-int-array的理解">关于C++中vector&lt;vector<int>&gt;array的理解</h5>
<p>解释：array用来保存一个3 * 3的二维数组，array的每个元素都是vector<int>类型</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));<span class="comment">//定义二维数组dp[][]，n行 m列</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是对以上二维数组的两种赋值方式：</p>
<p>1️⃣采用vector模板中的方法push_back()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//array用来保存一个3*3的二维数组，array的每个元素都是vector&lt;int&gt;类型</span></span><br><span class="line">    vector &lt;vector&lt;<span class="type">int</span>&gt;&gt;array;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="type">int</span> value;</span><br><span class="line">            cin &gt;&gt; value;</span><br><span class="line">            v.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        array.<span class="built_in">push_back</span>(v); <span class="comment">//保存array的每个元素</span></span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;array.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;<span class="number">3</span>; j++)</span><br><span class="line">            cout &lt;&lt;array[i][j];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2️⃣用分配空间的resize()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector &lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">array</span>(<span class="number">3</span>);<span class="comment">//首先给array开辟了三个空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        array[i].<span class="built_in">resize</span>(<span class="number">3</span>);<span class="comment">//给array中每个元素开辟了三个空间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            cin &gt;&gt; array[i][j];<span class="comment">//直接对开辟的空间赋值即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;array.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;<span class="number">3</span>; j++)</span><br><span class="line">            cout &lt;&lt;array[i][j];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="array-size">array.size()</h5>
<p>获得数组的条目数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>对于二维数组来说得到的是二维数组的行数</p>
<hr>
<h5 id="memset">memset()</h5>
<p>C 库函数 <strong>void *memset(void *str, int c, size_t n)</strong> 复制字符 <strong>c</strong>（一个无符号字符）到参数 <strong>str</strong> 所指向的字符串的<mark>前 <strong>n</strong> 个字符</mark>。</p>
<p>声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>str</strong> – 指向要填充的内存块。</p>
</li>
<li class="lvl-2">
<p><strong>c</strong> – 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。</p>
</li>
<li class="lvl-2">
<p><strong>n</strong> – 要被设置为该值的字符数</p>
</li>
</ul>
<p>返回值：</p>
<p>该值返回一个指向存储区 str 的指针。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>(str,<span class="string">&quot;This is string.h library function&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(str);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">memset</span>(str,<span class="string">&#x27;$&#x27;</span>,<span class="number">7</span>);</span><br><span class="line">   <span class="built_in">puts</span>(str);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	输出结果如下：符号$被复制到str的前7个位置上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">This is string.h library function</span><br><span class="line">$$$$$$$ string.h library function</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="unique">unique()</h5>
<p>unique函数属于STL中比较常用函数，它的功能是元素去重。</p>
<p><u><em><strong>返回值：</strong></em></u>是一个迭代器，指向的是去重之后容器中不重复序列的最后一个元素的下一个元素。</p>
<blockquote>
<p>unique函数的去重过程实际上就是<u><em><strong>不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置</strong>。</em></u></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/553062-20180513221754094-1680292644.png" alt="unique示例图"></p>
<ol>
<li class="lvl-3">
<p>有很多文章说的是，unique去重的过程是将重复的元素移到容器的后面去，实际上这种说法并不正确，应该是把不重复的元素移到前面来</p>
</li>
<li class="lvl-3">
<p>unique函数在使用前需要对容器中的元素进行排序(当然不是必须的，但我们绝大数情况下需要这么做)，由于本例中的元素已经是排好序的，所以此处我没排序，但实际使用中不要忘记</p>
</li>
</ol>
</blockquote>
<p>unique函数的函数原型如下：</p>
<p>1.只有两个参数，且参数类型都是迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">unique</span><span class="params">(iterator it_1,iterator it_2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中这两个参数表示对容器中[it_1，it_2)范围的元素进行去重(<strong>注：区间是前闭后开，即不包含it_2所指的元素</strong>),返回值是一个迭代器，<strong>它指向的是去重后容器中不重复序列的最后一个元素的下一个元素</strong>。</p>
<p>2.有三个参数，且前两个参数类型为迭代器，最后一个参数类型可以看作是bool类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">unique</span><span class="params">(iterator it_1,iterator it_2,<span class="type">bool</span> MyFunc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中前两个参数和返回值同上面类型的unique函数是一样的，主要区别在于第三个参数。这里的第三个参数表示的是<strong>自定义元素是否相等</strong>。也就是说通过自定义两个元素相等的规则，来对容器中元素进行去重。<u>这里的第三个参数与STL中sort函数的第三个参数功能类似。</u></p>
<hr>
<h3 id="begin-和end-容器">begin()和end()容器⭐️</h3>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7376.html">C++ STL begin()和end()函数用法 (biancheng.net)</a></p>
</blockquote>
<p><u><em><strong>begin()和end()容器：</strong></em></u></p>
<ol>
<li class="lvl-3">
<p>可以对向量（vector）、集合（set）、map……等有用；</p>
</li>
<li class="lvl-3">
<p>也对数组有相同的作用；</p>
<ul class="lvl-2">
<li class="lvl-5">将指定数组传给 begin() 函数，其会返回一个指向该数组首个元素的指针；将指定数组传给 end() 函数，其会返回一个指向数组中最后一个元素之后位置的指针。</li>
</ul>
</li>
</ol>
<h3 id="vector-容器">vector 容器</h3>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/6749.html">C++ STL vector容器详解 (biancheng.net)</a></p>
</blockquote>
<p>&quot;vector函数的作用就是申请内存空间，vector是一种可以自动扩展的容器，也就是可以根据元素个数自动申请内存，那么有什么必要去主动为它申请内存空间呢？答案是有必要的，我们来看个例子。假如要使用vector存储1000个数据：</p>
<p>方式1：vector vec, 然后调用1000次 vec.push_back()；方式2：vector vec,然后调用vec.reserve(1000)申请1000个元素的内存，再调用1000次 vec.push_back()；</p>
<p>方式1要进行若干次内存分配；而方式2只需要进行1次内存分配。其效率立见高下，所以在需要对大量数据进行处理的时候，使用reserve主动分配内存可以提升程序执行效率。&quot;</p>
<hr>
<h5 id="vector-resize">vector ::resize()</h5>
<p><em>一、resize<br>
1、resize(n)<br>
调整容器的长度大小，使其能容纳n个元素。如果n小于容器的当前的size，则删除多出来的元素。否则，添加采用值初始化的元素。<br>
2、 resize(n，t)<br>
多一个参数t，将所有新添加的元素初始化为t。</em></p>
<hr>
<h5 id="vector-reserve">vector ::reserve()</h5>
<p><em>二、reserve<br>
reserver()的用法只有一种：reserve(n)<br>
预分配n个元素的存储空间。</em></p>
<p><em>size（长度）：指容器当前拥有的元素个数；<br>
capacity（容量）：则指容器在必须分配新存储空间之前可以存储的元素总数，也可以说是预分配存储空间的大小。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*@function 申请n个元素的内存空间</span></span><br><span class="line"><span class="comment">*@param n  元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span> <span class="params">(size_type n)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>容器调用resize()函数后，所有的空间都已经初始化了，所以可以直接访问。而reserve()函数预分配出的空间没有被初始化，所以不可访问。</strong></p>
<p>1）resize()函数对vector的影响。<br>
size：调用resize(n)后，vector的size即为n，且其中元素都为0。<br>
capacity：取决于调整后的容器的size是否大于capacity。如果调整后size大于capacity，则capacity调整为size大小，否则不变</p>
<p>2）reserve()函数对vector影响<br>
capacity：调用reserve(n)后，若容器的capacity&lt;n，则重新分配内存空间，从而使得capacity等于n。如果capacity&gt;=n，capacity无变化。</p>
<blockquote>
<p>在 C++ 中，<code>vector</code> 是一种动态数组（可变大小的连续内存块），<code>reserve()</code> 是 <code>vector</code> 的一个成员函数，用于预留容器的存储空间。它接受一个参数，该参数表示要预留的元素个数。</p>
<p>调用 <code>reserve()</code> 函数并不会改变 <code>vector</code> 的大小，而仅仅是分配足够的内存以容纳指定数量的元素。这可以避免在向 <code>vector</code> 添加元素时重复分配内存，从而提高程序性能。</p>
<p>需要注意的是，如果你在 <code>reserve()</code> 函数中传递的参数小于当前容器的大小，则不会发生任何事情。如果你想缩小容器的大小，可以使用 <code>resize()</code> 或 <code>shrink_to_fit()</code> 函数。</p>
</blockquote>
<hr>
<h5 id="u-容器的begin-cbegin-rbegin-crbegin-函数-u"><u>容器的begin()、cbegin()、rbegin()、crbegin()函数</u></h5>
<p>总结：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>begin();end()</code>正序迭代器</p>
</li>
<li class="lvl-2">
<p><code>cbegin();cend()</code> 返回 <code>const</code> 的<code>begin();end()</code></p>
</li>
<li class="lvl-2">
<p><code>rbegin();rend()</code> 逆序迭代器</p>
</li>
<li class="lvl-2">
<p><code>crbegin();crend()</code> 返回 <code>const</code> 的 <code>rbegin();rend()</code></p>
</li>
</ul>
<hr>
<h5 id="find-函数">find() 函数</h5>
<p>find()返回指定元素出现的第一个位置下标。</p>
<p>如下为 find() 函数的语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。</p>
<blockquote>
<p>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p>
<p>当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</p>
</blockquote>
<hr>
<h5 id="erase-函数">erase() 函数</h5>
<p>erase() 函数三种用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符</span></span><br><span class="line"><span class="built_in">erase</span>(pos,n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、删除position处的一个字符(position是个string类型的迭代器)</span></span><br><span class="line"><span class="built_in">erase</span>(position);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、删除从first到last之间的字符（first和last都是迭代器）</span></span><br><span class="line"><span class="built_in">erase</span>(first,last);</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="vector-begin">vector::begin()</h5>
<p>vector::begin()是 “vector” 头文件的库函数，用于获取向量的第一个元素。它返回一个指向向量第一个元素的迭代器。</p>
<hr>
<h5 id="vector-back">vector::back()</h5>
<p>**vector :: back()<strong>是</strong>“ vector”**标头的库函数，用于访问矢量的最后一个元素，它返回对矢量的最后一个元素的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*定义一个没有初始化空间的向量（也可以说是数组）</span></span><br><span class="line"><span class="comment">*这个时候不能用数组的形式对其赋值：dp[i]=23，是不被允许的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;dp;</span><br><span class="line">dp.<span class="built_in">push_back</span>(<span class="number">23</span>);<span class="comment">//合法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="vector-push-back">vector::push_back()</h5>
<p>vector::push_back()在vector尾部加入一个数据;</p>
<hr>
<h5 id="vector-pop-back">vector::pop_back()</h5>
<p>vector::pop_back() 是&quot;vector&quot; 头文件的库函数，用于从vector 尾部删除一个元素，从vector 后面删除元素并返回void。</p>
<hr>
<h5 id="iota-函数">iota() 函数</h5>
<p>C++中 iota() 是用来批量递增赋值vector的元素的。</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// iota函数可以把数组初始化为0到n-1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><u>注意与atoi()函数区分开</u></p>
</blockquote>
<hr>
<h5 id="atoi-函数">atoi() 函数</h5>
<p>扫描str字符串，将数字或正负号转换为int型</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;-10&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="built_in">atoi</span>(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %d\n&quot;</span>, num1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果： </span></span><br><span class="line">num1 = <span class="number">-10</span></span><br><span class="line"></span><br><span class="line">而 <span class="type">char</span> str1[] = <span class="string">&quot;abc-1100def&quot;</span>;结果是： num1 = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<p>vector::insert()与vector::emplace()</p>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/6834.html">C++ STL vector插入元素（insert()和emplace()）详解 (biancheng.net)</a></p>
</blockquote>
<p><u><strong>emplace()的插入效率更高</strong></u></p>
<hr>
<h3 id="array-容器">array 容器</h3>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/6688.html">C++ array(STL array)容器用法详解 (biancheng.net)</a></p>
</blockquote>
<p>它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建具有 10 个 double 类型元素的 array 容器</span></span><br><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values&#123;&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="list-容器">list 容器</h3>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/6933.html">C++ STL list添加（插入）元素方法详解 (biancheng.net)</a></p>
</blockquote>
<p>成员方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>push_front()：向 list 容器首个元素前添加新元素；</p>
</li>
<li class="lvl-2">
<p>push_back()：向 list 容器最后一个元素后添加新元素；</p>
</li>
<li class="lvl-2">
<p>emplace_front()：在容器首个元素前直接生成新的元素；</p>
</li>
<li class="lvl-2">
<p>emplace_back()：在容器最后一个元素后直接生成新的元素；</p>
</li>
<li class="lvl-2">
<p>emplace()：在容器的指定位置直接生成新的元素；</p>
</li>
<li class="lvl-2">
<p>insert()：在指定位置插入新元素；</p>
</li>
<li class="lvl-2">
<p>splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。</p>
</li>
</ul>
<h5 id="list-splice-成员方法">list splice()成员方法</h5>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>void splice (iterator position, list&amp; x);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，<em><mark><strong>将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</strong></mark></em></td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator i);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是==<em><strong>将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处</strong></em>==。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是==<em><strong>将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处</strong></em>==。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种语法格式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span> <span class="params">(iterator position, list&amp; x)</span></span>;</span><br><span class="line"><span class="comment">// 第二种语法格式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span> <span class="params">(iterator position, list&amp; x, iterator i)</span></span>;</span><br><span class="line"><span class="comment">// 第三种语法格式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span> <span class="params">(iterator position, list&amp; x, iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><mark>list 容器</mark>底层使用的是<u><em>链表存储结构</em></u>，splice() 成员方法移动元素的方式是，将存储该元素的节点从 list 容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中。这意味着，当使用 splice() 成员方法将 x 容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除。</p>
</blockquote>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 2 个 list 容器</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;, mylist2&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it = ++mylist1.<span class="built_in">begin</span>(); <span class="comment">//指向 mylist1 容器中的元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    mylist1.<span class="built_in">splice</span>(it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                 <span class="comment">// mylist2:</span></span><br><span class="line">                                 <span class="comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span></span><br><span class="line">    mylist2.<span class="built_in">splice</span>(mylist2.<span class="built_in">begin</span>(), mylist1, it);   <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                                    <span class="comment">// mylist2: 2</span></span><br><span class="line">                                                    <span class="comment">// it 仍然指向元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span></span><br><span class="line">    mylist2.<span class="built_in">splice</span>(mylist2.<span class="built_in">begin</span>(), mylist1, mylist1.<span class="built_in">begin</span>(), mylist1.<span class="built_in">end</span>());<span class="comment">//mylist1:</span></span><br><span class="line">                                                                             <span class="comment">//mylist2:1 10 20 30 3 4 2</span></span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mylist1 包含 &quot;</span> &lt;&lt; mylist1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mylist2 包含 &quot;</span> &lt;&lt; mylist2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 mylist2 容器中存储的数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mylist2:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mylist2.<span class="built_in">begin</span>(); iter != mylist2.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">mylist1 包含 <span class="number">0</span>个元素</span><br><span class="line">mylist2 包含 <span class="number">7</span>个元素</span><br><span class="line">mylist2:<span class="number">1</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h5 id="list-insert-成员方法">list insert()成员方法</h5>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（例如 array、vector、deque 等）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 { } 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody>
</table>
<h5 id="list-迭代器-iterator">list 迭代器 iterator</h5>
<blockquote>
<p>详细参考：<a href="https://blog.csdn.net/m0_55717883/article/details/120668205">(77条消息) 简单说明C++ STL list中的迭代器（iterator）_Mr.Z2001的博客-CSDN博客_c++ list iterator</a></p>
</blockquote>
<p>迭代器的类型声明是<code>list&lt;Type T&gt;::iterator</code>，当然也可以<code>auto</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; a &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; b &#123;<span class="number">2</span>, <span class="number">4</span>&#125;;<span class="comment">//构造函数</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator ita = a.<span class="built_in">begin</span>();<span class="comment">//类似于指针</span></span><br><span class="line"><span class="keyword">auto</span> itb = b.<span class="built_in">begin</span>();<span class="comment">//声明一下我们要讨论的迭代器ita和itb，分别作用于链表a和链表b</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="map-容器">map 容器</h3>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7173.html">C++ STL map容器详解 (biancheng.net)</a></p>
</blockquote>
<blockquote>
<p>map是STL的一个关联容器，存储的都是 pair 对象。</p>
<ul class="lvl-1">
<li class="lvl-2">第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li>
<li class="lvl-2">第二个可以称为该关键字的值(value)；</li>
<li class="lvl-2"><mark>map中的键值对会<code>自动</code>根据key进行升序排序</mark>。⭐️</li>
</ul>
<hr>
<p>1️⃣<code>map.first</code>会得到Map中key的有效值;<br>
2️⃣<code>map.second</code>会得到Map中value的有效值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map类型可以初始化大小</span></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;<span class="built_in">buckets</span>(n);</span><br><span class="line"><span class="comment">//但是不能像vector一样初始化值</span></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;<span class="built_in">buckets</span>(n,<span class="number">0</span>);<span class="comment">//这是错误的写法</span></span><br></pre></td></tr></table></figure>
<p>map容器插入键值对的方法一般有三种：</p>
<ol>
<li class="lvl-3">
<p>map[“key”] = value;</p>
</li>
<li class="lvl-3">
<p>map.insert(make_pair&lt;&gt;(&quot;&quot;, “”));</p>
</li>
<li class="lvl-3">
<p>map.emplace(&quot;&quot;, “”);</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">hash</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">    cin&gt;&gt;y&gt;&gt;result;</span><br><span class="line">    hash[i]=make_pair&lt;&gt;(y,result);<span class="comment">//&lt;&gt;不需要写成&lt;int,int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>用下标插入会覆盖 value 值，用 insert 插入键值对则不覆盖（插入失败）</mark></p>
<p>参考：<a href="https://blog.csdn.net/m0_46471347/article/details/105090118">(77条消息) C++ map、unordered_map 插入元素的覆盖问题_cyberickk的博客-CSDN博客</a></p>
<hr>
</blockquote>
<h5 id="从map中获取第一个键和值">从map中获取第一个键和值</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>获取键 key：<code>your_map.begin()-&gt;first</code></p>
</li>
<li class="lvl-2">
<p>获取值 value：<code>your_map.begin()-&gt;second</code></p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/ab94f358cc379299731b9aaa4814fd47.png" alt="img"></p>
<hr>
<h5 id="unordered-map与map的-span-style-color-red-区别-span">unordered_map与map的<span style="color: red;">区别</span></h5>
<ol>
<li class="lvl-3">
<p>unordered_map使用的hash表存储，无序；map用的平衡二叉搜索树，有序；</p>
</li>
<li class="lvl-3">
<p>unordered_map的搜索的时间复杂度最好情况是O(1)，最坏是O(n)；map搜索的时间复杂度永远是O(log n)（由于平衡二叉搜索树的原因）</p>
</li>
<li class="lvl-3">
<p>在map中，使用用户<span style="color: red;">自定义的key</span>的时候，需要重写&lt;操作，<strong>或者</strong>传入一个外部的函数，用于比较key(vector<int> 可以不定义，有默认的)；unordered_map需要为key的类型提供hash函数的定义，<strong>并且</strong>需要重写==。（注意二者的“或者”与“并且”）</p>
</li>
</ol>
<blockquote>
<p>参考：[c++ unordered_map与map - 知乎 (<a href="http://zhihu.com">zhihu.com</a>)](<a href="https://zhuanlan.zhihu.com/p/468286147#:~:text=%E6%80%BB%E7%BB%93%E6%9D%A5%E8%AF%B4%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%9C%89%E5%A6%82%E4%B8%8B%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB%EF%BC%9A">https://zhuanlan.zhihu.com/p/468286147#:~:text=总结来说，主要有如下几点区别：</a> 1.unordered_map使用的hash表存储，无序；map用的平衡二叉搜索树，有序； 2.unordered_map的搜索的时间复杂度最好情况是O,(1)，最坏是O (n)；map搜索的时间复杂度永远是O (log n)（由于平衡二叉搜索树的原因）)</p>
</blockquote>
<hr>
<h5 id="unordered-map-容器">unordered_map 容器</h5>
<blockquote>
<p>详细参考：<a href="http://c.biancheng.net/view/7231.html">C++ STL unordered_map容器用法详解 (biancheng.net)</a></p>
</blockquote>
<p>unordered_map 容器，直译过来就是&quot;无序 map 容器&quot;的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map与unordered_map容器的数组形式</span></span><br><span class="line"><span class="comment">//key代表的时数组下标，val代表的时数组下标对应的值</span></span><br><span class="line">map&lt;string, string&gt; data;</span><br><span class="line">	data[<span class="string">&quot;_id&quot;</span>] = <span class="string">&quot;7846464&quot;</span>;</span><br><span class="line">	data[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;老张&quot;</span>;</span><br><span class="line">	data[<span class="string">&quot;comment&quot;</span>] = <span class="string">&quot;记住：别想着返回数组，都是把外面的数组地址传进去赋值&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通用式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	data[key]=val;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>unordered_map 使用栈形式存储数据，后入先出。</p>
</blockquote>
<p><strong>unordered_map 的初始化</strong></p>
<ol>
<li class="lvl-3">
<p>如果不想全部拷贝，可以使用 unordered_map 类模板提供的迭代器，在现有 unordered_map 容器中选择部分区域内的键值对，为新建 unordered_map 容器初始化。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入 2 个迭代器，</span></span><br><span class="line"><span class="function">std::unordered_map&lt;std::string, std::string&gt; <span class="title">umap2</span><span class="params">(++umap.begin(),umap.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建的 umap2 容器，其内部就包含 umap 容器中除第 1 个键值对外的所有其它键值对。</p>
</li>
</ol>
<h5 id="unordered-map的emplace-插入键值对">unordered_map的emplace()插入键值对</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加新键值对</span></span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Java教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Linux教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出 umap 存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap size = &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用迭代器输出 umap 容器存储的所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="unordered-multimap容器">unordered_multimap容器</h5>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7248.html">C++ STL unordered_multimap容器精讲 (biancheng.net)</a></p>
</blockquote>
<p>std::unordered_multimap是C++STL中的一个关联容器它以无序的方式存储元素。它类似于std::unordered_map，但允许将多个值映射到同一个键。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_multimap&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert some key-value pairs</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;cherry&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apricot&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;blueberry&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over the multimap and print its contents</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = myMap.<span class="built_in">begin</span>(); itr != myMap.<span class="built_in">end</span>(); ++itr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; itr-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Key: <span class="number">1</span>, Value: apple</span><br><span class="line">Key: <span class="number">1</span>, Value: apricot</span><br><span class="line">Key: <span class="number">2</span>, Value: banana</span><br><span class="line">Key: <span class="number">2</span>, Value: blueberry</span><br><span class="line">Key: <span class="number">3</span>, Value: cherry</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="for循环：for-int-num-nums">for循环：for(int &amp; num : nums)</h5>
<p>其中nums是一个<code>vector&lt;int&gt;</code>类型的向量，这里也就是数组的意思。其中for(int  &amp; num : nums)的num可以是任意字符，只要保证后一个nums是指定的数组名即可。</p>
<p>迭代器遍历，对于数组来说，等同于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for(int &amp; num : nums)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">	<span class="type">int</span> num = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//特别的：</span></span><br><span class="line"><span class="comment">//const int &amp;num:buckets[i]中的buckets[i]指的是一个常向量，那么这里的num直接等于buckets[i]，即num=buckets[i]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> &amp;num:buckets[i])&#123;<span class="comment">//buckets[i]是一个常向量</span></span><br><span class="line">	ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : range) <span class="comment">// 拷贝元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp;x : range)<span class="comment">// 修改元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;x : range)<span class="comment">// 只读元素（无法修改）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>想要拷贝元素：for(auto x:range)</p>
<p>想要修改元素 : for(auto &amp;&amp;x:range)</p>
<p>想要只读元素：for(const auto&amp; x:range)</p>
<p>改变vector<bool>本身元素：for(auto x:vector<bool>)</p>
<p>不改变vector<bool>本身元素：for(bool x:vector<bool>)</p>
<p>参考：<a href="https://blog.csdn.net/HERODING23/article/details/120952320">(77条消息) 算法笔记 C++中const和auto的那些事 HERODING的算法之路_HERODING23的博客-CSDN博客_auto const</a></p>
</blockquote>
<hr>
<h5 id="auto类型推导">auto类型推导</h5>
<blockquote>
<p>作用：使得编译器会在编译期间自动推导出变量的类型</p>
<p>详细参考：<a href="http://c.biancheng.net/view/3718.html">C++ auto（类型推导）精讲 (biancheng.net)</a></p>
</blockquote>
<p>auto 的一些基本用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">5</span>;                 <span class="comment">// OK: x是int类型</span></span><br><span class="line"><span class="keyword">auto</span> pi = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">1</span>);      <span class="comment">// OK: pi被推导为int*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> *v = &amp;x, u = <span class="number">6</span>;  <span class="comment">// OK: v是const int*类型，u是const int类型</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> y = <span class="number">0.0</span>;        <span class="comment">// OK: y是double类型</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> r;                 <span class="comment">// error: auto不再表示存储类型指示符</span></span><br><span class="line"><span class="keyword">auto</span> s;                     <span class="comment">// error: auto无法推导出s的类型</span></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="stack栈">stack栈</h5>
<blockquote>
<p>详细参考：<a href="https://blog.csdn.net/wqw1672/article/details/105501165">(77条消息) C++ STACK与pair的基本用法_wqw1672的博客-CSDN博客</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; first ; <span class="comment">// 构造一个存放int类型的空栈，size=0；</span></span><br><span class="line">stack&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; third;          <span class="comment">//指明用vector实现一个栈（存放int），空栈size=0</span></span><br></pre></td></tr></table></figure>
<p>std::stack&lt;int，std::vector&lt;int&gt;是C++STL中使用std::vector作为底层容器的堆栈容器。这意味着元素存储在由std::vector分配的一个连续的内存块中，堆栈操作在这个内部vector容器上执行。</p>
<hr>
<h5 id="pair">pair⭐️</h5>
<blockquote>
<p>参考：</p>
</blockquote>
<p><code>template&lt;class T1,class T2&gt; struct pair</code></p>
<p>参数：T1是第一个值的数据类型，T2是第二个值的数据类型。功能：pair将一对值(T1和T2)组合成一个值，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">pair.first	<span class="comment">//获取第一个值</span></span><br><span class="line">pair.second	<span class="comment">//获取第二个值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<p><code>stack&lt;pair&lt;int, int&gt;&gt; island</code>：定义存储类型是pair&lt;int, int&gt;的栈</p>
<h5 id="pair初始化操作：">pair初始化操作：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash[m];<span class="comment">//定义一个pair类型的数组hash</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p1</span><span class="params">(v1, v2)</span></span>;<span class="comment">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2</span></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);<span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="c-sort-对pair进行排序：">c++ sort 对pair进行排序：</h6>
<p><u><em><strong>默认情况下会先按照pair的first进行排序，如果first相同则会继续比较second。</strong></em></u></p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;test[<span class="number">3</span>];</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		test[i]=<span class="built_in">make_pair</span>(a,b);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">sort</span>(test,test+<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">		cout&lt;&lt;test[i].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;test[i].second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="stack-top-函数">stack:top() 函数</h5>
<blockquote>
<p>stack:top()的类型是stack<Type></p>
</blockquote>
<p>返回栈顶元素，但不在<a href="">堆栈</a>中删除它。</p>
<hr>
<h5 id="stack-pop-函数">stack:pop() 函数</h5>
<blockquote>
<p><mark>注意：stack:pop()的类型是void</mark></p>
</blockquote>
<p>返回栈顶元素，并在<a href="">堆栈</a>中删除它。</p>
<hr>
<h3 id="queue-容器">queue 容器</h3>
<blockquote>
<p>详细参考：<a href="http://c.biancheng.net/view/479.html">C++ queue(STL queue)用法详解 (biancheng.net)</a></p>
</blockquote>
<p><code>queue&lt;pair&lt;int, int&gt;&gt;points</code>创建了存储pair类型的队列</p>
<p>queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</p>
</li>
<li class="lvl-2">
<p>back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</p>
</li>
<li class="lvl-2">
<p>push(const T&amp; obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</p>
</li>
<li class="lvl-2">
<p>push(T&amp;&amp; obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</p>
</li>
<li class="lvl-2">
<p>pop()：删除 queue 中的第一个元素。</p>
</li>
<li class="lvl-2">
<p>size()：返回 queue 中元素的个数。</p>
</li>
<li class="lvl-2">
<p>empty()：如果 queue 中没有元素的话，返回 true。</p>
</li>
<li class="lvl-2">
<p>emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</p>
</li>
<li class="lvl-2">
<p>swap(queue<T> &amp;other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</p>
</li>
</ul>
<hr>
<h5 id="priority-queue">priority_queue</h5>
<p>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是<u>存储对象的类型</u>，第二个参数是<u>存储元素的底层容器</u>，第三个参数是<u>函数对象</u>，它<code>定义了一个用来决定元素顺序的断言</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//priority_queue 具体实例</span></span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Comp&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; a</span><br><span class="line"><span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; a;</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现小顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注意queue的push操作是将元素从右边往左边加入，这意味着左边的元素比右边的元素先进入queue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::less&lt;T&gt; 的底层实现代码——数组升序、大顶堆</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">    <span class="comment">//定义新的排序规则</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;_lhs, <span class="type">const</span> T &amp;_rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _lhs &lt; _rhs;	<span class="comment">//根据返回的值为true或false判断是否执行交换（为false则交换）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果左边的元素比右边的大，则返回false，并执行将两个元素位置进行交换的操作，相当于是将将大元素进行上浮操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::greater&lt;T&gt; 的底层实现代码——数组降序、小顶堆</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;_lhs, <span class="type">const</span> T &amp;_rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _lhs &gt; _rhs;	<span class="comment">//根据返回的值为true或false判断是否执行交换（为false则交换）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果左边的元素比右边的小，则返回false，并执行将两个元素位置进行交换的操作，相当于是将将大元素进行下沉操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>priority_queue优先队列，我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队</p>
<p>和队列基本操作相同:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>top 访问队头元素</p>
</li>
<li class="lvl-2">
<p>empty 队列是否为空</p>
</li>
<li class="lvl-2">
<p>size 返回队列内元素个数</p>
</li>
<li class="lvl-2">
<p>push 插入元素到队尾 (并排序)</p>
</li>
<li class="lvl-2">
<p>emplace 原地构造一个元素并插入队列</p>
</li>
<li class="lvl-2">
<p>pop 弹出队头元素</p>
</li>
<li class="lvl-2">
<p>swap 交换内容</p>
</li>
</ul>
<blockquote>
<p>详细参考：<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-79937886-blog-102580332.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-79937886-blog-102580332.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=2">(77条消息) c++优先队列(priority_queue)用法详解_吕白_的博客-CSDN博客_priority_queue用法</a></p>
</blockquote>
<hr>
<h5 id="deque-容器">deque 容器</h5>
<p>deque是<mark>双向列表</mark>，可在<u>头尾进行插入和删除操作</u>。</p>
<blockquote>
<p>详细参考：<a href="http://c.biancheng.net/view/6860.html">C++ STL deque容器（详解版） (biancheng.net)</a></p>
</blockquote>
<p>deque的部分成员函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>front()：返回第一个元素的引用。</p>
</li>
<li class="lvl-2">
<p>back()： 返回最后一个元素的引用。</p>
</li>
<li class="lvl-2">
<p>push_back()：在序列的尾部添加一个元素。</p>
</li>
<li class="lvl-2">
<p>push_front()： 在序列的头部添加一个元素。</p>
</li>
<li class="lvl-2">
<p>pop_back()：移除容器尾部的元素。</p>
</li>
<li class="lvl-2">
<p>pop_front()：移除容器头部的元素。</p>
</li>
<li class="lvl-2">
<p>begin()：返回指向容器中第一个元素的迭代器。</p>
</li>
<li class="lvl-2">
<p>end()：返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</p>
</li>
</ul>
<hr>
<h3 id="set-容器">set 容器</h3>
<p><u>set 容器存储的各个键值对，要求键 <mark>key 和值 value 必须相等</mark></u></p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7192.html">C++ STL set容器完全攻略（超级详细） (biancheng.net)</a></p>
</blockquote>
<hr>
<h4 id="multiset">multiset</h4>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/386.html">C++ multiset，STL multiset详解 (biancheng.net)</a></p>
</blockquote>
<p>multiset 是关联容器的一种，是排序好的集合（元素已经进行了排序），并且允许有相同的元素。</p>
<p>不能直接修改 multiset 容器中元素的值。<u>因为元素被修改后，容器并<mark>不会自动重新调整顺序</mark>，于是容器的有序性就会被破坏</u>，再在其上进行查找等操作就会得到错误的结果。因此，<u><em><strong>如果要修改 multiset 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</strong></em></u></p>
<p>类模板的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Pred</span> = less&lt;Key&gt;, <span class="keyword">class</span> B = allocator&lt;Key&gt; &gt; <span class="keyword">class</span> multiset &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该模板有三个类型参数：Key、Pred 和 B。类型参数可以有默认值，默认值就是某种类型。例如，Pred 类型参数的默认值就是 less<Key> 类型，B 的默认值就是 allocator<Key> 类型。</p>
<p>第一个类型参数说明 multiset 容器中的每个元素都是 Key 类型的。第二个类型参数 Pred 用于指明容器中元素的排序规则，在被实例化后，Pred 可以是函数对象类，也可以是函数<a href="http://c.biancheng.net/c/80/">指针</a>类型。</p>
<p>less的类模板定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> _Tp &amp;__x, <span class="type">const</span> _Tp &amp;__y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="unordered-set-容器">unordered_set 容器</h4>
<p>unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</p>
<p>部分成员函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>insert()： 向容器中添加新元素。</p>
</li>
<li class="lvl-2">
<p>erase()： 删除指定元素。</p>
</li>
<li class="lvl-2">
<p>empty()： 若容器为空，则返回 true；否则 false。</p>
</li>
<li class="lvl-2">
<p>begin()：返回指向容器中第一个元素的正向迭代器。</p>
</li>
<li class="lvl-2">
<p>end()：返回指向容器中最后一个元素之后位置的正向迭代器。</p>
</li>
<li class="lvl-2">
<p>count(key)：<u>在容器中查找值为 key 的元素的个数</u>。</p>
</li>
</ul>
<p>部分拷贝，可以使用 unordered_set 类模板提供的迭代器。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入 2 个迭代器，</span></span><br><span class="line"><span class="function">std::unordered_set&lt;std::string&gt; <span class="title">uset2</span><span class="params">(++uset.begin(),uset.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建的 uset2 容器，其内部就包含 uset 容器中除第 1 个元素外的所有其它元素。</p>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7250.html">C++ STL unordered_set容器完全攻略 (biancheng.net)</a></p>
</blockquote>
<hr>
<h5 id="substr-函数">substr() 函数</h5>
<p><code>substr(size_type _Off = 0,size_type _Count = npos)</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>size_type _Off：起始位置</p>
</li>
<li class="lvl-2">
<p>size_type _Count：字符数目</p>
</li>
</ul>
<blockquote>
<p>参考：[(77条消息) C<ins>string类中substr()函数的使用方法_&amp;Mr.Gong的博客-CSDN博客_c</ins> string substr](<a href="https://blog.csdn.net/weixin_42258743/article/details/107782394#:~:text=substr%EF%BC%88%EF%BC%89%E5%AE%9A%E4%B9%89">https://blog.csdn.net/weixin_42258743/article/details/107782394#:~:text=substr（）定义</a>. substr,()是C%2B%2B语言函数，主要功能是复制子字符串，要求从指定位置开始，并具有指定的长度。. 如果没有指定长度_Count或_Count%2B_Off超出了源字符串的长度，则子字符串将延续到源字符串的结尾。.)</p>
</blockquote>
<hr>
<h5 id="stoi-函数">stoi() 函数</h5>
<p>stoi（字符串，起始位置，n进制），将 n 进制的字符串转化为十进制</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_30502965/article/details/102374637">(77条消息) C++中stoi函数_weixin_30502965的博客-CSDN博客</a></p>
</blockquote>
<hr>
<h5 id="istringstream">istringstream</h5>
<p>istringstream：实现类用于执行C++风格的串流的输入操作。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/longzaitianya1989/article/details/52909786">(77条消息) C++中的istringstream 的用法_longzaitianya1989的博客-CSDN博客_istringstream</a></p>
</blockquote>
<hr>
<h3 id="string">string</h3>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/2236.html">C++ string详解，C++字符串详解 (biancheng.net)</a></p>
</blockquote>
<h4 id="compare-函数">compare 函数</h4>
<p>类 basic_string 的成员函数 compare() 的原型如下：</p>
<p>int compare (const basic_string&amp; s) const;<br>
int compare (const Ch* p) const;<br>
int compare (size_type pos, size_type n, const basic_string&amp; s) const;<br>
int compare (size_type pos, size_type n, const basic_string&amp; s,size_type pos2, size_type n2) const;<br>
int compare (size_type pos, size_type n, const Ch* p, size_type = npos) const;</p>
<p><mark>若参与比较的两个串值相同，则函数返回 0；若字符串 S 按字典顺序要先于 S2，则返回负值；反之，则返回正值。</mark></p>
<hr>
<h5 id="算术右移">算术右移</h5>
<p>在汇编语言中，对于算术右移(高位补符号位)，<mark>如果最高位为1，则补1，否则补0</mark>， 如将10000000算术右移7位，应该变成11111111；</p>
<h5 id="逻辑右移">逻辑右移</h5>
<p>对于逻辑右移7位，则不考虑符号位，变为00000001，这点就是算术右移和逻辑右移的区别。</p>
<h5 id="算术左移">算术左移</h5>
<p>对于算术左移，在右边补0：比如 00101011算术左移一位:01010110</p>
<h5 id="逻辑左移">逻辑左移</h5>
<p>对于逻辑左移，同样是在右边补0，如：00010111逻辑左移两位：01011100</p>
<p>⭕️左移一般将低位补0。但右移可以是逻辑右移（高位补0）或算术右移（<mark><u>高位补符号位</u></mark>）。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>将一个值左移</mtext><mi>N</mi><mtext>位相当于乘以</mtext><msup><mn>2</mn><mi>N</mi></msup><mtext>。同理，算术右移</mtext><mi>N</mi><mtext>位，相当于除以</mtext><msup><mn>2</mn><mi>N</mi></msup><mtext>。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{将一个值左移N位相当于乘以2^N。同理，算术右移N位，相当于除以2^N。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord cjk_fallback" style="color:red;">将一个值左移</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">位相当于乘以</span><span class="mord" style="color:red;"><span class="mord" style="color:red;">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mathnormal mtight" style="margin-right:0.10903em;color:red;">N</span></span></span></span></span></span></span></span><span class="mord cjk_fallback" style="color:red;">。同理，算术右移</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">位，相当于除以</span><span class="mord" style="color:red;"><span class="mord" style="color:red;">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mathnormal mtight" style="margin-right:0.10903em;color:red;">N</span></span></span></span></span></span></span></span><span class="mord cjk_fallback" style="color:red;">。</span></span></span></span></p>
<hr>
<h5 id="isdigit-函数">isdigit() 函数</h5>
<p>C 库函数<code>int isdigit(int c)</code>检查所传的字符是否是十进制数字字符。</p>
<p>十进制数字是：0 1 2 3 4 5 6 7 8 9</p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isdigit</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果 c 是一个数字，则该函数返回非零值，否则返回 0。</p>
<hr>
<h5 id="accumulate">accumulate()</h5>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/ZauberC/article/details/124166429">(77条消息) C<ins>中accumulate的用法_CV矿工的博客-CSDN博客_accumulate c</ins></a></p>
</blockquote>
<p>accumulate定义在#include中，作用有两个，一个是累加求和，另一个是自定义类型数据的处理。</p>
<p><code>int sum = accumulate(vec.begin() , vec.end() , 42);  </code></p>
<p>accumulate带有三个形参：头两个形参指定要<mark>累加的元素范围</mark>，第三个形参则是<mark>累加的初值</mark>。</p>
<p>除此之外，accumulate还有第四个参数：一个回调函数来实现自定义数据的处理</p>
<p>如：<code>int sum = accumulate(subject, subject + 3, 0, [](int a, Grade b)&#123;return a + b.grade; &#125;);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>() , vec.<span class="built_in">end</span>() , <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(subject, subject + <span class="number">3</span>, <span class="number">0</span>, [](<span class="type">int</span> a, Grade b)&#123;<span class="keyword">return</span> a + b.grade; &#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="lower-bound-函数">lower_bound() 函数</h5>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7521.html">C++ lower_bound()函数用法详解 (biancheng.net)</a></p>
</blockquote>
<p>lower_bound() 函数用于在指定区域内查找<mark>不小于目标值</mark>的第一个元素。</p>
<p><u><strong>返回值：返回一个迭代器</strong></u></p>
<p>基本形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 [first, last) 区域内查找不小于 val 的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>lower_bound() 返回值是一个迭代器,返回指向大于等于key的<code>第一个值的位置</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">number[<span class="number">8</span>]=&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">30</span>,<span class="number">69</span>,<span class="number">70</span>,<span class="number">96</span>,<span class="number">100</span>&#125;.设要插入数字<span class="number">3</span>,<span class="number">9</span>,<span class="number">111.</span> pos为要插入的位置的下标，则</span><br><span class="line">pos = <span class="built_in">lower_bound</span>( number, number + <span class="number">8</span>, <span class="number">3</span>) - number，pos = <span class="number">0.</span>即number数组的下标为<span class="number">0</span>的位置。</span><br><span class="line">pos = <span class="built_in">lower_bound</span>( number, number + <span class="number">8</span>, <span class="number">9</span>) - number， pos = <span class="number">1</span>，即number数组的下标为<span class="number">1</span>的位置（即<span class="number">10</span>所在的位置）。</span><br><span class="line">pos = <span class="built_in">lower_bound</span>( number, number + <span class="number">8</span>, <span class="number">111</span>) - number， pos = <span class="number">8</span>，即number数组的下标为<span class="number">8</span>的位置（但下标上限为<span class="number">7</span>，所以返回最后一个元素的下一个元素）。</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::lower_bound</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义查找规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i&gt;j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以函数对象的形式定义查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//从 a 数组中找到第一个不小于 3 的元素</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">lower_bound</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//根据 mycomp2 规则，从 myvector 容器中找到第一个违背 mycomp2 规则的元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="built_in">lower_bound</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="built_in">mycomp2</span>());	<span class="comment">// mycomp2(element, 3),当mycomp2返回为true时即表示当前满足comp结果，所以此时lower_bound将会返回值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	输出结果：</span></span><br><span class="line"><span class="comment">*  		*p = 3</span></span><br><span class="line"><span class="comment">*  		*iter = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h6 id="lower-bound-如何只对pair的first进行查询">lower_bound()如何只对pair的first进行查询</h6>
<blockquote>
<p>参考：<a href="https://stackoverflow.com/questions/55392781/how-to-use-lower-bound-on-set-of-pairs">c++ - How to use lower_bound() on set of pairs? - Stack Overflow</a></p>
</blockquote>
<p>lower_bound()可以自定义comp函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mycomp2(3, element),当mycomp2返回为true时即表示当前满足comp结果，所以此时lower_bound将会返回值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="upper-bound-函数">upper_bound() 函数</h5>
<blockquote>
<p>参考：<a href="http://c.biancheng.net/view/7527.html">C++ upper_bound()函数（精讲版） (biancheng.net)</a></p>
</blockquote>
<p>用于在指定范围内查找<mark>大于目标值</mark>的第一个元素。</p>
<p>基本形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找[first, last)区域中第一个大于 val 的元素。</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p><mark>其它与lower_bound()函数相似</mark></p>
<blockquote>
<p>值得注意的是：</p>
<p>由于 upper_bound() 底层实现采用的是二分查找的方式，因此该函数仅适用于“已排好序”的序列。注意，这里所说的“已排好序”，并不要求数据完全按照某个排序规则进行升序或降序排序，而仅仅要求 [first, last) 区域内所有令 element&lt;val（或者 comp(val, element）成立的元素都位于不成立元素的前面（其中 element 为指定范围内的元素）。</p>
</blockquote>
<hr>
<h5 id="count-函数">count() 函数</h5>
<p>C++ 函数 <strong>std::algorithm::count()</strong> 返回值在范围内的出现次数。 该函数使用 <code>operator ==</code> 进行比较。</p>
<p>参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>first</strong> − 将迭代器输入到搜索序列的初始位置。</p>
</li>
<li class="lvl-2">
<p><strong>last</strong> − 将迭代器输入到搜索序列的最终位置。</p>
</li>
<li class="lvl-2">
<p><strong>val</strong> − 要在范围内搜索的值。</p>
</li>
</ul>
<p>实例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">   cnt = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Number 3 occurs &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Number <span class="number">3</span> occurs <span class="number">4</span> times.</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="to-string-函数">to_string() 函数</h5>
<p>功能：将数字常量转换为字符串</p>
<hr>
<h5 id="reverse函数">reverse函数</h5>
<p>实现翻转数组、字符串和向量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻转字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="comment">//1 显示未翻转的字符串</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2 翻转数组，然后显示</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line">abcdefg</span><br><span class="line">gfedcba</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="fmod-double-x-double-y">fmod(double x, double y)</h5>
<p>C 库函数 double fmod(double x, double y)返回 <strong>x</strong> 除以 <strong>y</strong> 的余数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">float</span> a, b;</span><br><span class="line">   <span class="type">int</span> c;</span><br><span class="line">   a = <span class="number">9.2</span>;</span><br><span class="line">   b = <span class="number">3.7</span>;</span><br><span class="line">   c = <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%f / %d 的余数是 %lf\n&quot;</span>, a, c, <span class="built_in">fmod</span>(a,c));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%f / %f 的余数是 %lf\n&quot;</span>, a, b, <span class="built_in">fmod</span>(a,b));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">9.200000</span> / <span class="number">2</span> 的余数是 <span class="number">1.200000</span></span><br><span class="line"><span class="number">9.200000</span> / <span class="number">3.700000</span> 的余数是 <span class="number">1.800000</span></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="log10-double-x">log10(double x)</h5>
<p>C 库函数 <strong>double log10(double x)</strong> 返回 <strong>x</strong> 的常用对数（基数为 10 的对数）。</p>
<h5 id="log-double-x">log(double x)</h5>
<p>C 库函数 <strong>double log(double x)</strong> 返回 <strong>x</strong> 的自然对数（基数为 e 的对数）。</p>
<hr>
<h4 id="左-右值以及引用">左/右值以及引用</h4>
<p>可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const对象等都是左值。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以取地址的，有名字的，非临时的就是左值；</p>
</li>
<li class="lvl-2">
<p>不能取地址的，没有名字的，临时的就是右值；</p>
</li>
</ul>
<h5 id="左值引用">左值引用</h5>
<p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左值引用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;  <span class="comment">// 定义一个左值引用变量，必须在定义时初始化</span></span><br><span class="line">b = <span class="number">20</span>;      <span class="comment">// 通过左值引用修改引用内存的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = <span class="number">10</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;var = temp;</span><br></pre></td></tr></table></figure>
<h5 id="右值引用">右值引用</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类型 &amp;&amp; 引用名 = 右值表达式;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;var = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="std-move">std::move</h5>
<blockquote>
<p>可以参考：<a href="https://zhuanlan.zhihu.com/p/94588204">C++右值引用（std::move） - 知乎 (zhihu.com)</a></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p>
</li>
<li class="lvl-2">
<p>C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。</p>
</li>
<li class="lvl-2">
<p>std::move是为性能而生。</p>
</li>
<li class="lvl-2">
<p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。</p>
</li>
</ul>
<p>用法：原lvalue值被moved from之后值被转移,所以为空字符串.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line">    <span class="comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After copy, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//调用移动构造函数，掏空str，掏空后，最好不要使用str</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After move, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of the vector are \&quot;&quot;</span> &lt;&lt; v[<span class="number">0</span>]</span><br><span class="line">                                         &lt;&lt; <span class="string">&quot;\&quot;, \&quot;&quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">After copy, str is <span class="string">&quot;Hello&quot;</span></span><br><span class="line">After move, str is <span class="string">&quot;&quot;</span></span><br><span class="line">The contents of the vector are <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="u-前缀和-u"><u>前缀和</u></h4>
<p>概念：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/20200716164747656.png" alt="img"></p>
<h5 id="partial-sum">partial_sum()</h5>
<p>对范围[first,last)内的元素逐个求累加和，放在result容器中。</p>
<p>函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span> <span class="params">(InputIterator first, </span></span></span><br><span class="line"><span class="params"><span class="function">                            InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                            OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; psum;</span><br><span class="line">    psum.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//将前缀和的结果保存在以psum.begin()开始的psum中</span></span><br><span class="line">    <span class="built_in">partial_sum</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), psum.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : psum) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>       <span class="number">3</span>       <span class="number">6</span>       <span class="number">10</span>      <span class="number">15</span>      </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="u-积分图-u"><u>积分图</u></h4>
<blockquote>
<p>相当于前缀和的二维拓展</p>
</blockquote>
<p>定义：图像是由一系列的离散像素点组成, 因此图像的积分其实就是求和. 图像积分图中每个点的值是原图像中该点左上角的所有像素值之和.</p>
<p>首先建立一个数组 A 作为积分图像，其宽高与原图像相等. 然后对这个数组赋值，每个点存储的是<code>该点与图像原点所构成的矩形</code>中所有像素的和：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028101723619.png" alt="image-20221028101723619"></p>
<hr>
<h4 id="数据类型：">数据类型：</h4>
<h5 id="1-有符号类型">1️⃣有符号类型</h5>
<p>使用以下名称可以保证固定长度：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>1字节 int8_t —— char</p>
</li>
<li class="lvl-2">
<p>2字节 int16_t —— short</p>
</li>
<li class="lvl-2">
<p>4字节 int32_t —— int</p>
</li>
<li class="lvl-2">
<p>8字节 int64_t —— long long</p>
</li>
</ul>
<h5 id="2-无符号类型">2️⃣无符号类型</h5>
<p><code>uint32_t</code>,<code>size_t</code>, <code>uint64_t</code></p>
<h5 id="数据类型转换：">数据类型转换：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String S;</span><br><span class="line">s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="comment">//表示将字符s[0]的ASCII码与字符&#x27;0&#x27;的ASCII码相减，</span></span><br><span class="line"><span class="comment">//如果s[0]是字符0~9，则表示将该字符变为对应的数字（int 型）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*将数字转换为对应字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">string ans=<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>;<span class="comment">//output:B</span></span><br><span class="line">string ans=<span class="string">&#x27;A&#x27;</span>+<span class="number">2</span>;<span class="comment">//output:C</span></span><br><span class="line">string ans=<span class="string">&#x27;A&#x27;</span>+<span class="number">3</span>;<span class="comment">//output:D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="comment">//ASCII:65-A...</span></span><br><span class="line"><span class="comment">//ASCII (American Standard Code for Information Interchange)</span></span><br><span class="line">string ans=<span class="built_in">char</span>(<span class="number">65</span>+<span class="number">1</span>);<span class="comment">//output:B</span></span><br><span class="line">string ans=<span class="built_in">char</span>(<span class="number">65</span>+<span class="number">2</span>);<span class="comment">//output:C</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line">s+=<span class="built_in">to_string</span>(<span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="参数列表">参数列表</h4>
<p>定义：以一个冒号（<code>：</code>）开始，接着是一个以逗号分隔（<code>,</code>）的数据成员列表，每个&quot;成员变量&quot;后面跟一个放在括号中的初始值或表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1900</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>):</span><br><span class="line">    _year(year),</span><br><span class="line">    _month(month),</span><br><span class="line">    _day(day)&#123;&#125;				<span class="comment">//参数列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="c-什么时候用-什么时候用"><mark>C++ 什么时候用 “.” 什么时候用“-&gt;”</mark></h4>
<p>假设有一个类: ClassA<br>
1、如果声明的是一个对象: <code>ClassA A</code><br>
则用 <code>A.function</code><br>
2、如果声明的是一个对象指针：<code>ClassA* A=new A;</code>则用 <code>A-&gt;function</code></p>
<blockquote>
<p><strong>从堆栈的角度来说：</strong><br>
对象放在堆上，就要用指针，也就是<code>对象指针-&gt;函数</code>；放在栈上,就<code>对象.函数</code></p>
</blockquote>
<hr>
<h3 id="构造函数与析构函数">构造函数与析构函数</h3>
<p>构造函数调用顺序：</p>
<ol>
<li class="lvl-3">
<p>基类构造函数</p>
</li>
<li class="lvl-3">
<p>对象成员构造函数</p>
</li>
<li class="lvl-3">
<p>派生类本身的构造函数</p>
</li>
</ol>
<p>析构函数调用顺序：</p>
<ol>
<li class="lvl-3">
<p>派生类本身的析构函数</p>
</li>
<li class="lvl-3">
<p>对象成员析构函数</p>
</li>
<li class="lvl-3">
<p>基类析构函数</p>
</li>
</ol>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B0::B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> a) &#123; cout &lt;&lt; <span class="string">&quot;B1::B()&quot;</span> &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">const</span> B&amp; b) &#123;cout &lt;&lt; <span class="string">&quot;B2::B()&quot;</span> &lt;&lt; endl;&#125; <span class="comment">// 拷贝构造</span></span><br><span class="line">  ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> :<span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">D</span>() &#123; cout &lt;&lt; <span class="string">&quot;D0::D()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">D</span>(<span class="type">int</span> a) &#123; cout &lt;&lt; <span class="string">&quot;D1::D()&quot;</span> &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">D</span>() &#123; cout &lt;&lt; <span class="string">&quot;~D()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------main函数-----------------------------------*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先构造再析构</span></span><br><span class="line"><span class="comment">// B0::B()</span></span><br><span class="line"><span class="comment">// ~B()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------main函数-----------------------------------*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基类构造-子类构造-子类析构-基类析构</span></span><br><span class="line"><span class="comment">// B0::B()</span></span><br><span class="line"><span class="comment">// D0::D()</span></span><br><span class="line"><span class="comment">// ~D()</span></span><br><span class="line"><span class="comment">// ~B()</span></span><br></pre></td></tr></table></figure>
<p>实例2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">O</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">O</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor O&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">O</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deconstructof O&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:O&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor A&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deconstructof A&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor B&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">B</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deconstructof B&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor C&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">C</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deconstructof C&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor D&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">D</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deconstructof D&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">E</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor E&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">E</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deconstructof E&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : E,D&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Constructor Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deconstructor Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------main函数-----------------------------------*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test *t = <span class="keyword">new</span> Test;</span><br><span class="line">	<span class="keyword">delete</span> t;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Constructor E</span><br><span class="line">Constructor D</span><br><span class="line">Constructor B</span><br><span class="line">Constructor O</span><br><span class="line">Constructor A</span><br><span class="line">Constructor Test</span><br><span class="line">Deconstructor Test</span><br><span class="line">Deconstructof A</span><br><span class="line">Deconstructof O</span><br><span class="line">Deconstructof B</span><br><span class="line">Deconstructof D</span><br><span class="line">Deconstructof E</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数学算法">数学算法</h2>
<h4 id="向量的内积和叉乘">向量的内积和叉乘</h4>
<h5 id="内积">内积</h5>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000752499.png" alt="image-20230312000752499"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000632698.png" alt="image-20230312000632698"></p>
</blockquote>
<h5 id="叉乘">叉乘</h5>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000739739.png" alt="image-20230312000739739"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230312000659502.png" alt="image-20230312000659502"></p>
</blockquote>
<h4 id="欧几里得算法">欧几里得算法</h4>
<p><strong>gcd(a,b) = gcd(b,a mod b)</strong></p>
<p>形象记忆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a % b = c</span><br><span class="line">	b % c = d</span><br><span class="line">		c % d = e</span><br><span class="line">			d % e = f</span><br><span class="line">				......</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>欧几里得算法拓展：</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_43872728/article/details/107289833">(77条消息) 扩展欧几里得算法超详解_Aloof__的博客-CSDN博客_扩展欧几里得原理</a></p>
</blockquote>
<p><strong>给予二整数 a 与 b, 必存在有整数 x 与 y 使得ax + by = gcd(a,b)</strong></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011195717705.png" alt="image-20221011195717705" style="zoom: 67%;" />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=(-7)*47+(11)*30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gcd(a,b)可以表示为a,b的整洗数线性组合，例如：gcd(6,14)=2,而2=(-2)*6+1*14.</span><br></pre></td></tr></table></figure>
<h4 id="绝对值函数abs"><mark>绝对值</mark>函数abs()</h4>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span><span class="comment">//C语言是math.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">10</span>;</span><br><span class="line">	<span class="type">float</span> c=<span class="number">1</span>,d=<span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> e=<span class="number">1</span>,f=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;b-a=&quot;</span>&lt;&lt;<span class="built_in">abs</span>(b-a)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;c-d=&quot;</span>&lt;&lt;<span class="built_in">abs</span>(c-d)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;e-f=&quot;</span>&lt;&lt;<span class="built_in">abs</span>(e-f)&lt;&lt;endl;</span><br><span class="line">	cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">b-a=<span class="number">9</span></span><br><span class="line">c-d=<span class="number">9</span></span><br><span class="line">e-f=<span class="number">9</span></span><br></pre></td></tr></table></figure>
<h4 id="c-实现四舍五入的几种方法">C++实现<mark>四舍五入</mark>的几种方法</h4>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/Xavier_97/article/details/126931927">(101条消息) C<ins>实现四舍五入的几种方法_c</ins>四舍五入_Xaiver_97的博客-CSDN博客</a></p>
<ol>
<li class="lvl-3">函数round()实现四舍五入</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> a = <span class="number">1.4999999</span>;</span><br><span class="line">  <span class="type">double</span> b = <span class="number">1.5000001</span>;</span><br><span class="line">  <span class="type">double</span> n_a = <span class="number">-1.4999999</span>;    </span><br><span class="line">  <span class="type">double</span> n_b = <span class="number">-1.5000001</span>; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(a) &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(b) &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(n_a) &lt;&lt; endl;    <span class="comment">// -1</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">round</span>(n_b) &lt;&lt; endl;    <span class="comment">// -2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>round()函数原理为：<code>x=(int)(x+0.5)</code>公式，故可以自己写出round()函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">round</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)(x+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="fisher-yates-洗牌算法">Fisher-Yates 洗牌算法</h4>
<blockquote>
<p>可以参考：<a href="https://zhuanlan.zhihu.com/p/334553072">Fisher-Yates洗牌算法！来自算法理论的创始人！ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h6 id="正向洗牌与反向洗牌算法：">正向洗牌与反向洗牌算法：</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffled</span><span class="params">(origin)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = origin.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 可以使用反向或者正向洗牌，效果相同。</span></span><br><span class="line"><span class="comment">// 反向洗牌：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(shuffled[i], shuffled[<span class="built_in">rand</span>() % (i + <span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 正向洗牌：</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line"><span class="comment">// int pos = rand() % (n - i);</span></span><br><span class="line"><span class="comment">// swap(shuffled[i], shuffled[i+pos]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">return</span> shuffled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="knuth-morris-pratt-kmp-算法">Knuth-Morris-Pratt（KMP）算法</h4>
<blockquote>
<p>参考：<a href="https://zh.wikipedia.org/wiki/KMP%E7%AE%97%E6%B3%95">KMP算法 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
</blockquote>
<h2 id="c-位运算及其应用">C++位运算及其应用</h2>
<h3 id="c-异或运算及其应用">C++ 异或运算及其应用</h3>
<h4 id="前置知识：">前置知识：</h4>
<p><strong>1.一个整数自己跟自己异或，结果为0。//因为异或的法则为，相同为0，不同为1，注意这里所说的都是二进制位。</strong></p>
<p><strong>2.任意一个整数跟0异或，结果为本身。//因为1异或0得1,0异或0,得0，所以1还是1,0还是0，没发生变化。</strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/1685178-20191127204008258-1599418865.png" alt="img"></p>
<blockquote>
<p>通过异或运算不用临时变量的情况下进行两个变量的值交换。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="c-c-算法">C/C++算法</h2>
<h3 id="排序算法">排序算法</h3>
<blockquote>
<p>参考：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h6 id="快速排序">快速排序</h6>
<blockquote>
<ol>
<li class="lvl-3">
<p>在数组中选一个基准数（通常为数组第一个）。</p>
</li>
<li class="lvl-3">
<p>将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边</p>
</li>
<li class="lvl-3">
<p>对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++算法基础</title>
    <url>/2023/04/11/University/Algorithm/Basic%20knowledge%20of%20C++/%E7%AE%97%E6%B3%95C++%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>C++算法基础</h1>
<blockquote>
<p>std：C<ins>std是指C</ins>编程语言的标准库（Standard Library），它包含了一系列的函数和类。</p>
<p>STL：C<ins>的STL指的是标准模板库（Standard Template Library），它是C</ins>标准库的一部分，提供了一组通用的模板类和函数，用于实现常见的数据结构和算法。</p>
</blockquote>
<h2 id="std算法">std算法</h2>
<h5 id="gcd">__gcd()</h5>
<p>计算整数 <code>m</code> 与 <code>n</code> 的最大公约数。</p>
<p><strong>返回值</strong></p>
<p>若 <code>m</code> 与 <code>n</code> 均为零则返回零。否则返回 <code>|m|</code> 与 <code>|n|</code> 的最大公约数。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;__gcd(<span class="number">15</span>, <span class="number">81</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;    <span class="comment">// 输出  3</span></span><br><span class="line">    cout&lt;&lt;__gcd(<span class="number">0</span>, <span class="number">44</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;     <span class="comment">// 输出  44</span></span><br><span class="line">    cout&lt;&lt;__gcd(<span class="number">0</span>, <span class="number">0</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;      <span class="comment">// 输出  0</span></span><br><span class="line">    cout&lt;&lt;__gcd(<span class="number">-6</span>, <span class="number">-15</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;   <span class="comment">// 输出  -3</span></span><br><span class="line">    cout&lt;&lt;__gcd(<span class="number">-17</span>,<span class="number">289</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;   <span class="comment">// 输出  -17</span></span><br><span class="line">    cout&lt;&lt;__gcd(<span class="number">17</span>,<span class="number">-289</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;   <span class="comment">// 输出  17</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="max-element">max_element()</h5>
<p>寻找范围 <code>[first, last)</code> 中的最大元素。</p>
<ol>
<li class="lvl-3">
<p>用 <code>operator&lt;</code> 比较元素。</p>
</li>
<li class="lvl-3">
<p>用给定的二元比较函数 <code>comp</code> 比较元素。</p>
</li>
</ol>
<p><strong>返回值</strong></p>
<p>指向范围 <code>[first, last)</code> 中最大元素的迭代器。若范围中有多个元素等价于最大元素，则返回指向首个这种元素的迭代器。若范围为空则返回 <code>last</code> 。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大</span></span><br><span class="line">ll id=<span class="built_in">max_element</span>(b+<span class="number">1</span>,b+n2+<span class="number">1</span>)-b;</span><br><span class="line"><span class="comment">// 最小</span></span><br><span class="line">ll id=<span class="built_in">min_element</span>(a+<span class="number">1</span>,a+n1+<span class="number">1</span>)-a;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="sort">sort()</h5>
<p>默认情况下sort函数使用小于号运算符来比较元素大小。因此可以通过以下方式来重写排序规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">choc</span> &#123;</span><br><span class="line">	<span class="type">int</span> price;<span class="comment">// 巧克力价格</span></span><br><span class="line">	<span class="type">int</span> len;<span class="comment">// 保质期到</span></span><br><span class="line">	<span class="type">int</span> cnt;<span class="comment">// 巧克力数量</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> choc&amp;b) &#123; <span class="comment">// 重载&lt;符号的原因是sort默认就是使用&lt;符号来实现排序的</span></span><br><span class="line">		<span class="keyword">if</span>(price == b.price)<span class="keyword">return</span> len&gt;b.len;<span class="comment">// 价格相等，则按保质期的长度降序</span></span><br><span class="line">		<span class="keyword">return</span> price&lt;b.price;<span class="comment">// 按价格升序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x, n;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">		cin&gt;&gt;a[i].price&gt;&gt;a[i].len&gt;&gt;a[i].cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n);<span class="comment">// 根据新规则排序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="next-permutation">next_permutation()</h5>
<p>变换范围 <code>[first, last)</code> 为来自所有按相对于 <code>operator&lt;</code> 或 <code>comp</code> 的字典序的下个排列。若这种排列存在则返回 true ，否则变换范围为首个排列（如同用 <code>std::sort(first, last)</code> ）并返回 false 。</p>
<p><strong>返回值</strong></p>
<p><u>若新排列按字典序大于旧者则为 true 。若抵达最后重排并重置范围为首个排列则为 false 。</u></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;aba&quot;</span>;</span><br><span class="line">    std::<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(std::<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));<span class="comment">// 当前排列的下一个排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">aab</span></span><br><span class="line"><span class="comment">aba</span></span><br><span class="line"><span class="comment">baa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="c-重载">C++重载</h2>
<h3 id="operator">operator &lt;</h3>
<p>重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">s_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id; <span class="type">long</span> <span class="type">long</span> n_dis;   <span class="comment">//id：结点；n_dis：这个结点到起点的距离</span></span><br><span class="line">    <span class="built_in">s_node</span>(<span class="type">int</span> b,<span class="type">long</span> <span class="type">long</span> c)&#123;id=b; n_dis=c;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> s_node &amp; a) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> n_dis &gt; a.n_dis;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用 <code>&lt;</code> 运算符时，如果我们有两个 <code>s_node</code> 类型的变量 <code>x</code> 和 <code>y</code>，则应该将它们作为参数传递给运算符函数，例如 <code>x&lt;y</code> 将调用 <code>&lt;</code> 运算符，并把 <code>x</code> 作为隐含的 <code>this</code> 参数传递进去，把 <code>y</code> 作为 <code>a</code> 参数传递进去，从而比较 <code>x</code> 和 <code>y</code> 的大小关系。</p>
</blockquote>
<h2 id="c-数组">C++数组</h2>
<h3 id="数组的初始化">数组的初始化</h3>
<p>在C++中，定义一个数组后，数组中的元素<mark>不会自动初始化为0</mark>。如果你想要<u><strong>将所有元素初始化为0，可以使用以下两种方法</strong></u>：</p>
<ol>
<li class="lvl-3">
<p>使用<code>memset</code>函数。该函数可以将一块内存空间按字节赋值为某个指定的值。例如，要将一个大小为<code>n+1</code>乘以<code>k+1</code>的二维数组<code>dp</code>中的所有元素都初始化为0，可以使用如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>对数组进行显式初始化。例如，要将<code>dp</code>数组中的所有元素都初始化为0，可以使用如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="c-类">C++类</h2>
<h3 id="string类">string类</h3>
<h4 id="构造函数">- 构造函数</h4>
<p><code>string(count, char)</code>是C++中的一个构造函数，它可以创建一个由重复字符构成的字符串。其中，第一个参数表示字符的个数，第二个参数表示要重复的字符。</p>
<p>例如，如果我们调用<code>string(3, 'A')</code>，就会创建一个由三个’A’字符构成的字符串&quot;AAA&quot;。如果我们调用<code>string(5, 'B')</code>，就会创建一个由五个’B’字符构成的字符串&quot;BBBBB&quot;。</p>
<h4 id="成员函数">- 成员函数</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>find()：<code>find()</code> 是一个字符串方法，它可以在一个较大的字符串中查找指定的子字符串，并返回该子字符串被找到的位置。如果没有找到该子字符串，则会返回 <code>npos</code>（表示“无位置”）。</p>
</li>
<li class="lvl-2">
<p>substr()：可用于从<code>string</code> 类型的字符串中提取子字符串；其中，<code>pos</code>参数表示要提取子字符串的开始位置，<code>len</code>参数表示要提取的字符数。默认情况下，<code>pos</code>为0，<code>len</code>为<code>s.size() - pos</code>。</p>
</li>
</ul>
<hr>
<h2 id="类型转换">类型转换</h2>
<h3 id="int-类型">int 类型</h3>
<p>范围：-2.147483648 × 10^9~2.147483647 × 10^9</p>
<h3 id="long-long-类型">long long 类型</h3>
<p>范围：-9.223372036854776 × 10^18~9.223372036854776 × 10^18</p>
<h3 id="int128-类型">__int128 类型</h3>
<p><code>__int128</code> 就是占用128字节的整数存储类型。由于是二进制，范围就是 −2<sup>127</sup> ~ 2<sup>127</sup>−1，如果使用了 <code>unsigned __int128</code>，则范围变成 0 ~ 2<sup>128</sup>，即约39位数！</p>
<h3 id="inf">INF</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;  <span class="comment">//这样定义INF的好处是: INF &lt;= INF+x 防止溢出</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="string转double">string转double</h3>
<p><code>std::stod()</code> 函数</p>
<blockquote>
<p>转译 string <code>str</code> 中的浮点值。</p>
</blockquote>
<h3 id="string转int">string转int</h3>
<p><code>std::stoi()</code> 函数</p>
<blockquote>
<p>转译字符串 <code>str</code> 中的有符号整数值。</p>
<p>舍弃所有空白符（以调用 <code>isspace()</code> 鉴别），直到找到首个非空白符，然后取尽可能多的字符组成<em>底 n</em> （其中 n=base ）的整数表示，并将它们转换成一个整数值。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;45&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;3.14159&quot;</span>;</span><br><span class="line">    std::string str3 = <span class="string">&quot;31337 with words&quot;</span>;</span><br><span class="line">    std::string str4 = <span class="string">&quot;words and 2&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> myint1 = std::<span class="built_in">stoi</span>(str1);</span><br><span class="line">    <span class="type">int</span> myint2 = std::<span class="built_in">stoi</span>(str2);</span><br><span class="line">    <span class="type">int</span> myint3 = std::<span class="built_in">stoi</span>(str3);</span><br><span class="line">    <span class="comment">// 错误： &#x27;std::invalid_argument&#x27;</span></span><br><span class="line">    <span class="comment">// int myint4 = std::stoi(str4);</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::stoi(\&quot;&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;\&quot;) is &quot;</span> &lt;&lt; myint1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::stoi(\&quot;&quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;\&quot;) is &quot;</span> &lt;&lt; myint2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::stoi(\&quot;&quot;</span> &lt;&lt; str3 &lt;&lt; <span class="string">&quot;\&quot;) is &quot;</span> &lt;&lt; myint3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str4 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint4 &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">std::stoi(&quot;45&quot;) is 45</span></span><br><span class="line"><span class="comment">std::stoi(&quot;3.14159&quot;) is 3</span></span><br><span class="line"><span class="comment">std::stoi(&quot;31337 with words&quot;) is 31337</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="c-位运算">C++位运算</h2>
<h5 id="算术右移">算术右移</h5>
<p>在汇编语言中，对于算术右移(高位补符号位)，<mark>如果最高位为1，则补1，否则补0</mark>， 如将10000000算术右移7位，应该变成11111111；</p>
<h5 id="逻辑右移">逻辑右移</h5>
<p>对于逻辑右移7位，则不考虑符号位，变为00000001，这点就是算术右移和逻辑右移的区别。</p>
<h5 id="算术左移">算术左移</h5>
<p>对于算术左移，在右边补0：比如 00101011算术左移一位:01010110</p>
<h5 id="逻辑左移">逻辑左移</h5>
<p>对于逻辑左移，同样是在右边补0，如：00010111逻辑左移两位：01011100</p>
<p>⭕️左移一般将低位补0。但右移可以是逻辑右移（高位补0）或算术右移（<mark><u>高位补符号位</u></mark>）。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>将一个值左移</mtext><mi>N</mi><mtext>位相当于乘以</mtext><msup><mn>2</mn><mi>N</mi></msup><mtext>。同理，算术右移</mtext><mi>N</mi><mtext>位，相当于除以</mtext><msup><mn>2</mn><mi>N</mi></msup><mtext>。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{将一个值左移N位相当于乘以2^N。同理，算术右移N位，相当于除以2^N。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord cjk_fallback" style="color:red;">将一个值左移</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">位相当于乘以</span><span class="mord" style="color:red;"><span class="mord" style="color:red;">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mathnormal mtight" style="margin-right:0.10903em;color:red;">N</span></span></span></span></span></span></span></span><span class="mord cjk_fallback" style="color:red;">。同理，算术右移</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">位，相当于除以</span><span class="mord" style="color:red;"><span class="mord" style="color:red;">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mathnormal mtight" style="margin-right:0.10903em;color:red;">N</span></span></span></span></span></span></span></span><span class="mord cjk_fallback" style="color:red;">。</span></span></span></span></p>
<hr>
<h5 id="左移与右移">左移与右移</h5>
<ol>
<li class="lvl-3">
<p>左移 &lt;&lt;<br>
取两个数字，左移第一个操作数的位，第二个操作数决定要移动的位置。换句话说，左移动一个整数 x 和一个整数 y（x&lt;&lt;y）等价于x乘以2<sup>y</sup>。</p>
</li>
<li class="lvl-3">
<p>右移 &gt;&gt;</p>
</li>
</ol>
<p>取两个数字，向右移动第一个操作数的位，第二个操作数决定移动的位置。同样地，右平移（x&gt;&gt;y）等价于x除以2<sup>y</sup>。</p>
<hr>
<h2 id="c-输入输出">C++输入输出</h2>
<h4 id="输出精度控制？-好像没效果">输出精度控制？（<mark>好像没效果</mark>）</h4>
<p><code>std::setprecision(int n)</code>：</p>
<p>控制输出浮点数的有效数字位数为n。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">double</span> pi = std::<span class="built_in">acos</span>(<span class="number">-1.L</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;default precision (6): &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;std::setprecision(10): &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; pi &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;max precision:         &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">setprecision</span>(std::numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::digits10 + <span class="number">1</span>)</span><br><span class="line">              &lt;&lt; pi &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="title">precision</span> <span class="params">(<span class="number">6</span>)</span>: <span class="number">3.14159</span></span></span><br><span class="line"><span class="function">std::setprecision(<span class="number">10</span>): <span class="number">3.141592654</span></span></span><br><span class="line"><span class="function">max precision:         <span class="number">3.141592653589793239</span></span></span><br></pre></td></tr></table></figure>
<h4 id="c语言输出精度控制-推荐">C语言输出精度控制（<mark>推荐</mark>）</h4>
<blockquote>
<p>对于有格式要求的输入输出，使用C语言的输入(scanf)和输出(printf)更加简便 。</p>
</blockquote>
<h5 id="1-格式控制符">1、格式控制符</h5>
<p>格式控制符 <code>%02d</code> 指定每个数值的宽度为2，不足两位则在前面补0；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d&quot;</span>, aa, bb, cc);<span class="comment">// 格式控制符 %02d 指定每个数值的宽度为2，不足两位则在前面补0</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭c-与c标准输入输出的同步">关闭C++与C标准输入输出的同步</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="cin-tie-0">cin.tie(0)</h4>
<p><code>cin.tie(0)</code>是一条C<ins>代码，它的作用是取消 <code>cin</code> 对 <code>cout</code> 的同步。在 C</ins> 中，当我们使用 <code>cin</code> 输入数据时，程序会默认先输出缓冲区中的内容，然后再等待用户输入。而这个输出操作可能会对程序的性能造成一定的影响，特别是当我们需要大量输入数据时。</p>
<p>为了避免这种性能问题，我们可以使用 <code>cin.tie(nullptr)</code> 或 <code>cin.tie(0)</code> 将 <code>cin</code> 与输出流分离。其中，<code>tie()</code> 函数是一个 I/O 流绑定函数，用于将两个流关联在一起，而参数为 <code>nullptr</code> 或 <code>0</code> 的 <code>tie()</code> 函数则表示取消绑定。</p>
<p>因此，<code>cin.tie(0)</code> 的作用就是取消 <code>cin</code> 和 <code>cout</code> 的绑定，使得输入操作和输出操作不再同步进行，从而提高程序的运行效率。</p>
<h4 id="cout-tie-0">cout.tie(0)</h4>
<p><code>cout.tie(0)</code>也是一条C<ins>代码，和<code>cin.tie(0)</code>类似，它的作用是取消 <code>cout</code> 对 <code>cin</code> 的同步。在 C</ins> 中，当我们使用 <code>cout</code> 输出数据时，程序会默认先将缓冲区中的内容输出到屏幕上，然后再等待用户输入。而这个输出操作可能会对程序的性能造成一定的影响，特别是当我们需要大量输出数据时。</p>
<p>为了避免这种性能问题，我们可以使用 <code>cout.tie(nullptr)</code> 或 <code>cout.tie(0)</code> 将 <code>cout</code> 与输入流分离。其中，<code>tie()</code> 函数是一个 I/O 流绑定函数，用于将两个流关联在一起，而参数为 <code>nullptr</code> 或 <code>0</code> 的 <code>tie()</code> 函数则表示取消绑定。</p>
<p>因此，<code>cout.tie(0)</code> 的作用就是取消 <code>cout</code> 和 <code>cin</code> 的绑定，使得输出操作和输入操作不再同步进行，从而提高程序的运行效率。</p>
<h4 id="eof-end-of-file">EOF（End Of File）</h4>
<p>通常在文本的最后存在此字符表示资料结束。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[cnt])!=EOF)cnt++;</span><br></pre></td></tr></table></figure>
<p>当上面的程序运行时，如果不加&quot; != EOF&quot;，那么这个程序就是个死循环，会一直运行下去；加上&quot; != EOF&quot;后该程序就不是死循环了，如果在终端不进行输入该程序会自动结束(while的意思就是说当当前输入缓存还有东西时就一直读取，直到输入缓存中的内容为空时停止)。</p>
<blockquote>
<p>在Terminal中输入完成之后按下<mark>CTRL+Z、Enter</mark>即可等价于EOF：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406010938399.png" alt="image-20230406010938399"></p>
</blockquote>
<h2 id="c-数学相关">C++数学相关</h2>
<h3 id="曼哈顿距离">曼哈顿距离</h3>
<p><mark>曼哈顿距离</mark>也称为**<u>城市街区距离或 L1 距离</u>**，它是在欧几里德空间中两点之间的距离度量方法之一。曼哈顿距离是指从一个点到另一个点沿着网格线走的最短距离，即沿着水平和垂直方向行走的距离之和。</p>
<p>例如，在二维平面上，点 A (x1, y1) 到点 B (x2, y2) 的曼哈顿距离为 |x1 - x2| + |y1 - y2|。</p>
<p>曼哈顿距离常用于计算机科学、统计学、数据挖掘等领域中，特别是在路线规划、图像处理、聚类分析等方面的应用比较广泛。</p>
<h3 id="等差等比数列">等差等比数列</h3>
<h5 id="1-等差数列">1、等差数列</h5>
<p>一个等差数列是指一个数列中每个相邻的数之间有着相同的差值。下面分别介绍等差数列的通式和求和公式。</p>
<p><strong>等差数列通式：</strong><br>
假设等差数列的第一项为a1，公差为d，则它的第n项an可以表示为：<br>
an = a1 + (n-1)d</p>
<p>例如，如果一个等差数列的第一项是2，公差是3，那么它的第5项就可以用上述公式计算得到：<br>
a5 = 2 + (5-1)×3 = 14</p>
<p><strong>等差数列求和公式：</strong><br>
对于一个有限项的等差数列，我们可以使用下面的公式来求和：<br>
Sn = n/2 × (a1 + an)</p>
<p>其中，Sn表示该等差数列的前n项和。例如，如果一个等差数列的前10项分别是2、5、8、11、14、17、20、23、26和29，则可以使用上述公式计算它们的和：<br>
S10 = 10/2 × (2 + 29) = 155</p>
<h5 id="2-等比数列">2、等比数列</h5>
<p>一个等比数列是指一个数列中每个相邻的数之间有着相同的比值。下面分别介绍等比数列的通式和求和公式。</p>
<p><strong>等比数列通式：</strong><br>
假设等比数列的第一项为a1，公比为q，则它的第n项an可以表示为：<br>
an = a1 × q^(n-1)</p>
<p>例如，如果一个等比数列的第一项是2，公比是3，那么它的第5项就可以用上述公式计算得到：<br>
a5 = 2 × 3^(5-1) = 162</p>
<p><strong>等比数列求和公式：</strong><br>
对于一个有限项的等比数列，我们可以使用下面的公式来求和：<br>
Sn = (a1 × (1-q^n)) / (1-q)</p>
<p>其中，Sn表示该等比数列的前n项和。例如，如果一个等比数列的前5项分别是2、6、18、54和162，则可以使用上述公式计算它们的和：<br>
S5 = (2 × (1-3^5)) / (1-3) = 242</p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-第三周</title>
    <url>/2023/09/10/University/Algorithm/7%20questions%20per%20week/%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>算法-第三周</h1>
<blockquote>
<p>一周7题，每日1题。</p>
<p>开始：2023年6月12日（周一）</p>
</blockquote>
<h3 id="p3368-模板-树状数组-2">P3368 【模板】树状数组 2</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P3368">https://www.luogu.com.cn/problem/P3368</a></p>
</li>
</ul>
<p>method1：让树状数组全为0，只记录修改信息，最后将修改信息与原序列相结合得到单点查询</p>
<p>method2：利用差分后的结果来建树（这里使用method2）</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>建树：用差分后的结果</p>
</li>
<li class="lvl-2">
<p>区间加法：利用差分法，f[x]=a[x]-a[x-1]</p>
</li>
<li class="lvl-2">
<p>查询单点：利用前缀和，a[x]=f[x]+a[x-1]</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P3368 【模板】树状数组 2</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tree[N], a[N]; <span class="comment">// 树状数组，原始序列 </span></span><br><span class="line"><span class="comment">// method1：让树状数组全为0，只记录修改信息，最后将修改信息与原序列相结合得到单点查询 </span></span><br><span class="line"><span class="comment">// method2：利用差分后的结果来建树 </span></span><br><span class="line"><span class="comment">// - 建树：用差分后的结果</span></span><br><span class="line"><span class="comment">// - 区间加法：利用差分法，f[x]=a[x]-a[x-1] </span></span><br><span class="line"><span class="comment">// - 查询单点：利用前缀和，a[x]=f[x]+a[x-1] </span></span><br><span class="line"><span class="comment">// （这里使用method2）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点加法 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">		tree[x] += k;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点查询 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		ans += tree[x]; <span class="comment">// 差分还原 </span></span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>, last = <span class="number">0</span>; <span class="comment">// 初始化为0，方便进行差分 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;now;</span><br><span class="line">		<span class="built_in">add</span>(i, now-last); <span class="comment">// 建树 </span></span><br><span class="line">		last = now;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> op, x, y, k;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123; <span class="comment">// 区间加法 </span></span><br><span class="line">			cin&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">add</span>(x, k), <span class="built_in">add</span>(y+<span class="number">1</span>, -k); <span class="comment">// 差分实现区间加法 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">search</span>(x)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1423-小玉在游泳">P1423 小玉在游泳</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1423">https://www.luogu.com.cn/problem/P1423</a></p>
</li>
</ul>
<p>C语言输入double类型数据：在<code>scanf</code>函数中使用<code>%lf</code>格式说明符来读取一个double类型的数值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> s;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>; <span class="comment">// 初始游一步 </span></span><br><span class="line"><span class="type">double</span> x = <span class="number">2</span>, pre = <span class="number">2</span>; <span class="comment">// x：总距离，pre：上一步的距离 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cin&gt;&gt;s;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;s);</span><br><span class="line">	<span class="keyword">while</span>(x&lt;s)&#123;</span><br><span class="line">		pre = pre*<span class="number">0.98</span>;</span><br><span class="line">		x = x + pre;</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="転倒数">転倒数</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/AT_chokudai_S001_j">https://www.luogu.com.cn/problem/AT_chokudai_S001_j</a></p>
</li>
</ul>
<h4 id="树状数组求逆序对">树状数组求逆序对</h4>
<h5 id="离散化：">离散化：</h5>
<p>假设我们有一个原始数组 <code>arr</code>，其中包含一些整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr = &#123;10, 30, 20, 15, 25&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们想要对这个数组进行离散化，将每个元素映射为连续的整数。离散化的目的是在处理一些问题时，将元素的实际值转换为一些连续的索引，便于后续的计算。</p>
<p>首先，创建一个辅助数组 <code>lsh</code>，大小与原始数组相同。然后，<strong><u>对原始数组进行排序</u></strong>，得到一个有序的数组 <code>sorted</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sorted = &#123;10, 15, 20, 25, 30&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，遍历有序数组 <code>sorted</code>，并<mark>将每个元素的值与其在原始数组中的对应位置进行映射</mark>，将映射结果存储在 <code>lsh</code> 数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsh[0] = 1   // 10 映射为 1</span><br><span class="line">lsh[1] = 4   // 15 映射为 4</span><br><span class="line">lsh[2] = 2   // 20 映射为 2</span><br><span class="line">lsh[3] = 5   // 25 映射为 5</span><br><span class="line">lsh[4] = 3   // 30 映射为 3</span><br></pre></td></tr></table></figure>
<p>最终，<code>lsh</code> 数组中的元素表示原始数组中每个元素离散化后的结果。在后续的计算中，我们<mark>可以使用 <code>lsh</code> 数组来代替原始数组</mark>，进行更方便的处理。</p>
<p>需要注意的是，离散化过程中，如果有多个相同的元素，它们在排序后的数组中的顺序决定了它们在离散化结果中的顺序。</p>
<blockquote>
<p><mark>离散化的实质</mark>就是：用原始数组的下标来替换其对应的元素（因为元素可以很大，而下标就想对比较小，且下标一定在定义的范围内），再将原数组下标映射为新的连续自然数<code>lsh[a[i].order]=i</code>，这里的a数组是一个结构体数组，包含<code>order,value</code>两个变量，a数组可以根据具体情况在不同排序规则下进行排序，最后我们只需要使用离散化后的数组lsh代替原始数组进行处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 结构体数组</span></span><br><span class="line">&gt;<span class="keyword">struct</span> <span class="title class_">Number</span>&#123;</span><br><span class="line"><span class="type">int</span> order;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&gt;&#125;a[N]; </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="树状数组：">树状数组：</h5>
<p>通过排序，并离散化之后，我们<mark>将得到的离散化数组利用桶排序中“桶”的思想代入到树状数组中进行处理</mark>，最后求出逆序对的数量（<strong><u>逆序对</u></strong>：i&lt;j,而a[i]&gt;a[j]，这就是一个逆序对），也就是找到比当前元素大的元素的个数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// AT_chokudai_S001_j —— 冒泡排序中有多少逆序对存在 </span></span><br><span class="line"><span class="comment">// 运用树状数组求逆序对</span></span><br><span class="line"><span class="comment">// 输入的原始序列的元素可能会很大，超过定义的树状数组的最大范围，因此需要进行离散化，也就是用原始序列对应的序号来标识对应的元素</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">	<span class="type">int</span> order;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;a[N]; </span><br><span class="line"><span class="type">int</span> lsh[N]; <span class="comment">// 离散化数组</span></span><br><span class="line"><span class="type">int</span> tree[N]; <span class="comment">// 树状数组</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans; <span class="comment">// 逆序对的数量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">		tree[x] += k;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		res += tree[x];</span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i].value;</span><br><span class="line">		a[i].order = i; <span class="comment">// 原始数组的序号 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 升序排序 </span></span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n, [](Number a, Number b)&#123; <span class="comment">// 匿名函数 </span></span><br><span class="line">		<span class="keyword">return</span> a.value&lt;b.value;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 离散化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		lsh[a[i].order] = i; <span class="comment">// 实质是：升序排序后，元素对应的新下标(这个新下标用在树状数组中进行计算逆序对) </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123; <span class="comment">// 这里的i控制的是冒泡排序中当前待排序数组的元素总个数 </span></span><br><span class="line">		<span class="built_in">add</span>(lsh[i], <span class="number">1</span>); <span class="comment">// 桶排序思想：&lt;=当前元素的元素个数有多少个</span></span><br><span class="line">		ans += i-<span class="built_in">getSum</span>(lsh[i]); </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p5019-noip2018-提高组-铺设道路">P5019 [NOIP2018 提高组] 铺设道路</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P5019">https://www.luogu.com.cn/problem/P5019</a></p>
</li>
</ul>
<h4 id="贪心法">贪心法</h4>
<p>题目里给的样例是4，3，2，5，3，5；</p>
<p>可以选择一个区间进行“填坑”操作；</p>
<p>所以我们的贪心策略是：</p>
<h6 id="若a-i-a-i-1-计数器sum-a-i-a-i-1-辅以差分思想">若a[i]&gt;a[i-1],计数器sum+=a[i]-a[i-1]; （辅以<mark>差分思想</mark>）⭐️</h6>
<p>那么为什么这样贪心是对的呢？</p>
<h5 id="贪心证明">贪心证明</h5>
<p>假设现在有一个坑，但旁边又有一个坑。</p>
<p>你肯定会选择把两个同时减1；</p>
<p>那么小的坑肯定会被大的坑“带着”填掉。</p>
<p>大的坑也会减少a[i]-a[i-1]的深度，可以说是“免费的”；</p>
<p>所以这样贪心是对的；</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P5019 [NOIP2018 提高组] 铺设道路</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> sum, pre = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span>(a&gt;pre)sum+=a-pre;</span><br><span class="line">		pre = a;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p4387-深基15-习9-验证栈序列">P4387 【深基15.习9】验证栈序列</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P4387">https://www.luogu.com.cn/problem/P4387</a></p>
</li>
</ul>
<p>栈模拟题：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>可以用数组模拟栈</p>
</li>
<li class="lvl-2">
<p>也可以直接用STL模板</p>
</li>
</ul>
<p><u><em><strong>两个序列 pushed 和 poped 两个序列，验证poped序列是否为pushed序列的出栈序列</strong></em></u></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P4387 【深基15.习9】验证栈序列</span></span><br><span class="line"><span class="comment">// 利用栈来辅助 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, Q; </span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;st; <span class="comment">// 定义栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;Q;</span><br><span class="line">	<span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123; </span><br><span class="line">			cin&gt;&gt;a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123; </span><br><span class="line">			cin&gt;&gt;b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			st.<span class="built_in">push</span>(a[i]);</span><br><span class="line">			<span class="keyword">while</span>(st.<span class="built_in">top</span>()==b[cnt])&#123; <span class="comment">// 相等则弹出栈 </span></span><br><span class="line">				st.<span class="built_in">pop</span>();</span><br><span class="line">				cnt++;</span><br><span class="line">				<span class="keyword">if</span>(st.<span class="built_in">empty</span>())<span class="keyword">break</span>; <span class="comment">// 栈为空则提前结束 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(st.<span class="built_in">empty</span>())cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">while</span>(!st.<span class="built_in">empty</span>())st.<span class="built_in">pop</span>(); <span class="comment">// 这里是为了下一次查询做处理 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1597-语句解析">P1597 语句解析</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1597">https://www.luogu.com.cn/problem/P1597</a></p>
</li>
</ul>
<p><span style="color: red;">分析：</span></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>一串符合语法的 PASCAL 语言，只有a*,<em>b</em>,*c三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，未赋值的变量值为 0。</p>
</li>
</ul>
<p>充分利用c语言优势（方便的输入和输出：scanf,printf）</p>
<p>表达式<code>scanf(&quot;%c:=%c;&quot;, &amp;s1, &amp;s2) == 2</code>：如果<code>scanf</code>函数成功读取了两个字符并且正确赋值给<code>s1</code>和<code>s2</code>，则<mark>返回值为2</mark>（<u><em>表示成功读取了两个数据</em></u>）。如果读取失败或者读取的数据不符合指定的格式，返回值会小于2。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>&quot;%c&quot;</code>表示的是读取的字符类型数据</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P1597 语句解析</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> y, x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c:=%c;&quot;</span>, &amp;y, &amp;x)==<span class="number">2</span>)&#123; <span class="comment">// 表示成功读取两个数据 </span></span><br><span class="line">		a[y-<span class="string">&#x27;a&#x27;</span>] = (x&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;9&#x27;</span>)?x-<span class="string">&#x27;0&#x27;</span>:a[x-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// 是整数则直接赋值，是变量调用则对应的变量值 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1424-小鱼的航程-改进版">P1424 小鱼的航程（改进版）</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1424">https://www.luogu.com.cn/problem/P1424</a></p>
</li>
</ul>
<p>简单的一个模拟题，但是要<mark>注意细节</mark></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P1424 小鱼的航程（改进版）</span></span><br><span class="line"><span class="type">int</span> x, n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>]; <span class="comment">// 不计0，6，7；只记1-5 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;n;</span><br><span class="line">	a[x%<span class="number">7</span>]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123; <span class="comment">// 注意：从周x开始，那么周x自然也算1天，因此循环还有n-1天 </span></span><br><span class="line">		a[(x+i)%<span class="number">7</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">accumulate</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+<span class="number">5</span>, <span class="number">0</span>)*<span class="number">250</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>算法练习</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-第一周</title>
    <url>/2023/06/07/University/Algorithm/7%20questions%20per%20week/%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>算法-第一周</h1>
<blockquote>
<p>一周7题，每日1题。</p>
<p>开始：2023年5月29日（周一）</p>
</blockquote>
<h3 id="p1387-最大正方形">P1387 最大正方形</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1387">P1387 最大正方形 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ul>
<p>// <code>min(min(f[i-1][j], f[i][j-1]), f[i-1][j-1])+1</code>解释如下：<br>
// 要保证构成正方形，那么就需要保证取 <code>f[i-1][j]</code>, <code>f[i][j-1]</code>, <code>f[i-1][j-1]</code>三个之间最小值+1,比如下面：<br>
// 0 1	——&gt;对应f[][]的值：0 1<br>
// 1 1 					                 1 1<br>
// 由于 <code>f[i-1][j-1]=0</code>,因此导致不能构成边长为2的正方形,因此<code>f[i][j]</code>的值还是1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 动态规划解法 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">// 第0行和0列作辅助运算 </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); </span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">			<span class="keyword">if</span>(a[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">				f[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i<span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]), f[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, f[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// min(min(f[i-1][j], f[i][j-1]), f[i-1][j-1])+1;解释如下：</span></span><br><span class="line"><span class="comment">// 要保证构成正方形，那么就需要保证取 f[i-1][j], f[i][j-1], f[i-1][j-1]三个之间最小值+1,比如下面：</span></span><br><span class="line"><span class="comment">// 0 1	——&gt;对应f[][]的值：0 1 </span></span><br><span class="line"><span class="comment">// 1 1 					1 1</span></span><br><span class="line"><span class="comment">// 由于 f[i-1][j-1]=0,因此导致不能构成边长为2的正方形,因此f[i][j]的值还是1 </span></span><br></pre></td></tr></table></figure>
<h3 id="p1025-noip2001-提高组-数的划分">P1025 [NOIP2001 提高组] 数的划分</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>[P1025 <a href="https://www.luogu.com.cn/problem/P1025">NOIP2001 提高组] 数的划分 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ul>
<p><span style="color: red;">思路分析：</span></p>
<p>这是一个经典的组合问题，可以使用递归或者动态规划来解决。</p>
<p>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 表示将整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 份的方案总数。</p>
<p>首先，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，显然无法分配，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n, k) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p>
<p>其次，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时，只有一种分配方案，即全放在一起，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(n, k) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>最后，考虑一般情况。我们可以钦定其中一份为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，然后对剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的分配，此时方案数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1, k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。另外，我们也可以不选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，而是将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 中的某个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 作为钦定的数，然后对剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的分配，此时方案数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-m, k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。因此，我们可以列出如下的递推式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mi>k</mi><mtext> or </mtext><mi>k</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>&lt;</mo><mi>k</mi><mtext> or </mtext><mi>k</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(n, k) = \begin{cases} 1 &amp; n = k \text{ or } k = 1 \\ 0 &amp; n &lt; k \text{ or } k = 0 \\ f(n-1, k-1) + f(n-2, k-1) + \cdots + f(n-k+1, k-1) &amp; \text{otherwise} \end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord text"><span class="mord"> or </span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord text"><span class="mord"> or </span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这个式子的含义是：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 份的方案总数，等于钦定一份为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，然后将剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 份的方案数，以及钦定一份为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，并将剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 份的方案数，由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的取值范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n-k+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，因此需要将这些情况累加起来。</p>
<p>最终的答案就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。实现时可以使用递归或者动态规划，时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span>。</p>
<p><u><em><strong><mark>将以上分析转换为代码思路：</mark></strong></em></u></p>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>划分</strong>： 此题可以划分为在满足k个数组合等于n时两种情况：包含1、不包含1</p>
</li>
<li class="lvl-2">
<p><strong>状态</strong>： <code>dp[i][j]</code>含义为数字i划分为j部分的划分数</p>
</li>
<li class="lvl-2">
<p><strong>当包含1时</strong>： 划分结果中至少有一个1 = 将n-1分成k-1份的结果（一定存在1，那么我就先划分出一个1，剩下的值无论怎么划分，最终结果中一定存在至少一个1）所以：<code>dp[i][j]=dp[i-1][j-1]+不包含1的划分数</code></p>
</li>
<li class="lvl-2">
<p><strong>当不包含1时</strong>： 划分结果中不存在1 = 将n-k划分为k份的结果（序列中不存在1，则划分结果序列中的数一定都大于等于2，所以等价于对于每一个数都减去1，则剩下的结果一定是n-k划分成k份的结果）不包含1的划分数 = <code>dp[i-j][j]</code></p>
</li>
<li class="lvl-2">
<p><strong>状态转移方程</strong>： <code>dp[i][j] = dp[i-1][j-1] + dp[i-j][j]</code></p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 主要是思维：包含1(dp[i-1][j-1])和不包含1(dp[i-j][j]) </span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">205</span>][<span class="number">7</span>];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i, k);++j)&#123;</span><br><span class="line">			dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i-j][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][k];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><u>以上使用递归也可解决，但存在过多重复计算，大数据量下不推荐使用！</u></p>
</blockquote>
<h3 id="p5057-cqoi2006-简单题">P5057 [CQOI2006]简单题</h3>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>思路：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{思路：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">思路：</span></span></span></span></p>
<ol>
<li class="lvl-3">线段树：区间修改+单点查询</li>
<li class="lvl-3"><mark>值得注意的是</mark>：
<ul class="lvl-3">
<li class="lvl-5"><em><strong>区间修改时</strong></em>：对于一个叶子结点A，如果A=0，那么翻转则变为A=1；如果A=1，为使其翻转我们可以让A=A+1=2，这个时候2的二进制：<code>10</code>，可以发现二进制最低位为0，相当于从1翻转为了0；依次类推，当我们再次对A进行翻转时，有A=A+1=3，3的二进制：<code>11</code>，最后一位为1，实现了翻转的目的。
<ul class="lvl-5">
<li class="lvl-7">相当于是每次<strong>区间修改的值恒为1</strong></li>
</ul>
</li>
<li class="lvl-5"><em><strong>单点查询时</strong></em>：只需要用<code>A&amp;1</code>取<u><strong>最后一位</strong></u>即可。</li>
</ul>
</li>
<li class="lvl-3">其他便是线段树的经典内容</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P5057 [CQOI2006]简单题</span></span><br><span class="line"><span class="comment">// 线段树：区间修改+单点查询</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], d[<span class="number">4</span>*N], b[<span class="number">4</span>*N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	d[p] = d[p&lt;&lt;<span class="number">1</span>]+d[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildT</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">		d[p] = <span class="number">0</span>; <span class="comment">// 题意：初始全为0 </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">buildT</span>(s, mid, p&lt;&lt;<span class="number">1</span>);	<span class="comment">// 左子树</span></span><br><span class="line">	<span class="built_in">buildT</span>(mid+<span class="number">1</span>, t, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>); <span class="comment">// 右子树 </span></span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateT</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span>&#123; <span class="comment">// 默认修改值恒为1 </span></span><br><span class="line">	<span class="keyword">if</span>(l&lt;=s&amp;&amp;t&lt;=r)&#123;</span><br><span class="line">		d[p] += (t-s+<span class="number">1</span>)*<span class="number">1</span>;</span><br><span class="line">		b[p] += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(b[p]&amp;&amp;s!=t)&#123;</span><br><span class="line">		d[p&lt;&lt;<span class="number">1</span>] += b[p]*(mid-s+<span class="number">1</span>), d[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += b[p]*(t-mid);</span><br><span class="line">		b[p&lt;&lt;<span class="number">1</span>] += b[p], b[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += b[p];</span><br><span class="line">		b[p] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">updateT</span>(s, mid, l, r, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)<span class="built_in">updateT</span>(mid+<span class="number">1</span>, t, l, r, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPoint</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> node, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="comment">// node为查询结点, [s, t]为当前节点包含的区间, p为当前节点的编号</span></span><br><span class="line">	<span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">		<span class="keyword">return</span> d[p]&amp;<span class="number">1</span>; <span class="comment">// 用&amp;1取二进制的最后一位：0或1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(b[p])&#123;</span><br><span class="line">		d[p&lt;&lt;<span class="number">1</span>] += b[p]*(mid-s+<span class="number">1</span>), d[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += b[p]*(t-mid);</span><br><span class="line">		b[p&lt;&lt;<span class="number">1</span>] += b[p], b[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += b[p];</span><br><span class="line">		b[p] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(node&lt;=mid)&#123; <span class="comment">// 遍历左子树 </span></span><br><span class="line">		<span class="built_in">getPoint</span>(s, mid, node, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">// 遍历右子树 </span></span><br><span class="line">		<span class="built_in">getPoint</span>(mid+<span class="number">1</span>, t, node, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; </span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i];</span></span><br><span class="line">	<span class="built_in">buildT</span>(<span class="number">1</span>, n, <span class="number">1</span>); <span class="comment">// 节点编号从1开始 </span></span><br><span class="line">	<span class="type">int</span> op, x, y, node;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			<span class="built_in">updateT</span>(<span class="number">1</span>, n, x, y, <span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123; <span class="comment">// 输出 </span></span><br><span class="line">			cin&gt;&gt;node;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">getPoint</span>(<span class="number">1</span>, n, node, <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p8278-mcoi-08-fill-in">P8278 「MCOI-08」Fill In</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P8278">https://www.luogu.com.cn/problem/P8278</a></p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>思路：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{思路：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">思路：</span></span></span></span></p>
<p>从左到右遍历：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>使用结构体存储区间信息（左右边界以及区间和）</p>
</li>
<li class="lvl-2">
<p>区间的左边界可能是-1可能不是-1，这对于还原一种可能得数组a来说并不影响，因为不管是否是-1，有区间和就可以将本区间的数给合理分配到对应的数组a的位置</p>
</li>
<li class="lvl-2">
<p>具有代表性的示例数据：</p>
</li>
<li class="lvl-2">
<p>10 （n）</p>
</li>
<li class="lvl-2">
<p>10 -1 20 -1 25 -1 -1 35 -1 -1 （p数组）</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601122521645.png" alt="image-20230601122521645"></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P8278 「MCOI-08」Fill In——前缀和 </span></span><br><span class="line"><span class="comment">// 从左到右遍历：</span></span><br><span class="line"><span class="comment">// 使用结构体存储区间信息（左右边界以及区间和） </span></span><br><span class="line"><span class="comment">// 区间的左边界可能是-1可能不是-1，这对于还原一种可能得数组a来说并不影响，因为不管是否是-1，有区间和就可以将本区间的数给合理分配到对应的数组a的位置 </span></span><br><span class="line"><span class="comment">// 具有代表性的示例数据：</span></span><br><span class="line"><span class="comment">// 10 （n） </span></span><br><span class="line"><span class="comment">// 10 -1 20 -1 25 -1 -1 35 -1 -1 （p数组） </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N]; </span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">interval</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, r, sum;</span><br><span class="line">&#125;f[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 控制结构体的下标 </span></span><br><span class="line"><span class="type">int</span> quotient, remain; <span class="comment">// 商，余数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem</span><span class="params">()</span></span>&#123; <span class="comment">//更新必要数据 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		f[i].l=f[i].r=f[i].sum=<span class="number">0</span>;</span><br><span class="line">		cnt = <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;p[i];</span><br><span class="line">		f[++cnt].l = <span class="number">1</span>; <span class="comment">// 初始化左边界为1 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">				f[cnt].r = i; <span class="comment">// 更新右边界 </span></span><br><span class="line">				f[cnt].sum = p[i]-p[f[cnt].l<span class="number">-1</span>];  <span class="comment">// 更新区间和 </span></span><br><span class="line">				f[++cnt].l = i+<span class="number">1</span>; <span class="comment">// 继续下一个区间</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历区间结构体 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cnt;++i)&#123; <span class="comment">// 不取cnt,是因为最后一个cnt表示的是最后一个区间只有左边界 </span></span><br><span class="line">			<span class="type">int</span> l = f[i].l, r = f[i].r, sum = f[i].sum;</span><br><span class="line">			quotient = sum/(r-l+<span class="number">1</span>); <span class="comment">// 商 </span></span><br><span class="line">			remain = sum%(r-l+<span class="number">1</span>); <span class="comment">// 余数 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=r;++j)p[j] = quotient; <span class="comment">// 区间内的值平均分，若有余数再依次+1</span></span><br><span class="line">			<span class="keyword">if</span>(remain&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;l+remain;++k)&#123;</span><br><span class="line">					p[k]++; <span class="comment">// 若有余数再依次+1</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最后处理没有转换的-1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">				p[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;p[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">mem</span>(); <span class="comment">// 更新必要数据避免上一次的数据影响到下一次的操作 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p6536-coci2013-2014-1-kušač">P6536 [COCI2013-2014#1] KUŠAČ</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P6536">https://www.luogu.com.cn/problem/P6536</a></p>
</li>
</ul>
<p>要注意的是： 一刀可将香肠分为两份 ，所以我们可以直接利用模拟来分析：</p>
<blockquote>
<p>我们可以将所有香肠首尾接在一起，成为一根完整的香肠，平均切就好了。<u>如果需要切的地方是原来香肠的接口，这一刀就不用切了。</u></p>
<ul class="lvl-2">
<li class="lvl-2">每一根香肠都可以看做是m份，所以n根香肠连起来就是<code>n*m</code></li>
<li class="lvl-2">每人要分<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mi>M</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，而连接起来的香肠总共看做是n*m份，因此采用循环每次i增加n</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>P</mi><mi>S</mi><mtext>：</mtext><mi>N</mi><mtext>，</mtext><mi>M</mi><mtext>分别是根数和人数；</mtext><mi>n</mi><mtext>，</mtext><mi>m</mi><mtext>分别是连接后的香肠的</mtext><mi>n</mi><mtext>小份和每根香肠有</mtext><mi>m</mi><mtext>小份</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{PS：N，M分别是根数和人数；n，m分别是连接后的香肠的n小份和每根香肠有m小份}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">PS</span><span class="mord cjk_fallback" style="color:red;">：</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span><span class="mord cjk_fallback" style="color:red;">分别是根数和人数；</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord mathnormal" style="color:red;">m</span><span class="mord cjk_fallback" style="color:red;">分别是连接后的香肠的</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord cjk_fallback" style="color:red;">小份和每根香肠有</span><span class="mord mathnormal" style="color:red;">m</span><span class="mord cjk_fallback" style="color:red;">小份</span></span></span></span></p>
<p><span style="color: red;">每根香肠有m小份，每一小份对应一个人，那么总共n根香肠，那么每根香肠都为一个人贡献一小份（共m人），那么就是每次在连接后的香肠中取n小份出来给一个人，而每取n小份就记一刀；之后判断是否为m的倍数，如果是则表明刚好切到了香肠与香肠之间的连接处，那么这一刀就不计到答案中</span></p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P6536 [COCI2013-2014#1] KU?A? </span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n*m;i+=n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%m!=<span class="number">0</span>)&#123; <span class="comment">// 不是整数倍 </span></span><br><span class="line">			ans++; <span class="comment">// 切的刀数 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1551-亲戚">P1551 亲戚</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1551">https://www.luogu.com.cn/problem/P1551</a></p>
</li>
</ul>
<p>并查集的两个函数：find(),unionSet().注意初始化每个元素的父节点为本，find()函数要用<code>完全的空间压缩方法</code>进行。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 找亲戚关系，典型的并查集应用 </span></span><br><span class="line"><span class="type">int</span> n, m, p;</span><br><span class="line"><span class="type">int</span> parent[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=parent[x])&#123; <span class="comment">// 未到达最终的祖宗节点 </span></span><br><span class="line">		parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(rootX!=rootY)&#123;</span><br><span class="line">		parent[rootX] = rootY;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123; <span class="comment">// 初始化祖先为自己 </span></span><br><span class="line">		parent[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">unionSet</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p--)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1420-最长连号">P1420 最长连号</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1420">https://www.luogu.com.cn/problem/P1420</a></p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P1420 最长连号 </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>, pre, cur;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	n--;</span><br><span class="line">	cin&gt;&gt;pre;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		cin&gt;&gt;cur;</span><br><span class="line">		<span class="keyword">if</span>(cur==pre+<span class="number">1</span>)&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cnt = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">		pre = cur;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>算法练习</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题1</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%971%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-数字三角形">1、数字三角形</h3>
<blockquote>
<p>lanqiao505：<a href="https://www.lanqiao.cn/problems/505/learning/?first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tag_category_id=8">数字三角形 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月28日22:42:09</strong></u></p>
<p>tags：动态规划</p>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328212345198.png" alt="image-20230328212345198"></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>定义数字三角形从第一行开始；</p>
</li>
<li class="lvl-3">
<p>相差不超过一是当你到了最后一排才考虑的，当奇数行情况下，最后的一个要加的数一定是最后一行中间那个数；偶数情况下就是中间两个数谁大加谁。可以自己推。</p>
</li>
<li class="lvl-3">
<p>所以动态规划直接从第二排开始，每个数加max（左上，上），最后输出奇数情况一定中间最大，偶数是中间两个其中一个大，所以没必要判断奇偶，就是<code>max（a[n][n/2],a[n][n/2+1]）</code>就行了</p>
</li>
</ol>
<blockquote>
<p>题目要求向左下的次数和右下次数相差不超过1，所以可以从次数和对矩阵找规律。 设(x,y)为(左下次数，右下次数)<br>
找到如下规律：<br>
(0,0)<br>
(1,0) (0,1)<br>
(2,0) (1,1) (0,2)<br>
(3,0) (2,1) (1,2) (0,3)<br>
(4,0) (3,1) (2,2) (1,3) (0,4)<br>
(5,0) (4,1) (3,2) (2,3) (1,4) (0,5)<br>
可以发现，奇数行次数相差不超过1为中间一个：例如：n=5时，满足条件的为(2,2);<br>
偶数行次数相差不超过1的为中间两个： 例如：n=6时，满足条件为(3,2), (2,3)。所以，从左上到右下依次计算最大值并保存，输出时对结果进行判断，若有奇数行，输出最后一行中间的数；若有偶数行，输出最后一行中间两个数中较大的数。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">// 初始化数据 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line">			cin&gt;&gt;dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;<span class="comment">// 从2行开始 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line">			dp[i][j] += <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">max</span>(dp[n][(n+<span class="number">1</span>)/<span class="number">2</span>], dp[n][(n+<span class="number">2</span>)/<span class="number">2</span>]);<span class="comment">// 如果n为奇数，那么(n+1)/2与(n+2)/2的值相同</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-特别数的和">2、特别数的和</h3>
<blockquote>
<p>lanqiao191：<a href="https://www.lanqiao.cn/problems/191/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;tags=%E6%9E%9A%E4%B8%BE">特别数的和 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日17:03:11</strong></u></p>
<p>tags：枚举</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>通过取余和整除的方式判断一个数是否含有2、0、1、9 四个数。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 判断是否包含2、0、1、9 </span></span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		<span class="type">int</span> t = x%<span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">2</span>||t==<span class="number">0</span>||t==<span class="number">1</span>||t==<span class="number">9</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> tmp = i;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(tmp))&#123;<span class="comment">// 判断是否符合条件 </span></span><br><span class="line">			sum += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-日期问题">3、日期问题</h3>
<blockquote>
<p>lanqiao103：<a href="https://www.lanqiao.cn/problems/103/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;tags=%E6%9E%9A%E4%B8%BE">日期问题 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日17:05:22</strong></u></p>
<p>tags：枚举</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>根据题意知道，为了方便输出的结果是按照时间顺序的，因此采用从小到大的枚举遍历方式；</p>
</li>
<li class="lvl-3">
<p>具有格式化的输入和输出最好采用C的标准输入和输出更方便。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出要按照时间顺序</span></span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> nums[] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> </span>&#123; <span class="comment">// 考虑 month和 day是否符合要求</span></span><br><span class="line">	<span class="keyword">if</span>(month&lt;<span class="number">1</span>||month&gt;<span class="number">12</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(day&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(month!=<span class="number">2</span>) &#123; <span class="comment">// 考虑非2月份</span></span><br><span class="line">		<span class="keyword">if</span>(day&gt;nums[month])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 考虑2月份</span></span><br><span class="line">		<span class="type">int</span> leap = (year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>);<span class="comment">// 如果是闰年则leap为1</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">28</span>+leap&lt;day)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 闰月29天</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cin&gt;&gt;str;</span></span><br><span class="line"><span class="comment">//	string s1 = str.substr(0, 2);</span></span><br><span class="line"><span class="comment">//	int aa = stoi(s1);</span></span><br><span class="line"><span class="comment">//	string s2 = str.substr(3, 2);</span></span><br><span class="line"><span class="comment">//	int bb = stoi(s2);</span></span><br><span class="line"><span class="comment">//	string s3 = str.substr(6, 2);</span></span><br><span class="line"><span class="comment">//	int cc = stoi(s3);</span></span><br><span class="line">	<span class="type">int</span> aa, bb, cc;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d/%d/%d&quot;</span>, &amp;aa, &amp;bb, &amp;cc);<span class="comment">// 对于有格式要求的输入输出，使用C语言的输入和输出更加简便 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">19600101</span>; x&lt;=<span class="number">20591231</span>; ++x) &#123; <span class="comment">// 枚举遍历</span></span><br><span class="line">		<span class="type">int</span> year = x/<span class="number">10000</span>, month = x%<span class="number">10000</span>/<span class="number">100</span>, day = x%<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(year, month, day)) &#123;</span><br><span class="line">			<span class="keyword">if</span>( aa==year%<span class="number">100</span>&amp;&amp;bb==month&amp;&amp;cc==day||</span><br><span class="line">				aa==month&amp;&amp;bb==day&amp;&amp;cc==year%<span class="number">100</span>||</span><br><span class="line">				aa==day&amp;&amp;bb==month&amp;&amp;cc==year%<span class="number">100</span> )</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d\n&quot;</span>, year, month, day);<span class="comment">// 格式控制符 %02d 指定每个数值的宽度为2，不足两位则在前面补0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-灌溉">4、灌溉</h3>
<blockquote>
<p>lanqiao551：<a href="https://www.lanqiao.cn/problems/551/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;tags=%E6%9E%9A%E4%B8%BE">灌溉 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日17:07:50</strong></u></p>
<p>tags：枚举</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>采用曼哈顿距离解决本题会非常简单；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 使用曼哈顿距离解决本题会非常简单</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t, k;<span class="comment">// 注意定义变量的时候不要重复了 </span></span><br><span class="line"><span class="type">int</span> r[<span class="number">101</span>], c[<span class="number">101</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i)&#123;<span class="comment">// 初始化位置坐标 </span></span><br><span class="line">		cin&gt;&gt;r[i]&gt;&gt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	<span class="comment">// 找出矩阵中的点与已知点之间的曼哈顿距离 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=t;++l)&#123;</span><br><span class="line">				<span class="type">int</span> d = <span class="built_in">abs</span>(r[l]-i)+<span class="built_in">abs</span>(c[l]-j);<span class="comment">// 求曼哈顿距离 </span></span><br><span class="line">				<span class="keyword">if</span>(d&lt;=k)&#123;<span class="comment">// 如果不大于k，则表明在k分钟内能够灌溉到当前位置 </span></span><br><span class="line">					cnt++;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">// 只要与已知的点有一个满足就行，不然可能会计算重复s </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-火星人">5、火星人</h3>
<blockquote>
<p>lanqiao572：<a href="https://www.lanqiao.cn/problems/572/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E7%81%AB%E6%98%9F%E4%BA%BA">火星人 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日18:16:34</strong></u></p>
<p>tags：排列型枚举</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>本题最关键的就是巧妙的运用<code>next_permutation()</code>的特性，从输入的排列开始继续往后排列M次得到的就是最终的结果；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> order[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;order[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="built_in">next_permutation</span>(order+<span class="number">1</span>, order+<span class="number">1</span>+n);<span class="comment">// 由当前排列往下继续m次就得到了最后改变后的排列结果 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cout&lt;&lt;order[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-日志统计">6、日志统计</h3>
<blockquote>
<p>lanqiao179：<a href="https://www.lanqiao.cn/problems/179/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;tags=%E5%B0%BA%E5%8F%96%E6%B3%95,%E5%B0%BA%E5%8F%96">日志统计 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日22:12</strong></u></p>
<p>tags：尺取</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>首先我们必须根据题意中的区间[T, T+D)，并将该区间作为一个滑动窗口；</p>
</li>
<li class="lvl-3">
<p>为了更好的方便使用滑动窗口，我们必须将输入的ts与id依据ts进行升序排序，这样从第一个ts开始进行区间滑动；滑动的条件是：当h[i].ts&gt;=h[l].ts+D时我们需要将区间的左边界向后移动，这里可以定义<code>l</code>来控制左边界的移动，又ts之间并不是等差变化，因此这里不能使用r来控制右区间的移动，而只能根据区间[T, T+D)来移动左边界。</p>
</li>
<li class="lvl-3">
<p>值得注意的是id是从0开始到100000结束，而不是从1开始的。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N, D, K;</span><br><span class="line"><span class="type">int</span> ts, id;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> ts, id;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(node&amp;a, node&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.ts&lt;b.ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node h[len];</span><br><span class="line"><span class="type">bool</span> ish[len];</span><br><span class="line"><span class="type">int</span> likeNum[len];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	l = <span class="number">1</span>;<span class="comment">// 控制移动窗口的左边界 </span></span><br><span class="line">	cin&gt;&gt;N&gt;&gt;D&gt;&gt;K;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">		cin&gt;&gt;h[i].ts&gt;&gt;h[i].id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(h+<span class="number">1</span>, h+<span class="number">1</span>+N, comp);<span class="comment">// 按照ts进行降序排序 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">		likeNum[h[i].id]++;<span class="comment">// 对应点赞数增加 </span></span><br><span class="line">		<span class="keyword">while</span>(h[i].ts&gt;=h[l].ts+D)likeNum[h[l++].id]--;<span class="comment">// 保证时间在左闭右开区间之内 </span></span><br><span class="line">		<span class="keyword">if</span>(likeNum[h[i].id]&gt;=K)ish[h[i].id] = <span class="literal">true</span>;<span class="comment">// 满足热帖的条件 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1e5</span>;++i)&#123;<span class="comment">// id是从0开始到100000结束 </span></span><br><span class="line">		<span class="keyword">if</span>(ish[i])&#123;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-回文判定">7、回文判定</h3>
<blockquote>
<p>lanqiao1371：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;tags=%E5%B0%BA%E5%8F%96%E6%B3%95,%E5%B0%BA%E5%8F%96">题库 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日</strong></u></p>
<p>tags：尺取</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>本题主要采用双指针反向搜索的方式进行处理；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 回文判定——双指针反向搜索 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> r = s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l == r)cout&lt;&lt;<span class="string">&quot;Y&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[l]!=s[r])&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;N&quot;</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			l++;</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Y&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-第二周</title>
    <url>/2023/06/11/University/Algorithm/7%20questions%20per%20week/%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>算法-第二周</h1>
<blockquote>
<p>一周7题，每日1题。</p>
<p>开始：2023年6月5日（周一）</p>
</blockquote>
<h3 id="p3902-递增">P3902 递增</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P3902">P3902 递增 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>思路：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{思路：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">思路：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>找到LIS的长度，除了LIS中的元素之外的其它元素都需要进行修改；</p>
</li>
<li class="lvl-3">
<p>修改元素为实数，而根据实数的性质可以知道：两个整数之间存在无穷实数；</p>
</li>
<li class="lvl-3">
<p>最后用序列的总数量n减去LIS（最长上升子序列）的长度就是需要修改的最小数量</p>
</li>
</ol>
<p><span style="color: red;">PS：</span>注意洛谷示例数据没有进行详细的解释，题目描述也不清楚。（差评！）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>; </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[N], now;  <span class="comment">// 改为实数，可以为浮点数(这里不用改，只需要知道有多少个元素需要改即可) </span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;now);</span><br><span class="line">		<span class="keyword">if</span>(now&gt;a[cnt])&#123;</span><br><span class="line">			a[++cnt] = now; <span class="comment">// 下标从1开始 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> id = <span class="built_in">lower_bound</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+cnt, now)-a;</span><br><span class="line">			a[id] = now;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n-cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p3130-usaco15dec-counting-haybale-p">P3130 [USACO15DEC] Counting Haybale P</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>[P3130 <a href="https://www.luogu.com.cn/problem/P3130">USACO15DEC] Counting Haybale P - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>思路：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{思路：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">思路：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>线段树解决；</p>
</li>
<li class="lvl-3">
<p>区间修改与区间求和的方法已知，重点是如何得到某一区间的最小值；</p>
<ol>
<li class="lvl-6">求区间的最小值，可以按照区间求和的思路进行实现，只需要将求个改为<code>min()</code>，求最小即可；</li>
<li class="lvl-6">注意需要定义一个对应于<code>d[]数组</code>的<code>Min[]数组</code>来存储最小值元素；</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// P3130 [USACO15DEC] Counting Haybale P</span></span><br><span class="line"><span class="comment">// 区间的操作</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">ll d[<span class="number">4</span>*N], b[<span class="number">4</span>*N], a[N], Min[<span class="number">4</span>*N]; <span class="comment">// 分别为存储：区间总和，懒惰标记，原始序列，叶子结点最小元素 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	d[p] = d[p&lt;&lt;<span class="number">1</span>]+d[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">	Min[p] = <span class="built_in">min</span>(Min[p&lt;&lt;<span class="number">1</span>], Min[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]); <span class="comment">// 维护叶子节点中最小元素 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(b[p]&amp;&amp;s!=t)&#123;</span><br><span class="line">		d[p&lt;&lt;<span class="number">1</span>] += b[p]*(mid-s+<span class="number">1</span>), d[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += b[p]*(t-mid);</span><br><span class="line">		b[p&lt;&lt;<span class="number">1</span>] += b[p], b[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += b[p];</span><br><span class="line">		Min[p&lt;&lt;<span class="number">1</span>] += b[p], Min[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += b[p];</span><br><span class="line">		b[p] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildT</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span></span>&#123; <span class="comment">// p为节点编号，从1开始 </span></span><br><span class="line">	<span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">		d[p] = a[s];</span><br><span class="line">		Min[p] = a[s];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">buildT</span>(s, mid, p&lt;&lt;<span class="number">1</span>), <span class="built_in">buildT</span>(mid+<span class="number">1</span>, t, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateT</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> l, <span class="type">int</span> r, ll c, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=s&amp;&amp;t&lt;=r)&#123;</span><br><span class="line">		d[p] += c*(t-s+<span class="number">1</span>);</span><br><span class="line">		b[p] += c;</span><br><span class="line">		Min[p] += c; <span class="comment">// 每一个叶子结点值都要增加c</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushdown</span>(s, t, p);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">updateT</span>(s, mid, l, r, c, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)<span class="built_in">updateT</span>(mid+<span class="number">1</span>, t, l, r, c, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间求和</span></span><br><span class="line"><span class="function">ll <span class="title">getSum</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=s&amp;&amp;t&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">return</span> d[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushdown</span>(s, t, p);</span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)sum += <span class="built_in">getSum</span>(s, mid, l, r, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)sum += <span class="built_in">getSum</span>(mid+<span class="number">1</span>, t, l, r, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间取最小</span></span><br><span class="line"><span class="function">ll <span class="title">getMin</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=s&amp;&amp;t&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">return</span> Min[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushdown</span>(s, t, p);</span><br><span class="line">	ll ans = INT_MAX;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans = <span class="built_in">getMin</span>(s, mid, l, r, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans = <span class="built_in">min</span>(ans, <span class="built_in">getMin</span>(mid+<span class="number">1</span>, t, l, r, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line">	<span class="type">char</span> op;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	ll k;</span><br><span class="line">	<span class="built_in">buildT</span>(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;M&#x27;</span>)&#123; <span class="comment">// 区间最小值 </span></span><br><span class="line">			cout&lt;&lt;<span class="built_in">getMin</span>(<span class="number">1</span>, n, x, y, <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;S&#x27;</span>)&#123; <span class="comment">// 区间求和 </span></span><br><span class="line">			cout&lt;&lt;<span class="built_in">getSum</span>(<span class="number">1</span>, n, x, y, <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;P&#x27;</span>)&#123; <span class="comment">// 区间修改 </span></span><br><span class="line">			cin&gt;&gt;k;</span><br><span class="line">			<span class="built_in">updateT</span>(<span class="number">1</span>, n, x, y, k, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1421-小玉买文具">P1421 小玉买文具</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1421">P1421 小玉买文具 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ul>
<p>简单的入门题：主要是整除的应用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> pen = <span class="number">19</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cout&lt;&lt;(a*<span class="number">10</span>+b)/pen&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p6184-usaco08oct-building-a-fence-g">P6184 [USACO08OCT]Building A Fence G</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>[P6184 <a href="https://www.luogu.com.cn/problem/P6184">USACO08OCT]Building A Fence G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ul>
<p><em><strong>引理</strong></em><br>
引理：构成四边形条件：任意一边长度小于周长除二。</p>
<p>证明：设四边为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a, b, c, d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span></span></span></span> ，周长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> ，因为有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a&lt;b+c+d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> ，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mi>a</mi><mo>&lt;</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">2 \times a&lt;a+b+c+d=S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> ，所 以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mfrac><mi>S</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a&lt;\frac{S}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><em><strong>动规设计</strong></em><br>
设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 表示切割出了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 块木板，这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 块木板总长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 的方案数。</p>
<p>显然可得方程: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mo>∑</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i, j}=\sum dp_{i-1, j-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>k&lt;=min(j, (n+1)/2-1)</code></p>
</li>
<li class="lvl-2">
<p><code>(n+1)/2-1</code>表示对n/2的向上取整</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line"><span class="comment">//设dp[i][j]表示已经切了i块木板，总长度为j的方案数</span></span><br><span class="line"><span class="comment">//初始化dp[0][0] = 1</span></span><br><span class="line"><span class="comment">//dp[i][j] = dp[i - 1][j - k](1 &lt;= k &lt;= min(j,(n + 1) / 2 - 1)</span></span><br><span class="line"><span class="comment">//k的边界值是为了保证能拼成四边形</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 考虑动态规划解决</span></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="type">int</span> dp[<span class="number">5</span>][<span class="number">2510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化，保证dp[1][1] = 1 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="built_in">min</span>(j, (n+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>);++k)&#123; </span><br><span class="line">				dp[i][j] += dp[i<span class="number">-1</span>][j-k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[<span class="number">4</span>][n]; <span class="comment">// 输出总方案数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1422-小玉家的电费">P1422 小玉家的电费</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1422">https://www.luogu.com.cn/problem/P1422</a></p>
</li>
</ul>
<p>使用C语言的输入输出更方便：printf、scanf；</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>printf：float和double对应的输出都是<code>&quot;%f&quot;</code></p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="type">double</span> fee;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">150</span>)&#123;</span><br><span class="line">		fee = n*<span class="number">0.4463</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">150</span>&amp;&amp;n&lt;=<span class="number">400</span>)&#123;</span><br><span class="line">		fee = <span class="number">150</span>*<span class="number">0.4463</span>;</span><br><span class="line">		fee += (n<span class="number">-150</span>)*<span class="number">0.4663</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">400</span>)&#123;</span><br><span class="line">		fee = <span class="number">150</span>*<span class="number">0.4463</span>+<span class="number">250</span>*<span class="number">0.4663</span>;</span><br><span class="line">		fee += (n<span class="number">-400</span>)*<span class="number">0.5663</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>, fee);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p1071-noip2009-提高组-潜伏者">P1071 [NOIP2009 提高组] 潜伏者</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P1071">https://www.luogu.com.cn/problem/P1071</a></p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><strong>A-Z必须有相应的密字</strong> 不然就输出Failed；</p>
</li>
<li class="lvl-3">
<p>如果<strong>同一个字母的密字重复</strong>了，就输出Failed；</p>
</li>
<li class="lvl-3">
<p><strong>同一个密字不可给多个字母使用</strong>（不同字母之间的密字不同）；</p>
</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;ump, ump2;</span><br><span class="line">string s1, s2, s3; <span class="comment">// 加密信息，加密信息所对应的原信息，要求翻译的加密信息 </span></span><br><span class="line"><span class="comment">// s1,s2的长度一致 </span></span><br><span class="line">string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!ump[s1[i]])&#123; <span class="comment">// 为空 </span></span><br><span class="line">			ump[s1[i]] = s2[i];</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ump[s1[i]]!=s2[i])&#123; <span class="comment">// 不一致：违反不同字母对应不同密字 </span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Failed&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 翻转key,val</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;e:ump)&#123; <span class="comment">// 不同字母之间的密字不同</span></span><br><span class="line">		<span class="keyword">if</span>(!ump2[e.second])&#123;</span><br><span class="line">			ump2[e.second] = e.first;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Failed&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(ump.<span class="built_in">size</span>()!=<span class="number">26</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Failed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 翻译</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s3.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		ans += ump[s3[i]];</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p3374-模板-树状数组-1">P3374 【模板】树状数组 1</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://www.luogu.com.cn/problem/P3374">https://www.luogu.com.cn/problem/P3374</a></p>
</li>
</ul>
<p>树状数组的区间求和：通过前缀和作差实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> n, m, tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123; <span class="comment">// 从左往右跳父节点 </span></span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)&#123; <span class="comment">// x&gt;n时跳出循环 </span></span><br><span class="line">		tree[x] += k;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 从右往左遍历 </span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123; <span class="comment">// x==0时跳出循环 </span></span><br><span class="line">		ans += tree[x];</span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 建树——通过add函数实现</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="built_in">add</span>(i, a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> op, x, y;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">add</span>(x, y);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">getSum</span>(y)-<span class="built_in">getSum</span>(x<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>算法练习</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题2</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%972%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-美丽区间">1、美丽区间</h3>
<blockquote>
<p>lanqiao1372：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;tags=%E5%B0%BA%E5%8F%96%E6%B3%95,%E5%B0%BA%E5%8F%96">题库 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日</strong></u></p>
<p>tags：尺取</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>采用双指针同向搜索的方法处理；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 美丽区间 ——双指针同向搜索 </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, S;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;S;</span><br><span class="line">	<span class="type">int</span> a[n+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1e5</span>;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>;i&lt;=n;)&#123;<span class="comment">// 双指针移动 </span></span><br><span class="line">		<span class="keyword">if</span>(sum&lt;S)&#123;</span><br><span class="line">			sum += a[i];</span><br><span class="line">			++i;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, i-j);</span><br><span class="line">			sum -= a[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans == <span class="number">1e5</span>)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-最少砝码">2、最少砝码</h3>
<blockquote>
<p>lanqiao1461：<a href="https://www.lanqiao.cn/problems/1461/learning/?problem_list_id=4&amp;page=1&amp;sort=students_count">最少砝码 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月29日</strong></u></p>
<p>tags：思维、递推</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>首先，1个砝码最大称到1（砝码重量：1） ； 2个砝码最大称到4（砝码重量：1,3） ；3个砝码最大称到13 ；</p>
</li>
<li class="lvl-3">
<p>推出公式为：新一级的砝码最大称重=上一级砝码上限 × 3 + 1</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;; i++) &#123;</span><br><span class="line">		sum = <span class="number">3</span> * sum + <span class="number">1</span>;<span class="comment">// 递推公式 </span></span><br><span class="line">		<span class="keyword">if</span>(n&lt;=sum) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-路径之谜">3、路径之谜</h3>
<blockquote>
<p>lanqiao-89：<a href="https://www.lanqiao.cn/problems/89/learning/">路径之谜 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月30日21:27:26</strong></u></p>
<p>tags：搜索、dfs</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>逆向思维，每走一步就取该位置处北方和西方靶子上的箭</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 路径之谜——逆向思维，每走一步就取该位置处北方和西方靶子上的箭 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两两组合形成上下左右四个方向</span></span><br><span class="line"><span class="comment">//      1------------------&gt; x</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      ↓</span></span><br><span class="line"><span class="comment">//      y</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> col[N], row[N];<span class="comment">// 前一个数组存储正北方向的靶子，后一个数组存储正西方向的靶子 </span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;res;<span class="comment">// 存储路径坐标 </span></span><br><span class="line"><span class="type">int</span> direct[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">// 存储四个移动方向</span></span><br><span class="line"><span class="type">bool</span> flag[N][N];<span class="comment">// 是否经过 </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==n<span class="number">-1</span>&amp;&amp;y==n<span class="number">-1</span>)&#123;<span class="comment">// 当到达终点位置时，判断靶子是否都没有箭了 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(col[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(row[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 靶子上都没有箭之后进行路径输出</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			<span class="type">int</span> xt = res[i].first;</span><br><span class="line">			<span class="type">int</span> yt = res[i].second;</span><br><span class="line">			<span class="type">int</span> num = yt*n+xt;<span class="comment">// 计算位置编号</span></span><br><span class="line">			cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 终止 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 继续遍历 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">// 判断是否越界 </span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=n||flag[y][x]==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(col[x]&lt;=<span class="number">0</span>||row[y]&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 靶子没箭了，但是没走到终点位置 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">check</span>(x, y))<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> xt, yt;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">			xt = direct[i]+x,yt = direct[i+<span class="number">1</span>]+y;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pd</span>(xt, yt))&#123;<span class="comment">// 判断是否越界 </span></span><br><span class="line">				flag[yt][xt]=<span class="number">1</span>;</span><br><span class="line">				res.<span class="built_in">push_back</span>(&#123;xt, yt&#125;);</span><br><span class="line">				col[xt]--;</span><br><span class="line">				row[yt]--;</span><br><span class="line">				<span class="built_in">dfs</span>(xt, yt);</span><br><span class="line">				flag[yt][xt]=<span class="number">0</span>;</span><br><span class="line">				res.<span class="built_in">pop_back</span>();</span><br><span class="line">				col[xt]++;</span><br><span class="line">				row[yt]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)cin&gt;&gt;col[i];<span class="comment">// 北方靶子 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)cin&gt;&gt;row[i];<span class="comment">// 西方靶子 </span></span><br><span class="line">	flag[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// 初始化入口(起点位置)</span></span><br><span class="line">	res.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	col[<span class="number">0</span>]--;</span><br><span class="line">	row[<span class="number">0</span>]--;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 深度优先搜索 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-n皇后问题">4、N皇后问题</h3>
<blockquote>
<p>lanqiao-1508：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;name=N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">N皇后问题 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月30日</strong></u></p>
<p>tags：搜索、dfs、回溯</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>N皇后问题使用回溯法解决；</p>
</li>
<li class="lvl-3">
<p>关键是要正确表示左右斜线；（左斜线：k=i+j；右斜线：k=i-j+N-1）</p>
</li>
<li class="lvl-3">
<p>在每次放置皇后的时候必须保证当前位置的同一行（这里不用定义数组，直接根据递归回溯来限制同一行只能有一个皇后）、同一列（定义bool型的col[N]）以及左右斜线上（定义bool型R[2 * N],L[2 * N]）没有放置过皇后；</p>
</li>
<li class="lvl-3">
<p>每放置一个位置<code>M[i][j]</code>就更新对应的<code>col[j],R[i-j+N-1],L[i+j]</code>。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> counts = <span class="number">0</span>;<span class="comment">// 计数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">N_queens</span><span class="params">(<span class="type">int</span> i, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;M, <span class="type">int</span> col[], <span class="type">int</span> L[], <span class="type">int</span> R[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; N;++j)&#123;<span class="comment">// 遍历每一行的位置 </span></span><br><span class="line">		<span class="keyword">if</span>(!col[j]&amp;&amp;!R[i-j+N<span class="number">-1</span>]&amp;&amp;!L[i+j])&#123;<span class="comment">// 可放置 </span></span><br><span class="line">			M[i][j] = i+<span class="number">1</span>;<span class="comment">// 放置皇后 </span></span><br><span class="line">			col[j] = L[i+j] = R[i-j+N<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i == N<span class="number">-1</span>)&#123;</span><br><span class="line">				counts++;<span class="comment">// 放置方法加1 </span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">N_queens</span>(i+<span class="number">1</span>, M, col, L, R);</span><br><span class="line">			&#125;</span><br><span class="line">			M[i][j] = <span class="number">0</span>;<span class="comment">// 回溯-去皇后 </span></span><br><span class="line">			col[j] = L[i+j] = R[i-j+N<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">M</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N, <span class="number">0</span>));<span class="comment">// 采用int M[N][N]，不方便给函数传参，这里要用vector动态数组 </span></span><br><span class="line">	<span class="type">int</span> col[N]=&#123;<span class="number">0</span>&#125;, L[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;, R[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;;<span class="comment">// 1则表明存储皇后 </span></span><br><span class="line"><span class="comment">//	count = 0;// 计数 </span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">N_queens</span>(<span class="number">0</span>, M, col, L, R);</span><br><span class="line">	cout&lt;&lt;n;<span class="comment">// 可行解数量 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-长草">5、长草</h3>
<blockquote>
<p>lanqiao-149：<a href="https://www.lanqiao.cn/problems/149/learning/">长草 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月31日</strong></u></p>
<p>tags：搜索、bfs、曼哈顿距离</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>草地每个月往外扩张一次；</p>
</li>
<li class="lvl-3">
<p>经典的bfs问题；</p>
</li>
<li class="lvl-3">
<p>尝试使用曼哈顿距离解决本题——更快速。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 长草</span></span><br><span class="line"><span class="comment">// 每个月往外扩张一次</span></span><br><span class="line"><span class="comment">// 尝试曼哈顿距离解决本题——更快速</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">vector&lt;PII&gt;vec;<span class="comment">// 存储长草的位置</span></span><br><span class="line"><span class="type">bool</span> isg[N][N];<span class="comment">// 存储是否长草</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">			cin&gt;&gt;ch;</span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;g&#x27;</span>) &#123;</span><br><span class="line">				vec.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">				isg[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!isg[i][j]) &#123; <span class="comment">// (i,j)位置还没长草</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>; l&lt;vec.<span class="built_in">size</span>(); ++l) &#123;</span><br><span class="line">					PII p = vec[l];<span class="comment">// 遍历当前已经长草的位置坐标</span></span><br><span class="line">					<span class="type">int</span> x = p.first;</span><br><span class="line">					<span class="type">int</span> y = p.second;</span><br><span class="line">					<span class="type">int</span> d = <span class="built_in">abs</span>(x-i) + <span class="built_in">abs</span>(y-j);<span class="comment">// 曼哈顿距离 </span></span><br><span class="line">					<span class="keyword">if</span>(d&lt;=k) &#123;</span><br><span class="line">						isg[i][j] = <span class="number">1</span>;<span class="comment">// 在k月内必定会长草 </span></span><br><span class="line">						<span class="keyword">break</span>;<span class="comment">// 没必要再看其它已经长草位置与(i,j)位置的曼哈顿距离 </span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;k;</span></span><br><span class="line">	<span class="type">char</span> tmp_c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(isg[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">				tmp_c = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				tmp_c = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;tmp_c;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bfs解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 长草——bfs </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">queue&lt;PII&gt;qu; <span class="comment">// 队列</span></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">bool</span> isg[N][N];<span class="comment">// 标记是否长草 </span></span><br><span class="line"><span class="type">int</span> direc[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">// 方位数组 </span></span><br><span class="line"><span class="type">int</span> len;<span class="comment">// 控制当前层队列长度，每一次将当前层的多有元素扩展之后就执行k-- </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">// 边界判断 </span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=m)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">			cin&gt;&gt;ch;</span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">&#x27;g&#x27;</span>) &#123;</span><br><span class="line">				qu.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">				isg[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	len = qu.<span class="built_in">size</span>();</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;!qu.<span class="built_in">empty</span>())&#123;<span class="comment">// k次循环并且队列不为空 </span></span><br><span class="line">		PII p = qu.<span class="built_in">front</span>();</span><br><span class="line">		qu.<span class="built_in">pop</span>();<span class="comment">// 去除首个元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;<span class="comment">// 四个方向 </span></span><br><span class="line">			<span class="type">int</span> x = p.first + direc[i];<span class="comment">// 控制行 </span></span><br><span class="line">			<span class="type">int</span> y = p.second + direc[i+<span class="number">1</span>];<span class="comment">// 控制列 </span></span><br><span class="line">			<span class="keyword">if</span>(isg[x][y]!=<span class="number">1</span>&amp;&amp;<span class="built_in">pd</span>(x, y))&#123;</span><br><span class="line">				isg[x][y] = <span class="number">1</span>;</span><br><span class="line">				qu.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		len--;<span class="comment">// 当前层的元素数量-1 </span></span><br><span class="line">		<span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">			k--;<span class="comment">// 一个月过去了 </span></span><br><span class="line">			len = qu.<span class="built_in">size</span>();<span class="comment">// 更新下一层的草块个数 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> tmp_c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(isg[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">				tmp_c = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				tmp_c = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;tmp_c;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-走迷宫">6、走迷宫</h3>
<blockquote>
<p>lanqiao-1216：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=886525&amp;compatibility=false">走迷宫 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年3月31日</strong></u></p>
<p>tags：搜索、bfs</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>典型的bfs解法，当到达终点时即结束搜索（用到一个check函数）；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 走迷宫 </span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">int</span> G[N][N];<span class="comment">// 网格迷宫</span></span><br><span class="line"><span class="type">int</span> direc[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125;; </span><br><span class="line">node startNode;<span class="comment">// 起点 </span></span><br><span class="line"><span class="comment">//int x1, y1;</span></span><br><span class="line"><span class="type">int</span> x2, y2;<span class="comment">// 终点 </span></span><br><span class="line"><span class="type">int</span> visit[N][N];<span class="comment">// 标记已经访问过的位置并存储从起点开始的距离</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line">queue&lt;PII&gt;qu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m||visit[x][y]!=<span class="number">0</span>||G[x][y]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==x2&amp;&amp;y==y2)&#123;<span class="comment">// 到达终点坐标 </span></span><br><span class="line">		ans = visit[x][y];<span class="comment">// 距离</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">// 广度优先搜索 </span></span><br><span class="line">	<span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		PII p = qu.<span class="built_in">front</span>();</span><br><span class="line">		qu.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">			<span class="type">int</span> x = p.first + direc[i];</span><br><span class="line">			<span class="type">int</span> y = p.second + direc[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pd</span>(x, y))&#123;<span class="comment">// 满足在矩阵内，没有访问过，可以通过 </span></span><br><span class="line">				visit[x][y] = visit[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line">				qu.<span class="built_in">push</span>(&#123;x, y&#125;); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(x, y))&#123;<span class="comment">// 到达终点——结束 </span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">			cin&gt;&gt;G[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;startNode.x&gt;&gt;startNode.y&gt;&gt;x2&gt;&gt;y2;<span class="comment">// 起点与终点 </span></span><br><span class="line">	qu.<span class="built_in">push</span>(&#123;startNode.x, startNode.y&#125;);</span><br><span class="line">	visit[startNode.x][startNode.y] = <span class="number">1</span>;<span class="comment">// 最后输出答案时减1即可</span></span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">0</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		cout&lt;&lt;ans<span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-合根植物">7、合根植物</h3>
<blockquote>
<p>lanqiao-110：<a href="https://www.lanqiao.cn/problems/110/learning/">合根植物 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月1日22:36:15</strong></u></p>
<p>tags：并查集</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>利用并查集的存储、查询以及合并操作处理输入，最后通过遍历parent数组判断有多少个根节点就能够知道有多少合根植物。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> m, n, k;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> parent[K];<span class="comment">// 存储父节点 </span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 并查集查询函数 </span></span><br><span class="line">	<span class="keyword">if</span>(x!=parent[x])&#123;<span class="comment">// 不是根节点 </span></span><br><span class="line">		parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parent[x]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(rootX!=rootY)&#123;</span><br><span class="line">		parent[rootX] = rootY;<span class="comment">// 合并，以rootY为根节点 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m*n;++i)&#123;</span><br><span class="line">		parent[i] = i;<span class="comment">// 初始化父节点为本身，即为根节点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">unionSet</span>(a, b);<span class="comment">// 合根 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m*n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==parent[i])&#123;<span class="comment">// 判断为根节点 </span></span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题3</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%973%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-跳石头">1、跳石头</h3>
<blockquote>
<p>lanqiao-364：<a href="https://www.lanqiao.cn/problems/364/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E8%B7%B3%E7%9F%B3%E5%A4%B4">跳石头 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月1日23:43:05</strong></u></p>
<p>tags：二分法</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>注意题目中的至多移走m块石头，那么当移走的石头越多，那么最短跳跃距离就越大，反之则越小；</p>
</li>
<li class="lvl-3">
<p>所以我们必须保证小于m而尽可能大于接近于m，<mark>实质是</mark>在所有可能的最小值中，找最大的那个，就是“最小值最大化”</p>
</li>
<li class="lvl-3">
<p>所以应该求得是：在单调递增序列d中查找&lt;=x的数中最大的一个（即x或x的前趋）；</p>
</li>
<li class="lvl-3">
<p>这里<mark>转换成了</mark>由当前d得到的可以移动的石头数量num与至多可以移动的数量m之间的比较。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> len, n, m;<span class="comment">// 分别为起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数 </span></span><br><span class="line"><span class="type">int</span> stone[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;<span class="comment">// 验证最短跳跃距离d是否满足条件 </span></span><br><span class="line">	<span class="type">int</span> pos = <span class="number">0</span>;<span class="comment">// 当前位置 </span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;<span class="comment">// 移去石头的数量 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(stone[i] - pos &lt; d)&#123;</span><br><span class="line">			num++;<span class="comment">// 符合要求可以去掉石头 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			pos = stone[i];<span class="comment">// 更新当前位置，表示的是在前一个[pos,pos+d]内已经去除了最多的石头数 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(num&lt;=m)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 满足至多移去m个石头 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;len&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;stone[i];<span class="comment">// 初始化石头到起点的距离 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前趋）</span></span><br><span class="line">	<span class="type">int</span> L = <span class="number">0</span>, R = len;</span><br><span class="line">	<span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">		<span class="type">int</span> mid = (L + R + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;<span class="comment">// 如果成立，那么表明当前的mid小了点，应该增大 </span></span><br><span class="line">			L = mid;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;		<span class="comment">// 否则表明当前的mid大了点，应该减小  </span></span><br><span class="line">			R = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;L;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-完全背包问题">2、完全背包问题</h3>
<blockquote>
<p>AcW-3：<a href="https://www.acwing.com/problem/content/3/">3. 完全背包问题 - AcWing题库</a></p>
<p><u><strong>完成时间：2023年4月2日</strong></u></p>
<p>tags：动态规划、背包问题</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>每种物品都有无限件可用；</p>
</li>
<li class="lvl-3">
<p>普通做法（采用二维数组）；</p>
</li>
<li class="lvl-3">
<p>空间压缩（采用一维数组、对容量顺序遍历）；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 完全背包问题 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N], v[N], w[N];<span class="comment">// v体积，w价值 </span></span><br><span class="line"><span class="type">int</span> n, V, res;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">	&#125;</span><br><span class="line">	res = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;++i)&#123;</span></span><br><span class="line"><span class="comment">//		for(int j=0;j&lt;=V;++j)&#123;</span></span><br><span class="line"><span class="comment">//			dp[i][j] = dp[i-1][j];</span></span><br><span class="line"><span class="comment">//			if(j&gt;=v[i])&#123;</span></span><br><span class="line"><span class="comment">//				dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i]);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			res = max(res, dp[i][j]);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//空间压缩</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;++j)&#123;<span class="comment">// 完全背包问题顺序遍历 </span></span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i])&#123;</span><br><span class="line">				f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]]+w[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;res;</span></span><br><span class="line">	cout&lt;&lt;f[V];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-多重背包问题-i">3、多重背包问题 I</h3>
<blockquote>
<p>AcW-4：<a href="https://www.acwing.com/problem/content/4/">4. 多重背包问题 I - AcWing题库</a></p>
<p><u><strong>完成时间：2023年4月2日</strong></u></p>
<p>tags：动态规划、背包问题</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>转换为01背包问题解决；</p>
</li>
<li class="lvl-3">
<p>在01背包的基础上添加数量条件限制（注意：状态转移方程有些许不同——<code>dp[i][j] = max(dp[i][j], dp[i-1][j-k*v[i]]+k*w[i]),k必须从0开始</code>）；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 多重背包问题 ——添加附加数量限制条件 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N], v[N], w[N], s[N];<span class="comment">// v体积，w价值，s数量 </span></span><br><span class="line"><span class="type">int</span> n, V;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;++j)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i];++k)&#123;<span class="comment">// 这里的k必须从0开始,k=0时有dp[i-1][j] </span></span><br><span class="line">				<span class="keyword">if</span>(j&gt;=k*v[i])&#123;</span><br><span class="line">					dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);<span class="comment">// 在01-背包问题的基础上作次数限制 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//空间压缩</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;++i)&#123;</span></span><br><span class="line"><span class="comment">//		for(int j=V;j&gt;=v[i];--j)&#123;</span></span><br><span class="line"><span class="comment">//			for(int k=1;k*v[i]&lt;=j&amp;&amp;k&lt;=s[i];++k)&#123;</span></span><br><span class="line"><span class="comment">//				f[j] = max(f[j], f[j-k*v[i]]+k*w[i]);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	cout&lt;&lt;dp[n][V];</span><br><span class="line"><span class="comment">//	cout&lt;&lt;f[V];</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-快乐司机">4、 快乐司机</h3>
<blockquote>
<p>lanqiao-1513：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=886638&amp;compatibility=false">第十四届蓝桥杯省赛冲刺营【第二期】 - 【课后练习】快乐司机 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月3日</strong></u></p>
<p>tags：贪心算法</p>
</blockquote>
<p>【题目描述】话说现在当司机光有红心不行，还要多拉快跑。多拉不是超载，是要让所载货物价值最大，特别是在当前油价日新月异的时候。司机所拉货物为<mark>散货</mark>，如大米、面粉、沙石、泥土⋯现在知道了汽车核载重量为w，可供选择的物品的数量n。每个物品的重量为gi, 价值为pi。求汽车可装载的最大价值。（n&lt;10000,w&lt;10000,0&lt;gi≤100,0≤pi≤100)。</p>
<p>【输入描述】输入第一行为由空格分开的两个整数n,w。第二行到第n+1行，每行有两个整数，由空格分开，分别表示gi和pi。</p>
<p>【输出描述】最大价值（保留一位小数）。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>因为所拉货物为<mark>散货</mark>，因此可以装一部分，由此我们需要计算每种货物的单位价值（pi/gi）；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">double</span> v, w, scale;<span class="comment">// 分别为价值、重量、单位价值 </span></span><br><span class="line">&#125;; </span><br><span class="line">node product[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> W;</span><br><span class="line"><span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(node&amp;a, node&amp;b)</span></span>&#123;<span class="comment">// 降序排序 </span></span><br><span class="line">	<span class="keyword">return</span> a.scale&gt;b.scale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;W;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;product[i].w&gt;&gt;product[i].v;</span><br><span class="line">		product[i].scale = product[i].v/product[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(product+<span class="number">1</span>, product+<span class="number">1</span>+n, comp);<span class="comment">// 针对scale排序 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(W&gt;=product[i].w)&#123;</span><br><span class="line">			res += product[i].v;<span class="comment">// 价值增加 </span></span><br><span class="line">			W -= product[i].w;<span class="comment">// 重量减少 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			res += W*product[i].scale;<span class="comment">// 剩余重量与单位价值之积 </span></span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">// 结束 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-防御力">5、防御力</h3>
<blockquote>
<p>lanqiao-226：<a href="https://www.lanqiao.cn/problems/226/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E9%98%B2%E5%BE%A1%E5%8A%9B">防御力 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月3日</strong></u></p>
<p>tags：贪心算法</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>要求字典序最小的使用道具的方式；</p>
</li>
<li class="lvl-3">
<p>根据分析知道A从小到大排序，B从大到小排序；</p>
</li>
<li class="lvl-3">
<p>PS：这道题编码简单，但是<mark>为什么是这样做的值得认真思考和证明！</mark></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 根据分析知道A从小到大排序，B从大到小排序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1, n2;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> delta;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;A;</span><br><span class="line">vector&lt;node&gt;B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp1</span><span class="params">(node &amp;a, node &amp;b)</span></span>&#123;<span class="comment">// 升序排序 </span></span><br><span class="line">	<span class="keyword">if</span>(a.delta!=b.delta)<span class="keyword">return</span> a.delta&lt;b.delta;<span class="comment">// 优先根据增值排序，再根据字典序排序 </span></span><br><span class="line">	<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp2</span><span class="params">(node &amp;a, node &amp;b)</span></span>&#123;<span class="comment">// 降序排序 </span></span><br><span class="line">	<span class="keyword">if</span>(a.delta!=b.delta)<span class="keyword">return</span> a.delta&gt;b.delta;<span class="comment">// 优先根据增值排序，再根据字典序排序 </span></span><br><span class="line">	<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)&#123;</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		cin&gt;&gt;tmp, A.<span class="built_in">push_back</span>(&#123;i, tmp&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)&#123;</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		cin&gt;&gt;tmp, B.<span class="built_in">push_back</span>(&#123;i, tmp&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), comp1);<span class="comment">// 升序排序 </span></span><br><span class="line">	<span class="built_in">sort</span>(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), comp2);<span class="comment">// 降序排序 </span></span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> indexA = <span class="number">0</span>, indexB = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;B[indexB++].id&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;A[indexA++].id&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;E&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-最少硬币问题">6、最少硬币问题</h3>
<blockquote>
<p>题目：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230403212121650.png" alt="image-20230403212121650" style="zoom:50%;" />
<p><u><strong>完成时间：2023年4月3日</strong></u></p>
<p>tags：动态规划</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>状态转移方程：<code>dp[j] = min(dp[j], dp[j-price[i]]+1);</code></p>
</li>
<li class="lvl-3">
<p>别忘了初始化dp[0] = 0；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">// 输入支付的金额 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;price = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>, INT_MAX);<span class="comment">// 动规求最小值</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=price[i];j&lt;=n;++j)&#123;</span><br><span class="line">			dp[j] = <span class="built_in">min</span>(dp[j], dp[j-price[i]]+<span class="number">1</span>);<span class="comment">// 求最小硬币数量 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">solve</span>(n);</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-小明的背包-1">7、小明的背包 1</h3>
<blockquote>
<p>lanqiao-1174：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=893781&amp;compatibility=false">第十四届蓝桥杯省赛冲刺营【第二期】 - 【课后练习】小明的背包 1 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月3日</strong></u></p>
<p>tags：动态规划、01-背包问题</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>经典的01-背包问题；</p>
</li>
<li class="lvl-3">
<p>采用滚动数组进行空间压缩时需要注意重量j从大到小遍历；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;<span class="comment">// V&lt;=1000</span></span><br><span class="line"><span class="type">int</span> n, V;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;n;++i)cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;// dp默认初始化为全0 </span></span><br><span class="line">	<span class="type">int</span> w, v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;w&gt;&gt;v;<span class="comment">// 分别为体积和价值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=w;--j)&#123;</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w]+v); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[V];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题4</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%974%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-装箱问题">1、装箱问题</h3>
<blockquote>
<p>lanqiao-763：<a href="https://www.lanqiao.cn/problems/763/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98">装箱问题 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月3日</strong></u></p>
<p>tags：动态规划、线性DP 01-背包简化版</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>使得剩余的空间最小，那么就是要装的体积要最大；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 装箱问题——01-背包简化版（即w=v） </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> V, n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">31</span>];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;V&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];--j)&#123;<span class="comment">// 空间压缩：自我滚动 </span></span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]]+v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;V-dp[V];<span class="comment">// 箱子剩余的空间大小 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-01-背包的方案数">2、01-背包的方案数</h3>
<blockquote>
<p>lanqiao-2186：<a href="https://www.lanqiao.cn/problems/2186/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name">01-背包的方案数 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月3日</strong></u></p>
<p>tags：动态规划、01-背包的方案数</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><code>dp[i][j][k]</code>分别为前i个数选择了j个数，并且这j个数的和为k；</p>
</li>
<li class="lvl-3">
<pre><code class="language-cpp">- 定义dp[][][]：dp[i][j][k]表示数字1~i取j个，和为k的方案数。
- 下面的分析沿用标准0/1背包的分析方法。
- 从i~1扩展到i，分两种情况：
（1）k≥i。数i可以要，也可以不要。
	要i。从1~i-1中取j-1个数，再取i，等价于dp[i-1][j-1][k-i]。
	不要i。从1~i-1中取j个数，等价于dp[i-1][j][k]
      合起来：dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k-i]
（2）k&lt;i。由于数i比总和k还大，显然i不能用。有：dp[i][j][k] = dp[i-1][j][k]

1~i个数 选0个和为0的情况只有一种那就是不选
for(int i=0;i&lt;=2022;i++)    dp[i][0][0]=1;   //特别注意这个初始化
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 思考：为什么 `dp[i][j&gt;0][0]` 不初始化为1呢？为什么 `dp[i][0][j&gt;0]` 不初始化为1呢？</span><br><span class="line"></span><br><span class="line">4. 使用自滚动数组进行空间压缩时j必须从大到小。</span><br><span class="line"></span><br><span class="line">解决代码：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 01-背包的方案数</span><br><span class="line">using ll = long long;</span><br><span class="line">ll dp[2222][11][2222];// dp[i][j][k]分别为前i个数选择了j个数，并且这j个数的和为k </span><br><span class="line">int n = 2022; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	// 初始化</span><br><span class="line">	for(int i=0;i&lt;=2022;++i)dp[i][0][0] = 1; // 1~i个数 选0个和为0的情况只有一种那就是不选</span><br><span class="line">	for(int i=1;i&lt;=2022;++i)&#123;// 必须是正整数 </span><br><span class="line">		for(int j=1;j&lt;=10;++j)&#123;</span><br><span class="line">			for(int k=1;k&lt;=2022;++k)&#123;</span><br><span class="line">				dp[i][j][k] = dp[i-1][j][k];</span><br><span class="line">				if(k&gt;=i)&#123;// k是当前需要的总和，如果k比1~i中的i还大的话，那么就可以选i或者也可不选 </span><br><span class="line">					dp[i][j][k] = dp[i][j][k]+dp[i-1][j-1][k-i];// 将两种请况合起来 </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;dp[2022][10][2022];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*空间压缩：自滚动数组*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 01-背包的方案数</span><br><span class="line">using ll = long long;</span><br><span class="line">ll dp[11][2222];// dp[i][j][k]分别为前i个数选择了j个数，并且这j个数的和为k </span><br><span class="line">int n = 2022; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	// 初始化</span><br><span class="line">	dp[0][0] = 1; // 1~i个数 选0个和为0的情况只有一种那就是不选</span><br><span class="line">	for(int i=1;i&lt;=2022;++i)&#123;// 必须是正整数 </span><br><span class="line">		for(int j=10;j&gt;=1;--j)&#123;// j必须从大的开始</span><br><span class="line">			for(int k=i;k&lt;=2022;++k)&#123;// 这里直接满足了k&gt;=i的条件 </span><br><span class="line">				dp[j][k] = dp[j][k]+dp[j-1][k-i];// 将两种请况合起来 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;dp[10][2022];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ol>
<h3 id="3-过河卒">3、过河卒</h3>
<blockquote>
<p>lanqiao-755：<a href="https://www.lanqiao.cn/problems/755/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name">过河卒 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月3日</strong></u></p>
<p>tags：动态规划、网格图上的DP</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><strong><u>采用标数法；</u></strong></p>
</li>
<li class="lvl-3">
<p>统计路径条数，看起来是个搜索题，可以用DFS求解。把马的控制点标记为不能走，绕过它们。不过，用DFS搜索的路径数量是天文数字，肯定超时。</p>
</li>
<li class="lvl-3">
<p>在小学上过奥数的都知道，这题应该用“标数法”，就是在每个坐标点上记录能走的路径条数。</p>
</li>
<li class="lvl-3">
<p>标数法实际上就是DP的递推。</p>
</li>
<li class="lvl-3">
<p>定义状态dp[][]：<code>dp[i][j]</code>表示卒走到坐标(i, j)时能走的路径条数。</p>
</li>
<li class="lvl-3">
<p>如果不考虑马的控制点，有： <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</code>也就是(i, j)点的路径条数等于它上面和左边的路径条数之和。这就是小学奥数的“标数法”的原理。</p>
</li>
<li class="lvl-3">
<p>本题的限制条件是马的控制点，只要令控制点的<code>dp[i][j] = 0</code>即可，即这个点上无路径。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230403235438365.png" alt="image-20230403235438365" style="zoom: 33%;" />
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 过河卒——网格图上的DP </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> xb, yb, xh, yh;<span class="comment">// 分别表示 B 点坐标和马的坐标</span></span><br><span class="line">ll dp[<span class="number">25</span>][<span class="number">25</span>];<span class="comment">// 注意不要数组溢出了 </span></span><br><span class="line"><span class="type">bool</span> control[<span class="number">25</span>][<span class="number">25</span>];<span class="comment">// 标记控制点，如果为1，则为控制点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;xb&gt;&gt;yb&gt;&gt;xh&gt;&gt;yh;</span><br><span class="line">	<span class="type">int</span> bx = xb + <span class="number">2</span>, by = yb + <span class="number">2</span>, hx = xh + <span class="number">2</span>, hy = yh + <span class="number">2</span>;<span class="comment">// 全部坐标+2防止马向左或上跳2格导致数组越界</span></span><br><span class="line">	control[hx][hy]=<span class="number">1</span>;<span class="comment">// 标记马的控制点</span></span><br><span class="line">	control[hx<span class="number">-2</span>][hy<span class="number">-1</span>] = <span class="number">1</span>, control[hx<span class="number">-1</span>][hy<span class="number">-2</span>] = <span class="number">1</span>, control[hx+<span class="number">1</span>][hy<span class="number">-2</span>] = <span class="number">1</span>, control[hx+<span class="number">2</span>][hy<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">	control[hx+<span class="number">2</span>][hy+<span class="number">1</span>] = <span class="number">1</span>, control[hx+<span class="number">1</span>][hy+<span class="number">2</span>] = <span class="number">1</span>, control[hx<span class="number">-1</span>][hy+<span class="number">2</span>] = <span class="number">1</span>, control[hx<span class="number">-2</span>][hy+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">// 初始化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=bx;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=by;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(control[i][j])dp[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[bx][by];</span><br><span class="line"><span class="comment">//	printf(&quot;%lld&quot;, dp[bx][by]);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-小明的背包-2">4、小明的背包 2</h3>
<blockquote>
<p>lanqiao-1175：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=893782&amp;compatibility=false">第十四届蓝桥杯省赛冲刺营【第二期】 - 【课后练习】小明的背包 2 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：动态规划、完全背包</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>自滚动数组进行空间压缩时，j从小到大（区别于01-背包问题）；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 完全背包问题 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, V;</span><br><span class="line"><span class="type">int</span> dp[N];<span class="comment">// 自滚动数组 </span></span><br><span class="line"><span class="type">int</span> w, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;w&gt;&gt;v;<span class="comment">// 体积、价值 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=w;j&lt;=V;++j)&#123;</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w]+v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[V];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-最长公共子序列">5、最长公共子序列</h3>
<blockquote>
<p>lanqiao-1189：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=893783&amp;compatibility=false">第十四届蓝桥杯省赛冲刺营【第二期】 - 【课后练习】最长公共子序列 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：动态规划</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>分解为2种情况：</p>
<p>（1）当ai = bj时，已求得Ai-1和Bj-1的最长公共子序列，在其尾部加上ai 或bj即可得到Ai和Bj的最长公共子序列。 状态转移方程： <code>dp[i][j] = dp[i-1][j-1] + 1</code></p>
<p>（2）当ai ≠ bj时，求解两个子问题： Ai-1和Bj的最长公共子序列；Ai和Bj-1的最长公共子序列。取最大值，状态转移方程： <code>dp[i][j] = max&#123;dp[i][j-1], dp[i-1][j]&#125;</code></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 最长公共子序列</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[j])dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]+<span class="number">1</span>;<span class="comment">// 取dp[i+1][j+1]，而不是dp[i][j]是因为(i,j)从0开始,防止数组越界 </span></span><br><span class="line">			<span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-蓝桥勇士">6、蓝桥勇士</h3>
<blockquote>
<p>lanqiao-1175：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=893784&amp;compatibility=false">第十四届蓝桥杯省赛冲刺营【第二期】 - 【课后练习】蓝桥勇士 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：动态规划、LIS</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>经典的C++问题——最长上升子序列（LIS）；</p>
</li>
<li class="lvl-3">
<p>最初始状态的长度都为1；</p>
</li>
<li class="lvl-3">
<p>定义dp[i]为以a[i]为结尾的最长上升子序列的长度。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 最长递增子序列 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dp[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">// 初始化 </span></span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		dp[i] = <span class="number">1</span>;<span class="comment">// 最初长度都为1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">				dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="built_in">max</span>(res, dp[i]);<span class="comment">// 存储最大长度，最答长度不一定在dp[n] </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-快速幂">7、快速幂</h3>
<blockquote>
<p>lanqiao-1514：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=886970&amp;compatibility=false">快速幂 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230404195345951.png" alt="image-20230404195345951"></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：简单数论</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230404191246938.png" alt="image-20230404191246938"></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll b, p, k;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fastPow</span><span class="params">(ll b, ll p, ll k)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	b %= k; <span class="comment">// 防止下方res*b越界 </span></span><br><span class="line">	<span class="keyword">while</span>(p)&#123;<span class="comment">// p为次数 </span></span><br><span class="line">		<span class="keyword">if</span>(p&amp;<span class="number">1</span>)res = (res*b)%k;</span><br><span class="line">		b = b*b%k;<span class="comment">// 对应于a^1,a^2,a^3…… 其中的指数代表的是n二进制中第几位的1（如：1011）</span></span><br><span class="line">		p = p&gt;&gt;<span class="number">1</span>;<span class="comment">// 右移一位 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;b&gt;&gt;p&gt;&gt;k;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">fastPow</span>(b, p, k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题6</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%976%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-分解质因数">1、分解质因数</h3>
<blockquote>
<p>lanqiao-1559：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=894710&amp;compatibility=false">分解质因数 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：简单数论、质因数分解</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405021119535.png" alt="image-20230405021119535"></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 分解质因数</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">20</span>];  <span class="comment">//p[]记录因子，p[1]是最小因子。一个int数的质因子最多有10几个</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">40</span>];  <span class="comment">//c[i]记录第i个因子的个数。一个因子的个数最多有30几个 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFactor</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;<span class="comment">// i为n因子 </span></span><br><span class="line">			p[++m] = i, c[m] = <span class="number">0</span>;<span class="comment">// 存储第m个因子以及其个数 </span></span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">				n /= i,c[m]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;<span class="comment">// 剩下的整数 </span></span><br><span class="line">		p[++m] = n, c[m] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=b;++i)&#123;</span><br><span class="line">		<span class="type">int</span> m = <span class="built_in">getFactor</span>(i);</span><br><span class="line">		cout&lt;&lt;i&lt;&lt;<span class="string">&quot;=&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;++k)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[k];++j)&#123;</span><br><span class="line">				cout&lt;&lt;p[k];</span><br><span class="line">				<span class="keyword">if</span>(j&lt;c[k])cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(k&lt;m)cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-最少砝码">2、最少砝码</h3>
<blockquote>
<p>lanqiao-1461：<a href="https://www.lanqiao.cn/problems/1461/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1461">最少砝码 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：思维训练、找规律</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405105822797.png" alt="image-20230405105822797"></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 最少砝码 </span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> R, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;N)&#123;</span><br><span class="line">		R = <span class="number">3</span>*R+<span class="number">1</span>;<span class="comment">// 推导出的公式 </span></span><br><span class="line">		cnt++; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-砍竹子">3、砍竹子</h3>
<blockquote>
<p>lanqiao-2117：<a href="https://www.lanqiao.cn/problems/2117/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=2117">砍竹子 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：思维训练、找规律</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>正解：思维。这样计算最少砍刀数：</p>
<p>（1）首先计算最多砍多少刀，计算每棵竹子砍到1需要多少刀，所有竹子砍数相加得到一个总数，记为ans；</p>
<p>（2）记录每棵竹子每次被砍后的新高度；</p>
<p>（3）比较<mark>任意两个相邻</mark>的竹子，它们是否有相同的高度，如果有相同的高度，这两棵竹子接下来可以一起砍，从而少砍一刀，ans减一；</p>
<p>（4）比较结束后，ans就是答案。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 砍竹子 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll total = <span class="number">0</span>;<span class="comment">// 存储对所有竹子一棵一棵的砍的总次数</span></span><br><span class="line">ll cnt = <span class="number">0</span>;<span class="comment">// 记录少砍多少刀</span></span><br><span class="line">ll x;<span class="comment">// 输入竹子的高度</span></span><br><span class="line">unordered_set&lt;ll&gt;h[N]; <span class="comment">// 定义了一个类型为set的数组，即h[i]就是一个set </span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sqr</span><span class="params">(ll n)</span></span>&#123;<span class="comment">// 由于数据过大时使用sqrt会出现误差 </span></span><br><span class="line">	ll x = <span class="built_in">sqrt</span>(n);<span class="comment">// 由于精度问题进行调整 </span></span><br><span class="line">	<span class="keyword">if</span>((x+<span class="number">1</span>)*(x+<span class="number">1</span>)&lt;=n)x = x+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x*x&gt;n)x = x<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		<span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;<span class="comment">// 竹子高度大于1时 </span></span><br><span class="line">			total++;</span><br><span class="line">			<span class="keyword">if</span>(h[i<span class="number">-1</span>].<span class="built_in">count</span>(x))cnt++;<span class="comment">// 必须保证是连续的具有相同高度的竹子</span></span><br><span class="line">			h[i].<span class="built_in">insert</span>(x);<span class="comment">// 存储当前第i个竹子的多个高度情况 </span></span><br><span class="line">			x = <span class="built_in">sqr</span>(x/<span class="number">2</span>+<span class="number">1</span>);<span class="comment">// 砍一刀之后剩下的高度 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;total-cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-排列小球">4、排列小球</h3>
<blockquote>
<p>lanqiao-546：<a href="https://www.lanqiao.cn/problems/546/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=546">排列小球 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：思维训练、dfs</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>初步看题可知为枚举各种颜色小球的数量，来实现递增序列，故确定思路为<mark>dfs</mark>.</p>
</li>
<li class="lvl-3">
<p>我们应该如何枚举小球呢？可以利用递增条件，<u><strong>记录上一次枚举的数量，下一次枚举需要大于这个数量</strong></u>；</p>
</li>
<li class="lvl-3">
<p><code>dfs(sum,x,last)</code>表示还需要sum个球中，前面选了颜色为last色的，x个球；</p>
</li>
<li class="lvl-3">
<p>如果接着再选j个颜色为i的，为<code>dfs(sum-j,j,i)</code>；</p>
</li>
<li class="lvl-3">
<p>递归边界所有球都用完，方案数加一。dfs过程中需要注意两个问题：</p>
<pre><code> （1）当前选的小球和上次选的小球颜色相同，则跳过。

 （2）每次枚举递增数量的小球。
</code></pre>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 排列小球</span></span><br><span class="line"><span class="type">int</span> nums[<span class="number">3</span>];<span class="comment">// 存储R,G,B的个数</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, total = <span class="number">0</span>;<span class="comment">// 分别为方案数、小球总数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> x, <span class="type">int</span> color)</span></span>&#123;<span class="comment">// 深度优先搜索 </span></span><br><span class="line">	<span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">		++res;<span class="comment">// 方案数+1 </span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==color)<span class="keyword">continue</span>;<span class="comment">// 颜色相同则换另一种颜色的球</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=x+<span class="number">1</span>;j&lt;=nums[i];++j)&#123;<span class="comment">// j从上一个颜色的球的个数+1开始遍历(球的数量递增) </span></span><br><span class="line">			nums[i] -= j;</span><br><span class="line">			<span class="keyword">if</span>(sum&gt;=j)<span class="built_in">dfs</span>(sum-j, j, i);</span><br><span class="line">			nums[i] += j;<span class="comment">// 恢复现场 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">		cin&gt;&gt;nums[i];</span><br><span class="line">		total += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(total, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-lcis">5、LCIS</h3>
<blockquote>
<p>lanqiao-1190：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1190">LCIS - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：思维训练、LCS、LIS</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>这题是动态规划问题经典问题</p>
<p>在动态规划中，最长公共子序列（LCS）与最长上升子序列（LIS）是基础的线性DP,本题要求求出两个不等长序列的最长公共上升子序列。</p>
<p>本体解法就是在最长公共子序列上找一遍最长上升子序列即可。</p>
<p>求解最长公共子序列，也就是在判断a[i] = = b[j]的前提下，再求出上升序列；</p>
<p><code>dp[i][j]</code>代表所有a[1 ~ i]和b[1 ~ j]中以b[j]结尾的公共上升子序列的集合；</p>
<p><code>dp[i][j]</code>的值等于该集合的子序列中长度的最大值；</p>
</li>
<li class="lvl-3">
<p><strong><u>状态方程</u></strong>：</p>
<p>对于当处于(a[i], b[j]) 状态时 ,由于dp状态就决定了，b[j]是一定作为这个状态下LICS的结尾的，所以对于a[i]，就有两种情况，将其纳入LCIS或者不纳入，首先先说不把a[i]纳入LCIS的情况：</p>
<p>（1）若是 a[i] != b[j] ，显然是一定不能讲a[i]与b[j]进行配对的，那么问题就缩小成了a的前i - 1个字符与b的前j个字符且以b[j]结尾的LCIS，即dp[i - 1, j]也就是说 ，i之前的以b[j]结尾的序列自然没有改变，长度仍然是<code>dp[i−1][j]</code>; 若是a[i] == b[i] 如果不想要a[i]与b[j]进行配对，是不是也会得到上面的结果，故当不想a[i]与b[j]配对(或无法配对)时，dp[i, j] = dp[i - 1, j]</p>
<p>（2）当a[i] == b[j]且它们进行配对时，就要在a串前i - 1个字符和b的前j - 1个字符中找到一个最长的序列，设这个序列以k结尾且b[k] &lt; b[j]，就等价于<code>dp[i][j]=max(dp[i - 1, k]) + 1</code></p>
<p>最后再遍历一边<code>dp[n][1~m]</code>，找出其中最大值即可。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// LCIS ——在求LCS的过程中求LIS </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2010</span>], b[<span class="number">2010</span>], dp[<span class="number">2010</span>][<span class="number">2010</span>];<span class="comment">// dp[i][j]代表所有a[1 ~ i]和b[1 ~ j]中以b[j]结尾的公共上升子序列的集合</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[j])&#123;<span class="comment">// 匹配 </span></span><br><span class="line">				dp[i][j] = <span class="number">1</span>;<span class="comment">// 表示初始的上升序列都是1 </span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;j;++k)&#123;</span><br><span class="line">					<span class="keyword">if</span>(b[k]&lt;b[j])&#123;</span><br><span class="line">						dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][k]+<span class="number">1</span>, dp[i][j]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">// 不匹配 </span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">		res = <span class="built_in">max</span>(res, dp[n][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-蓝桥公园">6、蓝桥公园</h3>
<blockquote>
<p>lanqiao-1121：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1121">蓝桥公园- 蓝桥云课 (lanqiao.cn)</a></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405163054608.png" alt="image-20230405163054608"  />
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：图论、Floyd算法</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>在代码中，0x3f经常被用作一个特殊的数值，比如在动态规划中，可以将dp数组初始化为0x3f，表示还没有任何状态值被更新过，相当于无限大的意思。(0x3f的十进制数为63)</p>
</li>
<li class="lvl-3">
<p><code>const long long INF = 0x3f3f3f3f3f3f3f3fLL;  //这样定义INF的好处是: INF &lt;= INF+x 防止溢出</code></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 蓝桥公园 </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;<span class="comment">// 这样定义INF的好处是: INF &lt;= INF+x 防止溢出</span></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">ll w;</span><br><span class="line"><span class="type">int</span> st, ed;</span><br><span class="line">ll dp[<span class="number">405</span>][<span class="number">405</span>];<span class="comment">// dp[i][j]:从i到j的距离 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;<span class="comment">// Floyd算法 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)&#123;<span class="comment">// k必须在最外循环层 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k]+dp[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));<span class="comment">// 初始化, 0x3f在这里指代INF</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;<span class="comment">// 存储图 </span></span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		dp[u][v] = dp[v][u] = <span class="built_in">min</span>(dp[u][v], w);<span class="comment">// 避免重边 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">floyd</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">		cin&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">		<span class="keyword">if</span>(dp[st][ed]==INF)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;<span class="comment">// 不可达 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(st==ed)cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;	<span class="comment">// 确保dp[i][i]=0（符合逻辑） </span></span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;dp[st][ed]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-蓝桥王国">7、蓝桥王国</h3>
<blockquote>
<p>lanqiao-1121：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1122">蓝桥王国 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230405171822310.png" alt="image-20230405171822310"></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：图论、Dijkstra算法</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>维护两个集合：已确定最短路径的结点集合A、这些结点向外扩散的邻居结点集合B。</p>
<p>（1）把起点s放到A中，把s所有的邻居放到B中。此时，邻居到s的距离就是直连距离。</p>
<p>（2）从B中找出距离起点s最短的结点u，放到A中。</p>
<p>（3）把u所有的新邻居放到B中。显然，u的每一条边都连接了一个邻居，每个新邻居都要加进去。其中u的一个新邻居v，它到s的距离dis(s, v)等于dis(s, u) + dis(u, v)。</p>
<p>（4）重复(2)、(3)，直到B为空时，结束。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 蓝桥王国 ——Dijkstra算法 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;<span class="comment">// 定义INF，并且保证了INF&lt;=INF+x，防止溢出</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> from, to;<span class="comment">// 起点，终点 ,起点from并没有用到，eg[i]的i就是from</span></span><br><span class="line">	ll w;<span class="comment">// 权重(距离) </span></span><br><span class="line">	<span class="built_in">edge</span>(<span class="type">int</span> a, <span class="type">int</span> b, ll c)&#123;</span><br><span class="line">		from = a;</span><br><span class="line">		to = b;</span><br><span class="line">		w = c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s_node</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;ll n_dis;<span class="comment">// 点id，当前点到起点的距离</span></span><br><span class="line">	<span class="built_in">s_node</span>(<span class="type">int</span> a, ll b)&#123;</span><br><span class="line">		id = a;</span><br><span class="line">		n_dis = b;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> s_node&amp;a)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n_dis&gt;a.n_dis;<span class="comment">// 实现优先队列根据n_dis升序排序？？？ </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;edge&gt;eg[N];<span class="comment">// 存储图——相当于是一个二维数组 </span></span><br><span class="line">ll dis[N];<span class="comment">// 存储点i到起点的距离</span></span><br><span class="line"><span class="type">bool</span> done[N];<span class="comment">// true标记已经找到了最短路径 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*_______________需要打印路径时加上以下代码____________________*/</span></span><br><span class="line"><span class="type">int</span> pre[N];<span class="comment">// 存储当前结点的前一结点，方便打印路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_path</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;<span class="comment">// 打印从s到t的最短路</span></span><br><span class="line">	<span class="keyword">if</span>(s==t)&#123;<span class="comment">// 打印起点</span></span><br><span class="line">		cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print_path</span>(s, pre[t]);<span class="comment">// 先打印前一个点</span></span><br><span class="line">	cout&lt;&lt;t&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">// 后打印当前点。最后打印的是终点t</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*____________________________________________________________*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;<span class="comment">// Dijkstra算法 </span></span><br><span class="line">	<span class="type">int</span> s = <span class="number">1</span>;<span class="comment">// 起点id </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		dis[i] = INF;<span class="comment">// 初始化距离为无穷大 </span></span><br><span class="line">		done[i] = <span class="literal">false</span>; <span class="comment">// 初始都为找到最短路径 </span></span><br><span class="line">	&#125;</span><br><span class="line">	dis[s] = <span class="number">0</span>;<span class="comment">// 起点到自己本身的距离为0 </span></span><br><span class="line">	priority_queue&lt;s_node&gt;Q;<span class="comment">// 优先队列存储新邻居结点——默认大顶堆 </span></span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="built_in">s_node</span>(s, dis[s]));<span class="comment">// 将起点存储到其中 </span></span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		s_node u = Q.<span class="built_in">top</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(done[u.id])<span class="keyword">continue</span>;<span class="comment">// 如果已经找到了，就跳过继续往下 </span></span><br><span class="line">		done[u.id] = <span class="literal">true</span>;<span class="comment">// 标记找到最短路径 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;eg[u.id].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			edge y = eg[u.id][i];<span class="comment">// 得到当前点u与其临界点之间的边 </span></span><br><span class="line">			<span class="keyword">if</span>(done[y.to])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[y.to]&gt;y.w+u.n_dis)&#123;</span><br><span class="line">				dis[y.to] = y.w+u.n_dis;<span class="comment">// 更新最短距离 </span></span><br><span class="line">				Q.<span class="built_in">push</span>(<span class="built_in">s_node</span>(y.to, dis[y.to]));<span class="comment">// 增加新邻居结点 </span></span><br><span class="line">				<span class="comment">//pre[y.to] = u.id;// 如果有需要，记录路径</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//print_path(s, n);// 如果有需要，打印路径: 起点1，终点n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)eg[i].<span class="built_in">clear</span>();<span class="comment">// 清除可能存在的元素 </span></span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		eg[u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(u, v, w));<span class="comment">// 单向，如果是双向，则再怎加eg[v].push_back()即可 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">dijkstra</span>();<span class="comment">// 调用Dijkstra算法 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">// 1~n个点 </span></span><br><span class="line">		<span class="keyword">if</span>(dis[i]&gt;=INF)cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题5</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%975%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-rsa解密">1、RSA解密</h3>
<blockquote>
<p>lanqiao-603：<a href="https://www.lanqiao.cn/problems/603/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=RSA%E8%A7%A3%E5%AF%86">RSA解密 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：简单数论</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>实质是快速幂问题，但是由于涉及到的数据太大，因此采用python解决，c++处理的话必须使用<code>__int128</code>类型；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lanqiao-603-附</span></span><br><span class="line">n = <span class="number">1001733993063167141</span></span><br><span class="line">d = <span class="number">212353</span></span><br><span class="line">c = <span class="number">20190324</span></span><br><span class="line">p = <span class="number">891234941</span></span><br><span class="line">q = <span class="number">1123984201</span></span><br><span class="line">temp = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">now = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">    now = i*temp+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(now%d==<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(now//d)<span class="comment"># 输出e</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速幂计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fastPow</span>(<span class="params">a, n, mod</span>):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    a %= mod</span><br><span class="line">    <span class="keyword">while</span>(n):</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>):res = (res*a)%mod</span><br><span class="line">        a = a*a%mod</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="built_in">print</span>(fastPow(c, now//d, n))</span><br></pre></td></tr></table></figure>
<h3 id="2-核桃的数量">2、核桃的数量</h3>
<blockquote>
<p>lanqiao-210：<a href="https://www.lanqiao.cn/problems/210/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E6%A0%B8%E6%A1%83%E7%9A%84%E6%95%B0%E9%87%8F">核桃的数量 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：简单数论、LCM</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>简单题，直接求最小公倍数即可；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 核桃的数量 </span></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a/__gcd(a, b)*b;<span class="comment">// 相除后乘，防止先乘导致溢出	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">	<span class="type">int</span> k = <span class="built_in">lcm</span>(a, b);</span><br><span class="line">	cout&lt;&lt;<span class="built_in">lcm</span>(k, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-hankson-的趣味题">3、Hankson 的趣味题</h3>
<blockquote>
<p>lanqiao-520：<a href="https://www.lanqiao.cn/problems/520/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=520">Hankson 的趣味题 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：简单数论、LCM、GCD</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>若x是b1的因子，有 x*y = b1，y也可能是答案。</p>
</li>
<li class="lvl-3">
<p>只需要在范围x&lt;=sqrt(b1)内查询，同时判断y就行了。</p>
</li>
<li class="lvl-3">
<p>但还是超时，因为gcd计算也要花时间，加上一个优化：<code>if(b1%x==0)</code>，表示b1是x的公倍数。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Hankson 的趣味题</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll a0, a1, b0, b1;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a/__gcd(a, b)*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a0&gt;&gt;a1&gt;&gt;b0&gt;&gt;b1;</span><br><span class="line">		ll ans = <span class="number">0</span>;<span class="comment">// 记录满足条件的个数 </span></span><br><span class="line">		<span class="keyword">for</span>(ll x=<span class="number">1</span>;x&lt;=<span class="built_in">sqrt</span>(b1);++x)&#123;<span class="comment">// b1一定比a1要大 </span></span><br><span class="line">			<span class="keyword">if</span>(b1%x==<span class="number">0</span>)&#123;<span class="comment">// 确保x能整除b1 </span></span><br><span class="line">				<span class="keyword">if</span>(__gcd(x, a0)==a1&amp;&amp;<span class="built_in">lcm</span>(x, b0)==b1)ans++;</span><br><span class="line">				ll y = b1/x;</span><br><span class="line">				<span class="keyword">if</span>(x==y)<span class="keyword">continue</span>;<span class="comment">// 相等，则不能重复计算</span></span><br><span class="line">				<span class="keyword">if</span>(__gcd(y, a0)==a1&amp;&amp;<span class="built_in">lcm</span>(y, b0)==b1)ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-寻找整数">4、寻找整数</h3>
<blockquote>
<p>lanqiao-2131：<a href="https://www.lanqiao.cn/problems/2131/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=2131">寻找整数 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月4日</strong></u></p>
<p>tags：简单数论、LCM</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230404235737258.png" alt="image-20230404235737258"></p>
</li>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230404235754817.png" alt="image-20230404235754817"></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 寻找整数</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> mod[N] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">16</span>,<span class="number">29</span>,<span class="number">27</span>,<span class="number">25</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">4</span>,<span class="number">29</span>,<span class="number">22</span>,<span class="number">37</span>,<span class="number">23</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">33</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">41</span>,<span class="number">46</span>&#125;;</span><br><span class="line">ll ans = <span class="number">2</span> + mod[<span class="number">2</span>]; <span class="comment">// 初始目标正整数为3，满足3%2=1 </span></span><br><span class="line">ll k = <span class="number">2</span>;<span class="comment">// 以第一个数作为第一个步长 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">3</span>;a&lt;N;++a)&#123;<span class="comment">// a为除数 </span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans%a==mod[a])&#123;<span class="comment">// 如果当前得到的目标正整数ans能够除a余mod[a]，则表明ans=a*index+mod[a]，满足条件 </span></span><br><span class="line">				k = k/__gcd(k, <span class="built_in">ll</span>(a))*a;<span class="comment">// 求新的步长 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				ans += k;<span class="comment">// 根据当前步长改变目标正整数ans的值 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-笨小猴">5、笨小猴</h3>
<blockquote>
<p>lanqiao-527：<a href="https://www.lanqiao.cn/problems/527/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=527">笨小猴 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：简单数论、素数（质数）判断</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>关键就是质数的判断</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">// 判断是否为质数 </span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 有因子，不是质数 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxn = INT_MIN, minn = INT_MAX;</span><br><span class="line"><span class="type">int</span> letter[<span class="number">26</span>];<span class="comment">// 存储每个字母出现的次数</span></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)letter[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(letter[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(letter[i]&gt;maxn)maxn = letter[i];</span><br><span class="line">		<span class="keyword">if</span>(letter[i]&lt;minn)minn = letter[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(len == maxn)minn = <span class="number">0</span>;<span class="comment">// 考虑边界情况 </span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;maxn&lt;&lt;&quot; &quot;&lt;&lt;minn&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">isPrime</span>(maxn-minn))&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;No Answer&quot;</span>&lt;&lt;endl&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Lucky Word&quot;</span>&lt;&lt;endl&lt;&lt;maxn-minn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-最大最小公倍数">6、最大最小公倍数</h3>
<blockquote>
<p>lanqiao-1510：<a href="https://www.lanqiao.cn/courses/18397/learning/?id=894709&amp;compatibility=false">最大最小公倍数 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：简单数论、相邻数、互质</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>最小的公倍数是三个数的质因数相乘，如果有几个质因数相同，则比较两数中哪个数的质因数的个数较多。例如6、7、8的最小公倍数，先分解因子：6=2×3，7=7×1，8=2×2×2，它们的最小公倍数是3×7×2×2×2。</p>
<p>大于1的两个相邻整数互质，它们没有公共的质因数。<mark>如果题目是任选二个数，最大的最小公倍数是N*(N-1)</mark>。</p>
</li>
<li class="lvl-3">
<p>对于连续的三个整数，分两种情况：</p>
<p>（1）N是奇数。N、N-1、N-2是奇偶奇，结论是这三个数两两互质，三个数的乘积就是最大的最小公倍数。三个数两两互质，也就是说任意一个质数，只在N、N-1、N-2中出现一次。逐个分析质数：</p>
<p>​     质因数2，只在N-1中出现。</p>
<p>​     质因数3，如果在N中出现（设N = 3a），就不会在N-1中出现（这要求N-1 = 3b，无解），也不会在N-2中出现（这要求N-2 = 3b，无解）。</p>
<p>推广到任何一个质数k，都只会在N、N-1、N-2中出现一次，所以三个数互质。</p>
<p>（2）N是偶数。</p>
<p>​	如果N为偶数，那么N与N-2最大公约数为2，所以我们要找下一个质数，此时需要考虑N与N-3的关系：</p>
<p>​	如果N能被3整除，则N-3也能被3整除，此时N与N-3不互质，但是N-1与N-3必然互质（N-1、N-3都为奇数），所以N-1、  N-2、N-3；</p>
<p>​	如果N不能被3整除，则N-3也不能被3整除，此时N与N-3互质，所以选择N、N-1、N-3。</p>
</li>
<li class="lvl-3">
<p><strong><u>注意是从相邻的3个数开始考虑的</u></strong></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 最大最小公倍数</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n; </span><br><span class="line">ll ans;<span class="comment">// 最大的最小公倍数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)ans = n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>);<span class="comment">// n为奇数	奇偶奇 </span></span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">// n为偶数,n-2也为偶数,因此不考虑,转而继续考虑n-3，依次类推 </span></span><br><span class="line">		<span class="comment">// n 与 n-3比较 </span></span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">1</span>)ans = n*(n<span class="number">-1</span>)*(n<span class="number">-3</span>);<span class="comment">// 偶奇奇 </span></span><br><span class="line">		<span class="keyword">else</span> ans = (n<span class="number">-1</span>)*(n<span class="number">-2</span>)*(n<span class="number">-3</span>);<span class="comment">// 奇偶奇	n能被3整除，则(n-3)也能被3整除且为奇数 </span></span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-质数">7、质数</h3>
<blockquote>
<p>lanqiao-1557：<a href="https://www.lanqiao.cn/problems/1557/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1557">质数 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：简单数论、质数筛</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>本题实质就是质数筛的使用；</p>
</li>
<li class="lvl-3">
<p>当数据不是很大时可以采用埃氏筛；如果数据较多，则需要使用欧拉筛（线性筛取，避免重复筛取）。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 筛选质数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> prime[N], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> bPrime[N]; <span class="comment">// true表示的是非质数 ,表示被筛掉 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(bPrime, <span class="literal">false</span>, <span class="built_in">sizeof</span>(bPrime));<span class="comment">// 默认均未被筛掉 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!bPrime[i])prime[cnt++] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;++j)&#123;<span class="comment">// 线性筛取，避免重复，提升效率 </span></span><br><span class="line">			bPrime[i*prime[j]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">getPrime</span>(n<span class="number">-1</span>);<span class="comment">// 题目要求不包含n本身 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;++i)&#123;</span><br><span class="line">		cout&lt;&lt;prime[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题7</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%977%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-随机数据下的最短路问题">1、随机数据下的最短路问题</h3>
<blockquote>
<p>lanqiao-1366：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1366">随机数据下的最短路问题 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月5日</strong></u></p>
<p>tags：图论、SPFA算法</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>（1）起点s入队，计算它所有邻居到s的最短距离。把s出队，状态有更新的邻居入队，没更新的不入队。</p>
<p>（2）现在队列的头部是s的一个邻居u。弹出u，更新它所有邻居的状态，把其中有状态变化的邻居入队列。</p>
<p>（3）继续以上过程，直到队列空。这也意味着，所有结点的状态都不再更新。最后的状态就是到起点s的最短路径。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 随机数据下的最短路问题</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;<span class="comment">// 目标点(终点) </span></span><br><span class="line">	ll w;<span class="comment">// 权重 </span></span><br><span class="line">	<span class="built_in">edge</span>(<span class="type">int</span> tt, ll ww)&#123;</span><br><span class="line">		to = tt;</span><br><span class="line">		w = ww;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">vector&lt;edge&gt;eg[N];</span><br><span class="line"><span class="type">int</span> inq[N];<span class="comment">// 标记点i在队列中</span></span><br><span class="line">ll dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;<span class="comment">// s为起点 </span></span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));<span class="comment">// 0x3f等价于INF</span></span><br><span class="line">	dist[s] = <span class="number">0</span>;<span class="comment">// 起点到自己的距离是0</span></span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);<span class="comment">// 从s开始，s进队列</span></span><br><span class="line">	inq[s] = <span class="number">1</span>;<span class="comment">// s在队列中 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		inq[u] = <span class="number">0</span>;<span class="comment">// u不在队列中 </span></span><br><span class="line">		<span class="keyword">if</span>(dist[u]==INF)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;eg[u].<span class="built_in">size</span>();++i)&#123;<span class="comment">// 遍历邻居结点 </span></span><br><span class="line">			<span class="type">int</span> v = eg[u][i].to;</span><br><span class="line">			ll w = eg[u][i].w;</span><br><span class="line">			<span class="keyword">if</span>(dist[v]&gt;dist[u]+w)&#123;<span class="comment">// u的第i个邻居v，它借道u，到s更近</span></span><br><span class="line">				dist[v] = dist[u]+w;<span class="comment">// 更新邻居v到s的距离</span></span><br><span class="line">				<span class="keyword">if</span>(!inq[v])&#123;<span class="comment">// 邻居v更新状态了，但v不在队列中，放进队列</span></span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					inq[v] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> a, b;ll c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<span class="comment">// a就是起点，v就是终点 </span></span><br><span class="line">		eg[a].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(b, c));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">spfa</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">// 点从1~n </span></span><br><span class="line">		<span class="keyword">if</span>(dist[i]==INF)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;dist[i]&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-聪明的猴子">2、聪明的猴子</h3>
<blockquote>
<p>lanqiao-862：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=862">聪明的猴子 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：图论、Kruskal算法、并查集、MST（最小生成树）</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>对边进行排序。</p>
</li>
<li class="lvl-3">
<p>判断圈，即处理连通性问题。这个问题用<mark>并查集</mark>简单而高效，并查集是kruskal算法的绝配。</p>
</li>
<li class="lvl-3">
<p><span style="color: red;">以下代码能够通过示例数据，但是不能AC？？？</span></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 聪明的猴子——Kruskal算法与并查集得到最小生成树 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u, v;<span class="comment">// 起点与终点 </span></span><br><span class="line">	<span class="type">double</span> w;<span class="comment">// 两点之间的距离 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">edge eg[N];</span><br><span class="line"><span class="type">int</span> monkey[NN], x[N], y[N];<span class="comment">// 分别为猴子的跳跃能力、树的x坐标与y坐标(方便求两树之间的距离w) </span></span><br><span class="line"><span class="type">int</span> parent[N];<span class="comment">// 存储结点的父节点，并查集</span></span><br><span class="line"><span class="type">int</span> m, n; <span class="comment">// 猴子的个数、树的棵树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(edge a, edge b)</span></span>&#123;<span class="comment">// 根据w升序排序 </span></span><br><span class="line">	<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 查找根节点 </span></span><br><span class="line">	<span class="keyword">if</span>(x!=parent[x])&#123;</span><br><span class="line">		parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parent[x];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">// 合并集合——连接x与y的根节点 </span></span><br><span class="line">	<span class="type">int</span> xx = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> yy = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(xx!=yy)parent[yy] = xx;<span class="comment">// yy为新的根节点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)cin&gt;&gt;monkey[i];</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 构建图结构</span></span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)&#123;<span class="comment">// 避免重复计算距离 </span></span><br><span class="line">			<span class="type">double</span> w = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((x[i]-x[j]), <span class="number">2</span>)+<span class="built_in">pow</span>((y[i]-y[j]), <span class="number">2</span>));<span class="comment">// 计算距离</span></span><br><span class="line">			eg[++cnt] = &#123;i, j, w&#125;;<span class="comment">// 初始化边数组 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">sort</span>(eg+<span class="number">1</span>, eg+<span class="number">1</span>+cnt, comp);<span class="comment">// 按照边权重升序排序 </span></span><br><span class="line">	<span class="comment">// 计算最小生成树以及MST中的最大边权重 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		parent[i] = i;<span class="comment">// 初始化根节点为本身 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;<span class="comment">// 存储最小生成树中结点的个数 </span></span><br><span class="line">	<span class="type">double</span> maxE = <span class="number">0.0</span>;<span class="comment">// 存储MST中边权重的最大值 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;<span class="comment">// 遍历所有的边edge </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(eg[i].u)!=<span class="built_in">find</span>(eg[i].v))&#123;<span class="comment">// 两个结点不具有相同的根节点 </span></span><br><span class="line">			<span class="built_in">merge</span>(eg[i].u, eg[i].v);<span class="comment">// 合并</span></span><br><span class="line">			num++;<span class="comment">// 结点数量增加</span></span><br><span class="line">			maxE = maxE&gt;=eg[i].w?maxE:eg[i].w;<span class="comment">// 更新MST中边的最大权重 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(num==n<span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">// n个结点组成MST之后只有n-1条边 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(monkey[i]&gt;=maxE)ans++;<span class="comment">// 满足要求的猴子数量+1 </span></span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-统计数字">3、统计数字</h3>
<blockquote>
<p>lanqiao-535：<a href="https://www.lanqiao.cn/problems/535/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=535">统计数字 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：排序进阶</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>突出map容器的使用，合理利用map容器的性质；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 统计数字 </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">map&lt;ll, <span class="type">int</span>&gt;h;<span class="comment">//存储(自然数，个数) </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	ll tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;tmp;</span><br><span class="line">		h[tmp]++;<span class="comment">// 计算相同自然数的个数，map自动根据key进行升序排序 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:h)&#123;</span><br><span class="line">		cout&lt;&lt;e.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;e.second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-错误票据">4、错误票据</h3>
<blockquote>
<p>lanqiao-205：<a href="https://www.lanqiao.cn/problems/205/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=205">错误票据 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：排序进阶</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>很简单，根据题意直接计算即可；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 错误票据</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans1, ans2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line"><span class="comment">//	while(scanf(&quot;%d&quot;, &amp;a[cnt])!=EOF)cnt++;</span></span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;a[cnt])cnt++;</span><br><span class="line">	<span class="built_in">sort</span>(a, a+cnt);<span class="comment">// 升序排序</span></span><br><span class="line">	<span class="comment">// 查找断号与重号</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cnt;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]&gt;<span class="number">1</span>)ans1 = a[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])ans2 = a[i];</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-奖学金">5、奖学金</h3>
<blockquote>
<p>lanqiao-531：<a href="https://www.lanqiao.cn/problems/531/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=531">奖学金 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：排序进阶</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>主要是排序规则的自定义；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 奖学金</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;<span class="comment">// 学号 </span></span><br><span class="line">	<span class="type">int</span> sum;</span><br><span class="line">	<span class="type">int</span> Chinese;<span class="comment">// 语文 </span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> stu&amp;a)<span class="type">const</span>&#123;<span class="comment">// 重载&lt;号，sort排序基于的就是&lt; </span></span><br><span class="line">		<span class="keyword">if</span>(sum==a.sum)&#123;</span><br><span class="line">			<span class="keyword">if</span>(Chinese==a.Chinese)&#123;</span><br><span class="line">				<span class="keyword">return</span> id&lt;a.id;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> Chinese&gt;a.Chinese;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum&gt;a.sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">stu stu[<span class="number">310</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> x, y, z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">		stu[i] = &#123;i, (x+y+z), x&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(stu+<span class="number">1</span>, stu+<span class="number">1</span>+n); <span class="comment">// 按照规则排序 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)&#123;<span class="comment">// 输出前5名 </span></span><br><span class="line">		cout&lt;&lt;stu[i].id&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;stu[i].sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-排列序数">6、排列序数</h3>
<blockquote>
<p>lanqiao-269：<a href="https://www.lanqiao.cn/problems/269/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E6%8E%92%E5%88%97%E5%BA%8F">排列序数 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：枚举、排列</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>next_permutation的使用；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str, tmp;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;str;</span><br><span class="line">	tmp = str;<span class="comment">// tmp存储目标排列 </span></span><br><span class="line">	<span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());<span class="comment">// 先得到最初的排列 </span></span><br><span class="line">	<span class="keyword">while</span>(tmp!=str)&#123;</span><br><span class="line">		<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-付账问题">7、付账问题</h3>
<blockquote>
<p>lanqiao-174：<a href="https://www.lanqiao.cn/problems/174/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=174">付账问题 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：枚举、排列</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>贪心法：</p>
<ol>
<li class="lvl-6">准备贪心：先将花费数组从小到大排序</li>
<li class="lvl-6">贪心策略：
<ul class="lvl-4">
<li class="lvl-8">从数组最小的元素开始，每次做判断</li>
<li class="lvl-8">若当前元素小于剩余花费平均值，则取该元素不改变值，将平均成本转嫁到后续元素上</li>
<li class="lvl-8">若当前元素大于等于剩余花费平均值，则后续元素也大于该平均值，能够承接前较小元素的成 本，将当前元素之后的所有元素取剩余花费平均值</li>
</ul>
</li>
<li class="lvl-6">结束贪心，解出标准差</li>
</ol>
</li>
<li class="lvl-3">
<p>精确度：</p>
<p>本题对于精确度要求较高，总结如下提升准确度的方法：</p>
<ol>
<li class="lvl-6">
<p>long long提升整数的准确度</p>
</li>
<li class="lvl-6">
<p>double可以承接18位左右有效数字</p>
</li>
<li class="lvl-6">
<p>尽量减少除法，转换成乘法</p>
</li>
<li class="lvl-6">
<p>尽量减少会导致误差的计算的次数</p>
</li>
</ol>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//  付账问题——尽量避免使用除法导致误差累积(转为使用乘法)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll S;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;S;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n);<span class="comment">// 升序排序 </span></span><br><span class="line">	<span class="type">double</span> sum = <span class="number">0</span>;<span class="comment">// 方差</span></span><br><span class="line">	<span class="type">double</span> avg = <span class="number">1.0</span>*S/n;<span class="comment">// 总平均值</span></span><br><span class="line">	<span class="comment">// 贪心算法开始 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]*(n-i+<span class="number">1</span>)&lt;S)&#123;<span class="comment">// 第i个人的钱不能够达到还差金额S与剩下人数(n-i+1)的平均值 </span></span><br><span class="line">			sum += (a[i]-avg)*(a[i]-avg);</span><br><span class="line">			S -= a[i];<span class="comment">// 更新还差金额 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">// 第i个人的钱能达到剩下平均值,证明后面的人都可以不用付完自己的全部钱了 </span></span><br><span class="line">			<span class="type">double</span> cur_avg = <span class="number">1.0</span>*S/(n-i+<span class="number">1</span>);<span class="comment">// 每人只需要付还差的金额S分摊到余下人身上的平均值那么多钱即可</span></span><br><span class="line">			sum += (cur_avg-avg)*(cur_avg-avg)*(n-i+<span class="number">1</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.4f&quot;</span>, <span class="built_in">sqrt</span>(sum/n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题9</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%979%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-小蓝吃糖果">1、小蓝吃糖果</h3>
<blockquote>
<p>lanqiao-1624：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1624">小蓝吃糖果 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：鸽笼定理（抽屉定理）</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>鸽巢原理，用“隔板法”求解。</p>
</li>
<li class="lvl-3">
<p>最多的一种糖果，把它的数量K看成K个隔板，隔成K个空间（把每个隔板的右边看成一个空间）；其它所有糖果的数量为S。</p>
<p>（1）如果S &lt; K-1，把S个糖果放到隔板之间，这K个隔板不够放，必然至少有2个隔板之间没有糖果，由于这2个隔板是同一种糖果，所以无解。</p>
<p>（2）S ≥ K-1时，肯定有解。其中一个解是：把S个糖果排成一个长队，其中同种类的糖果是挨在一起的，然后每次取K个糖果，按顺序一个一个地放进K个空间。由于隔板数量比每一种糖果的数量都多，所以不可能有2个同样的糖果被放进一个空间里。把S个糖果放完，就是一个解，一些隔板里面可能放好几种糖果。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1005000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Max=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sum += a[i];              <span class="comment">//所有糖果数量</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;Max)  Max=a[i];   <span class="comment">//最多的一种糖果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum-Max+<span class="number">1</span>&gt;=Max) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>               <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-杨辉三角形">2、杨辉三角形</h3>
<blockquote>
<p>lanqiao-1457：<a href="https://www.lanqiao.cn/problems/1457/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1457">杨辉三角形 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月7日</strong></u></p>
<p>tags：二项式、组合数、杨辉三角</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>通过观察不难发现，如果某一行的第二个数是n，那么第三个数就绝对是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">C_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>=<strong>n(n-1)/2</strong>，因此，当n=44732的时候，第三个数绝对是<strong>44732x44731/2 = 1,000,453,546 &gt; 10亿</strong>，你第三个数都已经大于10亿了，杨辉三角除了第二个数外其他都是递增的，所以最后需要加上n * (n + 1) / 2 +2计算出n必定会出现的位置，防止程序无输出的情况。</p>
</li>
<li class="lvl-3">
<p>自滚动数组计算杨辉三角，由于杨辉三角的对称性，我们只需要计算前半三角即可，a[0]表示的是第1列(第1列全为1)；</p>
</li>
<li class="lvl-3">
<p>如果i为奇数行并且j为奇数行的最中间一列，那么当前数就等于上一行前一个数的2倍，因为上一行的a[j-1]=a[j]；否则等于上两个数相加。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//  杨辉三角形</span></span><br><span class="line"><span class="comment">// N的范围是1~10亿 </span></span><br><span class="line"><span class="comment">// 若某行的第二个数是n，当n=44732的时候，第三个数绝对是44732x44731/2 = 1,000,453,546 &gt; 10亿</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll a[<span class="number">44732</span>]; <span class="comment">// 自滚动数组计算杨辉三角，由于杨辉三角的对称性，我们只需要计算前半三角即可，a[0]表示的是第1列(第1列全为1) </span></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;<span class="comment">// 恒为1的话第一次出现就是第一个数 </span></span><br><span class="line">		cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 第一列全为1 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;<span class="number">44732</span>;++i)&#123;<span class="comment">// 从第3行开始 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i/<span class="number">2</span>;j&gt;<span class="number">0</span>;--j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==i/<span class="number">2</span>&amp;&amp;i%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">// 如果i为奇数行并且j为奇数行的最中间一列，那么当前数就等于上一行前一个数的2倍，因为上一行的a[j-1]=a[j] </span></span><br><span class="line">				a[j] = <span class="number">2</span>*a[j<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">// 否则等于上两个数相加 </span></span><br><span class="line">				a[j] = a[j<span class="number">-1</span>] + a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(a[j]==n)&#123;<span class="comment">// 第一次找到 </span></span><br><span class="line">				cout&lt;&lt;(i<span class="number">-1</span>)*i/<span class="number">2</span>+j+<span class="number">1</span>;<span class="comment">// 计算前i-1行的元素个数加上当前行的列号j，注意列号从0开始，所以需要再+1</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;n*(n+<span class="number">1</span>)/<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3">3、</h3>
<blockquote>
<p>lanqiao-1457：<a href="https://www.lanqiao.cn/problems/1457/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1457">杨辉三角形 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月7日</strong></u></p>
<p>tags：二项式、组合数、杨辉三角</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-星期一">4、星期一</h3>
<blockquote>
<p>lanqiao-611：<a href="https://www.lanqiao.cn/problems/611/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=611">星期一 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月7日</strong></u></p>
<p>tags：简单数学</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>遍历从1901到2000年的每一年，判断是否是闰年，如果是闰年则总天数+366；否则总天数+365，最后除以7即可，结合1901 年 1 月 1 日是周几，得到最后有多少个周一。</p>
</li>
<li class="lvl-3">
<p>注意：1901年1月1日是星期二（可以通过Excel得到，或者根据当前日期推导2000年12月31日是星期几）。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 星期一 </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_r</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>||n%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1901</span>;i&lt;=<span class="number">2000</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">is_r</span>(i))res += <span class="number">366</span>;</span><br><span class="line">		<span class="keyword">else</span> res += <span class="number">365</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = res / <span class="number">7</span>;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法每日一题8</title>
    <url>/2023/04/11/University/Algorithm/question%20each%20day/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%978%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>每日一题</h1>
<blockquote>
<p>每日一题系列旨在督促本人坚持算法练习，并期望将之养成一个习惯。</p>
</blockquote>
<h3 id="1-寒假作业">1、寒假作业</h3>
<blockquote>
<p>lanqiao-1388：<a href="https://www.lanqiao.cn/problems/1388/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1388">寒假作业 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：dfs</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>使用深度优先搜索将所有情况遍历一遍，判断最终符合要求的方案数；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 寒假作业</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;<span class="comment">// 下标从0开始 </span></span><br><span class="line"><span class="type">int</span> b[<span class="number">20</span>];</span><br><span class="line"><span class="type">bool</span> visit[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="number">13</span>)&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="number">3</span>&amp;&amp;b[<span class="number">0</span>]+b[<span class="number">1</span>]!=b[<span class="number">2</span>])<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="number">6</span>&amp;&amp;b[<span class="number">3</span>]-b[<span class="number">4</span>]!=b[<span class="number">5</span>])<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="number">9</span>&amp;&amp;b[<span class="number">6</span>]*b[<span class="number">7</span>]!=b[<span class="number">8</span>])<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="number">12</span>&amp;&amp;b[<span class="number">9</span>]!=b[<span class="number">11</span>]*b[<span class="number">10</span>])<span class="keyword">return</span>;<span class="comment">// 将除法转换为乘法 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visit[i])&#123;<span class="comment">// 未使用过 </span></span><br><span class="line">			visit[i] = <span class="literal">true</span>;</span><br><span class="line">			b[s] = a[i];</span><br><span class="line">			<span class="built_in">dfs</span>(s+<span class="number">1</span>, len);</span><br><span class="line">			visit[i] = <span class="literal">false</span>;<span class="comment">// 恢复现场 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">13</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-跳蚱蜢">2、跳蚱蜢</h3>
<blockquote>
<p>lanqiao-642：<a href="https://www.lanqiao.cn/problems/642/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=642">跳蚱蜢 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：dfs、思维</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>采用queue队列实现bfs遍历，由初始态012345678到目标087654321；</p>
</li>
<li class="lvl-3">
<p>因为蚱蜢很多，跳蚱蜢很复杂，因此建议跳空盘，更好理解；</p>
</li>
<li class="lvl-3">
<p>注意根据题意知，应该有4中跳法：顺时针跳1步、顺时针跳2步、逆时针跳1步、逆时针跳2步；</p>
</li>
<li class="lvl-3">
<p>可以采用set和map进行去重以及判断是否达到了最后的目标。</p>
</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{注意：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>将反方向的-2到达的位置，转换为正方向下的位置坐标7。<code>int k=(j+9)%9;</code></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 跳蚱蜢——广度优先搜索 ——求最短路径问题 </span></span><br><span class="line">string str;</span><br><span class="line">unordered_map&lt;string, <span class="type">bool</span>&gt;visited;<span class="comment">// 标记是否已经跳过当前状态 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	string s;<span class="comment">// 当前状态 </span></span><br><span class="line">	<span class="type">int</span> t;<span class="comment">// 到达当前状态的跳跃次数</span></span><br><span class="line">	<span class="built_in">node</span>(string ss, <span class="type">int</span> tt)&#123;</span><br><span class="line">		s = ss;</span><br><span class="line">		t = tt;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">// 广度优先搜索 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		string s = now.s;</span><br><span class="line">		<span class="type">int</span> step = now.t;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">&quot;087654321&quot;</span>)&#123;</span><br><span class="line">			cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;result:&quot;</span>&lt;&lt;step;<span class="comment">// 最终结果</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-2</span>;j&lt;=i+<span class="number">2</span>;++j)&#123;<span class="comment">// 四种移动方式 </span></span><br><span class="line">			<span class="type">int</span> k = (j+<span class="number">9</span>)%<span class="number">9</span>;<span class="comment">// 方便向逆时针跳动时得到的下标为顺时针下的位置</span></span><br><span class="line">			<span class="keyword">if</span>(i==k)<span class="keyword">continue</span>;<span class="comment">// 相当于没有移动 </span></span><br><span class="line">			string news = s;</span><br><span class="line">			<span class="built_in">swap</span>(news[i], news[k]);<span class="comment">// 当前空盘与目标数进行交换</span></span><br><span class="line">			<span class="keyword">if</span>(!visited[news]) &#123;<span class="comment">// 如果还没有访问过 </span></span><br><span class="line">				visited[news] = <span class="literal">true</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">node</span>(news, step+<span class="number">1</span>)); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	str = <span class="string">&quot;012345678&quot;</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">node</span>(str, <span class="number">0</span>));</span><br><span class="line">	visited[str] = <span class="literal">true</span>;<span class="comment">// 当前状态已经遍历过</span></span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-七段码">3、七段码</h3>
<blockquote>
<p>lanqiao-595：<a href="https://www.lanqiao.cn/problems/595/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=595">七段码 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月6日</strong></u></p>
<p>tags：回溯法、思维</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>邻接矩阵+回溯法；</p>
</li>
<li class="lvl-3">
<p>还可以通过并查集+dfs来解决；</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 七段码 ——dfs+并查集 </span></span><br><span class="line"><span class="type">int</span> ans;<span class="comment">// 结果 </span></span><br><span class="line"><span class="type">bool</span> un[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">bool</span> visit[<span class="number">8</span>];<span class="comment">// 标记是否点亮 </span></span><br><span class="line"><span class="type">int</span> parent[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">// 并查集初始化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;++i)&#123;</span><br><span class="line">		parent[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=parent[x])&#123;</span><br><span class="line">		parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> xx = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> yy = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(xx!=yy)parent[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">init</span>();<span class="comment">// 并查集初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(un[i][j]&amp;&amp;visit[i]&amp;&amp;visit[j])<span class="built_in">unionSet</span>(i, j);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[i]&amp;&amp;parent[i]==i)flag++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 只有flag为1时才能够证明整个七段码中只有一个连通图 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">8</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>())ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	visit[x] = <span class="literal">true</span>;<span class="comment">// 点亮</span></span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	visit[x] = <span class="literal">false</span>;<span class="comment">// 不点亮</span></span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	un[<span class="number">1</span>][<span class="number">2</span>] = un[<span class="number">1</span>][<span class="number">6</span>] = <span class="number">1</span>; </span><br><span class="line">	un[<span class="number">2</span>][<span class="number">1</span>] = un[<span class="number">2</span>][<span class="number">3</span>] = un[<span class="number">2</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">	un[<span class="number">3</span>][<span class="number">4</span>] = un[<span class="number">3</span>][<span class="number">7</span>] = un[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	un[<span class="number">4</span>][<span class="number">3</span>] = un[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">	un[<span class="number">5</span>][<span class="number">4</span>] = un[<span class="number">5</span>][<span class="number">6</span>] = un[<span class="number">5</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">	un[<span class="number">6</span>][<span class="number">5</span>] = un[<span class="number">6</span>][<span class="number">1</span>] = un[<span class="number">6</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">	un[<span class="number">7</span>][<span class="number">2</span>] = un[<span class="number">7</span>][<span class="number">3</span>] = un[<span class="number">7</span>][<span class="number">5</span>] = un[<span class="number">7</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-分割立方体">4、分割立方体</h3>
<blockquote>
<p>lanqiao-1620：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1620">分割立方体 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407114619810.png" alt="image-20230407114619810"></p>
<p><u><strong>完成时间：2023年4月7日</strong></u></p>
<p>tags：组合数学、数学思维</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407003931879.png" alt="image-20230407003931879"></p>
</li>
<li class="lvl-3">
<p>1）正方体和周围3个正方体相邻，总个数3 × 8；</p>
<p>2）正方体和周围4个正方体相邻，总个数4×(n-2)×12；</p>
<p>3）正方体和周围5个正方体相邻，总个数5×6×(n×n -4×n+4)；</p>
<p>4）正方体和周围6个正方体相邻，总个数6 ×(n×n×n - n×n×6+n×12-8)；</p>
<p>最后把这4个情况求和再除以2（因为求的是对数而不是个数）。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 分割立方体——逆向思维，用总共的两两关系减去共有4个公共点的关系数 </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll sum = n*n*n*(n*n*n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> edge3 = <span class="number">8</span>;<span class="comment">// 与三个小正方体直接邻接的正方体数量（以面邻接而不是边） </span></span><br><span class="line">	<span class="type">int</span> ans3 = <span class="number">3</span>*edge3;</span><br><span class="line">	<span class="type">int</span> edge4 = (n<span class="number">-2</span>)*<span class="number">12</span>;</span><br><span class="line">	<span class="type">int</span> ans4 = <span class="number">4</span>*edge4;</span><br><span class="line">	<span class="type">int</span> edge5 = <span class="number">6</span>*(n*n<span class="number">-4</span>*n+<span class="number">4</span>);</span><br><span class="line">	<span class="type">int</span> ans5 = <span class="number">5</span>*edge5;</span><br><span class="line">	<span class="type">int</span> edge6 = (n*n*n-n*n*<span class="number">6</span>+n*<span class="number">12</span><span class="number">-8</span>);</span><br><span class="line">	<span class="type">int</span> ans6 = <span class="number">6</span>*edge6;</span><br><span class="line">	ll ans = ans3+ans4+ans5+ans6;</span><br><span class="line">	cout&lt;&lt;(sum-ans/<span class="number">2</span>);<span class="comment">// 除2是因为求的是对数而不是个数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-挑选子串">5、挑选子串</h3>
<blockquote>
<p>lanqiao-1621：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1621">挑选子串 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月7日</strong></u></p>
<p>tags：组合数（无序）、数学思维</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>一个个地输入ai，直到输入的数字里，大于m的数够k个，就可以开始统计了。</p>
<p>（1）若正好到k个数，情况总数是：第一个大于m的位置i，乘以i以后的个数，相当于求出了这一段区间的总个数。</p>
<p>（2）大于k个后，怎么求出以后的序列个数而且保证不重复呢？从前往后推理，用倒数第二个位置-倒数第一个位置的差，乘上后面的个数。</p>
</li>
<li class="lvl-3">
<p><mark>（1）与（2）分析没有看懂？？？</mark></p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200050</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)  &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;=m)&#123;</span><br><span class="line">                d[++t]=i;      <span class="comment">//d[]：比m大的数字所在位置</span></span><br><span class="line">                <span class="keyword">if</span>(t&gt;=k) &#123;     <span class="comment">//首先统计出k个比m大的</span></span><br><span class="line">                    <span class="keyword">if</span>(t==k)   sum += d[<span class="number">1</span>]*(n-i+<span class="number">1</span>);<span class="comment">// ???</span></span><br><span class="line">                    <span class="keyword">else</span>       sum += (d[t-k+<span class="number">1</span>]-d[t-k])*(n-i+<span class="number">1</span>);<span class="comment">// ???</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-糊涂人装信">6、糊涂人装信</h3>
<blockquote>
<p>lanqiao-1622：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1622">糊涂人装信 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月7日</strong></u></p>
<p>tags：组合数（无序）、数学思维</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407012527796.png" alt="image-20230407012527796"></p>
</li>
<li class="lvl-3">
<p>如果只有1封信完全放错，那么其它n-1封信都没有放错，那么这封放错的信又应该放到什么位置上呢，所以为0种可能 ；</p>
</li>
<li class="lvl-3">
<p>只有至少2封信完全放错才能够成立，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mn>2</mn><mn>2</mn></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C_2^2 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>(组合数) 。</p>
</li>
</ol>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 糊涂人装信</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll dp[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	dp[<span class="number">1</span>] = dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 如果只有1封信完全放错，那么其它n-1封信都没有放错，那么这封放错的信又应该放到什么位置上呢，所以为0种可能 </span></span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">// 只有至少2封信完全放错才能够成立，C_2^2 = 1(组合数) </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">22</span>;++i)&#123;</span><br><span class="line">		dp[i] = (i<span class="number">-1</span>)*(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-战斗吧n皇后">7、战斗吧N皇后</h3>
<blockquote>
<p>lanqiao-1623：<a href="https://www.lanqiao.cn/problems/?first_category_id=1&amp;sort=students_count&amp;problem_id=1623">战斗吧N皇后 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><u><strong>完成时间：2023年4月7日</strong></u></p>
<p>tags：组合数（无序）、数学思维</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>两个皇后如果能攻击，位于同一行、同一列、同一对角线。</p>
</li>
<li class="lvl-3">
<p>设矩阵为n * m，前2者的可能性是(m+n-2) * n * m。</p>
</li>
<li class="lvl-3">
<p>其他情况请自己思考。</p>
</li>
</ol>
<p><span style="color: red;">以下代码中的各种请况没有看懂？？？</span></p>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; m)    <span class="built_in">swap</span>(n, m);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; m * (m - <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = m * n * (m + n - <span class="number">2</span>);</span><br><span class="line">        ans += <span class="number">2</span> * (n - <span class="number">2</span>) * (n - <span class="number">1</span>) * (<span class="number">2</span> * n - <span class="number">3</span>) / <span class="number">3</span>;</span><br><span class="line">        ans += <span class="number">2</span> * (n - <span class="number">1</span>) * (n - <span class="number">2</span>);</span><br><span class="line">        ans += <span class="number">2</span> * (m - n + <span class="number">1</span>) * n * (n - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>AI编程基础</title>
    <url>/2023/09/09/University/Coding/ML/AI_Code%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>AI编程基础</h1>
<h2 id="函数">函数</h2>
<h3 id="shape">shape</h3>
<p><code>shape</code>是一个函数，用于获取数组的形状（即维度大小）。它的作用是告诉我们关于数组的结构信息，例如有多少<u><strong>行和列</strong></u>，或者更高维度的情况下，还有多少维。这对于数组操作和计算非常重要，因为它决定了如何索引、切片和重塑数组。</p>
<p>具体而言，对于一个二维数组（矩阵），<code>shape</code>返回一个包含两个元素的元组，分别表示数组的行数和列数。例如，对于一个形状为<code>(3, 4)</code>的二维数组，它有3行和4列。</p>
<h3 id="reshape">reshape</h3>
<p>例如，a.reshape(shape) ： 不改变numpy数组a的元素，返回一个shape形状的数组，原数组a不变</p>
<h3 id="axis：指定数据操作的维度">axis：指定数据操作的维度</h3>
<p>对数据进行操作时，经常需要在横轴方向或者数轴方向对数据进行操作，这时需要设定参数<a href="">axis</a>的值：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>axis = 0 代表对横轴操作，也就是第0轴；</p>
</li>
<li class="lvl-2">
<p>axis = 1 代表对纵轴操作，也就是第1轴；</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#生成一个3行4列的数组</span></span><br><span class="line">In [<span class="number">2</span>]: a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">In [<span class="number">3</span>]: a</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment">#axis= 0 对a的横轴进行操作，在运算的过程中其运算的方向表现为纵向运算</span></span><br><span class="line">In [<span class="number">4</span>]: a.<span class="built_in">sum</span>(axis = <span class="number">0</span>)</span><br><span class="line">Out[<span class="number">4</span>]: array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</span><br><span class="line"><span class="comment">#axis= 1 对a的纵轴进行操作，在运算的过程中其运算的方向表现为横向运算</span></span><br><span class="line">In [<span class="number">5</span>]: a.<span class="built_in">sum</span>(axis = <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">5</span>]: array([ <span class="number">6</span>, <span class="number">22</span>, <span class="number">38</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>axis=0：表示沿着第一个维度（行）进行操作</p>
</li>
<li class="lvl-2">
<p>axis=1：表示沿着第二个维度（列）进行操作</p>
</li>
<li class="lvl-2">
<p>axis=2：表示沿着第三个维度进行操作，以此类推</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Coding</category>
        <category>机器学习</category>
        <category>AI Coding</category>
      </categories>
      <tags>
        <tag>AI编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>AI领域学习指南</title>
    <url>/2023/05/15/University/AI/ML/AI%E9%A2%86%E5%9F%9F%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>AI领域学习指南</h1>
<h3 id="机器学习-深度学习-网站汇总">机器学习 深度学习 网站汇总</h3>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/337548019">https://zhuanlan.zhihu.com/p/337548019</a></p>
</blockquote>
<h3 id="李沐大佬课程"><a href="https://github.com/mli">李沐</a>大佬课程⭐️</h3>
<blockquote>
<p>参考：<a href="https://courses.d2l.ai/zh-v2/">https://courses.d2l.ai/zh-v2/</a></p>
</blockquote>
<h3 id="深度学习论文精读">深度学习论文精读</h3>
<blockquote>
<p>参考：<a href="https://github.com/mli/paper-reading">https://github.com/mli/paper-reading</a></p>
</blockquote>
<h3 id="动手学深度学习">《动手学深度学习》</h3>
<blockquote>
<p>参考：<a href="https://github.com/d2l-ai/d2l-zh">d2l-ai/d2l-zh: 《动手学深度学习》：面向中文读者、能运行、可讨论。中英文版被60多个国家的400多所大学用于教学。 (github.com)</a></p>
</blockquote>
<h3 id="动手学深度学习-评论区">《动手学深度学习》评论区</h3>
<blockquote>
<p>参考：<a href="https://discuss.d2l.ai/">https://discuss.d2l.ai/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>机器学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>学习指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle入门</title>
    <url>/2023/05/14/University/Coding/ML/Kaggle%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1><a href="https://www.kaggle.com/">Kaggle</a>入门</h1>
<h3 id="kaggle入门">Kaggle入门</h3>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/25686876">Kaggle入门，看这一篇就够了 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="scikit-learn">scikit-learn</h3>
<blockquote>
<p>参考：<a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a></p>
</blockquote>
<p>​</p>
<h3 id="第一个机器学习模型">第一个机器学习模型</h3>
<p>The steps to building and using a model are:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Define:</strong> What type of model will it be? A decision tree? Some other type of model? Some other parameters of the model type are specified too.</p>
</li>
<li class="lvl-2">
<p><strong>Fit:</strong> Capture patterns from provided data. This is the heart of modeling.</p>
</li>
<li class="lvl-2">
<p><strong>Predict:</strong> Just what it sounds like</p>
</li>
<li class="lvl-2">
<p><strong>Evaluate</strong>: Determine how accurate the model’s predictions are.</p>
</li>
</ul>
<h5 id="定义与拟合">定义与拟合</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define model. Specify a number for random_state to ensure same results each run</span></span><br><span class="line">melbourne_model = DecisionTreeRegressor(random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit model</span></span><br><span class="line">melbourne_model.fit(X, y)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Specifying a number for <code>random_state</code> ensures you get the same results in each run. This is considered a good practice. You use any number, and model quality won’t depend meaningfully on exactly what value you choose.</p>
</blockquote>
<h5 id="预测">预测</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Making predictions for the following 5 houses:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(X.head())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The predictions are&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(melbourne_model.predict(X.head()))	<span class="comment"># 预测前几行数据</span></span><br></pre></td></tr></table></figure>
<h3 id="model-validation">Model Validation</h3>
<p>许多人在测量预测精度时犯了一个巨大的错误。他们使用训练数据进行预测，并将这些预测与训练数据中的目标值进行比较。</p>
<p>有许多度量来总结模型质量，其中之一是<strong>平均绝对误差</strong>（也称为<strong>MAE</strong>）。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>要么</mtext><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>b</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>e</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>r</mi><mo>=</mo><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext> </mtext><mo>−</mo><mtext> </mtext><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>a</mi><mi>l</mi><mspace linebreak="newline"></mspace><mtext>或者</mtext><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>a</mi><mi>b</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>e</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>r</mi><mo>=</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext> </mtext><mo>−</mo><mtext> </mtext><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">要么mean\_absolute\_error=actual\_val \ - \ predict\_val \\ 或者mean\_absolute\_error=predict\_val \ - \ actual\_val
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord cjk_fallback">要么</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">an</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">ab</span><span class="mord mathnormal">so</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.02778em;">error</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord cjk_fallback">或者</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">an</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">ab</span><span class="mord mathnormal">so</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.02778em;">error</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br><span class="line"></span><br><span class="line">predicted_home_prices = melbourne_model.predict(X)</span><br><span class="line">mean_absolute_error(y, predicted_home_prices)	<span class="comment"># 计算样本内得分 </span></span><br></pre></td></tr></table></figure>
<p>我们刚刚计算的度量可以称为“样本内”得分。我们使用了一个房屋“样本”来构建模型并对其进行评估。以下是为什么这很糟糕的原因。</p>
<p>想象一下，在大型房地产市场中，门的颜色与房价无关。</p>
<p>然而，在你用来建立模型的数据样本中，所有带绿色门的房子都非常昂贵。该模型的工作是找到预测房价的模式，因此它将看到这种模式，并且它将始终预测带绿色门的房屋的高价格。</p>
<p>由于该模式是从训练数据中得出的，因此该模型在训练数据中看起来是准确的。</p>
<p>但是，如果当模型看到新数据时，这种模式不成立，那么在实践中使用该模型将非常不准确。</p>
<p>由于模型的实际价值来自于对新数据的预测，我们衡量的是未用于构建模型的数据的性能。做到这一点最简单的方法是从模型构建过程中排除一些数据，然后使用这些数据在以前从未见过的数据上测试模型的准确性。这些数据称为<strong>验证数据</strong>。</p>
<p>scikit-learn库有一个函数train_test_split将数据分成两部分。我们将使用其中的一些数据作为训练数据来拟合模型，我们将使用其他数据作为验证数据来计算mean_absolute_error。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># split data into training and validation data, for both features and target</span></span><br><span class="line"><span class="comment"># The split is based on a random number generator. Supplying a numeric value to</span></span><br><span class="line"><span class="comment"># the random_state argument guarantees we get the same split every time we</span></span><br><span class="line"><span class="comment"># run this script.</span></span><br><span class="line">train_X, val_X, train_y, val_y = train_test_split(X, y, random_state = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># Define model</span></span><br><span class="line">melbourne_model = DecisionTreeRegressor()</span><br><span class="line"><span class="comment"># Fit model</span></span><br><span class="line">melbourne_model.fit(train_X, train_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get predicted prices on validation data</span></span><br><span class="line">val_predictions = melbourne_model.predict(val_X)</span><br><span class="line"><span class="built_in">print</span>(mean_absolute_error(val_y, val_predictions))	<span class="comment"># 计算“样本”外得分</span></span><br></pre></td></tr></table></figure>
<h3 id="underfitting-and-overfitting">Underfitting and Overfitting</h3>
<h5 id="overfitting">Overfitting</h5>
<blockquote>
<p>When we divide the houses amongst many leaves, we also have fewer houses in each leaf. Leaves with very few houses will make predictions that are quite close to those homes’ actual values, but they may make very unreliable predictions for new data (because each prediction is based on only a few houses).This is a phenomenon called <strong>overfitting</strong>.</p>
</blockquote>
<h5 id="underfitting">Underfitting</h5>
<blockquote>
<p>At an extreme, if a tree divides houses into only 2 or 4, each group still has a wide variety of houses. Resulting predictions may be far off for most houses, even in the training data (and it will be bad in validation too for the same reason). When a model fails to capture important distinctions and patterns in the data, so it performs poorly even in training data, that is called <strong>underfitting</strong>.</p>
</blockquote>
<h2 id="coding基础知识">Coding基础知识</h2>
<h3 id="axis：指定数据操作的维度">axis：指定数据操作的维度</h3>
<p>对数据进行操作时，经常需要在横轴方向或者数轴方向对数据进行操作，这时需要设定参数<a href="">axis</a>的值：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>axis = 0 代表对横轴操作，也就是第0轴；</p>
</li>
<li class="lvl-2">
<p>axis = 1 代表对纵轴操作，也就是第1轴；</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#生成一个3行4列的数组</span></span><br><span class="line">In [<span class="number">2</span>]: a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">In [<span class="number">3</span>]: a</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment">#axis= 0 对a的横轴进行操作，在运算的过程中其运算的方向表现为纵向运算</span></span><br><span class="line">In [<span class="number">4</span>]: a.<span class="built_in">sum</span>(axis = <span class="number">0</span>)</span><br><span class="line">Out[<span class="number">4</span>]: array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</span><br><span class="line"><span class="comment">#axis= 1 对a的纵轴进行操作，在运算的过程中其运算的方向表现为横向运算</span></span><br><span class="line">In [<span class="number">5</span>]: a.<span class="built_in">sum</span>(axis = <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">5</span>]: array([ <span class="number">6</span>, <span class="number">22</span>, <span class="number">38</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>axis=0：表示沿着第一个维度（行）进行操作</p>
</li>
<li class="lvl-2">
<p>axis=1：表示沿着第二个维度（列）进行操作</p>
</li>
<li class="lvl-2">
<p>axis=2：表示沿着第三个维度进行操作，以此类推</p>
</li>
</ul>
</blockquote>
<h3 id="pandas处理特定数据行或列">pandas处理特定数据行或列</h3>
<h5 id="pandas删除-选取含有特定数值的行或列">pandas删除/选取含有特定数值的行或列</h5>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/luocheng7430/article/details/80330566">(113条消息) pandas.DataFrame删除/选取含有特定数值的行或列_pandas删除特定值的行_luocheng7430的博客-CSDN博客</a></p>
</blockquote>
<h5 id="pandas处理重复行">pandas处理重复行</h5>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_40981268/article/details/86498762">(113条消息) pandas: DataFrame 删除重复的行_pandas 删除重复行_大白羊的进阶之路的博客-CSDN博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Coding</category>
        <category>机器学习</category>
        <category>Kaggle</category>
      </categories>
      <tags>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>C++经典问题</title>
    <url>/2023/04/11/University/Algorithm/Classic%20problems/C++%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>C++经典问题</h1>
<h3 id="求整数的两个质数因子">求整数的两个质数因子</h3>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>关键理论：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{关键理论：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">关键理论：</span></span></span></span></p>
<p><mark>质数分解唯一性</mark>是一个重要的数论概念，它指出任何一个大于1的正整数都可以被唯一地表示成若干个质数的积。</p>
<p>具体来说，对于一个大于1的正整数n，它可以写成以下形式的质因数积：</p>
<p>n = p1^k1 * p2^k2 * … * pn^kn</p>
<p>其中p1, p2, …, pn为质数，k1, k2, …, kn为正整数。这个表示方式称为n的质因数分解式，也称为n的标准分解式。</p>
<p>质数分解唯一性指出：<u>任何一个正整数n都<mark>有且仅有一种</mark>质因数分解式</u>。也就是说，不管用什么方法，只要将n分解成若干个质数的积，得到的分解式都是唯一的。</p>
<p>这个性质在数论和其它领域中都有广泛的应用。例如，在密码学中，**<u>RSA公钥加密算法</u>**就是<mark>基于质数分解唯一性</mark>的安全性原理而设计的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算两个质数p，q</span></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;<span class="built_in">sqrt</span>(n);++i) &#123;<span class="comment">// &quot;质数分解唯一性&quot;:一个数有且只有1种质因数分解式</span></span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        p = i, q = n/i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q;</span><br></pre></td></tr></table></figure>
<h3 id="求整数的所有因子">求整数的所有因子</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">	<span class="keyword">if</span> (n % k == <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题">背包问题</h3>
<ol>
<li class="lvl-3">
<p>01背包问题（每种物品只能选一次）</p>
</li>
<li class="lvl-3">
<p>完全背包问题（每种物品都可以选无限次）</p>
</li>
<li class="lvl-3">
<p>多重背包问题（每种物品具有不同的选择上限）</p>
<ul class="lvl-2">
<li class="lvl-5">可以转换为01背包问题；</li>
<li class="lvl-5">或是添加附加数量限制条件；</li>
</ul>
</li>
</ol>
<h4 id="3-多重背包问题">3.多重背包问题</h4>
<h5 id="转换为01背包问题">转换为01背包问题</h5>
<p>解法代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照别人AC的代码写的居然死活过不了？？？</span></span><br></pre></td></tr></table></figure>
<h5 id="添加附加数量限制条件">添加附加数量限制条件</h5>
<p>解法代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 多重背包问题 ——添加附加数量限制条件 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N], v[N], w[N], s[N];<span class="comment">// v体积，w价值，s数量 </span></span><br><span class="line"><span class="type">int</span> n, V;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;++j)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i];++k)&#123;<span class="comment">// 这里的k必须从0开始,k=0时有dp[i-1][j] </span></span><br><span class="line">				<span class="keyword">if</span>(j&gt;=k*v[i])&#123;</span><br><span class="line">					dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);<span class="comment">// 在01-背包问题的基础上作次数限制 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//空间压缩</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;++i)&#123;</span></span><br><span class="line"><span class="comment">//		for(int j=V;j&gt;=v[i];--j)&#123;</span></span><br><span class="line"><span class="comment">//			for(int k=1;k*v[i]&lt;=j&amp;&amp;k&lt;=s[i];++k)&#123;</span></span><br><span class="line"><span class="comment">//				f[j] = max(f[j], f[j-k*v[i]]+k*w[i]);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	cout&lt;&lt;dp[n][V];</span><br><span class="line"><span class="comment">//	cout&lt;&lt;f[V];</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>01背包与完全背包问题可以参考<code>PDF:LeetCode 101</code>;</p>
</blockquote>
<h3 id="判断闰年">判断闰年</h3>
<p>如果一个年份能够被4整除但不能被100整除，或者能够被400整除，则该年份是闰年。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="lcs">LCS</h3>
<p>在C++中，LCS是<u><strong>最长公共子序列</strong></u>（Longest Common Subsequence）的缩写，它是一种经典的计算机科学问题，通常用于比较两个字符串或序列之间的相似性。给定两个序列X和Y，LCS问题的目标是找到一个最长的序列Z，使得Z既是X的子序列又是Y的子序列。</p>
<p>LCS问题在自然语言处理、生物信息学、数据压缩等领域都有广泛应用。C++提供了许多实现LCS问题的算法，包括动态规划、贪心算法、分治算法等。</p>
<p>下面是一个使用动态规划算法实现LCS问题的C++代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcs</span><span class="params">(string X, string Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = X.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> n = Y.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> L[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                L[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                L[i][j] = L[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L[i][j] = <span class="built_in">max</span>(L[i - <span class="number">1</span>][j], L[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> L[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string X = <span class="string">&quot;AGGTAB&quot;</span>;</span><br><span class="line">    string Y = <span class="string">&quot;GXTXAYB&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of LCS is &quot;</span> &lt;&lt; <span class="built_in">lcs</span>(X, Y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序使用二维数组<code>L[m+1][n+1]</code>存储最长公共子序列长度的计算结果。在计算<code>L[i][j]</code>时，如果字符串X的第i个字符等于字符串Y的第j个字符，则<code>L[i][j]</code>的值为<code>L[i-1][j-1]+1</code>；否则，<code>L[i][j]</code>的值为<code>L[i-1][j]</code>和<code>L[i][j-1]</code>中的较大值。最终，函数返回<code>L[m][n]</code>的值，即X和Y的最长公共子序列的长度。</p>
<h3 id="lis">LIS</h3>
<p>C++ LIS 是指<u><strong>最长上升子序列</strong></u>（Longest Increasing Subsequence）的算法实现，它是一种常用的动态规划算法。在一个序列中找到一个最长的子序列使得这个子序列中的所有元素都按照顺序递增排列，这个子序列就被称为最长上升子序列。</p>
<p>C++ 中可以使用动态规划来解决最长上升子序列问题，具体实现步骤如下：</p>
<ol>
<li class="lvl-3">
<p>定义一个长度为 n 的数组 dp，dp[i] 表示以第 i 个元素结尾的最长上升子序列的长度。</p>
</li>
<li class="lvl-3">
<p>初始化 dp 数组，将每个元素的最长上升子序列长度初始化为 1。</p>
</li>
<li class="lvl-3">
<p>遍历数组，对于每个元素 i，从头开始遍历到 i - 1，如果发现一个元素 j 比 i 小，并且 dp[j] + 1 &gt; dp[i]，则更新 dp[i] 的值为 dp[j] + 1。</p>
</li>
<li class="lvl-3">
<p>最后遍历整个 dp 数组，找到最大的 dp[i] 值即可。</p>
</li>
</ol>
<p>C++ LIS 算法的时间复杂度为 O(n^2)，因此，在处理较长的序列时，该算法可能会比较耗时。</p>
<p>下面是 C++ 实现最长上升子序列（LIS）的典型代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lis</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, dp[i]);</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lis</span>(arr, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该实现中，<code>lis()</code> 函数计算最长上升子序列的长度。首先创建一个大小为 n 的数组 <code>dp</code>，并将所有元素初始化为 1。然后，使用嵌套的循环遍历整个数组，如果找到一个比当前元素小的元素，则更新 <code>dp[i]</code> 的值。最后，遍历整个 <code>dp</code> 数组，找到最大的值即为最长上升子序列的长度。</p>
<h3 id="编辑距离">编辑距离</h3>
<ol>
<li class="lvl-3">
<p>编辑距离为两个字符串，a 和 b 通过多少次变换，<u><strong>使得 a 变成 b</strong></u>。</p>
</li>
<li class="lvl-3">
<p>修改包含三种：</p>
<ol>
<li class="lvl-6">删除操作，将 a[i] 从 a 中移除</li>
<li class="lvl-6">插入操作，在 a[i] 后加上 b[j]</li>
<li class="lvl-6">替换操作，将 a[i] 修改为 b[j]</li>
</ol>
</li>
<li class="lvl-3">
<p>初始状态，i=j=0，都在字符串的开头。</p>
<p>然后开始判断 a[i]=?b[j]</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>如果相同，那么就不需要修改，所以<code>dp[i+1][j+1]=dp[i][j]</code></p>
<p>所以在a[i-1]等于b[j-1]时，<code>dp[i][j]</code>这个状态由<code>dp[i-1][j-1]</code>转移而来。</p>
<p><code>dp[i][j]=dp[i-1][j-1]</code></p>
</li>
<li class="lvl-5">
<p>如果不同，那就需要进行三种可能的操作</p>
</li>
</ul>
<ol>
<li class="lvl-6">
<p><u><strong>修改操作</strong></u>：</p>
<p>a[i] 修改为 b[j]， 因为编辑了一次，所以+1</p>
<p><code>dp[i+1][j+1]=dp[i][j]+1</code></p>
<p>所以在a[i-1]不等于b[j-1]时，<code>dp[i][j]</code>这个状态由<code>dp[i-1][j-1]</code>转移而来。</p>
<p><code>dp[i][j]=dp[i-1][j-1]+1</code></p>
</li>
<li class="lvl-6">
<p><u><strong>删除操作</strong></u>，直接把 a[i] 删除，此时转移到 <code>dp[i][j+1]</code> ，因为 a[i] 被删除，但是下一个字符到了 a[i] 的位置，而对应比较的位置到了b[j+1]。</p>
<p>所以此时状态转移到了<code>dp[i][j+1]</code></p>
<p><code>dp[i][j+1]=dp[i][j]+1</code></p>
<p>因为编辑了一次，所以+1</p>
<p>所以在a[i-1]不等于b[j-1]时，<code>dp[i][j]</code>就有可能通过<code>dp[i-1][j]</code>转移而来。</p>
</li>
<li class="lvl-6">
<p><u><strong>插入操作</strong></u>，在a[i]后添加一个b[j]，那么此时a[i+1]和b[j]对应，因为加了一个字符就变成了a[i+1],而且跟b[j]对应，那么下一个状态转移到了<code>dp[i+1][j]</code></p>
<p><code>dp[i+1][j]=dp[i][j]+1</code></p>
<p>此时状态转移到了 <code>dp[i+1][j]=dp[i][j]+1</code></p>
<p>因为编辑了一次，所以+1</p>
<p>所以在a[i-1]不等于b[j-1]时，<code>dp[i][j]</code>就有可能通过<code>dp[i][j-1]</code>转移而来。</p>
</li>
</ol>
<p>那么不同时，我们选择他们的最小值即可。</p>
</li>
</ol>
<p>模版代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 99999999</span></span><br><span class="line">string s, t;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = INF;<span class="comment">// 这里不能用INT_MAX，因为后面有+1操作，这样会使得INT_MAX+1为负数,那么min求得的就是负数,不是最终答案 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>],<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大公约数">最大公约数</h3>
<p>以下是使用C++求最大公约数的两种方法：</p>
<p>方法一：辗转相除法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> r = x % y;</span><br><span class="line">        x = y;</span><br><span class="line">        y = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：递归法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % y == <span class="number">0</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者写成：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 辗转相除法的递归实现</span></span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方法都可以求出最大公约数，其中辗转相除法比较容易理解，而递归法则比较简洁。</p>
<h3 id="最小公倍数">最小公倍数</h3>
<p>可以通过先求最大公约数，再用两个数的乘积除以最大公约数来求得最小公倍数。</p>
<p>以下是一个C++函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b) / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>gcd</code>函数为求最大公约数的函数，<code>lcm</code>函数则调用了<code>gcd</code>函数来求解最小公倍数，返回值即为a和b的最小公倍数。</p>
<h3 id="蛇形填数">蛇形填数</h3>
<p>以8*8的填充矩阵为例：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316150544093.png" alt="填充顺序"></p>
<p>实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	矩阵的左上三角形与右下三角形的填充规则是不同的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//扫描数据的个数</span></span><br><span class="line"><span class="type">double</span> M[<span class="number">8</span>][<span class="number">8</span>];<span class="comment">//填充矩阵 </span></span><br><span class="line"><span class="comment">//针对蛇形填充——定义4个方向 ：右，左下，下，右上(上三角形);(下三角形)需要交换dx[0]与dy[0]以及dx[2]与dy[2] </span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;<span class="comment">//dx控制列，dy控制行 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(M,<span class="number">0</span>,<span class="built_in">sizeof</span>(M));<span class="comment">//赋值全0 </span></span><br><span class="line">	<span class="type">int</span> y=<span class="number">0</span>,x=<span class="number">0</span>,md=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;M[y][x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//循环直到将所有的数据填充到矩阵中 </span></span><br><span class="line">		y+=dy[md];</span><br><span class="line">		x+=dx[md];</span><br><span class="line">		cin&gt;&gt;M[y][x];</span><br><span class="line">		<span class="keyword">if</span>(md==<span class="number">0</span>||md==<span class="number">2</span>)md=(md+<span class="number">1</span>)%<span class="number">4</span>;<span class="comment">//每一次在经过向右或向下操作后，需要转换为左下或右上。 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(md==<span class="number">1</span>||md==<span class="number">3</span>)&#123;<span class="comment">//确保是因下或右上操作</span></span><br><span class="line">			<span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>||x==<span class="number">7</span>||y==<span class="number">7</span>)md=(md+<span class="number">1</span>)%<span class="number">4</span>;<span class="comment">//左下或右上达到矩阵边界之后需要进行操作的切换 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(y==<span class="number">7</span>&amp;&amp;x==<span class="number">0</span>)&#123;<span class="comment">//遍历到了右下三角形，需要交换dx[0]与dy[0]以及dx[2]与dy[2]</span></span><br><span class="line">			<span class="built_in">swap</span>(dx[<span class="number">0</span>],dy[<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">swap</span>(dx[<span class="number">2</span>],dy[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>经典问题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习ML</title>
    <url>/2023/05/14/University/AI/ML/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>机器学习（machine learning，ML）</h1>
<h3 id="机器学习的关键组件">机器学习的关键组件</h3>
<ol>
<li class="lvl-3">
<p>可以用来学习的<em>数据</em>（data）；</p>
</li>
<li class="lvl-3">
<p>如何转换数据的<em>模型</em>（model）；</p>
</li>
<li class="lvl-3">
<p>一个<em>目标函数</em>（objective function），用来量化模型的有效性；</p>
</li>
<li class="lvl-3">
<p>调整模型参数以优化目标函数的<em>算法</em>（algorithm）。</p>
</li>
</ol>
<h4 id="数据">数据</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>样本（example）：每个样本由一组称为<em>特征</em>（features，或<em>协变量</em>（covariates））的属性组成</p>
<ul class="lvl-2">
<li class="lvl-4">特征（features）</li>
<li class="lvl-4">维数（dimensionality）：特征向量的长度</li>
</ul>
</li>
<li class="lvl-2">
<p><u><em><strong>与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据。</strong></em></u></p>
</li>
</ul>
<h4 id="模型">模型</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>涉及到数据的转换</p>
</li>
</ul>
<blockquote>
<p>深度学习：由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为<em>深度学习</em>（deep learning）</p>
</blockquote>
<h4 id="目标函数">目标函数</h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，这被称之为<em>目标函数</em>（objective function）。</p>
</li>
<li class="lvl-2">
<p>因为越低越好，所以这些函数有时被称为<em>损失函数</em>（loss function，或cost function）。</p>
</li>
</ul>
<p><u><em><strong>当然我们也可以取一个新的函数，优化到它的最高点。</strong></em></u></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>训练数据集</em>（training dataset，或称为<em>训练集</em>（training set））</p>
</li>
<li class="lvl-2">
<p><em>测试数据集</em>（test dataset，或称为<em>测试集</em>（test set））</p>
</li>
<li class="lvl-2">
<p><u><em><strong>在训练数据上表现良好的模型，并不一定在“测试集”上有同样的性能</strong></em></u></p>
</li>
</ul>
<p>训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型</p>
<h5 id="过拟合-overfitting">过拟合（overfitting）</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>当一个模型在训练集上表现良好，但不能推广到测试集时，这个模型被称为<em>过拟合</em>（overfitting）的</p>
</li>
</ul>
<blockquote>
<p>例如：当我们把房子分成多片叶子时，每片叶子上的房子也就更少了。拥有非常少房子的叶子会做出非常接近这些房子的实际值的预测，但是他们可能会对新数据做出非常不可靠的预测（因为每个预测都是基于很少的房子）。这就是所谓的<strong>过度拟合现象。</strong></p>
</blockquote>
<h5 id="欠拟合-underfitting">欠拟合（underfitting）</h5>
<blockquote>
<p>在极端情况下，如果一棵树只把房子分成2或4个，那么每一组仍然有各种各样的房子。即使是在培训数据中，最终的预测对于大多数房屋来说也可能是遥远的(而且出于同样的原因，在验证方面也会很糟糕)。当一个模型无法捕捉到数据中的重要区别和模式时，即使在训练数据方面，它的表现也很差，这就是所谓的<strong>欠拟合</strong>。</p>
</blockquote>
<h4 id="优化算法">优化算法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>能够搜索出<mark>最佳参数</mark>，以<u><strong>最小化</strong></u>损失函数</p>
</li>
</ul>
<p><u><em><strong>深度学习中，大多流行的优化算法通常基于一种基本方法–梯度下降（gradient descent）。</strong></em></u></p>
<blockquote>
<p>在每个步骤中，梯度下降法都会检查每个参数，看看如果仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</p>
</blockquote>
<h3 id="监督学习">监督学习</h3>
<p><em>监督学习</em>（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个<em>样本</em>（example）。</p>
<h5 id="监督学习的学习过程：">监督学习的学习过程：</h5>
<ol>
<li class="lvl-3">
<p>从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；</p>
</li>
<li class="lvl-3">
<p>选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；</p>
</li>
<li class="lvl-3">
<p>将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/supervised-learning.svg" alt="../_images/supervised-learning.svg"></p>
<h4 id="回归">回归</h4>
<p><em>回归</em>（regression）是最简单的监督学习任务之一。</p>
<details>
    <summary ><span style="color: red;">经验法则</span></summary>
    <!-- 在这里输入您要隐藏的文本内容 -->
    <p>判断回归问题的一个很好的经验法则是，任何有关“有多少”的问题很可能就是回归问题。</p>
</details>
<h4 id="分类">分类</h4>
<p><em>分类</em>问题希望模型能够预测样本属于哪个<em>类别</em>（category，正式称为<em>类</em>（class））</p>
<h5 id="交叉熵">交叉熵</h5>
<p>分类问题的常见损失函数被称为<em>交叉熵</em>（cross-entropy）</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>回归是训练一个回归函数来输出一个数值；分类是训练一个分类器来输出预测的类别。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{回归是训练一个回归函数来输出一个数值； 分类是训练一个分类器来输出预测的类别。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">回归是训练一个回归函数来输出一个数值；分类是训练一个分类器来输出预测的类别。</span></span></span></span></p>
<h5 id="分类问题">分类问题</h5>
<h6 id="二项分类">二项分类</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><em><strong>最简单的分类问题是只有两类，这被称之为二项分类（binomial classification）</strong></em></u></p>
</li>
</ul>
<h6 id="多项分类">多项分类</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>当有两个及以上类别时，称为<em>多项分类</em>（multiclass classification）问题</p>
</li>
</ul>
<h6 id="层次分类">层次分类</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>人们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为<em>层次分类</em>(hierarchical classification)。</p>
</li>
</ul>
<h6 id="多标签分类">多标签分类</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>学习预测不相互排斥的类别的问题称为<em>多标签分类</em>（multi-label classification）</p>
</li>
</ul>
<p><mark>监督学习与环境的交互</mark></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/data-collection.svg" alt="../_images/data-collection.svg"></p>
<h3 id="无监督学习">无监督学习</h3>
<p>这类数据中不含有“目标”的机器学习问题通常被为<em>无监督学习</em>（unsupervised learning）</p>
<p>无监督学习适用于以下问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>聚类</em>（clustering）问题</p>
</li>
<li class="lvl-2">
<p><em>主成分分析</em>（principal component analysis）问题</p>
</li>
<li class="lvl-2">
<p><em>因果关系</em>（causality）和<em>概率图模型</em>（probabilistic graphical models）问题</p>
</li>
<li class="lvl-2">
<p><em>生成对抗性网络</em>（generative adversarial networks）</p>
</li>
</ul>
<h3 id="强化学习">强化学习</h3>
<p>智能体（agent）在一系列的时间步骤上与环境交互。</p>
<blockquote>
<p>在每个特定时间点，智能体从环境接收一些<em>观察</em>（observation），并且必须选择一个<em>动作</em>（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后智能体从环境中获得<em>奖励</em>（reward）。 此后新一轮循环开始，智能体接收后续观察，并选择后续操作，依此类推。</p>
</blockquote>
<p><mark>强化学习和环境之间的相互作用</mark></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/rl-environment.svg" alt="../_images/rl-environment.svg"></p>
<details>
    <summary ><span style="color: red;">强化学习框架的通用性十分强大</span></summary>
    <!-- 在这里输入您要隐藏的文本内容 -->
    <p>例如，我们可以将任何监督学习问题转化为强化学习问题。 假设我们有一个分类问题，可以创建一个强化学习智能体，每个分类对应一个“动作”。 然后，我们可以创建一个环境，该环境给予智能体的奖励。 这个奖励与原始监督学习问题的损失函数是一致的。</p>
</details>
<details>
    <summary ><span style="color: red;">一些特殊情况下的强化学习问题</span></summary>
    <!-- 在这里输入您要隐藏的文本内容 -->
    <p>当环境可被完全观察到时，强化学习问题被称为*马尔可夫决策过程*（markov decision process）。 当状态不依赖于之前的操作时，我们称该问题为*上下文赌博机*（contextual bandit problem）。 当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的*多臂赌博机*（multi-armed bandit problem）。</p>
</details>
<blockquote>
<p>补充：考虑到数据和计算的稀缺性，<em>核方法</em>（kernel method）、<em>决策树</em>（decision tree）和<em>图模型</em>（graph models）等强大的统计工具（在经验上）证明是更为优越的。 与神经网络不同的是，这些算法不需要数周的训练，而且有很强的理论依据，可以提供可预测的结果。</p>
</blockquote>
<h3 id="深度学习的特点">深度学习的特点</h3>
<p>深度学习是“深度”的，模型学习了许多“层”的转换，每一层提供一个层次的表示。 例如，靠近输入的层可以表示数据的低级细节，而接近分类输出的层可以表示用于区分的更抽象的概念。 由于<em>表示学习</em>（representation learning）目的是寻找表示本身，因此深度学习可以称为“多级表示学习”。</p>
<h1>Reference</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="http://zh.d2l.ai/chapter_introduction/index.html">http://zh.d2l.ai/chapter_introduction/index.html</a></p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>机器学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络CNN</title>
    <url>/2023/05/21/University/AI/ML/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>卷积神经网络CNN</h1>
<p><em><strong>卷积神经网络</strong></em>（convolutional neural networks，CNN）是机器学习利用自然图像中一些<u><strong>已知结构</strong></u>的创造性方法。</p>
<h2 id="不变性">不变性</h2>
<p>假设我们想从一张图片中找到某个物体。 合理的假设是：无论哪种方法找到这个物体，都应该和物体的位置无关。理想情况下，我们的系统应该能够利用常识：猪通常不在天上飞，飞机通常不在水里游泳。 但是，如果一只猪出现在图片顶部，我们还是应该认出它。</p>
<p>卷积神经网络正是将<em><strong>空间不变性</strong></em>（spatial invariance）的这一概念系统化，从而基于这个模型使用较少的参数来学习有用的表示。</p>
<h5 id="神经网络架构特性">神经网络架构特性</h5>
<ol>
<li class="lvl-3">
<p><em><strong>平移不变性</strong></em>（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的<u>前面几层</u>应该对相同的图像区域具有相似的反应，即为“平移不变性”。</p>
</li>
<li class="lvl-3">
<p><em><strong>局部性</strong></em>（locality）：神经网络的前面几层应该只探索输入图像中的<u>局部区域</u>，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</p>
</li>
</ol>
<h2 id="多层感知机的限制">多层感知机的限制</h2>
<p>多层感知机的输入是二维图像<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">X</span></span></span></span>，其隐藏表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">H</mi></mrow><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">H</span></span></span></span>在数学上是一个矩阵，在代码中表示为二维张量。</p>
<p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">X</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">H</mi></mrow><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">H</span></span></span></span>具有相同的形状。</p>
<p>为了方便理解，我们可以认为，无论是输入还是隐藏表示都拥有空间结构。</p>
<p>使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">X</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{X}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>分别表示输入图像和隐藏表示中位置（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>）处的像素。</p>
<p>为了使每个隐藏神经元都能接收到每个输入像素的信息，我们将参数从权重矩阵（如同我们先前在多层感知机中所做的那样）替换为四阶权重张量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">W</mi></mrow><annotation encoding="application/x-tex">\mathsf{W}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf" style="margin-right:0.01389em;">W</span></span></span></span>。假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">U</mi></mrow><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">U</span></span></span></span>包含偏置参数，我们可以将全连接层形式化地表示为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mrow><mo fence="true">[</mo><mi mathvariant="bold">H</mi><mo fence="true">]</mo></mrow><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">[</mo><mi mathvariant="bold">U</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><munder><mo>∑</mo><mi>k</mi></munder><munder><mo>∑</mo><mi>l</mi></munder><mo stretchy="false">[</mo><mi mathvariant="sans-serif">W</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo stretchy="false">[</mo><mi mathvariant="bold">X</mi><msub><mo stretchy="false">]</mo><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">[</mo><mi mathvariant="bold">U</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>b</mi></munder><mo stretchy="false">[</mo><mi mathvariant="sans-serif">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">[</mo><mi mathvariant="bold">X</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mi>b</mi></mrow></msub><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \left[\mathbf{H}\right]_{i, j} &amp;= [\mathbf{U}]_{i, j} + \sum_k \sum_l[\mathsf{W}]_{i, j, k, l}  [\mathbf{X}]_{k, l}\\ &amp;=  [\mathbf{U}]_{i, j} +
\sum_a \sum_b [\mathsf{V}]_{i, j, a, b}  [\mathbf{X}]_{i+a, j+b}.\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.3042em;vertical-align:-2.4021em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9021em;"><span style="top:-4.9021em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathbf">H</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4021em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9021em;"><span style="top:-4.9021em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">[</span><span class="mord mathbf">U</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">W</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathbf">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">[</span><span class="mord mathbf">U</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathbf">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4021em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">W</mi></mrow><annotation encoding="application/x-tex">\mathsf{W}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf" style="margin-right:0.01389em;">W</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">V</mi></mrow><annotation encoding="application/x-tex">\mathsf{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf" style="margin-right:0.01389em;">V</span></span></span></span>的转换只是形式上的转换，因为在这两个四阶张量的元素之间存在一一对应的关系。</p>
<p>我们只需重新索引下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k, l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>，使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>i</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">k = i+a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>j</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">l = j+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，由此可得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo>=</mo><mo stretchy="false">[</mo><mi mathvariant="sans-serif">W</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{V}]_{i, j, a, b} = [\mathsf{W}]_{i, j, i+a, j+b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">W</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>索引<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>通过在正偏移和负偏移之间移动覆盖了整个图像。</p>
<p>对于隐藏表示中任意给定位置（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>）处的像素值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，可以通过在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>中以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>为中心对像素进行加权求和得到，加权使用的权重为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{V}]_{i, j, a, b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<h3 id="平移不变性">平移不变性</h3>
<p><u><em><strong>引用上述的第一个原则：平移不变性。</strong></em></u></p>
<p>这意味着检测对象在输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">X</span></span></span></span>中的平移，应该仅导致隐藏表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">H</mi></mrow><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">H</span></span></span></span>中的平移。也就是说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">V</mi></mrow><annotation encoding="application/x-tex">\mathsf{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf" style="margin-right:0.01389em;">V</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">U</mi></mrow><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">U</span></span></span></span>实际上不依赖于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>的值，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo>=</mo><mo stretchy="false">[</mo><mi mathvariant="bold">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{V}]_{i, j, a, b} = [\mathbf{V}]_{a, b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf" style="margin-right:0.01597em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">U</mi></mrow><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">U</span></span></span></span>是一个常数，比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>。因此，我们可以简化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">H</mi></mrow><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">H</span></span></span></span>定义为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>u</mi><mo>+</mo><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>b</mi></munder><mo stretchy="false">[</mo><mi mathvariant="bold">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">[</mo><mi mathvariant="bold">X</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mi>b</mi></mrow></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j} = u + \sum_a\sum_b [\mathbf{V}]_{a, b} [\mathbf{X}]_{i+a, j+b}.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.3521em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathbf" style="margin-right:0.01597em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathbf">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p>
<p>这就是<em><strong>卷积</strong></em>（convolution）。我们是在使用系数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{V}]_{a, b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf" style="margin-right:0.01597em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>对位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>附近的像素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i+a, j+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>进行加权得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>注意，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{V}]_{a, b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf" style="margin-right:0.01597em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的系数比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{V}]_{i, j, a, b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>少很多，因为前者不再依赖于图像中的位置。</p>
<h3 id="局部性">局部性</h3>
<p><u><em><strong>引用上述的第二个原则：局部性。</strong></em></u></p>
<p>如上所述，为了收集用来训练参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的相关信息，我们不应偏离到距<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>很远的地方。这意味着在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">|a|&gt; \Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">|b| &gt; \Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span>的范围之外，我们可以设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">[\mathbf{V}]_{a, b} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf" style="margin-right:0.01597em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。因此，我们可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>重写为：</p>
<p>\begin{equation}[\mathbf{H}]_{i, j} = u + \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} [\mathbf{V}]_{a, b}  [\mathbf{X}]_{i+a, j+b} \label{convolutional layer} \end{equation}
</p>
<p>简而言之，上述公式就是一个<em><strong>卷积层</strong></em>（convolutional layer），而卷积神经网络是包含卷积层的一类特殊的神经网络。</p>
<p>在深度学习研究中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">V</mi></mrow><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">V</span></span></span></span>被称为<em><strong>卷积核</strong></em>（convolution kernel）或者<em><strong>滤波器</strong></em>（filter），亦或简单地称之为该<u>卷积层的<em><strong>权重</strong></em></u>，通常该权重是可学习的参数。</p>
<p>当图像处理的局部区域很小时，卷积神经网络与多层感知机的训练差异可能是巨大的：以前，多层感知机可能需要数十亿个参数来表示网络中的一层，而现在卷积神经网络通常只需要几百个参数，而且不需要改变输入或隐藏表示的维数。</p>
<p>参数大幅减少的代价是，我们的特征现在是平移不变的，并且当确定每个隐藏活性值时，每一层只包含局部的信息。</p>
<p>以上所有的权重学习都将依赖于<u><strong>归纳偏置</strong></u>。当这种偏置与现实<u>相符时</u>，我们就能得到样本有效的模型，并且这些模型能很好地泛化到未知数据中。但如果这偏置与现实<u>不符时</u>，比如当图像不满足平移不变时，我们的模型可能难以拟合我们的训练数据。</p>
<h2 id="卷积-convolution">卷积（convolution）</h2>
<h3 id="为什么称为-卷积">为什么称为“卷积”</h3>
<p>为什么上面的操作被称为卷积（convolution）。</p>
<p>在数学中，两个函数（比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo>:</mo><msup><mi mathvariant="double-struck">R</mi><mi>d</mi></msup><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">f, g: \mathbb{R}^d \to \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>）之间的“卷积”被定义为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∗</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∫</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">z</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi mathvariant="bold">z</mi><mo stretchy="false">)</mo><mi>d</mi><mi mathvariant="bold">z</mi></mrow><annotation encoding="application/x-tex">(f * g)(\mathbf{x}) = \int f(\mathbf{z}) g(\mathbf{x}-\mathbf{z}) d\mathbf{z}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2222em;vertical-align:-0.8622em;"></span><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">z</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">z</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathbf">z</span></span></span></span></span></p>
<p>也就是说，卷积是当把一个函数“翻转”并移位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span></span></span></span>时，测量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>之间的重叠。</p>
<p>当为离散对象时，积分就变成求和。例如，对于由索引为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>的、平方可和的、无限维向量集合中抽取的向量，我们得到以下定义：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∗</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>a</mi></munder><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f * g)(i) = \sum_a f(a) g(i-a)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3em;vertical-align:-1.25em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></span></p>
<p>对于二维张量，则为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>的索引<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>的索引<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-a, j-b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>上的对应加和：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∗</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>b</mi></munder><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f * g)(i, j) = \sum_a\sum_b f(a, b) g(i-a, j-b)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3521em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span></p>
<p>这看起来类似于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>重写后的公式，但有一个主要区别：这里不是使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i+a, j+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>，而是使用差值。然而，这种区别是表面的，因为我们总是可以匹配两个公式之间的符号。我们在公式\eqref{convolutional layer}（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{H}]_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>重写后的公式）中的原始定义更正确地描述了<em><strong>互相关</strong></em>（cross-correlation）。</p>
<h3 id="通道-channel">通道（channel）</h3>
<p>实际上，图像不是二维张量，而是一个由高度、宽度和颜色组成的三维张量，比如包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>×</mo><mn>1024</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1024 \times 1024 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>个像素。</p>
<p>前两个轴与像素的空间位置有关，而第三个轴可以看作每个像素的多维表示。</p>
<p>因此，我们将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">X</mi></mrow><annotation encoding="application/x-tex">\mathsf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf">X</span></span></span></span>索引为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">X</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{X}]_{i, j, k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。由此卷积相应地调整为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{V}]_{a,b,c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，而不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="bold">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathbf{V}]_{a,b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathbf" style="margin-right:0.01597em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>此外，由于输入图像是三维的，我们的隐藏表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">H</mi></mrow><annotation encoding="application/x-tex">\mathsf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf">H</span></span></span></span>也最好采用三维张量。换句话说，对于每一个空间位置，我们想要采用一组而不是一个隐藏表示。这样一组隐藏表示可以想象成一些互相堆叠的二维网格。因此，我们可以把隐藏表示想象为一系列具有二维张量的***<u>通道</u>***（channel）。</p>
<p>这些通道有时也被称为***<u>特征映射</u>***（feature maps），因为每个通道都向后续层提供一组空间化的学习特征。</p>
<p>直观上可以想象在靠近输入的底层，一些通道专门识别边缘，而一些通道专门识别纹理。</p>
<p>为了支持输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">X</mi></mrow><annotation encoding="application/x-tex">\mathsf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf">X</span></span></span></span>和隐藏表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">H</mi></mrow><annotation encoding="application/x-tex">\mathsf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf">H</span></span></span></span>中的多个通道，我们可以在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">V</mi></mrow><annotation encoding="application/x-tex">\mathsf{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf" style="margin-right:0.01389em;">V</span></span></span></span>中添加第四个坐标，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">V</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{V}]_{a, b, c, d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">V</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。综上所述，</p>
<p>\begin{equation}[\mathsf{H}]_{i,j,d} = \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} \sum_c [\mathsf{V}]_{a, b, c, d} [\mathsf{X}]_{i+a, j+b, c} \label{eq_conv-layer-channels} \end{equation}
</p>
<p>其中隐藏表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">H</mi></mrow><annotation encoding="application/x-tex">\mathsf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf">H</span></span></span></span>中的索引<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>表示输出通道，而随后的输出将继续以三维张量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">H</mi></mrow><annotation encoding="application/x-tex">\mathsf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf">H</span></span></span></span>作为输入进入下一个卷积层。</p>
<p>所以，上式\eqref{eq_conv-layer-channels}可以定义具有多个通道的卷积层，而其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">V</mi></mrow><annotation encoding="application/x-tex">\mathsf{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf" style="margin-right:0.01389em;">V</span></span></span></span>是该卷积层的权重。</p>
<h2 id="互相关运算">互相关运算</h2>
<p>在卷积层中，<u>输入张量</u>和<u>核张量</u>通过<u><strong>互相关运算</strong></u>（cross-correlation）产生输出张量。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/correlation.svg" alt="../_images/correlation.svg"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>输入是高度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>、宽度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>的二维张量（即形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>）。</p>
</li>
<li class="lvl-2">
<p>卷积核的高度和宽度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，则卷积核窗口（或卷积窗口）的形状由内核的高度和宽度决定（即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>）。</p>
</li>
</ul>
<p>在二维互相关运算中，卷积窗口从输入张量的左上角开始，<u><strong>从左到右、从上到下</strong></u>滑动。</p>
<p>当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的<u><strong>输出张量值</strong></u>。</p>
<p>在如上例子中，输出张量的四个元素由二维互相关运算得到，这个输出高度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>、宽度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，如下所示：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo>×</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>19</mn><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mn>1</mn><mo>×</mo><mn>0</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>5</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>25</mn><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mn>3</mn><mo>×</mo><mn>0</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>6</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>7</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>37</mn><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mn>4</mn><mo>×</mo><mn>0</mn><mo>+</mo><mn>5</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>7</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>8</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>43.</mn></mrow><annotation encoding="application/x-tex">0\times0+1\times1+3\times2+4\times3=19,\\
1\times0+2\times1+4\times2+5\times3=25,\\
3\times0+4\times1+6\times2+7\times3=37,\\
4\times0+5\times1+7\times2+8\times3=43.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">19</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">25</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">37</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">43.</span></span></span></span></span></p>
<p>注意，输出大小略小于输入大小。这是因为卷积核的宽度和高度大于1，而卷积核只与图像中每个大小完全适合的位置进行互相关运算。</p>
<p>所以，输出大小等于输入大小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>×</mo><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">n_h \times n_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>减去卷积核大小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">k_h \times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n_h-k_h+1) \times (n_w-k_w+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>这是因为我们需要足够的空间在图像上“移动”卷积核。</p>
<blockquote>
<p><u><em><strong>如何通过在图像边界周围填充零来保证有足够的空间移动卷积核，从而保持输出大小不变。</strong></em></u></p>
</blockquote>
<p>卷积层中的两个被训练的参数是卷积核权重（weight）和标量偏置（bias）</p>
<h3 id="从数据中学习卷积核的参数">从数据中学习卷积核的参数</h3>
<p>当有了更复杂数值的卷积核，或者连续的卷积层时，我们不可能手动设计滤波器。</p>
<p>可以通过仅查看“输入-输出”来学习由<code>X</code>生成<code>Y</code>的卷积核。 我们先构造一个卷积层，并将其卷积核初始化为随机张量。接下来，在每次迭代中，我们比较<code>Y</code>与卷积层输出的平方误差，然后计算梯度来更新卷积核。</p>
<blockquote>
<p>为了与深度学习文献中的标准术语保持一致，我们将继续把“互相关运算”称为**<u><mark>卷积运算</mark></u><strong>，尽管严格地说，它们略有不同。 此外，对于卷积核张量上的权重，我们称其为</strong>*<u>元素</u>***。</p>
</blockquote>
<p>**<u>特征映射</u>**可以被视为一个输入映射到下一层的空间维度的转换器。</p>
<p>在卷积神经网络中，对于某一层的任意元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，其<em><strong>感受野</strong></em>（receptive field）是指在前向传播期间可能影响<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>计算的所有元素（来自所有先前层）。</p>
<p>请注意，感受野可能大于输入的实际大小。用以上输入（3 * 3）以及卷积核（2 * 2）为例来解释感受野：</p>
<p>给定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>卷积核，阴影输出元素值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>19</mn></mrow><annotation encoding="application/x-tex">19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">19</span></span></span></span>的感受野是输入阴影部分的四个元素。</p>
<p>假设之前输出为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Y</mi></mrow><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span>，其大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，现在我们在其后<u>附加一个卷积层</u>，该卷积层以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Y</mi></mrow><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span>为输入，输出单个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>。</p>
<p>在这种情况下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Y</mi></mrow><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span>上的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>的感受野包括<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Y</mi></mrow><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span>的所有<u>四个元素</u>，而输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Y</mi></mrow><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span>的感受野包括最初所有九个输入元素。</p>
<p>因此，当一个特征图中的任意元素需要检测更广区域的输入特征时，我们可以构建一个更深的网络。</p>
<h2 id="填充-padding-和步幅-stride">填充（padding）和步幅（stride）</h2>
<p>假设以下情景：</p>
<p>有时，在应用了连续的卷积之后，我们最终得到的<u>输出远小于输入大小</u>。这是由于卷积核的宽度和高度<u>通常大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></u>所导致的。比如，一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>240</mn><mo>×</mo><mn>240</mn></mrow><annotation encoding="application/x-tex">240 \times 240</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">240</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">240</span></span></span></span>像素的图像，经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5 \times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>的卷积后，将减少到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>200</mn><mo>×</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">200 \times 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">200</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">200</span></span></span></span>像素。如此一来，原始图像的<u>边界丢失了许多有用信息</u>。而***<u>填充</u><em><strong>是解决此问题最有效的方法；有时，我们可能希望大幅降低图像的宽度和高度。例如，如果我们发现原始的</strong>输入分辨率十分冗余</em>*。***<u>步幅</u>***则可以在这类情况下提供帮助。</p>
<h3 id="填充-padding">填充（padding）</h3>
<p><u><strong><em>填充</em>（padding）</strong></u>：在输入图像的边界填充元素（通常填充元素是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）。</p>
<p>在下图中，我们将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>输入填充到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5 \times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，那么它的输出就增加为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/conv-pad.svg" alt="../_images/conv-pad.svg"></p>
<p>通常，如果我们添加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">p_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>行填充（大约一半在顶部，一半在底部）和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">p_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>列填充（左侧大约一半，右侧一半），则输出形状将为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><msub><mi>p</mi><mi>h</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><msub><mi>p</mi><mi>w</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>这意味着输出的高度和宽度将分别增加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">p_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">p_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>在许多情况下，我们需要设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub><mo>=</mo><msub><mi>k</mi><mi>h</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_h=k_h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>w</mi></msub><mo>=</mo><msub><mi>k</mi><mi>w</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_w=k_w-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，使输入和输出<u>具有相同的高度和宽度</u>。这样可以在构建网络时更容易地<u>预测每个图层的输出形状</u>。</p>
<p>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">k_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是奇数，我们将在高度的两侧填充<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">p_h/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span>行。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">k_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是偶数，则一种可能性是在输入顶部填充<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mi>p</mi><mi>h</mi></msub><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil p_h/2\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>行，在底部填充<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mi>p</mi><mi>h</mi></msub><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor p_h/2\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span>行（<mark><u>一个向上取整，一个向下取整</u></mark>）。同理，我们填充宽度的两侧。</p>
<p>卷积神经网络中<u><mark>卷积核的高度和宽度</mark></u>通常为<u><strong>奇数</strong></u>，例如1、3、5或7。选择奇数的好处是，保持空间维度的同时，我们可以<u>在顶部和底部填充相同数量的行</u>，<u>在左侧和右侧填充相同数量的列</u>。</p>
<p>此外，使用奇数的核大小和填充大小也提供了书写上的便利。对于任何二维张量<code>X</code>，当满足：</p>
<ol>
<li class="lvl-3">
<p>卷积核的大小是奇数；</p>
</li>
<li class="lvl-3">
<p>所有边的填充行数和列数相同；</p>
</li>
<li class="lvl-3">
<p>输出与输入具有相同高度和宽度</p>
</li>
</ol>
<p>则可以得出：输出<code>Y[i, j]</code>是通过以输入<code>X[i, j]</code>为中心，与卷积核进行互相关计算得到的。</p>
<p>当卷积核的高度和宽度不同时，我们可以填充不同的高度和宽度，使输出和输入具有相同的高度和宽度。在如下示例中，我们使用高度为5，宽度为3的卷积核，高度和宽度两边的填充分别为2和1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># padding=(2, 1)：表示在行方向上，高处与低处都要填充2行，在列方向上，左边和右边都需要填充1行</span></span><br><span class="line"><span class="comment"># Ph = Kh - 1 = 4; Pw = Kw - 1 = 2</span></span><br><span class="line">conv2d = nn.Conv2D(<span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：(8, 8)</span></span><br></pre></td></tr></table></figure>
<h3 id="步幅-stride">步幅（stride）</h3>
<p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。在前面的例子中，我们默认每次滑动一个元素。但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素。</p>
<p>我们将每次滑动元素的数量称为***<u>步幅</u>***（stride）。到目前为止，我们只使用过高度或宽度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的步幅，那么如何使用较大的步幅呢？</p>
<p>下图是垂直步幅为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，水平步幅为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>的二维互相关运算。着色部分是输出元素以及用于输出计算的输入和内核张量元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>0</mn><mo>+</mo><mn>0</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">0\times0+0\times1+1\times2+2\times3=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mn>0</mn><mo>+</mo><mn>6</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>0</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">0\times0+6\times1+0\times2+0\times3=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>。</p>
<p>可以看到，为了计算输出中第一列的第二个元素和第一行的第二个元素，卷积窗口分别向下滑动三行和向右滑动两列。但是，当卷积窗口继续向右滑动两列时，没有输出，因为输入元素无法填充窗口（除非我们添加另一列填充）。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/conv-stride.svg" alt="../_images/conv-stride.svg"></p>
<p>通常，当垂直步幅为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">s_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、水平步幅为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">s_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，输出形状为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><msub><mi>p</mi><mi>h</mi></msub><mo>+</mo><msub><mi>s</mi><mi>h</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>h</mi></msub><mo stretchy="false">⌋</mo><mo>×</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><msub><mi>p</mi><mi>w</mi></msub><mo>+</mo><msub><mi>s</mi><mi>w</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>w</mi></msub><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌋</span></span></span></span></span></p>
<p>如果我们设置了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub><mo>=</mo><msub><mi>k</mi><mi>h</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_h=k_h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>w</mi></msub><mo>=</mo><msub><mi>k</mi><mi>w</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_w=k_w-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则输出形状将简化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>+</mo><msub><mi>s</mi><mi>h</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>h</mi></msub><mo stretchy="false">⌋</mo><mo>×</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>w</mi></msub><mo>+</mo><msub><mi>s</mi><mi>w</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>w</mi></msub><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor(n_h+s_h-1)/s_h\rfloor \times \lfloor(n_w+s_w-1)/s_w\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌋</span></span></span></span>。</p>
<p>更进一步，如果输入的高度和宽度可以被垂直和水平步幅整除，则输出形状将为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>h</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>w</mi></msub><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>w</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n_h/s_h) \times (n_w/s_w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2D(<span class="number">1</span>, kernel_size=(<span class="number">3</span>, <span class="number">5</span>), padding=(<span class="number">0</span>, <span class="number">1</span>), strides=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：(2, 2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了简洁起见，当输入高度和宽度两侧的填充数量分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">p_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">p_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，我们称之为填充<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>p</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>w</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p_h, p_w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub><mo>=</mo><msub><mi>p</mi><mi>w</mi></msub><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p_h = p_w = p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>时，填充是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>。同理，当高度和宽度上的步幅分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">s_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">s_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，我们称之为步幅<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>w</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_h, s_w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。特别地，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>h</mi></msub><mo>=</mo><msub><mi>s</mi><mi>w</mi></msub><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s_h = s_w = s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>时，我们称步幅为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>。<u><strong>默认情况下，填充为0，步幅为1</strong></u>。在实践中，我们<u><strong>很少使用不一致的步幅或填充</strong></u>，也就是说，我们通常有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub><mo>=</mo><msub><mi>p</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">p_h = p_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>h</mi></msub><mo>=</mo><msub><mi>s</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">s_h = s_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</blockquote>
<h2 id="多输入多输出通道">多输入多输出通道</h2>
<h3 id="多输入通道-单输出">多输入通道-单输出</h3>
<p>当输入包含多个通道时，需要构造一个与输入数据<u><strong>具有相同输入通道数</strong></u>的<mark>卷积核</mark>，以便与输入数据进行互相关运算。假设输入的通道数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么卷积核的输入通道数也需要为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如果卷积核的窗口形状是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">k_h\times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>时，我们可以把卷积核看作形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">k_h\times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的二维张量。</p>
<p>然而，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c_i&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>时，我们卷积核的每个输入通道将包含形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">k_h\times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的张量。将这些张量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>连结在一起可以得到形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>×</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">c_i\times k_h\times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的卷积核。由于输入和卷积核都有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个通道，我们可以<u><strong>对每个通道</strong></u>输入的二维张量和卷积核的二维张量<u><strong>进行互相关运算</strong></u>，<u><strong>再对通道求和</strong></u>（将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的结果相加）得到二维张量。这是多通道输入和多输入通道卷积核之间进行二维互相关运算的结果。</p>
<p>如下图中，一个具有两个输入通道的二维互相关运算的示例。阴影部分是第一个输出元素以及用于计算这个输出的输入和核张量元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>5</mn><mo>×</mo><mn>4</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>56</mn></mrow><annotation encoding="application/x-tex">(1\times1+2\times2+4\times3+5\times4)+(0\times0+1\times1+3\times2+4\times3)=56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">56</span></span></span></span>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/conv-multi-in.svg" alt="../_images/conv-multi-in.svg"></p>
<h3 id="多输出通道">多输出通道</h3>
<p>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">c_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别表示<u>输入和输出通道的数目</u>，并让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">k_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为卷积核的高度和宽度。为了获得多个通道的输出，我们可以<u><strong>为每个输出通道创建一个</strong></u>形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>×</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">c_i\times k_h\times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的<u><strong>卷积核张量</strong></u>，这样卷积核的形状是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>o</mi></msub><mo>×</mo><msub><mi>c</mi><mi>i</mi></msub><mo>×</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">c_o\times c_i\times k_h\times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p>
<h3 id="1-times-1-卷积层"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 卷积层</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub><mo>=</mo><msub><mi>k</mi><mi>w</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k_h = k_w = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，看起来似乎没有多大意义。毕竟，卷积的本质是有效提取相邻像素间的相关特征，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积显然没有此作用。尽管如此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>仍然十分流行，经常包含在复杂深层网络的设计中。</p>
<p>因为使用了最小窗口，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积失去了<mark>卷积层的特有能力</mark>——在高度和宽度维度上，<u><strong>识别相邻元素间相互作用</strong></u>的能力。</p>
<p>其实<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积的<u><strong>唯一计算</strong></u>发生在<u>通道上</u>。</p>
<p>如下图，展示了使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积核与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>个输入通道和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>个输出通道的互相关计算。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/conv-1x1.svg" alt="../_images/conv-1x1.svg"></p>
<p>这里输入和输出具有相同的高度和宽度，输出中的每个元素都是从输入图像中同一位置的元素的线性组合。</p>
<p>我们可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层看作在每个像素位置应用的全连接层，以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个输入值转换为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">c_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个输出值。</p>
<p>因为这仍然是一个卷积层，所以跨像素的权重是一致的。同时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层需要的权重维度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>o</mi></msub><mo>×</mo><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_o\times c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，再额外加上一个偏置。</p>
<h2 id="汇聚层-pooling-池运算">汇聚层（pooling）|池运算</h2>
<p><u><em><strong>汇聚层具有双重目的：降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性。</strong></em></u></p>
<h3 id="最大汇聚层和平均汇聚层">最大汇聚层和平均汇聚层</h3>
<p>与卷积层类似，汇聚层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口（有时称为***<u>汇聚窗口</u>***）遍历的每个位置计算一个输出。</p>
<p>然而，不同于卷积层中的输入与卷积核之间的互相关计算，<u><strong>汇聚层不包含参数</strong></u>。</p>
<p>相反，<u><strong>池运算是确定性的</strong></u>，我们通常计算汇聚窗口中所有元素的<u><strong>最大值或平均值</strong></u>。这些操作分别称为*<u><strong>最大汇聚层</strong></u><em>（maximum pooling）和</em><u><strong>平均汇聚层</strong></u>*（average pooling）。</p>
<p>在这两种情况下，与互相关运算符一样，汇聚窗口从输入张量的左上角开始，从左往右、从上往下的在输入张量内滑动。在汇聚窗口到达的每个位置，它计算该窗口中输入子张量的<u>最大值或平均值</u>。计算最大值或平均值是<u>取决于</u>使用了最大汇聚层还是平均汇聚层。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/pooling.svg" alt="../_images/pooling.svg"></p>
<p>上图中的输出张量的高度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，宽度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。这四个元素为每个汇聚窗口中的最大值：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>7</mn><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8.</mn><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">\max(0, 1, 3, 4)=4,\\
\max(1, 2, 4, 5)=5,\\
\max(3, 4, 6, 7)=7,\\
\max(4, 5, 7, 8)=8.\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">4</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">5</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8.</span></span><span class="mspace newline"></span></span></span></span></p>
<p><mark>汇聚窗口形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>的汇聚层称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>汇聚层，汇聚操作称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>汇聚。</mark></p>
<p>与卷积层一样，汇聚层也可以通过<u><strong>填充和步幅</strong></u>来<u>改变输出形状</u>。默认情况下，深度学习框架中的<u>步幅与汇聚窗口的大小相同</u>。</p>
<p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着<u><strong>汇聚层的输出通道数与输入通道数相同</strong></u>。</p>
<h2 id="lenet：识别图像中的手写数字">LeNet：识别图像中的手写数字</h2>
<p>LeNet取得了与支持向量机（support vector machines）性能相媲美的成果，成为<mark>监督学习</mark>的主流方法。 LeNet被广泛用于自动取款机（ATM）机中，帮助识别处理支票的数字。</p>
<h3 id="lenet"><a href="http://zh.d2l.ai/chapter_convolutional-neural-networks/lenet.html#id2">LeNet ¶</a></h3>
<p>总体来看，LeNet（LeNet-5）由两个部分组成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>卷积编码器</strong></u>：由两个卷积层组成;</p>
</li>
<li class="lvl-2">
<p><u><strong>全连接层密集块</strong></u>：由三个全连接层组成。</p>
</li>
</ul>
<p>架构如下图所示：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/lenet.svg" alt="../_images/lenet.svg"></p>
<p>LeNet中的数据流。输入是手写数字，输出为10种可能结果的概率。</p>
<p>每个卷积块中的基本单元是一个卷积层、一个sigmoid激活函数和平均汇聚层。请注意，虽然ReLU和最大汇聚层更有效，但它们在20世纪90年代还没有出现。每个卷积层使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>卷积核和一个sigmoid激活函数。这些层将输入映射到多个二维特征输出，通常同时增加通道的数量。第一卷积层有6个输出通道，而第二个卷积层有16个输出通道。每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>池操作（步幅2）通过<u>空间下采样</u><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>将维数减少4倍。卷积的输出形状由<u><strong>批量大小、通道数、高度、宽度决定</strong></u>。</p>
<p>为了将卷积块的输出传递给稠密块，我们必须在小批量中展平每个样本。换言之，我们将这个<u><strong>四维输入</strong></u>转换成全连接层所期望的二维输入。这里的二维表示的<u><strong>第一个维度索引小批量中的样本</strong></u>，<u><strong>第二个维度给出每个样本的平面向量表示</strong></u>。LeNet的稠密块有三个全连接层，分别有120、84和10个输出。因为我们在执行分类任务，所以输出层的10维对应于最后输出结果的数量。</p>
<p>通过下面的LeNet代码，可以看出用深度学习框架实现此类模型非常简单。我们只需要实例化一个<code>Sequential</code>块并将需要的层连接在一起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, gluon, init, np, npx</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line">net = nn.Sequential()</span><br><span class="line">net.add(nn.Conv2D(channels=<span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Conv2D(channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        <span class="comment"># 默认情况下，“Dense”会自动将形状为（批量大小，通道数，高度，宽度）的输入，</span></span><br><span class="line">        <span class="comment"># 转换为形状为（批量大小，通道数*高度*宽度）的输入</span></span><br><span class="line">        nn.Dense(<span class="number">120</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.Dense(<span class="number">84</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.Dense(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们对原始模型做了一点小改动，去掉了最后一层的高斯激活。除此之外，这个网络与最初的LeNet-5一致。</p>
</blockquote>
<p>下图为简化版的LeNet示意图：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/lenet-vert.svg" alt="../_images/lenet-vert.svg"></p>
<p>打印出每层的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conv0 output shape:  (1, 6, 28, 28)</span><br><span class="line">pool0 output shape:  (1, 6, 14, 14)</span><br><span class="line">conv1 output shape:  (1, 16, 10, 10)</span><br><span class="line">pool1 output shape:  (1, 16, 5, 5)</span><br><span class="line">dense0 output shape:         (1, 120)</span><br><span class="line">dense1 output shape:         (1, 84)</span><br><span class="line">dense2 output shape:         (1, 10)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，在整个卷积块中，与上一层相比，每一层特征的高度和宽度都减小了。</p>
<p>第一个卷积层使用2个像素的填充，来补偿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5 \times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>卷积核导致的特征减少。</p>
<p>相反，第二个卷积层没有填充，因此高度和宽度都减少了4个像素。</p>
<p>随着层叠的上升，通道的数量从输入时的1个，增加到第一个卷积层之后的6个，再到第二个卷积层之后的16个。</p>
<p>同时，每个汇聚层的高度和宽度都减半。最后，每个全连接层减少维数，最终输出一个维数与结果分类数相匹配的输出。</p>
</blockquote>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>图像<u><strong>的平移不变性</strong></u>使我们以相同的方式处理局部图像，而不在乎它的位置。</p>
</li>
<li class="lvl-2">
<p><u><strong>局部性</strong></u>意味着计算相应的隐藏表示只需一小部分局部图像像素。</p>
</li>
<li class="lvl-2">
<p>在图像处理中，卷积层通常比全连接层需要<u>更少的参数</u>，但依旧获得高效用的模型。</p>
</li>
<li class="lvl-2">
<p>卷积神经网络（CNN）是一类特殊的神经网络，它可以<u>包含多个卷积层</u>。</p>
</li>
<li class="lvl-2">
<p>多个输入和输出通道使模型在每个空间位置可以获取图像的<mark>多方面特征</mark>。</p>
</li>
<li class="lvl-2">
<p>二维卷积层的核心计算是二维<u><strong>互相关运算</strong></u>。<u>最简单的形式</u>是，对二维输入数据和卷积核执行互相关操作，然后添加一个偏置。</p>
</li>
<li class="lvl-2">
<p>我们可以设计一个<u><strong>卷积核</strong></u>来<mark>检测图像的边缘</mark>。</p>
</li>
<li class="lvl-2">
<p>我们可以<u>从数据中学习<mark>卷积核</mark>的参数</u>。</p>
</li>
<li class="lvl-2">
<p>学习卷积核时，无论用严格卷积运算或互相关运算，卷积层的输出不会受太大影响。</p>
</li>
<li class="lvl-2">
<p>当需要检测输入特征中更广区域时，我们可以构建一个更深的卷积网络。</p>
</li>
<li class="lvl-2">
<p><mark>填充</mark>可以<u><strong>增加输出的高度和宽度</strong></u>。这常用来使输出与输入具有相同的高和宽。</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>步幅</mark>可以<u><strong>减小输出的高和宽</strong></u>，例如输出的高和宽仅为输入的高和宽的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">1/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal">n</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>是一个大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的整数）。</p>
</li>
<li class="lvl-2">
<p>填充和步幅可用于<u>有效地调整</u>数据的维度。</p>
</li>
<li class="lvl-2">
<p>多输入多输出通道可以用来扩展卷积层的模型。</p>
</li>
<li class="lvl-2">
<p>当以每像素为基础应用时，<mark><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层</mark>相当于<u><strong>全连接层</strong></u>。</p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层通常用于调整网络层的通道数量和控制模型复杂性。</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于给定输入元素，<u><strong>最大汇聚层</strong>会输出该窗口内的最大值</u>，<u><strong>平均汇聚层</strong>会输出该窗口内的平均值</u>。</p>
</li>
<li class="lvl-2">
<p>汇聚层的主要优点之一是<u>减轻卷积层对位置的过度敏感</u>。</p>
</li>
<li class="lvl-2">
<p>我们可以<u>指定汇聚层的填充和步幅</u>。</p>
</li>
<li class="lvl-2">
<p>使用最大汇聚层以及大于1的步幅，可<u>减少空间维度</u>（如高度和宽度）。</p>
</li>
<li class="lvl-2">
<p>汇聚层的<u><strong>输出通道数与输入通道数相同</strong></u>。</p>
</li>
<li class="lvl-2">
<p>卷积神经网络（CNN）是一类使用<u><strong>卷积层</strong></u>的网络。</p>
</li>
<li class="lvl-2">
<p>在卷积神经网络中，我们组合使用<u><strong>卷积层、非线性激活函数和汇聚层</strong></u>。</p>
</li>
<li class="lvl-2">
<p>为了构造高性能的卷积神经网络，我们通常<u>对卷积层进行排列</u>，<mark>逐渐降低</mark>其表示的<u><strong>空间分辨率</strong></u>，同时<mark>增加</mark><u><strong>通道数</strong></u>。</p>
</li>
<li class="lvl-2">
<p>在传统的卷积神经网络中，卷积块编码得到的表征在输出之前需由一个或多个<u>全连接层进行处理</u>。</p>
</li>
<li class="lvl-2">
<p>LeNet是最早发布的卷积神经网络之一。</p>
</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>空间下采样是指在图像或特征图中减少样本点的数量，从而减小图像或特征图的尺寸。它是一种降低数据维度的方法，常用于计算机视觉和图像处理领域。空间下采样可以通过不同的操作来实现，其中最常见的方法是使用池化（pooling）操作。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>机器学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>ML</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>线性神经网络LNN</title>
    <url>/2023/05/14/University/AI/ML/%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CLNN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>线性神经网络LNN</h1>
<h2 id="线性回归">线性回归</h2>
<p><em>回归</em>（regression）是能为一个或多个自变量与因变量之间关系建模的一类方法。</p>
<p><u><em><strong>当我们想预测一个<span style="color: red;">数值</span>时，就会涉及到回归问题。</strong></em></u> | 但不是所有的<em>预测</em>都是回归问题。</p>
<h3 id="线性回归的基本元素">线性回归的基本元素</h3>
<p>训练集的每行数据（比如一次房屋交易相对应的数据）称为<em><strong>样本</strong></em>（sample）， 也可以称为<em><strong>数据点</strong></em>（data point）或<em><strong>数据样本</strong></em>（data instance）。</p>
<p>我们把试图预测的目标（比如预测房屋价格）称为<em><strong>标签</strong></em>（label）或<em><strong>目标</strong></em>（target）。 预测所依据的自变量（面积和房龄）称为<em><strong>特征</strong></em>（feature）或<em><strong>协变量</strong></em>（covariate）。</p>
<h3 id="线性模型">线性模型</h3>
<p>仿射变换：$$\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b.$$</p>
<ul class="lvl-0">
<li class="lvl-3">
<p>仿射变换的特点是通过加权和对特征进行<em><strong>线性变换</strong></em>（linear transformation）， 并通过偏置项来进行<em><strong>平移</strong></em>（translation）。</p>
</li>
</ul>
<p>当我们的输入包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>个特征时，我们将预测结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span>（通常使用“尖角”符号表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>的估计值）表示为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>=</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>w</mi><mi>d</mi></msub><msub><mi>x</mi><mi>d</mi></msub><mo>+</mo><mi>b</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\hat{y} = w_1  x_1 + ... + w_d  x_d + b.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span></span></span></span></span></p>
<p>进一步简化为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>=</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\hat{y} = \mathbf{w}^\top \mathbf{x} + b.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">X</span></span></span></span>的每一行是一个样本，每一列是一种特征。</p>
<p>在开始寻找最好的<em><strong>模型参数</strong></em>（model parameters）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>之前，我们还需要两个东西：（1）一种模型质量的<u><em><strong>度量方式</strong></em></u>；（2）一种能够更新模型以提高模型预测质量的方法。</p>
<h3 id="损失函数-loss-function">损失函数（loss function）</h3>
<p>回归问题中最常用的损失函数是平方误差函数。</p>
<p>当样本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的预测值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\hat{y}^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，其相应的真实标签为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">y^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>时，平方误差可以定义为以下公式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.04em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.354em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p>
<p>用线性模型拟合数据图示：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/fit-linreg.svg" alt="用线性模型拟合数据"></p>
<p>由于平方误差函数中的二次方项，估计值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\hat{y}^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>和观测值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">y^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>之间较大的差异将导致更大的损失。</p>
<p>为了度量模型在整个数据集上的质量，我们需计算在训练集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个样本上的损失均值（也等价于求和）。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.354em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p>
<p>在训练模型时，我们希望寻找一组参数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">w</mi><mo>∗</mo></msup><mo separator="true">,</mo><msup><mi>b</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{w}^*, b^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>），这组参数能最小化在所有训练样本上的总损失。如下式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">w</mi><mo>∗</mo></msup><mo separator="true">,</mo><msup><mi>b</mi><mo>∗</mo></msup><mo>=</mo><munder><mrow><mi mathvariant="normal">argmin</mi><mo>⁡</mo></mrow><mrow><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi></mrow></munder><mtext> </mtext><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}^*, b^* = \operatorname*{argmin}_{\mathbf{w}, b}\  L(\mathbf{w}, b).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9331em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8327em;vertical-align:-1.0827em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-2.1535em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">argmin</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0827em;"><span></span></span></span></span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p>
<p><em><strong><u>线性回归的解可以用一个公式简单地表达出来， 这类解叫作解析解（analytical solution）</u></strong></em></p>
<h3 id="随机梯度下降">随机梯度下降</h3>
<p>随机梯度下降：在损失函数递减的方向上更新参数来降低误差。</p>
<details>
    <summary ><span style="color: red;">梯度下降的用法</span></summary>
    <!-- 在这里输入您要隐藏的文本内容 -->
    <p>梯度下降最简单的用法是计算损失函数（数据集中所有样本的损失均值） 关于模型参数的导数（在这里也可以称为梯度）。 但实际中的执行可能会非常慢：因为在每一次更新参数之前，我们必须遍历整个数据集。 因此，我们通常会在每次需要计算更新的时候随机抽取一小批样本， 这种变体叫做*小批量随机梯度下降*（minibatch stochastic gradient descent）。</p>
</details>
<p>用下面的数学公式来表示这一更新过程（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi></mrow><annotation encoding="application/x-tex">\partial</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span>表示偏导数）：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4293em;vertical-align:-1.3217em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p>
<p>总结一下，算法的步骤如下：（1）初始化模型参数的值，如随机初始化；（2）从数据集中随机抽取小批量样本且在负梯度的方向上更新参数，并不断迭代这一步骤。</p>
<p>对于平方损失和仿射变换，我们可以明确地写成如下形式:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">w</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mi mathvariant="bold">w</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mi mathvariant="bold">w</mi></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="bold">w</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>b</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mi>b</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mi>b</mi></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \mathbf{w} &amp;\leftarrow \mathbf{w} -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{\mathbf{w}} l^{(i)}(\mathbf{w}, b) = \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right),\\ b &amp;\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_b l^{(i)}(\mathbf{w}, b)  = b - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.5434em;vertical-align:-2.5217em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.0217em;"><span style="top:-5.0217em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.5217em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.0217em;"><span style="top:-5.0217em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1611em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.5217em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>以上公式中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span></span></span></span>都是向量。</p>
<p>在这里，更优雅的向量表示法比系数表示法（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">w_1, w_2, \ldots, w_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）更具可读性。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\mathcal{B}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span></span>表示每个小批量中的样本数，这也称为<em>批量大小</em>（batch size）。</p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>表示<em>学习率</em>（learning rate）。</p>
</li>
<li class="lvl-2">
<p>批量大小和学习率的值通常是手动预先指定，而不是通过模型训练得到的。</p>
</li>
</ul>
<p>这些可以调整但不在训练过程中更新的参数称为<em>超参数</em>（hyperparameter）。</p>
<p><em>调参</em>（hyperparameter tuning）是选择超参数的过程。</p>
<p>超参数通常是我们根据训练迭代结果来调整的，而训练迭代结果是在独立的<em>验证数据集</em>（validation dataset）上评估得到的。</p>
<p>在训练了预先确定的若干迭代次数后（或者直到满足某些其他停止条件后），我们记录下模型参数的估计值，表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">w</mi><mo>^</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>b</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\mathbf{w}}, \hat{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1523em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>。</p>
<p><mark>泛化：找到一组参数，这组参数能够在我们从未见过的数据上实现较低的损失， 这一挑战被称为<em>泛化</em>（generalization）。</mark></p>
<h3 id="数据矢量化">数据矢量化</h3>
<p>在训练我们的模型时，我们经常希望能够同时处理整个小批量的样本。 为了实现这一点，需要我们对计算进行矢量化， 从而利用线性代数库，而不是在Python中编写开销高昂的for循环。</p>
<h2 id="正态分布与平方损失">正态分布与平方损失</h2>
<p>正态分布（normal distribution），也称为<em>高斯分布</em>（Gaussian distribution）。</p>
<p>简单的说，若随机变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>具有均值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span>和方差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>（标准差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>），其正态分布概率密度函数如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></msqrt></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (x - \mu)^2\right).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.1549em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9551em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9151em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0849em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p>
<p>均方误差损失函数（简称均方损失）可以用于线性回归的一个原因是：我们假设了观测中包含噪声，其中噪声服从正态分布。噪声正态分布如下式:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>ϵ</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">y = \mathbf{w}^\top \mathbf{x} + b + \epsilon,
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϵ</span><span class="mpunct">,</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon \sim \mathcal{N}(0, \sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.14736em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>因此，我们现在可以写出通过给定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span></span></span></span>观测到特定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>的<em>似然</em>（likelihood）：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mo>∣</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></msqrt></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>−</mo><mi>b</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">P(y \mid \mathbf{x}) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.1549em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9551em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9151em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0849em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p>
<p>现在，根据极大似然估计法，参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>的最优值是使整个数据集的<em>似然</em>最大的值：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>p</mi><mo stretchy="false">(</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">∣</mi><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">P(\mathbf y \mid \mathbf X) = \prod_{i=1}^{n} p(y^{(i)}|\mathbf{x}^{(i)}).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p>
<p>根据极大似然估计法选择的估计量称为<em><strong>极大似然估计量</strong></em>。虽然使许多指数函数的乘积最大化看起来很困难，但是我们可以在不改变目标的前提下，通过最大化似然对数来简化。</p>
<p>由于历史原因，优化通常是说最小化而不是最大化。我们可以改为<em><strong>最小化负对数似然</strong></em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-\log P(\mathbf y \mid \mathbf X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span></span></span></span>。</p>
<p>由此可以得到的数学公式是：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><msup><mrow><mo fence="true">(</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mi>b</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">-\log P(\mathbf y \mid \mathbf X) = \sum_{i=1}^n \frac{1}{2} \log(2 \pi \sigma^2) + \frac{1}{2 \sigma^2} \left(y^{(i)} - \mathbf{w}^\top \mathbf{x}^{(i)} - b\right)^2.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.04em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.354em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>现在我们只需要假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>是某个固定常数就可以忽略第一项，因为第一项不依赖于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>。</p>
</li>
<li class="lvl-2">
<p>现在第二项除了常数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\sigma^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>外，其余部分和前面介绍的均方误差是一样的。</p>
</li>
<li class="lvl-2">
<p>幸运的是，上面式子的解并不依赖于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>。</p>
</li>
</ul>
<p><u><em><strong>因此，在高斯噪声的假设下，最小化均方误差等价于对线性模型的极大似然估计。</strong></em></u></p>
<h2 id="从线性回归到深度网络">从线性回归到深度网络</h2>
<h3 id="神经网络图">神经网络图</h3>
<p>我们将线性回归模型描述为一个神经网络。 需要注意的是，该图只显示连接模式，即<u><strong>只显示每个输入如何连接到输出</strong></u>，隐去了权重和偏置的值。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/singleneuron.svg" alt="../_images/singleneuron.svg"></p>
<p>因此输入层中的<em>输入数</em>（或称为<em>特征维度</em>，feature dimensionality）为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>，网络的输出为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">o_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，因此输出层中的<em><strong>输出数</strong></em>是1。</p>
<p>需要注意的是，输入值都是已经给定的，并且只有一个<em><strong>计算</strong></em>神经元。 由于模型重点在发生计算的地方，所以通常我们在计算层数时<u>不考虑输入层</u>。 也就是说，上图中神经网络的<em><strong>层数</strong></em>为1。 我们可以将线性回归模型视为仅由<mark>单个人工神经元</mark>组成的神经网络，或称为<mark>单层神经网络</mark>。</p>
<h4 id="全连接层">全连接层</h4>
<p>对于线性回归，<u><strong>每个输入都与每个输出相连</strong></u>， 我们将这种变换（上图中的输出层） 称为<em><strong>全连接层</strong></em>（fully-connected layer）或称为<em><strong>稠密层</strong></em>（dense layer）。</p>
<h2 id="总结">总结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>机器学习模型中的关键要素是<u><strong>训练数据</strong></u>、<u><strong>损失函数</strong></u>、<u><strong>优化算法</strong></u>，还有<u><strong>模型本身</strong></u>。</p>
</li>
<li class="lvl-2">
<p><u><strong>矢量化</strong></u>使数学表达上更简洁，同时运行的更快。</p>
</li>
<li class="lvl-2">
<p><u><strong>最小化目标函数</strong></u>和执行<u><strong>极大似然估计</strong></u>等价。</p>
</li>
<li class="lvl-2">
<p>线性回归模型也是一个简单的神经网络。</p>
</li>
</ul>
<h1>Reference</h1>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="http://zh.d2l.ai/chapter_linear-networks/index.html">http://zh.d2l.ai/chapter_linear-networks/index.html</a></p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>机器学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>ML</tag>
        <tag>LNN</tag>
      </tags>
  </entry>
  <entry>
    <title>图像增广</title>
    <url>/2023/10/15/University/AI/CV/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%B9%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>图像增广</h1>
<blockquote>
<p>参考：<a href="http://zh.d2l.ai/chapter_computer-vision/image-augmentation.html">13.1. 图像增广 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></p>
</blockquote>
<p>图像增广在对训练图像进行一系列的随机变化之后，<strong>生成相似但不同的训练样本</strong>，从而扩大了训练集的规模。 此外，应用图像增广的原因是，随机改变训练样本可以<strong>减少模型对某些属性的依赖</strong>，从而<strong>提高模型的泛化能力</strong>。 例如，我们可以以不同的方式裁剪图像，使感兴趣的对象出现在不同的位置，减少模型对于对象出现位置的依赖。 我们还可以调整亮度、颜色等因素来降低模型对颜色的敏感度。</p>
<h2 id="常用的图像增广方法">常用的图像增广方法</h2>
<p>大多数图像增广方法都具有一定的随机性。</p>
<p><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_18_0.svg" alt="../_images/output_image-augmentation_7d0887_18_0.svg"></p>
<center>示例图像</center>
<h3 id="翻转和裁剪">翻转和裁剪</h3>
<p>左右翻转图像通常不会改变对象的类别。</p>
<p><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_42_0.svg" alt="../_images/output_image-augmentation_7d0887_42_0.svg"></p>
<center>左右翻转</center>
<p>上下翻转图像不如左右图像翻转那样常用。但是，至少对于以上示例图像，上下翻转不会妨碍识别。</p>
<p><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_54_0.svg" alt="../_images/output_image-augmentation_7d0887_54_0.svg"></p>
<center>上下翻转</center>
<ul class="lvl-0">
<li class="lvl-2">
<p>汇聚层（池化层）可以<strong>降低卷积层对目标位置的敏感性</strong>；</p>
</li>
<li class="lvl-2">
<p>通过对图像进行随机裁剪，使物体以不同的比例出现在图像的不同位置，也可以<strong>降低对目标位置的敏感度</strong>。</p>
</li>
</ul>
<p>下面的代码将随机裁剪一个面积为原始面积10%到100%的区域，该区域的宽高比从0.5～2之间随机取值。 然后，区域的宽度和高度都被缩放到200像素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shape_aug = torchvision.transforms.RandomResizedCrop(</span><br><span class="line">    (<span class="number">200</span>, <span class="number">200</span>), scale=(<span class="number">0.1</span>, <span class="number">1</span>), ratio=(<span class="number">0.5</span>, <span class="number">2</span>))</span><br><span class="line">apply(img, shape_aug)</span><br></pre></td></tr></table></figure>
<p><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_66_0.svg" alt="../_images/output_image-augmentation_7d0887_66_0.svg"></p>
<h3 id="改变颜色">改变颜色</h3>
<p>可以改变图像颜色的四个方面：<u><strong>亮度、对比度、饱和度和色调</strong></u></p>
<p>下图示例：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_78_0.svg" alt="../_images/output_image-augmentation_7d0887_78_0.svg"></th>
<th style="text-align:center"><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_90_0.svg" alt="../_images/output_image-augmentation_7d0887_90_0.svg"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_102_0.svg" alt="../_images/output_image-augmentation_7d0887_102_0.svg"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="结合多种图像增广方法">结合多种图像增广方法</h3>
<p>实践中，结合多种图像增广方法。</p>
<p><img src="http://zh.d2l.ai/_images/output_image-augmentation_7d0887_114_0.svg" alt="../_images/output_image-augmentation_7d0887_114_0.svg"></p>
<h2 id="使用图像增广进行训练">使用图像增广进行训练</h2>
<p>通常<strong>只对训练样本进行图像增广</strong>，且在预测过程中不使用随机操作的图像增广。</p>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>图像增广<u><strong>基于现有的训练数据生成随机图像</strong></u>，来<strong>提高模型的泛化能力</strong>。</p>
</li>
<li class="lvl-2">
<p>为了在预测过程中得到确切的结果，我们通常<strong>对训练样本只进行图像增广</strong>，而<strong>在预测过程中不使用带随机操作的图像增广</strong>。</p>
</li>
<li class="lvl-2">
<p>深度学习框架提供了许多不同的图像增广方法，这些方法<strong>可以被同时应用</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>图像增广</tag>
      </tags>
  </entry>
  <entry>
    <title>“现代”卷积神经网络CNN</title>
    <url>/2023/09/09/University/AI/ML/%E2%80%9C%E7%8E%B0%E4%BB%A3%E2%80%9D%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>—“现代”卷积神经网络CNN—</h1>
<p>包括以下架构模型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>AlexNet。它是第一个在大规模视觉竞赛中击败传统计算机视觉模型的大型神经网络；</p>
</li>
<li class="lvl-2">
<p>使用重复块的网络（VGG）。它利用许多重复的神经网络块；</p>
</li>
<li class="lvl-2">
<p>网络中的网络（NiN）。它重复使用由卷积层和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层（用来代替全连接层）来构建深层网络;</p>
</li>
<li class="lvl-2">
<p>含并行连结的网络（GoogLeNet）。它使用并行连结的网络，通过不同窗口大小的卷积层和最大汇聚层来并行抽取信息；</p>
</li>
<li class="lvl-2">
<p>残差网络（ResNet）。它通过残差块构建跨层的数据通道，是计算机视觉中最流行的体系架构；</p>
</li>
<li class="lvl-2">
<p>稠密连接网络（DenseNet）。它的计算成本很高，但给我们带来了更好的效果。</p>
</li>
</ul>
<h1>深度卷积神经网络（AlexNet）</h1>
<p>经典机器学习的流水线看起来更像下面这样：</p>
<ol>
<li class="lvl-3">
<p>获取一个有趣的数据集。在早期，收集这些数据集需要昂贵的传感器（在当时最先进的图像也就100万像素）。</p>
</li>
<li class="lvl-3">
<p>根据光学、几何学、其他知识以及偶然的发现，手工对特征数据集进行预处理。</p>
</li>
<li class="lvl-3">
<p>通过标准的特征提取算法，如SIFT（尺度不变特征变换） (<a href="http://zh.d2l.ai/chapter_references/zreferences.html#id102">Lowe, 2004</a>)和SURF（加速鲁棒特征） (<a href="http://zh.d2l.ai/chapter_references/zreferences.html#id7">Bay <em>et al.</em>, 2006</a>)或其他手动调整的流水线来输入数据。</p>
</li>
<li class="lvl-3">
<p>将提取的特征送入最喜欢的分类器中（例如线性模型或其它核方法），以训练分类器。</p>
</li>
</ol>
<h2 id="学习表征">学习表征</h2>
<p>事实上，Alex Krizhevsky、Ilya Sutskever和Geoff Hinton提出了一种新的<u><strong>卷积神经网络变体</strong></u><em><strong>AlexNet</strong></em>。在2012年ImageNet挑战赛中取得了轰动一时的成绩。AlexNet以Alex Krizhevsky的名字命名，他是论文 (<a href="http://zh.d2l.ai/chapter_references/zreferences.html#id88">Krizhevsky <em>et al.</em>, 2012</a>)的第一作者。</p>
<p>有趣的是，在网络的最底层，模型学习到了一些类似于传统滤波器的特征抽取器。 <a href="http://zh.d2l.ai/chapter_convolutional-modern/alexnet.html#fig-filters">图7.1.1</a>是从AlexNet论文 (<a href="http://zh.d2l.ai/chapter_references/zreferences.html#id88">Krizhevsky <em>et al.</em>, 2012</a>)复制的，描述了<u><strong>底层图像特征</strong></u>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/filters.png" alt="../_images/filters.png"></p>
<p>AlexNet的更高层建立在这些<u><strong>底层表示的基础上</strong></u>，以表示更大的特征，如眼睛、鼻子、草叶等等。而更高的层可以<u><strong>检测整个物体</strong></u>，如人、飞机、狗或飞盘。最终的<u><strong>隐藏神经元</strong></u>可以学习<u><strong>图像的综合表示</strong></u>，从而使属于不同类别的数据<u>易于区分</u>。</p>
<p><u><em><strong>深度卷积神经网络的突破可归因于两个关键因素：数据、硬件。</strong></em></u></p>
<h3 id="缺少的成分：数据">缺少的成分：数据</h3>
<p>包含许多特征的深度模型需要<u><strong>大量的有标签数据</strong></u>，才能显著优于基于<u><strong>凸优化</strong></u>的传统方法（如<u><strong>线性方法</strong></u>和<u><strong>核方法</strong></u>）。 然而，限于早期计算机有限的存储和90年代有限的研究预算，大部分研究只基于小的公开数据集。</p>
<h3 id="缺少的成分：硬件">缺少的成分：硬件</h3>
<p>深度学习对计算资源要求很高，训练可能需要<u><strong>数百个迭代轮数</strong></u>，每次迭代都需要通过代价高昂的许多<u><strong>线性代数层</strong></u>传递数据。这也是为什么在20世纪90年代至21世纪初，优化凸目标的简单算法是研究人员的首选。然而，用GPU训练神经网络改变了这一格局。<em><strong>图形处理器</strong></em>（Graphics Processing Unit，GPU）早年用来加速图形处理，使电脑游戏玩家受益。GPU可优化高吞吐量的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>矩阵和向量乘法，从而服务于基本的图形任务。幸运的是，这些数学运算与卷积层的计算惊人地相似。</p>
<p>当Alex Krizhevsky和Ilya Sutskever实现了可以在GPU硬件上运行的<u><strong>深度卷积神经网络</strong></u>时，一个重大突破出现了。他们意识到卷积神经网络中的计算瓶颈：<u><strong>卷积和矩阵乘法</strong></u>，都是可以在硬件上<u><strong>并行化</strong></u>的操作。</p>
<h2 id="alexnet">AlexNet</h2>
<p>AlexNet首次证明了<em><strong>学习到的特征</strong></em>可以超越<em><strong>手工设计的特征</strong></em>。</p>
<p>AlexNet使用了**<u>8层</u>**卷积神经网络。</p>
<p>AlexNet和LeNet的架构非常相似，如下图所示。（这里提供的是一个稍微精简版本的AlexNet，去除了当年需要两个小型GPU同时运算的设计特点。）</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/alexnet.svg" alt="从LeNet（左）到AlexNet（右）"></p>
<p>图中：<mark>从LeNet（左）到AlexNet（右）</mark></p>
<p>AlexNet和LeNet的设计理念非常相似，但也存在显著差异。</p>
<ol>
<li class="lvl-3">
<p>AlexNet比相对较小的LeNet5要深得多。AlexNet由八层组成：<u><strong>五个卷积层</strong></u>、<u><strong>两个全连接隐藏层</strong></u>和<u><strong>一个全连接输出层</strong></u>。</p>
</li>
<li class="lvl-3">
<p>AlexNet使用<u><strong>ReLU</strong></u>而不是<u><strong>sigmoid</strong></u>作为其激活函数。</p>
</li>
</ol>
<h3 id="模型设计">模型设计</h3>
<p>在AlexNet的第一层，卷积窗口的形状是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn><mo>×</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">11\times11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>。</p>
<p>由于ImageNet中大多数图像的宽和高比MNIST图像的<u>多10倍以上</u>，因此，需要一个更大的卷积窗口来捕获目标。</p>
<p>第二层中的卷积窗口形状被缩减为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，然后是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>。</p>
<p>此外，在第一层、第二层和第五层卷积层之后，加入窗口形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>、步幅为2的最大汇聚层。</p>
<p>而且，AlexNet的<u><strong>卷积通道数目</strong></u>是LeNet的<u>10倍</u>。</p>
<p>在最后一个卷积层后有两个<u>全连接层</u>，分别有<u><strong>4096个输出</strong></u>。</p>
<p>这两个巨大的全连接层拥有将<u>近1GB的模型参数</u>。</p>
<p>由于早期GPU显存有限，原版的AlexNet采用了双数据流设计，使得每个GPU只负责存储和计算模型的一半参数。幸运的是，现在GPU显存相对充裕，所以现在很少需要跨GPU分解模型。</p>
<h3 id="激活函数">激活函数</h3>
<p>此外，AlexNet将sigmoid激活函数改为<mark>更简单的</mark><u><strong>ReLU激活函数</strong></u>。 一方面，ReLU激活函数的<u>计算更简单</u>，它不需要如sigmoid激活函数那般复杂的求幂运算。 另一方面，当使用不同的参数初始化方法时，ReLU激活函数<u>使训练模型更加容易</u>。 当sigmoid激活函数的输出非常接近于0或1时，这些区域的梯度几乎为0，因此<u><strong>反向传播</strong></u><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>无法继续更新一些模型参数。 相反，ReLU激活函数在正区间的梯度总是1。 因此，如果模型参数没有正确初始化，sigmoid函数可能在正区间内得到几乎为0的梯度，从而使模型无法得到有效的训练。</p>
<h3 id="容量控制和预处理">容量控制和预处理</h3>
<p>AlexNet通过**<u>暂退法</u>**控制全连接层的<u>模型复杂度</u>，而LeNet只使用了<u><strong>权重衰减</strong></u>。 为了进一步扩充数据，AlexNet在训练时增加了大量的<u><strong>图像增强数据</strong></u>，如<u><em>翻转、裁切和变色</em></u>。 这使得模型更健壮，更大的样本量有效地<u><strong>减少了过拟合</strong></u>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> np, npx</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line">net = nn.Sequential()</span><br><span class="line"></span><br><span class="line">net.add(</span><br><span class="line">    <span class="comment"># 这里使用一个11*11的更大窗口来捕捉对象。</span></span><br><span class="line">    <span class="comment"># 同时，步幅为4，以减少输出的高度和宽度。</span></span><br><span class="line">    <span class="comment"># 另外，输出通道的数目远大于LeNet</span></span><br><span class="line">    nn.Conv2D(<span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数</span></span><br><span class="line">    nn.Conv2D(<span class="number">256</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 使用三个连续的卷积层和一个较小的卷积窗口。</span></span><br><span class="line">    <span class="comment"># 除了最后的卷积层，输出通道的数量进一步增加。</span></span><br><span class="line">    <span class="comment"># 前两个卷积层后不使用汇聚层来减小输入的高和宽</span></span><br><span class="line">    nn.Conv2D(<span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    nn.Conv2D(<span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    nn.Conv2D(<span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合</span></span><br><span class="line">    nn.Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    nn.Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000</span></span><br><span class="line">    nn.Dense(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>构造一个高度和宽度都为224的单通道数据，来观察每一层输出的形状。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.random.uniform(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">net.initialize()</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.name, <span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conv0 output shape:  (1, 96, 54, 54)</span><br><span class="line">pool0 output shape:  (1, 96, 26, 26)</span><br><span class="line">conv1 output shape:  (1, 256, 26, 26)</span><br><span class="line">pool1 output shape:  (1, 256, 12, 12)</span><br><span class="line">conv2 output shape:  (1, 384, 12, 12)</span><br><span class="line">conv3 output shape:  (1, 384, 12, 12)</span><br><span class="line">conv4 output shape:  (1, 256, 12, 12)</span><br><span class="line">pool2 output shape:  (1, 256, 5, 5)</span><br><span class="line">dense0 output shape:         (1, 4096)</span><br><span class="line">dropout0 output shape:       (1, 4096)</span><br><span class="line">dense1 output shape:         (1, 4096)</span><br><span class="line">dropout1 output shape:       (1, 4096)</span><br><span class="line">dense2 output shape:         (1, 10)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="读取数据集">读取数据集</h2>
<p>将AlexNet直接应用于Fashion-MNIST的一个问题是，[<strong>Fashion-MNIST图像的分辨率</strong>]（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>28</mn><mo>×</mo><mn>28</mn></mrow><annotation encoding="application/x-tex">28 \times 28</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">28</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">28</span></span></span></span>像素）(<strong>低于ImageNet图像。</strong>)<br>
为了解决这个问题，(<strong>我们将它们增加到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>224</mn><mo>×</mo><mn>224</mn></mrow><annotation encoding="application/x-tex">224 \times 224</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">224</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">224</span></span></span></span></strong>)（通常来讲<mark>这不是一个明智的做法</mark>，但在这里这样做是为了有效使用AlexNet架构）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br></pre></td></tr></table></figure>
<h2 id="训练alexnet">训练AlexNet <a href="http://zh.d2l.ai/chapter_convolutional-modern/alexnet.html#id16">¶</a></h2>
<p>现在AlexNet可以开始被训练了。与LeNet相比，这里的主要变化是<u>使用更小的学习速率</u>训练，这是因为网络更深更广、图像分辨率更高，训练卷积神经网络就更昂贵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.01</span>, <span class="number">10</span></span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loss 0.335, train acc 0.877, test acc 0.892</span><br><span class="line">4112.0 examples/sec on gpu(0)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/output_alexnet_180871_35_1.svg" alt="../_images/output_alexnet_180871_35_1.svg"></p>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>AlexNet的架构与LeNet相似，但使用了<u><strong>更多的卷积层和更多的参数</strong></u>来拟合大规模的ImageNet数据集。</p>
</li>
<li class="lvl-2">
<p>今天，AlexNet已经被更有效的架构所超越，但它是从浅层网络到深层网络的关键一步。</p>
</li>
<li class="lvl-2">
<p>尽管AlexNet的代码只比LeNet多出几行，但学术界花了很多年才接受深度学习这一概念，并应用其出色的实验结果。这也是由于缺乏有效的计算工具。</p>
</li>
<li class="lvl-2">
<p><u><strong>Dropout</strong></u>、<u><strong>ReLU</strong></u>和<u><strong>预处理</strong></u>是提升计算机视觉任务性能的其他关键步骤。</p>
</li>
</ul>
<h1>使用块的网络（VGG）</h1>
<p>与芯片设计中工程师从放置晶体管到逻辑元件再到逻辑块的过程类似，神经网络架构的设计也逐渐变得更加抽象。研究人员开始从<u><strong>单个神经元</strong></u>的角度思考问题，发展到<u><strong>整个层</strong></u>，现在又转向<u><strong>块</strong></u>，重复层的模式。</p>
<p>使用块的想法首先出现在牛津大学的<a href="http://www.robots.ox.ac.uk/~vgg/">视觉几何组（visual geometry group）</a>的<em><strong>VGG</strong>网络</em>中。通过使用循环和子程序，可以很容易地在任何现代深度学习框架的代码中实现这些重复的架构。</p>
<h2 id="vgg块">VGG块</h2>
<p>经典卷积神经网络的基本组成部分是下面的这个序列：</p>
<ol>
<li class="lvl-3">
<p>带填充以保持分辨率的**<u>卷积层</u>**；</p>
</li>
<li class="lvl-3">
<p>非线性<u><strong>激活函数</strong></u>，如ReLU；</p>
</li>
<li class="lvl-3">
<p><u><strong>汇聚层</strong></u>，如最大汇聚层。</p>
</li>
</ol>
<p>而一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层。在最初的VGG论文中 (<a href="http://zh.d2l.ai/chapter_references/zreferences.html#id153">Simonyan and Zisserman, 2014</a>)，作者使用了<u>带有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>卷积核、填充为1（保持高度和宽度）的卷积层，和带有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>汇聚窗口、步幅为2（每个块后的分辨率减半）的最大汇聚层</u>。在下面的代码中，我们定义了一个名为<code>vgg_block</code>的函数来实现一个VGG块。</p>
<p>该函数有两个参数，分别对应于卷积层的数量<code>num_convs</code>和输出通道的数量<code>num_channels</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> np, npx</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vgg_block</span>(<span class="params">num_convs, num_channels</span>):</span><br><span class="line">    blk = nn.Sequential()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">        blk.add(nn.Conv2D(num_channels, kernel_size=<span class="number">3</span>,</span><br><span class="line">                          padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    blk.add(nn.MaxPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br></pre></td></tr></table></figure>
<h2 id="vgg网络">VGG网络</h2>
<p>与AlexNet、LeNet一样，VGG网络可以分为两部分：第一部分主要由<u><strong>卷积层</strong></u>和<u><strong>汇聚层</strong></u>组成，第二部分由<u><strong>全连接层</strong></u>组成。如下图中所示。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/vgg.svg" alt="../_images/vgg.svg"></p>
<p><mark><strong><u><em>从AlexNet到VGG，它们本质上都是块设计。</em></u></strong></mark></p>
<p>VGG神经网络连接的几个VGG块（在<code>vgg_block</code>函数中定义）。其中有超参数变量<code>conv_arch</code>。该变量指定了每个VGG块里卷积层个数和输出通道数。全连接模块则与AlexNet中的相同。</p>
<p>原始VGG网络有5个卷积块，其中前两个块各有一个卷积层，后三个块各包含两个卷积层。 第一个模块有64个输出通道，每个后续模块将输出通道数量翻倍，直到该数字达到512。由于该网络使用8个卷积层和3个全连接层（全连接模块则与AlexNet中的相同），因此它通常被称为VGG-11。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv_arch = ((<span class="number">1</span>, <span class="number">64</span>), (<span class="number">1</span>, <span class="number">128</span>), (<span class="number">2</span>, <span class="number">256</span>), (<span class="number">2</span>, <span class="number">512</span>), (<span class="number">2</span>, <span class="number">512</span>))</span><br></pre></td></tr></table></figure>
<p>下面的代码实现了VGG-11。可以通过在<code>conv_arch</code>上执行for循环来简单实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vgg</span>(<span class="params">conv_arch</span>):</span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    <span class="comment"># 卷积层部分</span></span><br><span class="line">    <span class="keyword">for</span> (num_convs, num_channels) <span class="keyword">in</span> conv_arch:</span><br><span class="line">        net.add(vgg_block(num_convs, num_channels))</span><br><span class="line">    <span class="comment"># 全连接层部分</span></span><br><span class="line">    net.add(nn.Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">            nn.Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">            nn.Dense(<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">net = vgg(conv_arch)</span><br></pre></td></tr></table></figure>
<p>接下来，我们将构建一个高度和宽度为224的单通道数据样本，以观察每个层输出的形状。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.initialize()</span><br><span class="line">X = np.random.uniform(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="keyword">for</span> blk <span class="keyword">in</span> net:</span><br><span class="line">    X = blk(X)</span><br><span class="line">    <span class="built_in">print</span>(blk.name, <span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequential1 output shape:    (1, 64, 112, 112)</span><br><span class="line">sequential2 output shape:    (1, 128, 56, 56)</span><br><span class="line">sequential3 output shape:    (1, 256, 28, 28)</span><br><span class="line">sequential4 output shape:    (1, 512, 14, 14)</span><br><span class="line">sequential5 output shape:    (1, 512, 7, 7)</span><br><span class="line">dense0 output shape:         (1, 4096)</span><br><span class="line">dropout0 output shape:       (1, 4096)</span><br><span class="line">dense1 output shape:         (1, 4096)</span><br><span class="line">dropout1 output shape:       (1, 4096)</span><br><span class="line">dense2 output shape:         (1, 10)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>正如从代码中所看到的，我们在每个块的高度和宽度减半，最终高度和宽度都为7。最后再展平表示，送入全连接层处理。</p>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>VGG-11使用可复用的卷积块构造网络。不同的VGG模型可通过每个块中<u><strong>卷积层数量</strong></u>和<u><strong>输出通道数量</strong></u>的差异来定义。</p>
</li>
<li class="lvl-2">
<p>块的使用导致网络定义的非常简洁。使用块可以有效地设计复杂的网络。</p>
</li>
<li class="lvl-2">
<p>在VGG论文中，Simonyan和Ziserman尝试了各种架构。特别是他们发现<u><strong>深层且窄的卷积</strong></u>（即3×3）比<u><strong>较浅层且宽的卷积</strong></u>更有效。</p>
</li>
</ul>
<h1>网络中的网络（NiN）</h1>
<p>LeNet、AlexNet和VGG都有一个共同的设计模式：通过一系列的<u><strong>卷积层与汇聚层</strong></u>来提取<u><strong>空间结构特征</strong></u>；然后通过<u><strong>全连接层</strong></u>对<mark>特征的表征</mark>进行处理。 AlexNet和VGG对LeNet的改进主要在于如何<u><strong>扩大和加深</strong></u>这两个模块。 或者，可以想象在这个过程的早期使用全连接层。然而，如果使用了<u>全连接层</u>，可能会完全放弃<u>表征的空间结构</u>。 **<em>网络中的网络</em>（<em>NiN</em>）**提供了一个非常简单的解决方案：在<u><strong>每个像素的通道上</strong></u>分别使用<u>多层感知机</u>。</p>
<h2 id="nin块">NiN块</h2>
<p>回想一下，卷积层的输入和输出由四维张量组成，张量的每个轴分别对应<u><strong>样本、通道、高度和宽度</strong></u>。</p>
<p>另外，全连接层的输入和输出通常是分别对应于<u><strong>样本和特征</strong></u>的二维张量。</p>
<p>NiN的想法是在每个像素位置（<u>针对每个高度和宽度</u>）应用一个全连接层。</p>
<p>如果我们将权重连接到每个空间位置，我们可以将其视为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层，或作为在每个像素位置上独立作用的全连接层。</p>
<p>从另一个角度看，即<u>将空间维度中的每个像素视为单个样本</u>，将<u><strong>通道维度</strong></u>视为<u><strong>不同特征</strong></u>（feature）。</p>
<p>如下图说明了VGG和NiN及它们的块之间主要架构差异。</p>
<p>NiN块以一个普通卷积层开始，后面是两个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的卷积层。这两个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层充当带有<u><strong>ReLU激活函数</strong></u>的逐像素全连接层。第一层的卷积窗口形状通常由用户设置。随后的卷积窗口形状固定为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/nin.svg" alt="../_images/nin.svg"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> np, npx</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nin_block</span>(<span class="params">num_channels, kernel_size, strides, padding</span>):</span><br><span class="line">    blk = nn.Sequential()</span><br><span class="line">    blk.add(nn.Conv2D(num_channels, kernel_size, strides, padding,</span><br><span class="line">                      activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">            nn.Conv2D(num_channels, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">            nn.Conv2D(num_channels, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br></pre></td></tr></table></figure>
<h2 id="nin模型">NiN模型</h2>
<p>最初的NiN网络是在AlexNet后不久提出的，显然从中得到了一些启示。</p>
<p>NiN使用窗口形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn><mo>×</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">11\times 11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>的卷积层，输出通道数量与AlexNet中的相同。</p>
<p>每个NiN块后有一个最大汇聚层，汇聚窗口形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，步幅为2。</p>
<p>NiN和AlexNet之间的一个显著区别是<u><strong>NiN完全取消了全连接层</strong></u>。</p>
<p>相反，NiN使用一个NiN块，其<u><strong>输出通道数等于标签类别的数量</strong></u>。最后放一个<em><strong>全局平均汇聚层</strong></em>（global average pooling layer），生成一个对数几率（logits）。</p>
<p>NiN设计的一个优点是，它显著<mark>减少了模型所需参数的数量</mark>。然而，在实践中，这种设计有时<u>会增加训练模型的时间</u>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential()</span><br><span class="line">net.add(nin_block(<span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, padding=<span class="number">0</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nin_block(<span class="number">256</span>, kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nin_block(<span class="number">384</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">        <span class="comment"># 标签类别数是10</span></span><br><span class="line">        nin_block(<span class="number">10</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">        <span class="comment"># 全局平均汇聚层将窗口形状自动设置成输入的高和宽</span></span><br><span class="line">        nn.GlobalAvgPool2D(),</span><br><span class="line">        <span class="comment"># 将四维的输出转成二维的输出，其形状为(批量大小,10)</span></span><br><span class="line">        nn.Flatten())</span><br></pre></td></tr></table></figure>
<p>创建一个数据样本来查看每个块的输出形状。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.random.uniform(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">net.initialize()</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.name, <span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequential1 output shape:    (1, 96, 54, 54)</span><br><span class="line">pool0 output shape:  (1, 96, 26, 26)</span><br><span class="line">sequential2 output shape:    (1, 256, 26, 26)</span><br><span class="line">pool1 output shape:  (1, 256, 12, 12)</span><br><span class="line">sequential3 output shape:    (1, 384, 12, 12)</span><br><span class="line">pool2 output shape:  (1, 384, 5, 5)</span><br><span class="line">dropout0 output shape:       (1, 384, 5, 5)</span><br><span class="line">sequential4 output shape:    (1, 10, 5, 5)</span><br><span class="line">pool3 output shape:  (1, 10, 1, 1)</span><br><span class="line">flatten0 output shape:       (1, 10)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>NiN使用由<u><strong>一个卷积层和多个1×1卷积层</strong></u>组成的块。该块可以在卷积神经网络中使用，以允许更多的每像素非线性。</p>
</li>
<li class="lvl-2">
<p>NiN去除了容易造成过拟合的全连接层，将它们替换为<u><strong>全局平均汇聚层</strong></u>（即在所有位置上进行求和）。该汇聚层<u>通道数量</u>为所需的<u>输出数量</u>（例如，Fashion-MNIST的输出为10）。</p>
</li>
<li class="lvl-2">
<p>移除全连接层可<u><strong>减少过拟合</strong></u>，同时<u><strong>显著减少NiN的参数</strong></u>。</p>
</li>
<li class="lvl-2">
<p>NiN的设计影响了许多后续卷积神经网络的设计。</p>
</li>
</ul>
<h1>含并行连结的网络（GoogLeNet）</h1>
<p>在2014年的ImageNet图像识别挑战赛中，一个名叫<em><strong>GoogLeNet</strong></em> (<a href="http://zh.d2l.ai/chapter_references/zreferences.html#id162">Szegedy <em>et al.</em>, 2015</a>)的网络架构大放异彩。 GoogLeNet吸收了<u><strong>NiN中串联网络</strong></u>的思想，并在此基础上做了改进。 这篇论文的一个重点是解决了<u><strong>什么样大小的卷积核最合适的问题</strong></u>。</p>
<h2 id="inception块">Inception块</h2>
<p>在GoogLeNet中，<u><strong>基本的卷积块</strong></u>被称为<em><strong>Inception块</strong></em>（Inception block）。这很可能得名于电影《盗梦空间》（Inception），因为电影中的一句话“我们需要走得更深”（“We need to go deeper”）。</p>
<p><span style="color: red;">Inception块的架构如下图所示：</span></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/inception.svg" alt="../_images/inception.svg"></p>
<p>如上图所示，Inception块由四条并行路径组成。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>前三条路径使用窗口大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>的卷积层，<u>从不同空间大小中提取信息</u>。</p>
</li>
<li class="lvl-2">
<p>中间的两条路径在输入上执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积，以<u>减少通道数</u>，从而<u>降低模型的复杂性</u>。</p>
</li>
<li class="lvl-2">
<p>第四条路径使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>最大汇聚层，然后使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层来改变通道数。</p>
</li>
</ul>
<p>这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。在Inception块中，通常调整的<u>超参数</u>是<u>每层输出通道数</u>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> np, npx</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inception</span>(nn.Block):</span><br><span class="line">    <span class="comment"># c1--c4是每条路径的输出通道数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, c1, c2, c3, c4, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Inception, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 线路1，单1x1卷积层</span></span><br><span class="line">        self.p1_1 = nn.Conv2D(c1, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        <span class="comment"># 线路2，1x1卷积层后接3x3卷积层</span></span><br><span class="line">        self.p2_1 = nn.Conv2D(c2[<span class="number">0</span>], kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p2_2 = nn.Conv2D(c2[<span class="number">1</span>], kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>,</span><br><span class="line">                              activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        <span class="comment"># 线路3，1x1卷积层后接5x5卷积层</span></span><br><span class="line">        self.p3_1 = nn.Conv2D(c3[<span class="number">0</span>], kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p3_2 = nn.Conv2D(c3[<span class="number">1</span>], kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>,</span><br><span class="line">                              activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        <span class="comment"># 线路4，3x3最大汇聚层后接1x1卷积层</span></span><br><span class="line">        self.p4_1 = nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.p4_2 = nn.Conv2D(c4, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        p1 = self.p1_1(x)</span><br><span class="line">        p2 = self.p2_2(self.p2_1(x))</span><br><span class="line">        p3 = self.p3_2(self.p3_1(x))</span><br><span class="line">        p4 = self.p4_2(self.p4_1(x))</span><br><span class="line">        <span class="comment"># 在通道维度上连结输出</span></span><br><span class="line">        <span class="keyword">return</span> np.concatenate((p1, p2, p3, p4), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>那么为什么GoogLeNet这个网络如此有效呢？ 首先我们考虑一下<u><strong>滤波器（filter）</strong></u>的组合，它们可以用各种滤波器尺寸探索图像，这意味着<u><strong>不同大小的滤波器可以有效地识别不同范围的图像细节</strong></u>。 同时，我们可以为不同的滤波器分配不同数量的参数。</p>
<h2 id="googlenet模型">GoogLeNet模型</h2>
<p>如下图所示，GoogLeNet一共使用<u><strong>9个Inception块和全局平均汇聚层的堆叠</strong></u>来生成其估计值。Inception块之间的最大汇聚层可<u><strong>降低维度</strong></u>。 第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平均汇聚层避免了在最后使用全连接层。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/inception-full.svg" alt="../_images/inception-full.svg"></p>
<p>第一个模块使用64个通道、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>×</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">7\times 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span>卷积层。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b1 = nn.Sequential()</span><br><span class="line">b1.add(nn.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">7</span>, strides=<span class="number">2</span>, padding=<span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">       nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>第二个模块使用两个卷积层：第一个卷积层是64个通道、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层；第二个卷积层使用将通道数量增加三倍的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>卷积层。这对应于Inception块中的第二条路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b2 = nn.Sequential()</span><br><span class="line">b2.add(nn.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">       nn.Conv2D(<span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">       nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>第三个模块串联两个完整的Inception块。</p>
<p>第一个Inception块的输出通道数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mo>+</mo><mn>128</mn><mo>+</mo><mn>32</mn><mo>+</mo><mn>32</mn><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">64+128+32+32=256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span>，四个路径之间的输出通道数量比为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mo>:</mo><mn>128</mn><mo>:</mo><mn>32</mn><mo>:</mo><mn>32</mn><mo>=</mo><mn>2</mn><mo>:</mo><mn>4</mn><mo>:</mo><mn>1</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">64:128:32:32=2:4:1:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>第二个和第三个路径首先将输入通道的数量分别减少到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>96</mn><mi mathvariant="normal">/</mi><mn>192</mn><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">96/192=1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">96/192</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi mathvariant="normal">/</mi><mn>192</mn><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>12</mn></mrow><annotation encoding="application/x-tex">16/192=1/12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16/192</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/12</span></span></span></span>，然后连接第二个卷积层。第二个Inception块的输出通道数增加到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>128</mn><mo>+</mo><mn>192</mn><mo>+</mo><mn>96</mn><mo>+</mo><mn>64</mn><mo>=</mo><mn>480</mn></mrow><annotation encoding="application/x-tex">128+192+96+64=480</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">192</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">96</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">480</span></span></span></span>，四个路径之间的输出通道数量比为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>128</mn><mo>:</mo><mn>192</mn><mo>:</mo><mn>96</mn><mo>:</mo><mn>64</mn><mo>=</mo><mn>4</mn><mo>:</mo><mn>6</mn><mo>:</mo><mn>3</mn><mo>:</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">128:192:96:64 = 4:6:3:2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">192</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">96</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。</p>
<p>第二条和第三条路径首先将输入通道的数量分别减少到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>128</mn><mi mathvariant="normal">/</mi><mn>256</mn><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">128/256=1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">128/256</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mi mathvariant="normal">/</mi><mn>256</mn><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">32/256=1/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">32/256</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/8</span></span></span></span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b3 = nn.Sequential()</span><br><span class="line">b3.add(Inception(<span class="number">64</span>, (<span class="number">96</span>, <span class="number">128</span>), (<span class="number">16</span>, <span class="number">32</span>), <span class="number">32</span>),</span><br><span class="line">       Inception(<span class="number">128</span>, (<span class="number">128</span>, <span class="number">192</span>), (<span class="number">32</span>, <span class="number">96</span>), <span class="number">64</span>),</span><br><span class="line">       nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>第四模块更加复杂，它串联了5个Inception块，其输出通道数分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>192</mn><mo>+</mo><mn>208</mn><mo>+</mo><mn>48</mn><mo>+</mo><mn>64</mn><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">192+208+48+64=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">192</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">208</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">48</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>160</mn><mo>+</mo><mn>224</mn><mo>+</mo><mn>64</mn><mo>+</mo><mn>64</mn><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">160+224+64+64=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">160</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">224</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>128</mn><mo>+</mo><mn>256</mn><mo>+</mo><mn>64</mn><mo>+</mo><mn>64</mn><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">128+256+64+64=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>112</mn><mo>+</mo><mn>288</mn><mo>+</mo><mn>64</mn><mo>+</mo><mn>64</mn><mo>=</mo><mn>528</mn></mrow><annotation encoding="application/x-tex">112+288+64+64=528</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">112</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">288</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">528</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn><mo>+</mo><mn>320</mn><mo>+</mo><mn>128</mn><mo>+</mo><mn>128</mn><mo>=</mo><mn>832</mn></mrow><annotation encoding="application/x-tex">256+320+128+128=832</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">320</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">832</span></span></span></span>。</p>
<p>这些路径的通道数分配和第三模块中的类似，首先是含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3×3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>卷积层的第二条路径输出最多通道，其次是仅含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1×1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层的第一条路径，之后是含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5×5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>卷积层的第三条路径和含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3×3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>最大汇聚层的第四条路径。其中第二、第三条路径都会先按比例减小通道数。这些比例在各个Inception块中都略有不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b4 = nn.Sequential()</span><br><span class="line">b4.add(Inception(<span class="number">192</span>, (<span class="number">96</span>, <span class="number">208</span>), (<span class="number">16</span>, <span class="number">48</span>), <span class="number">64</span>),</span><br><span class="line">       Inception(<span class="number">160</span>, (<span class="number">112</span>, <span class="number">224</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">       Inception(<span class="number">128</span>, (<span class="number">128</span>, <span class="number">256</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">       Inception(<span class="number">112</span>, (<span class="number">144</span>, <span class="number">288</span>), (<span class="number">32</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">       Inception(<span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">       nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>第五模块包含输出通道数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn><mo>+</mo><mn>320</mn><mo>+</mo><mn>128</mn><mo>+</mo><mn>128</mn><mo>=</mo><mn>832</mn></mrow><annotation encoding="application/x-tex">256+320+128+128=832</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">320</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">832</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>384</mn><mo>+</mo><mn>384</mn><mo>+</mo><mn>128</mn><mo>+</mo><mn>128</mn><mo>=</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">384+384+128+128=1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">384</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">384</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span>的两个Inception块。其中每条路径通道数的分配思路和第三、第四模块中的一致，只是在具体数值上有所不同。</p>
<p>需要注意的是，第五模块的后面紧跟输出层，该模块同NiN一样使用全局平均汇聚层，将每个通道的高和宽变成1。</p>
<p>最后我们将输出变成二维数组，再接上一个输出个数为标签类别数的全连接层。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b5 = nn.Sequential()</span><br><span class="line">b5.add(Inception(<span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">       Inception(<span class="number">384</span>, (<span class="number">192</span>, <span class="number">384</span>), (<span class="number">48</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">       nn.GlobalAvgPool2D())</span><br><span class="line"></span><br><span class="line">net = nn.Sequential()</span><br><span class="line">net.add(b1, b2, b3, b4, b5, nn.Dense(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>GoogLeNet模型的计算复杂，而且<u><strong>不如VGG那样便于修改通道数</strong></u>。 为了使Fashion-MNIST上的训练短小精悍，我们将输入的高和宽从224降到96，这简化了计算。下面演示各个模块输出的形状变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.random.uniform(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">96</span>))</span><br><span class="line">net.initialize()</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.name, <span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequential0 output shape:    (1, 64, 24, 24)</span><br><span class="line">sequential1 output shape:    (1, 192, 12, 12)</span><br><span class="line">sequential2 output shape:    (1, 480, 6, 6)</span><br><span class="line">sequential3 output shape:    (1, 832, 3, 3)</span><br><span class="line">sequential4 output shape:    (1, 1024, 1, 1)</span><br><span class="line">dense0 output shape:         (1, 10)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Inception块相当于一个有4条路径的子网络。它<u><strong>通过不同窗口形状的卷积层和最大汇聚层来<mark>并行抽取信息</mark></strong></u>，并使用1×1卷积层减少每像素级别上的通道维数从而降低模型复杂度。</p>
</li>
<li class="lvl-2">
<p>GoogLeNet将多个设计精细的Inception块与其他层（卷积层、全连接层）<mark>串联</mark>起来。<u>其中Inception块的通道数分配之比是在ImageNet数据集上通过大量的实验得来的。</u></p>
</li>
<li class="lvl-2">
<p>GoogLeNet和它的后继者们一度是ImageNet上最有效的模型之一：它以较低的计算复杂度提供了类似的测试精度。</p>
</li>
</ul>
<h1>批量规范化（batch normalization）</h1>
<p><em><strong>批量规范化</strong></em>（batch normalization） (<a href="http://zh.d2l.ai/chapter_references/zreferences.html#id75">Ioffe and Szegedy, 2015</a>)，这是一种流行且有效的技术，可持续加速深层网络的<u><strong>收敛速度</strong></u>。 再结合<u><strong>残差块</strong></u>，<mark>批量规范化</mark>使得研究人员能够训练100层以上的网络。</p>
<h2 id="训练深层网络">训练深层网络</h2>
<p>数据预处理的方式通常会对最终结果产生巨大影响。</p>
<p>对于典型的<u>多层感知机</u>或<u>卷积神经网络</u>。当我们训练时，中间层中的变量（例如，多层感知机中的仿射变换输出）可能具有更广的变化范围：不论是沿着从输入到输出的层，跨同一层中的单元，或是随着时间的推移，<u>模型参数</u>的随着训练<strong>更新变幻莫测</strong>。 批量规范化的发明者非正式地假设，这些变量分布中的<mark>这种偏移可能会阻碍网络的收敛</mark>。 直观地说，我们可能会猜想，如果一个层的可变值是另一层的100倍，这可能需要对学习率进行补偿调整。</p>
<p>更深层的网络很复杂，<mark>容易过拟合</mark>。 这意味着正则化变得更加重要。</p>
<h3 id="批量规范化原理">批量规范化原理</h3>
<p>批量规范化应用于<u><strong>单个可选层</strong></u>（也可以<u><strong>应用到所有层</strong></u>），其<mark>原理如下</mark>：</p>
<p>在每次训练迭代中，我们<u><strong>首先规范化输入</strong></u>，即*<span style="color: red;">通过减去其<mark>均值</mark>并除以其<mark>标准差</mark></span><em>，其中两者均基于当前小批量处理。 接下来，我们<u><strong>应用比例系数和比例偏移</strong></u>。 正是由于这个==基于</em><strong>批量</strong><em>统计的</em><strong>标准化</strong>*==，才有了<em><strong>批量规范化</strong></em>的名称。</p>
<p>如果我们尝试使用大小为1的小批量应用批量规范化，我们将<u>无法学到任何东西</u>。 这是因为在减去均值之后，每个隐藏单元将为0。 所以，只有使用<mark>足够大的小批量</mark>，批量规范化这种方法才是<mark>有效且稳定的</mark>。 请注意，<u><em>在应用批量规范化时，批量大小的选择可能比没有批量规范化时更重要</em></u>。</p>
<p>从形式上来说，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>表示一个来自小批量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>的输入，批量规范化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">N</mi></mrow><annotation encoding="application/x-tex">\mathrm{BN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">BN</span></span></span></span></span>根据以下表达式转换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span></span></span></span>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">N</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="bold-italic">γ</mi><mo>⊙</mo><mfrac><mrow><mi mathvariant="bold">x</mi><mo>−</mo><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><msub><mover accent="true"><mi mathvariant="bold-italic">σ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mfrac><mo>+</mo><mi mathvariant="bold-italic">β</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">BN</span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.06389em;">γ</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.2209em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3849em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">σ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03403em;">β</span></span></span><span class="mord">.</span></span></span></span></span></p>
<p>在以上公式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\boldsymbol{\mu}}_\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.952em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span>是小批量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>的<mark>样本均值</mark>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">σ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\boldsymbol{\sigma}}_\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8579em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">σ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是小批量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>的<mark>样本标准差</mark>。</p>
<p>应用标准化后，生成的小批量的平均值为0和单位方差为1。</p>
<p>由于单位方差（与其他一些魔法数）是一个主观的选择，因此我们通常包含<em><strong>拉伸参数</strong></em>（scale）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">γ</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\gamma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.06389em;">γ</span></span></span></span></span></span>和<em><strong>偏移参数</strong></em>（shift）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">β</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03403em;">β</span></span></span></span></span></span>，它们的形状与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span></span></span></span>相同。请注意，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">γ</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\gamma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.06389em;">γ</span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">β</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03403em;">β</span></span></span></span></span></span>是需要与其他模型参数一起学习的参数。</p>
<p>由于在训练过程中，中间层的变化幅度不能过于剧烈，而批量规范化将每一层主动居中，并将它们<u>重新调整为给定的平均值和大小</u>（通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\boldsymbol{\mu}}_\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.952em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">σ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">{\hat{\boldsymbol{\sigma}}_\mathcal{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8579em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">σ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>）。</p>
<p>从形式上来看，我们计算出以上公式中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\boldsymbol{\mu}}_\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.952em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">σ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">{\hat{\boldsymbol{\sigma}}_\mathcal{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8579em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">σ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，如下所示：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi mathvariant="bold">x</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><mi mathvariant="bold">x</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msubsup><mover accent="true"><mi mathvariant="bold-italic">σ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi><mn>2</mn></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi mathvariant="bold">x</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mi>ϵ</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \hat{\boldsymbol{\mu}}_\mathcal{B} &amp;= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} \mathbf{x},\\
\hat{\boldsymbol{\sigma}}_\mathcal{B}^2 &amp;= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \hat{\boldsymbol{\mu}}_{\mathcal{B}})^2 + \epsilon.\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.8863em;vertical-align:-2.6931em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1931em;"><span style="top:-5.1931em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">σ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span style="top:-2.453em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span><span style="top:-3.1608em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6931em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1931em;"><span style="top:-5.1931em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">x</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ϵ</span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6931em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>请注意，我们在方差估计值中添加一个小的常量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，以确保我们<u>永远不会尝试除以零</u>，即使在经验方差估计值可能消失的情况下也是如此。估计值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\boldsymbol{\mu}}_\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.952em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold-italic">σ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><annotation encoding="application/x-tex">{\hat{\boldsymbol{\sigma}}_\mathcal{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8579em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">σ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>通过使用<mark>平均值和方差的噪声（noise）估计来抵消缩放问题</mark>。乍看起来，这种噪声是一个问题，而事实上它是有益的。</p>
<p><u><em>事实证明，这是深度学习中一个反复出现的主题。</em></u></p>
<p>由于尚未在理论上明确的原因，优化中的<mark>各种噪声源</mark>通常会<u><strong>导致更快的训练和较少的过拟合</strong></u>：这种变化似乎是正则化的一种形式。在一些初步研究中，将批量规范化的性质与贝叶斯先验相关联。这些理论揭示了<mark>为什么批量规范化最适应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mo>∼</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">50 \sim 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>范围中的中等批量大小的难题</mark>。</p>
<p>另外，批量规范化层在**“训练模式”<strong>（通过小批量统计数据规范化）和</strong>“预测模式”**（通过数据集统计规范化）中的功能不同。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>在训练过程中</u>，我们无法得知使用整个数据集来估计平均值和方差，所以只能<u>根据每个小批次的平均值和方差不断训练模型</u>。</p>
</li>
<li class="lvl-2">
<p><u>而在预测模式下</u>，可以根据整个数据集精确计算批量规范化所需的平均值和方差。</p>
</li>
</ul>
<h2 id="批量规范化层">批量规范化层</h2>
<p>批量规范化和其他层之间的一个关键区别是，由于批量规范化在完整的小批量上运行，因此我们不能像以前在引入其他层时那样忽略批量大小。 我们在下面讨论这两种情况：全连接层和卷积层，他们的批量规范化实现略有不同。</p>
<h3 id="全连接层">全连接层</h3>
<p>通常，我们将批量规范化层<mark>置于</mark>全连接层中的<mark>仿射变换</mark>和<mark>激活函数</mark>之间。</p>
<p>设全连接层的输入为x，权重参数和偏置参数分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">W</mi></mrow><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\mathbf{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathbf">b</span></span></span></span>，激活函数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>，批量规范化的运算符为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">N</mi></mrow><annotation encoding="application/x-tex">\mathrm{BN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">BN</span></span></span></span></span>。那么，使用批量规范化的全连接层的输出的计算详情如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">h</mi><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">N</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="bold">W</mi><mi mathvariant="bold">x</mi><mo>+</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{h} = \phi(\mathrm{BN}(\mathbf{W}\mathbf{x} + \mathbf{b}) )
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathbf">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">BN</span></span><span class="mopen">(</span><span class="mord mathbf">Wx</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">b</span><span class="mclose">))</span></span></span></span></span></p>
<blockquote>
<p>均值和方差是在应用变换的&quot;相同&quot;小批量上计算的。</p>
</blockquote>
<h3 id="卷积层">卷积层</h3>
<p>同样，对于卷积层，我们可以<mark>在卷积层之后和非线性激活函数之前应用批量规范化</mark>。</p>
<p>当卷积有多个输出通道时，我们需要对这些通道的“每个”输出执行批量规范化，每个通道都有自己的<u><strong>拉伸（scale）</strong></u>和<u><strong>偏移（shift）</strong></u>参数，这两个参数都是<strong>标量</strong>。</p>
<p>假设我们的小批量包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>个样本，并且对于每个通道，卷积的输出具有高度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>和宽度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>。那么对于卷积层，我们在每个输出通道的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>⋅</mo><mi>p</mi><mo>⋅</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">m \cdot p \cdot q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>个元素上同时执行每个批量规范化。因此，在计算平均值和方差时，我们会<u>收集所有空间位置的值</u>，然后在给定通道内应用<u>相同的均值和方差</u>，以便在每个空间位置对值进行规范化。</p>
<h3 id="预测过程中的批量规范化">预测过程中的批量规范化</h3>
<p>批量规范化在训练模式和预测模式下的<u>行为通常不同</u>。 首先，将训练好的模型用于预测时，我们<u><strong>不再需要样本均值中的噪声以及在微批次上估计每个小批次产生的样本方差</strong></u>了。 其次，例如，我们可能需要使用我们的模型对逐个样本进行预测。 一种常用的方法是<u><strong>通过移动平均估算整个训练数据集的样本均值和方差</strong></u>，并在预测时使用它们得到确定的输出。 可见，和暂退法一样，批量规范化层在训练模式和预测模式下的计算结果也是不一样的。</p>
<h2 id="从零实现">从零实现</h2>
<p>下面，从头开始实现一个具有张量的批量规范化层。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, init, np, npx</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batch_norm</span>(<span class="params">X, gamma, beta, moving_mean, moving_var, eps, momentum</span>):</span><br><span class="line">    <span class="comment"># 通过autograd来判断当前模式是训练模式还是预测模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> autograd.is_training():</span><br><span class="line">        <span class="comment"># 如果是在预测模式下，直接使用传入的移动平均所得的均值和方差</span></span><br><span class="line">        X_hat = (X - moving_mean) / np.sqrt(moving_var + eps)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(X.shape) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 使用全连接层的情况，计算特征维上的均值和方差</span></span><br><span class="line">            mean = X.mean(axis=<span class="number">0</span>)</span><br><span class="line">            var = ((X - mean) ** <span class="number">2</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 使用二维卷积层的情况，计算通道维上（axis=1）的均值和方差。</span></span><br><span class="line">            <span class="comment"># 这里我们需要保持X的形状以便后面可以做广播运算</span></span><br><span class="line">            mean = X.mean(axis=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdims=<span class="literal">True</span>)</span><br><span class="line">            var = ((X - mean) ** <span class="number">2</span>).mean(axis=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdims=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 训练模式下，用当前的均值和方差做标准化</span></span><br><span class="line">        X_hat = (X - mean) / np.sqrt(var + eps)</span><br><span class="line">        <span class="comment"># 更新移动平均的均值和方差</span></span><br><span class="line">        moving_mean = momentum * moving_mean + (<span class="number">1.0</span> - momentum) * mean</span><br><span class="line">        moving_var = momentum * moving_var + (<span class="number">1.0</span> - momentum) * var</span><br><span class="line">    Y = gamma * X_hat + beta  <span class="comment"># 缩放和移位</span></span><br><span class="line">    <span class="keyword">return</span> Y, moving_mean, moving_var</span><br></pre></td></tr></table></figure>
<p>我们现在可以创建一个正确的<code>BatchNorm</code>层。 这个层将保持适当的参数：拉伸<code>gamma</code>和偏移<code>beta</code>,这两个参数将在训练过程中更新。 此外，我们的层将<mark>保存均值和方差的移动平均值</mark>，以便在模型预测期间随后使用。</p>
<p>撇开算法细节，注意我们实现层的基础设计模式。 通常情况下，我们<mark>用一个单独的函数定义其数学原理</mark>，比如说<code>batch_norm</code>。 然后，我们将此功能集成到一个自定义层中，其代码主要处理数据移动到训练设备（如GPU）、分配和初始化任何必需的变量、跟踪移动平均线（此处为均值和方差）等问题。 为了方便起见，我们并不担心在这里自动推断输入形状，因此我们需要指定整个特征的数量。</p>
<blockquote>
<p>深度学习框架中的<mark>批量规范化API</mark>将为我们解决上述问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BatchNorm</span>(nn.Block):</span><br><span class="line">    <span class="comment"># num_features：完全连接层的输出数量或卷积层的输出通道数。</span></span><br><span class="line">    <span class="comment"># num_dims：2表示完全连接层，4表示卷积层</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_features, num_dims, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="keyword">if</span> num_dims == <span class="number">2</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0</span></span><br><span class="line">        self.gamma = self.params.get(<span class="string">&#x27;gamma&#x27;</span>, shape=shape, init=init.One())</span><br><span class="line">        self.beta = self.params.get(<span class="string">&#x27;beta&#x27;</span>, shape=shape, init=init.Zero())</span><br><span class="line">        <span class="comment"># 非模型参数的变量初始化为0和1</span></span><br><span class="line">        self.moving_mean = np.zeros(shape)</span><br><span class="line">        self.moving_var = np.ones(shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 如果X不在内存上，将moving_mean和moving_var</span></span><br><span class="line">        <span class="comment"># 复制到X所在显存上</span></span><br><span class="line">        <span class="keyword">if</span> self.moving_mean.ctx != X.ctx:</span><br><span class="line">            self.moving_mean = self.moving_mean.copyto(X.ctx)</span><br><span class="line">            self.moving_var = self.moving_var.copyto(X.ctx)</span><br><span class="line">        <span class="comment"># 保存更新过的moving_mean和moving_var</span></span><br><span class="line">        Y, self.moving_mean, self.moving_var = batch_norm(</span><br><span class="line">            X, self.gamma.data(), self.beta.data(), self.moving_mean,</span><br><span class="line">            self.moving_var, eps=<span class="number">1e-12</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">        <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure>
<h2 id="使用批量规范化层的-lenet">使用批量规范化层的 LeNet</h2>
<p>为了更好理解如何应用<code>BatchNorm</code>，下面我们将其应用于LeNet模型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>批量规范化是在卷积层或全连接层之后、相应的激活函数之前应用的。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential()</span><br><span class="line">net.add(nn.Conv2D(<span class="number">6</span>, kernel_size=<span class="number">5</span>),</span><br><span class="line">        BatchNorm(<span class="number">6</span>, num_dims=<span class="number">4</span>),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Conv2D(<span class="number">16</span>, kernel_size=<span class="number">5</span>),</span><br><span class="line">        BatchNorm(<span class="number">16</span>, num_dims=<span class="number">4</span>),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Dense(<span class="number">120</span>),</span><br><span class="line">        BatchNorm(<span class="number">120</span>, num_dims=<span class="number">2</span>),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.Dense(<span class="number">84</span>),</span><br><span class="line">        BatchNorm(<span class="number">84</span>, num_dims=<span class="number">2</span>),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.Dense(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h2 id="简明实现">简明实现</h2>
<p>除了使用我们刚刚定义的<code>BatchNorm</code>，我们也可以直接使用深度学习框架中定义的<code>BatchNorm</code>。 该代码看起来几乎与上面的代码相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential()</span><br><span class="line">net.add(nn.Conv2D(<span class="number">6</span>, kernel_size=<span class="number">5</span>),</span><br><span class="line">        nn.BatchNorm(),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Conv2D(<span class="number">16</span>, kernel_size=<span class="number">5</span>),</span><br><span class="line">        nn.BatchNorm(),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Dense(<span class="number">120</span>),</span><br><span class="line">        nn.BatchNorm(),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.Dense(<span class="number">84</span>),</span><br><span class="line">        nn.BatchNorm(),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">        nn.Dense(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常<mark>高级API变体运行速度快得多</mark>，因为它的代码已编译为C++或CUDA，而我们的自定义代码由Python实现。</p>
</blockquote>
<h2 id="争议">争议</h2>
<p>直观地说，批量规范化被认为可以<u><strong>使优化更加平滑</strong></u>。 然而，我们必须小心区分直觉和对我们观察到的现象的真实解释。 回想一下，我们甚至不知道简单的神经网络（多层感知机和传统的卷积神经网络）为什么如此有效。 即使在<mark>暂退法和权重衰减</mark>的情况下，它们仍然非常灵活，因此<u>无法通过常规的学习理论泛化保证来解释它们是否能够泛化到看不见的数据</u>。</p>
<p>在提出批量规范化的论文中，作者除了介绍了其应用，还解释了其原理：通过减少<em><strong>内部协变量偏移</strong></em>（internal covariate shift）。 据推测，作者所说的<em><strong>内部协变量转移</strong></em>类似于上述的投机直觉，即变量值的分布在训练过程中会发生变化。 然而，这种解释有两个问题： 1、这种偏移与严格定义的<em><strong>协变量偏移</strong></em>（covariate shift）非常不同，所以这个名字用词不当； 2、这种解释只提供了一种不明确的直觉，但留下了一个有待后续挖掘的问题：<em><u>为什么这项技术如此有效？</u></em></p>
<blockquote>
<p>批量规范化已经被证明是一种不可或缺的方法。它<mark>适用于几乎所有图像分类器</mark>，并在学术界获得了数万引用。</p>
</blockquote>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在模型训练过程中，批量规范化利用<mark>小批量的均值和标准差</mark>，<u>不断调整神经网络的中间输出</u>，使整个神经网络各层的<u><strong>中间输出值更加稳定</strong></u>。</p>
</li>
<li class="lvl-2">
<p>批量规范化在全连接层和卷积层的<u>使用</u>略有<u>不同</u>。</p>
</li>
<li class="lvl-2">
<p>批量规范化层和暂退层一样，<mark>在训练模式和预测模式下</mark><u>计算不同</u>。</p>
</li>
<li class="lvl-2">
<p>批量规范化有许多有益的副作用，主要是<mark>正则化</mark>。另一方面，“减少内部协变量偏移”的原始动机似乎不是一个有效的解释。</p>
</li>
</ul>
<h1>残差网络（ResNet）</h1>
<h2 id="函数类">函数类</h2>
<p><img src="https://zh.d2l.ai/_images/functionclasses.svg" alt="../_images/functionclasses.svg"></p>
<p><em>对于非嵌套函数类，较复杂（由较大区域表示）的函数类不能保证更接近“真”函数（ f∗ ）。这种现象在嵌套函数类中不会发生。</em></p>
<p>因此，只有<strong>当较复杂的函数类包含较小的函数类时</strong>，我们<strong>才能确保提高它们的性能</strong>。 对于深度神经网络，如果我们能将新添加的层训练成<em>恒等映射</em>（identity function）<strong>f(x)=x</strong>，新模型和原模型将同样有效。 同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。</p>
<p>残差网络的<strong>核心思想</strong>是：每个附加层都应该<u><strong>更容易地包含原始函数</strong></u>作为其元素之一。 于是，<u><em><strong>残差块</strong></em></u>（residual blocks）便诞生了，这个设计对如何建立深层神经网络产生了深远的影响。</p>
<p><mark>ResNet引入了残差块（Residual Block），其中的<strong>关键思想</strong>是通过添加<strong>跳跃连接</strong>（也称为<u>快捷连接</u>）来允许输入直接<strong>绕过一层或多层的神经网络层</strong>，并<strong>将输入与输出相加，从而构建了一个恒等映射</strong>。</mark></p>
<h2 id="残差块">残差块</h2>
<p>假设我们的原始输入为<strong>x</strong>，而希望学出的理想映射为<strong>f(x)</strong>，**f(x)**作为激活函数的输入。</p>
<p><img src="https://zh.d2l.ai/_images/residual-block.svg" alt="../_images/residual-block.svg"></p>
<center>*正常块（左边）和残差块（右边）*</center>
<p>左图虚线框中的部分需要直接拟合出该映射<strong>f(x)</strong>，而右图虚线框中的部分则需要拟合出残差映射<strong>f(x)−x</strong>。</p>
<p>残差映射在现实中往往更容易优化。 以<strong>恒等映射</strong>作为我们希望学到的理想映射<strong>f(x)</strong>，只用将右图虚线框内上方的加权运算（如仿射）的权重和偏置参数设成0，那么**f(x)**即为<u><strong>恒等映射</strong></u>。</p>
<p>实际中，当理想映射<strong>f(x)<strong>极接近于</strong>恒等映射</strong>时，<strong>残差映射</strong>也易于<u>捕捉恒等映射的细微波动</u>。</p>
<blockquote>
<p>每个<strong>残差块</strong>（Residual Block）都包含了一个<strong>恒等映射</strong>。这是为了解决深度神经网络训练中的<u><strong>梯度消失</strong></u>问题，使得网络能够更轻松地学习到恒等映射，然后只需学习残差（即差异）部分。</p>
<p>一个恒等映射块的结构：输出 = 输入 + 某些函数(输入)</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>输出=ReLU(卷积(ReLU(卷积(输入))))+输入</p>
<ul class="lvl-3">
<li class="lvl-4">输入x经过一个卷积层和非线性激活函数（如ReLU），<strong>产生一个中间特征图</strong>。</li>
<li class="lvl-4">中间特征图再经过另一个卷积层和激活函数，得到另一个特征图。</li>
<li class="lvl-4">最后，将第二个特征图与输入x相加，得到最终的输出。</li>
</ul>
</li>
</ul>
</blockquote>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> tensorflow <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 残差块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(tf.keras.Model):  <span class="comment">#@save</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_channels, use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = tf.keras.layers.Conv2D(</span><br><span class="line">            num_channels, padding=<span class="string">&#x27;same&#x27;</span>, kernel_size=<span class="number">3</span>, strides=strides)</span><br><span class="line">        self.conv2 = tf.keras.layers.Conv2D(</span><br><span class="line">            num_channels, kernel_size=<span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.conv3 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = tf.keras.layers.Conv2D(</span><br><span class="line">                num_channels, kernel_size=<span class="number">1</span>, strides=strides)</span><br><span class="line">        self.bn1 = tf.keras.layers.BatchNormalization()</span><br><span class="line">        self.bn2 = tf.keras.layers.BatchNormalization()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, X</span>):</span><br><span class="line">        Y = tf.keras.activations.relu(self.bn1(self.conv1(X)))</span><br><span class="line">        Y = self.bn2(self.conv2(Y))</span><br><span class="line">        <span class="keyword">if</span> self.conv3 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        Y += X</span><br><span class="line">        <span class="keyword">return</span> tf.keras.activations.relu(Y)</span><br></pre></td></tr></table></figure>
<p>生成两种类型的网络： 一种是当<code>use_1x1conv=False</code>时，应用ReLU非线性函数之前，将输入添加到输出。 另一种是当<code>use_1x1conv=True</code>时，添加通过1×1卷积调整通道和分辨率。</p>
<p><img src="https://zh.d2l.ai/_images/resnet-block.svg" alt="../_images/resnet-block.svg"></p>
<h2 id="resnet模型">ResNet模型</h2>
<p>ResNet的前两层跟之前介绍的GoogLeNet中的一样： 在输出通道数为64、步幅为2的7×7卷积层后，接步幅为2的3×3的<strong>最大汇聚层</strong>(池化层)。 不同之处在于ResNet每个卷积层后增加了<strong>批量规范化层</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b1 = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">7</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    tf.keras.layers.BatchNormalization(),</span><br><span class="line">    tf.keras.layers.Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<p>通过配置不同的通道数和模块里的残差块数可以得到<strong>不同的ResNet模型</strong>，例如更深的含152层的ResNet-152。 虽然ResNet的主体架构跟GoogLeNet类似，但ResNet架构更简单，修改也更方便。这些因素都导致了ResNet迅速被广泛使用。</p>
<p>ResNet结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResnetBlock</span>(tf.keras.layers.Layer):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_channels, num_residuals, first_block=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResnetBlock, self).__init__(**kwargs)</span><br><span class="line">        self.residual_layers = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">                self.residual_layers.append(</span><br><span class="line">                    Residual(num_channels, use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.residual_layers.append(Residual(num_channels))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.residual_layers.layers:</span><br><span class="line">            X = layer(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">    </span><br><span class="line">b2 = ResnetBlock(<span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>)</span><br><span class="line">b3 = ResnetBlock(<span class="number">128</span>, <span class="number">2</span>)</span><br><span class="line">b4 = ResnetBlock(<span class="number">256</span>, <span class="number">2</span>)</span><br><span class="line">b5 = ResnetBlock(<span class="number">512</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 回想之前我们定义一个函数，以便用它在tf.distribute.MirroredStrategy的范围，</span></span><br><span class="line"><span class="comment"># 来利用各种计算资源，例如gpu。另外，尽管我们已经创建了b1、b2、b3、b4、b5，</span></span><br><span class="line"><span class="comment"># 但是我们将在这个函数的作用域内重新创建它们</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>():</span><br><span class="line">    <span class="keyword">return</span> tf.keras.Sequential([</span><br><span class="line">        <span class="comment"># Thefollowinglayersarethesameasb1thatwecreatedearlier</span></span><br><span class="line">        tf.keras.layers.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">7</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">        tf.keras.layers.BatchNormalization(),</span><br><span class="line">        tf.keras.layers.Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        tf.keras.layers.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">        <span class="comment"># Thefollowinglayersarethesameasb2,b3,b4,andb5thatwe</span></span><br><span class="line">        <span class="comment"># createdearlier</span></span><br><span class="line">        ResnetBlock(<span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>),</span><br><span class="line">        ResnetBlock(<span class="number">128</span>, <span class="number">2</span>),</span><br><span class="line">        ResnetBlock(<span class="number">256</span>, <span class="number">2</span>),</span><br><span class="line">        ResnetBlock(<span class="number">512</span>, <span class="number">2</span>),</span><br><span class="line">        tf.keras.layers.GlobalAvgPool2D(),</span><br><span class="line">        tf.keras.layers.Dense(units=<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>
<p>ResNet中不同模块的输入形状是如何变化的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Conv2D output shape:         (<span class="number">1</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">64</span>) <span class="comment"># (batch_size, height, width, channels)</span></span><br><span class="line">BatchNormalization output shape:     (<span class="number">1</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">64</span>)</span><br><span class="line">Activation output shape:     (<span class="number">1</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">64</span>)</span><br><span class="line">MaxPooling2D output shape:   (<span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">64</span>)</span><br><span class="line">ResnetBlock output shape:    (<span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">64</span>)</span><br><span class="line">ResnetBlock output shape:    (<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">128</span>)</span><br><span class="line">ResnetBlock output shape:    (<span class="number">1</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">256</span>)</span><br><span class="line">ResnetBlock output shape:    (<span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">512</span>)</span><br><span class="line">GlobalAveragePooling2D output shape:         (<span class="number">1</span>, <span class="number">512</span>)</span><br><span class="line">Dense output shape:  (<span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>学习嵌套函数（nested function）是训练神经网络的理想情况。在深层神经网络中，学习另一层作为恒等映射（identity function）较容易（尽管这是一个极端情况）。</p>
</li>
<li class="lvl-2">
<p>残差映射可以更容易地学习同一函数，例如将权重层中的参数近似为零。</p>
</li>
<li class="lvl-2">
<p>利用残差块（residual blocks）可以训练出一个有效的深层神经网络：输入可以通过层间的残余连接更快地向前传播。</p>
</li>
<li class="lvl-2">
<p>残差网络（ResNet）对随后的深层神经网络设计产生了深远影响。</p>
</li>
<li class="lvl-2">
<p>残差网络（ResNet）有效解决<strong>梯度消失</strong>和<strong>梯度爆炸</strong>问题。</p>
</li>
</ul>
<h1>稠密连接网络（DenseNet）</h1>
<p><em>稠密连接网络</em>（DenseNet）在某种程度上是ResNet的逻辑扩展。</p>
<p>ResNet将函数展开为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="bold">x</mi><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f(\mathbf{x}) = \mathbf{x} + g(\mathbf{x}).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p>
<p>也就是说，ResNet将**f(x)<strong>分解为两部分：一个简单的线性项和一个复杂的非线性项。 那么再向前拓展一步，如果我们想将</strong>f(x)**拓展成超过两部分的信息呢？ 一种方案便是DenseNet。</p>
<p><img src="https://zh.d2l.ai/_images/densenet-block.svg" alt="../_images/densenet-block.svg"></p>
<center>*ResNet（左）与 DenseNet（右）在跨层连接上的主要区别：使用相加和使用连结。*</center>
<p>ResNet和DenseNet的关键区别在于，DenseNet输出是<em>连接</em>（用图中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo separator="true">,</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[,]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">]</span></span></span></span>表示）而不是如ResNet的简单相加。</p>
<p>因此，在应用越来越复杂的函数序列后，我们执行从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span></span></span></span>到其展开式的映射：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">x</mi><mo>→</mo><mrow><mo fence="true">[</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>f</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{x} \to \left[
\mathbf{x},
f_1(\mathbf{x}),
f_2([\mathbf{x}, f_1(\mathbf{x})]), f_3([\mathbf{x}, f_1(\mathbf{x}), f_2([\mathbf{x}, f_1(\mathbf{x})])]), \ldots\right].
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">([</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)])</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">([</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">([</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)])])</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p>
<p>最后，将这些展开式结合到多层感知机中，再次减少特征的数量。</p>
<p><img src="https://zh.d2l.ai/_images/densenet.svg" alt="../_images/densenet.svg"></p>
<center>*稠密连接示意图*</center>
<p>稠密网络主要由2部分构成：<em><strong>稠密块</strong></em>（dense block）和<em><strong>过渡层</strong></em>（transition layer）。 前者定义如何连接输入和输出，而后者则控制通道数量，使其不会太复杂。</p>
<h2 id="稠密块体">稠密块体</h2>
<p>稠密块的<strong>主要思想</strong>是在网络中创建密集的连接，<u><strong>每个层都与前面的层直接连接</strong></u>，以便接受来自前面层的输入。这种密集的连接方式有助于传播梯度更好地进行梯度更新，从而促进了训练过程的<u><strong>稳定性和收敛性</strong></u>。稠密块的结构如下所示：</p>
<ol>
<li class="lvl-3">
<p>输入层：接受来自前一层的特征图作为输入。</p>
</li>
<li class="lvl-3">
<p>若干个卷积层：在输入层上堆叠多个卷积层，通常包括卷积核大小、激活函数和其他超参数的调整。</p>
</li>
<li class="lvl-3">
<p>输出特征图：每个卷积层的输出都被连接到稠密块的输出，形成了一个更大的特征图，其中包含了来自所有层的信息。</p>
</li>
</ol>
<h5 id="特点：">特点：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于稠密块的连接非常密集，因此网络的<u><strong>前一层特征图会直接影响到后面的所有层</strong></u>，这使得网络非常深，并且可以从不同层次的特征中提取信息，有助于提高网络的表示能力。</p>
</li>
<li class="lvl-2">
<p>此外，稠密块还具有<u><strong>参数共享</strong></u>的优点，因为每个层都可以重复使用前面层的输出。</p>
</li>
</ul>
<p><strong>举个例子</strong>，我们定义一个有2个输出<strong>通道数为10</strong>的<code>DenseBlock</code>。 使用<strong>通道数为3的输入</strong>时，我们会得到<strong>通道数为3+2×10=23的输出</strong>。 <strong>卷积块的通道数</strong>控制了输出通道数相对于输入通道数的增长，因此也被称为<u><em><strong>增长率</strong></em></u>（growth rate）。</p>
<h2 id="过渡层">过渡层</h2>
<p><strong>过渡层</strong>可以用来控制模型复杂度。 它通过<strong>1×1卷积层</strong>来减小通道数，并使用<strong>步幅为2的平均汇聚层</strong>减半高和宽，从而进一步降低模型复杂度。</p>
<blockquote>
<p>公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><msub><mi>p</mi><mi>h</mi></msub><mo>+</mo><msub><mi>s</mi><mi>h</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>h</mi></msub><mo stretchy="false">⌋</mo><mo>×</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><msub><mi>p</mi><mi>w</mi></msub><mo>+</mo><msub><mi>s</mi><mi>w</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>w</mi></msub><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌋</span></span></span></span>，当步幅stride=2时，使得输出的高和宽减半。</p>
</blockquote>
<h2 id="densenet模型">DenseNet模型</h2>
<p>DenseNet首先使用同ResNet一样的单卷积层和最大汇聚层。</p>
<p>类似于ResNet使用的4个残差块，DenseNet使用的是4个稠密块。 与ResNet类似，我们可以设置每个稠密块使用多少个卷积层，这里设为4。</p>
<p>稠密块里的卷积层通道数（即增长率）设为32，所以每个稠密块将增加128个通道。</p>
<p>在每个模块之间，ResNet通过步幅为2的残差块减小高和宽，DenseNet则使用过渡层来减半高和宽，并减半通道数。</p>
<blockquote>
<p>参考：<a href="https://zh.d2l.ai/chapter_convolutional-modern/densenet.html#id4">https://zh.d2l.ai/chapter_convolutional-modern/densenet.html#id4</a></p>
</blockquote>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在跨层连接上，不同于ResNet中将输入与输出相加，稠密连接网络（DenseNet）在通道维上<u><strong>连结输入与输出</strong></u>。</p>
</li>
<li class="lvl-2">
<p>DenseNet的主要构建模块是<u><strong>稠密块</strong></u>和<u><strong>过渡层</strong></u>。</p>
</li>
<li class="lvl-2">
<p>在构建DenseNet时，我们需要通过<strong>添加过渡层来控制网络的维数</strong>，从而再次<strong>减少通道的数量</strong>。</p>
</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>反向传播（Backpropagation）是一种在神经网络中进行训练的常用算法。它用于计算网络中每个参数对于损失函数的梯度，进而通过梯度下降法或其他优化算法来更新网络参数，以最小化损失函数。它基于链式法则（chain rule），主要分为两个阶段：前向传播和反向传播。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>机器学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>ML</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测和边界框</title>
    <url>/2023/10/25/University/AI/CV/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%92%8C%E8%BE%B9%E7%95%8C%E6%A1%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>目标检测和边界框</h1>
<blockquote>
<p>详细参考：<a href="https://zh.d2l.ai/chapter_computer-vision/bounding-box.html">https://zh.d2l.ai/chapter_computer-vision/bounding-box.html</a></p>
</blockquote>
<p><em><strong>目标检测</strong></em>或<em><strong>目标识别</strong></em>：不仅想知道它们的类别，还想得到它们在图像中的具体位置。</p>
<h2 id="边界框">边界框</h2>
<p>在目标检测中，我们通常使用<em><strong>边界框</strong></em>（bounding box）来描述对象的空间位置。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>边界框是矩形的，由矩形左上角的以及右下角的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>坐标决定。</p>
</li>
<li class="lvl-2">
<p>另一种常用的边界框表示方法是边界框中心的(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>)轴坐标以及框的宽度和高度。</p>
</li>
</ul>
<p><img src="https://zh.d2l.ai/_images/output_bounding-box_d6b70e_21_0.svg" alt="../_images/output_bounding-box_d6b70e_21_0.svg"></p>
<p>根据坐标信息定义图像中狗和猫的边界框。 图像中坐标的原点是图像的左上角，<u>向右的方向为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>轴的正方向，向下的方向为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>轴的正方向</u>。</p>
<p>在图像上添加边界框之后，如下图所示：</p>
<p><img src="https://zh.d2l.ai/_images/output_bounding-box_d6b70e_70_0.svg" alt="../_images/output_bounding-box_d6b70e_70_0.svg"></p>
<h2 id="实践：-待定">实践：（待定）</h2>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>目标检测不仅可以识别图像中所有感兴趣的物体，还能识别它们的位置，该位置通常由矩形边界框表示。</p>
</li>
<li class="lvl-2">
<p>我们可以在两种常用的边界框表示（中间，宽度，高度）和（左上，右下）坐标之间进行转换。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉CV-1</title>
    <url>/2023/09/10/University/AI/CV/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>计算机视觉CV</h1>
<blockquote>
<p>参考：<a href="https://www.kaggle.com/learn/computer-vision">https://www.kaggle.com/learn/computer-vision</a></p>
</blockquote>
<h3 id="卷积神经网络-convnet-cnn">卷积神经网络（convnet，CNN）</h3>
<p>一种深度学习神经网络架构，特别适用于处理具有网格结构（例如图像和视频）的数据。能够有效地捕捉图像中的局部特征，并具备平移不变性。</p>
<h3 id="对抗网络-adversarial-networks">对抗网络（adversarial networks）</h3>
<p>对抗网络（Adversarial Networks），通常指的是生成对抗网络（Generative Adversarial Networks，GANs），是一种深度学习模型框架，由两个神经网络模型组成，一个是生成器（Generator），另一个是判别器（Discriminator）。GANs 的<mark>核心思想</mark>是<u><strong>通过对抗训练的方式来生成逼真的数据样本。</strong></u></p>
<p>GANs的主要组成和工作原理：</p>
<ol>
<li class="lvl-3">
<p><strong>生成器（Generator）</strong>：生成器是一个神经网络模型，它的任务是<u><strong>生成与真实数据样本类似的合成数据样本</strong></u>。它接受一个随机噪声向量（通常称为潜在空间向量）作为输入，并将其映射到一个数据样本的空间。生成器尝试生成越来越逼真的数据样本，以欺骗判别器。</p>
</li>
<li class="lvl-3">
<p><strong>判别器（Discriminator）</strong>：判别器是另一个神经网络模型，它的任务是评估给定的数据样本是真实数据还是生成器生成的合成数据。<u><strong>判别器的目标是区分真实数据和生成器生成的数据</strong></u>。它输出一个概率值，表示输入样本是真实数据的概率。</p>
</li>
<li class="lvl-3">
<p><strong>对抗过程</strong>：GANs 的训练过程是一个对抗过程。<mark>生成器和判别器相互竞争和对抗</mark>。生成器试图生成足够逼真的数据，以欺骗判别器，而判别器试图更好地区分真实数据和生成数据。这个过程通过<u><strong>最小化生成器和判别器之间的损失函数</strong></u>来进行，通常使用<mark>交替优化</mark>的方式。</p>
</li>
<li class="lvl-3">
<p><strong>损失函数</strong>：生成器和判别器都有各自的损失函数。<u><strong>生成器的损失函数衡量生成的数据与真实数据之间的差距</strong></u>，<u><strong>判别器的损失函数衡量判别器的分类性能</strong></u>。GANs的优化目标是找到平衡点，使生成器生成逼真的数据，并且判别器无法准确地区分真伪。</p>
</li>
<li class="lvl-3">
<p><strong>生成逼真样本</strong>：一旦训练完成，生成器可以用来生成逼真的数据样本，这些样本在统计上类似于训练数据。这在图像生成、图像修复、超分辨率、生成艺术等应用中具有广泛的用途。</p>
</li>
</ol>
<h3 id="图像分割-image-segmentation">图像分割（image segmentation）</h3>
<p>图像分割（Image Segmentation）是计算机视觉领域的一个重要任务，其目标是<u><strong>将图像分成若干个不同的区域或对象，使得每个区域内的像素具有相似的特征或语义</strong></u>。图像分割通常用于将图像中的每个像素分配到特定的类别或分割对象，从而识别和提取图像中的各种物体、边界和结构。</p>
<p>图像分割的<mark>主要类型</mark>和应用：</p>
<ol>
<li class="lvl-3">
<p><strong>语义分割（Semantic Segmentation）</strong>：在语义分割中，目标是<u><strong>将图像中的每个像素分配到预定义的语义类别</strong></u>，通常<u><strong>使用类别标签来表示不同的对象或区域</strong></u>。这种分割技术可用于实现图像中对象的精确识别和像素级别的分类。</p>
</li>
<li class="lvl-3">
<p><strong>实例分割（Instance Segmentation）</strong>：实例分割不仅要求分割图像中的对象，还<u><strong>需要将相同类别的不同实例区分开来</strong></u>。这种分割技术对于多对象场景中的对象检测和跟踪非常有用。</p>
</li>
<li class="lvl-3">
<p><strong>边缘检测（Edge Detection）</strong>：边缘检测是图像分割的一种形式，它<u><strong>旨在识别图像中的物体边界</strong></u>。通常通过<u><strong>检测像素值之间的梯度或差异来实现</strong></u>。</p>
</li>
<li class="lvl-3">
<p><strong>实际应用</strong>：图像分割在各种实际应用中都有广泛的用途，包括医学图像分析（如肿瘤检测和器官分割）、自动驾驶（识别道路和障碍物）、计算机视觉系统中的对象识别和跟踪、图像编辑和合成、卫星图像分析等领域。</p>
</li>
</ol>
<h3 id="卷积分类器-convolutional-classifier">卷积分类器（Convolutional Classifier）</h3>
<p>包含：a <strong>convolutional base</strong> and a <strong>dense head</strong>.</p>
<p>卷积基础convolutional base：用于从图像中提取特征，由卷积层和池化层组成。</p>
<p>密集头部dense head：用于分类的部分，通常由全连接层（Fully Connected Layers）组成。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>全连接层</strong>的主要特点是每个神经元都与前一层的每个神经元相连接。</p>
</li>
</ul>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/U0n5xjU.png" alt="The parts of a convnet: image, base, head, class; input, extract, classify, output." style="zoom:50%;" />
<p>特征提取的示例图：</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/UUAafkn.png" alt="The idea of feature extraction." style="zoom: 25%;" />
<p>网络在训练过程中的目标是学习两件事：</p>
<ol>
<li class="lvl-3">
<p>从图像中提取哪些特征（基础）；</p>
</li>
<li class="lvl-3">
<p>哪个类别与哪些特征相匹配（头部）。</p>
</li>
</ol>
<h5 id="u-attaching-a-head-of-dense-layers-to-a-pretrained-base-u"><u><em><strong>attaching a head of dense layers to a pretrained base</strong></em></u></h5>
<p>卷积网络很少从头开始训练。更常见的是，我们重用预训练模型的基础。然后我们在预训练的基础上附加一个未经训练的头部。换句话说，我们重用网络中已经学会执行 1. 提取特征，并附加一些新层来学习；2. 分类的部分。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/E49fsmV.png" alt="Attaching a new head to a trained base." style="zoom:25%;" />
<blockquote>
<p>头部包含较少的层，在已有的Base上加上一个new Head可以从相对较少的数据创建非常准确的分类器。</p>
<p>重用预训练模型是一种称为<mark>迁移学习</mark>的技术。它非常有效，以至于现在几乎每个图像分类器都会使用它。</p>
</blockquote>
<p>分类模型结构：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>输入：预训练的 VGG16 模型输出的特征图。</p>
</li>
<li class="lvl-2">
<p>中间层：Flatten 层将特征图展平，接着是一个具有6个神经元的全连接层，用于学习特征的高级表示。</p>
</li>
<li class="lvl-2">
<p>输出层：具有一个神经元的全连接输出层，用于进行二分类，输出一个样本属于正类别的概率。</p>
</li>
</ul>
<blockquote>
<p>预训练的 VGG16<mark>设置为不可训练，保证其权重不变</mark>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    pretrained_base,</span><br><span class="line">    layers.Flatten(),</span><br><span class="line">    layers.Dense(<span class="number">6</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h4 id="模型训练过程分析">模型训练过程分析</h4>
<table>
<thead>
<tr>
<th>训练数据的loss与验证数据的loss</th>
<th>更多操作训练数据的accuracy与验证数据的accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___16_0.png" alt="img"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___16_1.png" alt="img"></td>
</tr>
</tbody>
</table>
<p>可以发现，随着训练epoch次数的增加，训练数据集的loss和accuracy逐渐增加。</p>
<p>而验证数据集的loss先减少再回升，这可能是因为训练次数的增加导致的<mark>过拟合</mark>；验证数据集的accuracy也在epoch=20左右的时候达到最大值之后下降。</p>
<h4 id="交叉熵-cross-entropy">交叉熵（Cross-Entropy）</h4>
<p>它用于衡量两个概率分布之间的相似性或差异性。交叉熵常被用于分类问题中，特别是在深度学习中，用作损失函数来衡量模型的性能和优化模型的参数。</p>
<p>在机器学习和深度学习中，交叉熵的定义如下：</p>
<p>假设有两个概率分布 P 和 Q，其中 <strong>P 表示真实分布（ground truth）</strong>，<strong>Q 表示模型的预测分布</strong>。交叉熵损失用于<u><strong>衡量 Q 预测与 P 真实分布之间的差异</strong></u>。其一般形式为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munder><mo>∑</mo><mi>i</mi></munder><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(P, Q) = -\sum_{i} P(i) \cdot \log(Q(i)) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">))</span></span></span></span></span></p>
<p>在二分类问题中，可以简化为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mo stretchy="false">[</mo><mi>P</mi><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>P</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>Q</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">H(P, Q) = -[P \cdot \log(Q) + (1 - P) \cdot \log(1 - Q)]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)]</span></span></span></span></span></p>
<p>其中，P 表示真实标签（0或1），Q 表示模型的预测值（0到1之间的概率值）。</p>
<p>要理解交叉熵的含义，可以将其视为<strong>衡量两个概率分布之间的“距离”</strong>。当模型的预测分布 Q 与真实分布 P 完全匹配时，交叉熵达到最小值为零。但是，如果 Q 的预测与 P 不匹配，交叉熵将增大，表明模型的预测与真实情况之间存在差异。</p>
<p>在分类问题中，通常使用交叉熵作为损失函数来训练模型，<strong><u>目标是最小化交叉熵</u></strong>，使模型的预测尽可能接近真实标签的分布。这有助于模型学习正确分类样本的能力。</p>
<blockquote>
<p>交叉熵是用于衡量概率分布之间差异的一种常用度量，特别在分类问题中广泛应用。它是深度学习中常见的损失函数之一，用于模型的训练和优化。</p>
</blockquote>
<h4 id="典型代码">典型代码</h4>
<h5 id="加载训练和验证集：">加载训练和验证集：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ds_train_ = image_dataset_from_directory(</span><br><span class="line">    <span class="string">&#x27;../input/car-or-truck/train&#x27;</span>,</span><br><span class="line">    labels=<span class="string">&#x27;inferred&#x27;</span>,</span><br><span class="line">    label_mode=<span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    image_size=[<span class="number">128</span>, <span class="number">128</span>],</span><br><span class="line">    interpolation=<span class="string">&#x27;nearest&#x27;</span>,</span><br><span class="line">    batch_size=<span class="number">64</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="数据管道data-pipeline-也就是对数据进行各种处理的函数集-：">数据管道Data Pipeline（也就是对数据进行各种处理的函数集）：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_to_float</span>(<span class="params">image, label</span>):</span><br><span class="line">    image = tf.image.convert_image_dtype(image, dtype=tf.float32)</span><br><span class="line">    <span class="keyword">return</span> image, label</span><br></pre></td></tr></table></figure>
<h5 id="对训练集和验证集的处理：">对训练集和验证集的处理：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AUTOTUNE = tf.data.experimental.AUTOTUNE</span><br><span class="line">ds_train = (</span><br><span class="line">    ds_train_</span><br><span class="line">    .<span class="built_in">map</span>(convert_to_float)</span><br><span class="line">    .cache()</span><br><span class="line">    .prefetch(buffer_size=AUTOTUNE)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li class="lvl-3">
<p><code>AUTOTUNE = tf.data.experimental.AUTOTUNE</code>：<code>AUTOTUNE</code> 是一个特殊的常量，它允许 TensorFlow <mark>自动选择最佳的参数值</mark>，以优化数据加载和处理性能。它通常用于设置数据集的缓存和预取参数，以使数据加载和模型训练尽可能快速。</p>
</li>
<li class="lvl-3">
<p><code>ds_train</code> 和 <code>ds_valid</code> 分别是<mark>训练集和验证集的数据集对象</mark>。</p>
</li>
<li class="lvl-3">
<p><code>.map(convert_to_float)</code>：这是使用 <code>.map</code> 操作来<mark>对数据集中的每个样本应用</mark> <code>convert_to_float</code> <mark>函数</mark>，即将图像数据从整数类型转换为浮点数类型。这是数据预处理的一部分，确保输入数据与深度学习模型的期望数据类型一致。</p>
</li>
<li class="lvl-3">
<p><code>.cache()</code>：这个操作<mark>将数据集缓存到内存中</mark>，以便在训练过程中更快地访问数据。这对于小型数据集或可以适应内存的数据集而言非常有用，因为它可以减少数据加载的时间。</p>
</li>
<li class="lvl-3">
<p><code>.prefetch(buffer_size=AUTOTUNE)</code>：这个操作是为了加速数据加载。它允许模型<mark>在训练时异步地从数据集中预取（预加载）样本到内存中</mark>，以便在训练过程中无需等待数据加载完成。<code>buffer_size</code> 参数设置为 <code>AUTOTUNE</code> 表示让 TensorFlow 自动选择合适的缓冲区大小以优化性能。</p>
</li>
</ol>
</blockquote>
<h5 id="模型的训练：">模型的训练：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">    metrics=[<span class="string">&#x27;binary_accuracy&#x27;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">history = model.fit(</span><br><span class="line">    ds_train,</span><br><span class="line">    validation_data=ds_valid,</span><br><span class="line">    epochs=<span class="number">30</span>,</span><br><span class="line">    verbose=<span class="number">0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>epochs=30</code> 指定了训练的时代数，即模型将<mark>遍历整个训练数据集的次数</mark>。</p>
<p><u><em><strong>在每个 <code>epoch</code> 中，训练数据集会被分成多个 <code>batch</code>，每个 batch 包含 batch_size 个样本。模型通过处理这些 batch 来学习数据集。</strong></em></u></p>
</blockquote>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉CV-2</title>
    <url>/2023/09/10/University/AI/CV/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Convolution、ReLU and Maximum Pooling</h1>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/U0n5xjU.png" alt="The parts of a convnet: image, base, head, class; input, extract, classify, output." style="zoom:50%;" />
<p>base执行的特征提取包括三个基本操作：</p>
<ol>
<li class="lvl-3">
<p>Filter：过滤图像的特定特征（卷积convolution）</p>
</li>
<li class="lvl-3">
<p>Detect：检测过滤图像中的该特征 (ReLU)</p>
</li>
<li class="lvl-3">
<p>Condense：压缩图像以增强特征（最大池化maximum pooling）</p>
</li>
</ol>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/IYO9lqp.png" alt="An example of the feature extraction process." style="zoom: 33%;" />
<p>通常，网络将对单个图像并行执行多次提取。</p>
<h2 id="filter-with-convolution">Filter with Convolution</h2>
<h3 id="weights">Weights</h3>
<p>卷积核（kernel，也叫：内核）：</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/uJfD9r9.png" alt="A 3x3 kernel." style="zoom: 50%;" />
<p>卷积核通过扫描图像并生成像素值的加权和来进行操作。卷积核的数量（Filters）也称为通道数（channels）。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/j3lk26U.png" alt="A kernel acts as a kind of lens." style="zoom: 33%;" />
<p>通过kernel_size=3的卷积核（kernel）对输入数据进行卷积操作。</p>
<blockquote>
<p><code>kernels = [edge, bottom_sobel, emboss, sharpen]</code></p>
<ol>
<li class="lvl-3"><code>edge</code>：这是一个卷积核，通常用于边缘检测。它可以帮助找到图像中的边界和轮廓。</li>
<li class="lvl-3"><code>bottom_sobel</code>：这是一个卷积核，也用于边缘检测，特别是检测垂直方向上的边缘。</li>
<li class="lvl-3"><code>emboss</code>：这是一个卷积核，通常用于图像浮雕效果。它可以使图像看起来有立体感，突出显示图像中的细节。</li>
<li class="lvl-3"><code>sharpen</code>：这是一个卷积核，用于增强图像的锐度。它可以使图像中的边缘更加清晰。</li>
</ol>
</blockquote>
<h3 id="activations">Activations</h3>
<p>网络中的激活我们称为特征图。它们是我们对图像应用滤镜时的结果；它们包含卷积核提取的视觉特征。</p>
<p>不同卷积核得到的不同特征图：</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/JxBwchH.png" alt="Three kernels and the feature maps they produce." style="zoom:67%;" />
<p>一般来说，卷积在其输入中强调的内容将与内核中正数的形状相匹配。上面的左侧和中间的内核都会过滤水平形状。</p>
<blockquote>
<p>使用<code>filters</code>参数，你可以告诉卷积层你希望它创建多少个特征图作为输出。</p>
</blockquote>
<h2 id="detect-with-relu">Detect with ReLU</h2>
<p>ReLU（修正线性单元）作为激活函数。</p>
<p>ReLU是深度学习中常用的激活函数，它<mark>将负输入值置为零</mark>，而<mark>保留正输入值不变</mark>。这有助于引入非线性性质，使模型能够学习复杂的特征映射。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/DxGJuTH.png" alt="Graph of the ReLU activation function." style="zoom:50%;" />
<p>ReLU 激活表明负值并不重要，因此将它们设置为 0。（“所有不重要的事情都同样不重要。”）</p>
<p>将ReLU应用到以下特征图中：</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/dKtwzPY.png" alt="ReLU applied to feature maps." style="zoom: 67%;" />
<p>与其他激活函数一样，ReLU 函数是<mark>非线性的</mark>。</p>
<h2 id="condense-with-maximum-pooling">Condense with Maximum Pooling</h2>
<p>MaxPool2D 层与 Conv2D 层非常相似，不同之处在于它使用简单的最大值函数而不是内核，其中 <code>pool_size</code> 参数类似于 <code>kernel_size</code>。然而，MaxPool2D 层不像其内核中的卷积层那样具有任何可训练权重。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/IYO9lqp.png" alt="An example of the feature extraction process." style="zoom:50%;" />
<p>请注意，应用 ReLU 函数（检测）后，特征图最终会出现大量“死区”，即<u><strong>仅包含 0 的大区域（图像中的黑色区域）</strong></u>。必须在整个网络中携带这些 0 激活会增加模型的大小，而不会添加太多有用的信息。相反，我们希望压缩特征图以仅保留最有用的部分——特征本身。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/hK5U2cd.png" alt="Maximum pooling replaces a patch with the maximum value in that patch." style="zoom:50%;" />
<h4 id="平移不变性">平移不变性</h4>
<p><code>zero-pixels</code>区域携带了位置信息，当使用池化操作去除这些pixels时，也就去除了特征图中存在的位置信息。</p>
<p>这赋予了卷积网络一种称为<mark>平移不变性</mark>的属性。意味着具有最大池化的卷积网络往往不会根据特征在图像中的位置来区分特征。</p>
<p><img src="https://storage.googleapis.com/kaggle-media/learn/images/97j8WA1.png" alt="Pooling tends to destroy positional information."></p>
<p>经过反复池化后，原始图像中的两个点变得无法区分。换句话说，池化破坏了他们的一些位置信息。由于网络无法再在特征图中区分它们，因此它也无法在原始图像中区分它们：它对于位置的差异来说是不变的。。</p>
<p><img src="https://storage.googleapis.com/kaggle-media/learn/images/kUMWdcP.png" alt="But only over small distances. Two dots far apart stay separated"></p>
<p>事实上，池化只会在网络中产生小距离的平移不变性，就像图像中的两个点一样。开始相距较远的特征在合并后仍将保持明显；仅丢失了部分位置信息，但并非全部。</p>
<h2 id="典型代码">典型代码</h2>
<p>获取图片并处理图片数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rc(<span class="string">&#x27;figure&#x27;</span>, autolayout=<span class="literal">True</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;axes&#x27;</span>, labelweight=<span class="string">&#x27;bold&#x27;</span>, labelsize=<span class="string">&#x27;large&#x27;</span>,</span><br><span class="line">       titleweight=<span class="string">&#x27;bold&#x27;</span>, titlesize=<span class="number">18</span>, titlepad=<span class="number">10</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;image&#x27;</span>, cmap=<span class="string">&#x27;magma&#x27;</span>)</span><br><span class="line"></span><br><span class="line">image_path = <span class="string">&#x27;../input/computer-vision-resources/car_feature.jpg&#x27;</span></span><br><span class="line">image = tf.io.read_file(image_path)</span><br><span class="line">image = tf.io.decode_jpeg(image)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">plt.imshow(tf.squeeze(image), cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___7_0.png" alt="img" style="zoom:25%;" />
<p>定义卷积核：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">kernel = tf.constant([</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>,  <span class="number">8</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">show_kernel(kernel)</span><br></pre></td></tr></table></figure>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___9_0.png" alt="img" style="zoom:50%;" />
<p>定义卷积层：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_filter = tf.nn.conv2d(</span><br><span class="line">    <span class="built_in">input</span>=image,</span><br><span class="line">    filters=kernel,</span><br><span class="line">    <span class="comment"># we&#x27;ll talk about these two in lesson 4!</span></span><br><span class="line">    strides=<span class="number">1</span>,</span><br><span class="line">    padding=<span class="string">&#x27;SAME&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">plt.imshow(tf.squeeze(image_filter))</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___13_0.png" alt="img" style="zoom: 50%;" />
<p>ReLU 函数的检测步骤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_detect = tf.nn.relu(image_filter)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">plt.imshow(tf.squeeze(image_detect))</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___15_0.png" alt="img" style="zoom: 50%;" />
<p>池化操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">image_condense = tf.nn.pool(</span><br><span class="line">    <span class="built_in">input</span>=image_detect, <span class="comment"># image in the Detect step above</span></span><br><span class="line">    window_shape=(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    pooling_type=<span class="string">&#x27;MAX&#x27;</span>,</span><br><span class="line">    <span class="comment"># we&#x27;ll see what these do in the next lesson!</span></span><br><span class="line">    strides=(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    padding=<span class="string">&#x27;SAME&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">plt.imshow(tf.squeeze(image_condense))</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___5_0.png" alt="img" style="zoom:50%;" />
<h3 id="global-average-pooling">Global Average Pooling</h3>
<h5 id="globalavgpool2d方法">GlobalAvgPool2D方法</h5>
<p>在卷积网络的头部广泛使用的一种平均池化方法——全局平均池化。 GlobalAvgPool2D 层通常用作网络头部部分或全部隐藏 Dense 层的替代。</p>
<ol>
<li class="lvl-3">
<p><strong>GlobalAveragePooling2D</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>工作方式</strong>：<code>GlobalAveragePooling2D</code> 是一种池化操作，它在整个特征图上计算平均值。具体来说，对于每个特征通道，它计算特征通道内所有值的平均值，然后<u><strong>输出每个特征通道的平均值作为结果</strong></u>。这个操作会将特征图的高度和宽度维度降为 1x1。</li>
<li class="lvl-5"><strong>效果</strong>：<code>GlobalAveragePooling2D</code> 有助于捕获整个特征图中的全局信息，因此在一些图像分类任务中表现良好。它可以减少模型的参数数量，降低过拟合风险，并提高模型的泛化能力。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Flatten</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>工作方式</strong>：<code>Flatten</code> 操作将特征图的所有元素拉平成一个一维向量，不进行任何池化或平均操作。它将特征图的高度、宽度和通道维度都展平成一个长向量。</li>
<li class="lvl-5"><strong>效果</strong>：<code>Flatten</code> 操作不捕获全局信息，它将特征图中的每个像素都视为独立的特征。通常在卷积层之后，用于连接全连接层之前，以将特征图转换为全连接层可以处理的格式。</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果你的任务是<mark>图像分类</mark>，<code>GlobalAveragePooling2D</code> 是一个较好的选择，因为它有助于捕获全局信息并减少参数数量。而如果你的任务是<mark>对象检测或图像分割</mark>等需要空间信息的任务，你可能需要保留特征图的空间结构，可以选择使用 <code>Flatten</code> 将特征图展平，然后连接到全连接层进行进一步处理。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image_dataset_from_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load VGG16</span></span><br><span class="line">pretrained_base = tf.keras.models.load_model(</span><br><span class="line">    <span class="string">&#x27;../input/cv-course-models/cv-course-models/vgg16-pretrained-base&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model = keras.Sequential([</span><br><span class="line">    pretrained_base,</span><br><span class="line">    <span class="comment"># Attach a global average pooling layer after the base</span></span><br><span class="line">    layers.GlobalAvgPool2D(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dataset</span></span><br><span class="line">ds = image_dataset_from_directory(</span><br><span class="line">    <span class="string">&#x27;../input/car-or-truck/train&#x27;</span>,</span><br><span class="line">    labels=<span class="string">&#x27;inferred&#x27;</span>,</span><br><span class="line">    label_mode=<span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    image_size=[<span class="number">128</span>, <span class="number">128</span>],</span><br><span class="line">    interpolation=<span class="string">&#x27;nearest&#x27;</span>,</span><br><span class="line">    batch_size=<span class="number">1</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ds_iter = <span class="built_in">iter</span>(ds)</span><br></pre></td></tr></table></figure>
<p>VGG16 库产生 512 个特征图。我们可以将每个特征图视为代表原始图像中的一些高级视觉特征——可能是车轮或窗户。池化地图为我们提供了一个数字，我们可以将其视为该功能的分数：如果该功能存在则较大，如果不存在则较小。汽车往往在一组功能上得分较高，而卡车则在另一组功能上得分较高。现在，头部不必尝试将原始特征映射到类，而只需处理 GlobalAvgPool2D 生成的这些分数，这对它来说是一个更容易解决的问题。</p>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉CV-4</title>
    <url>/2023/09/10/University/AI/CV/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV-4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Custom Convnets</h1>
<p>我们了解了卷积网络如何通过三个操作来执行特征提取：<u><strong>过滤、检测和压缩</strong></u>。单轮特征提取只能从图像中提取相对简单的特征，例如简单的线条或对比度。这些对于解决大多数分类问题来说太简单了。相反，卷积网络将一遍又一遍地重复这种提取，以便特征随着它们深入网络而变得更加复杂和精致。</p>
<h2 id="convolutional-blocks">Convolutional Blocks</h2>
<p><img src="https://storage.googleapis.com/kaggle-media/learn/images/pr8VwCZ.png" alt="Extraction as a sequence of blocks."></p>
<p>这些卷积块是 Conv2D 和 MaxPool2D 层的堆栈。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/8D6IhEw.png" alt="A kind of extraction block: convolution, ReLU, pooling." style="zoom:50%;" />
<p><strong>每个块代表一轮提取</strong>，通过组合这些块，卷积网络可以组合和重新组合生成的特征，对它们进行增长和整形，以更好地适应当前的问题。现代卷积网络的深层结构使得这种复杂的特征工程成为可能，并在很大程度上保证了它们的卓越性能。</p>
<h2 id="经典代码">经典代码</h2>
<h3 id="step-1-load-data">Step 1 - Load Data</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load training and validation sets</span></span><br><span class="line">ds_train_ = image_dataset_from_directory(</span><br><span class="line">    <span class="string">&#x27;../input/car-or-truck/train&#x27;</span>,</span><br><span class="line">    labels=<span class="string">&#x27;inferred&#x27;</span>,</span><br><span class="line">    label_mode=<span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    image_size=[<span class="number">128</span>, <span class="number">128</span>],</span><br><span class="line">    interpolation=<span class="string">&#x27;nearest&#x27;</span>,</span><br><span class="line">    batch_size=<span class="number">64</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">ds_valid_ = image_dataset_from_directory(</span><br><span class="line">    <span class="string">&#x27;../input/car-or-truck/valid&#x27;</span>,</span><br><span class="line">    labels=<span class="string">&#x27;inferred&#x27;</span>,</span><br><span class="line">    label_mode=<span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    image_size=[<span class="number">128</span>, <span class="number">128</span>],</span><br><span class="line">    interpolation=<span class="string">&#x27;nearest&#x27;</span>,</span><br><span class="line">    batch_size=<span class="number">64</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Data Pipeline</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_to_float</span>(<span class="params">image, label</span>):</span><br><span class="line">    image = tf.image.convert_image_dtype(image, dtype=tf.float32)</span><br><span class="line">    <span class="keyword">return</span> image, label</span><br><span class="line"></span><br><span class="line">AUTOTUNE = tf.data.experimental.AUTOTUNE</span><br><span class="line">ds_train = (</span><br><span class="line">    ds_train_</span><br><span class="line">    .<span class="built_in">map</span>(convert_to_float)</span><br><span class="line">    .cache()</span><br><span class="line">    .prefetch(buffer_size=AUTOTUNE)</span><br><span class="line">)</span><br><span class="line">ds_valid = (</span><br><span class="line">    ds_valid_</span><br><span class="line">    .<span class="built_in">map</span>(convert_to_float)</span><br><span class="line">    .cache()</span><br><span class="line">    .prefetch(buffer_size=AUTOTUNE)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="step-2-define-model">Step 2 - Define Model</h3>
<p>将使用的模型的图示：</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/U1VdoDJ.png" alt="Diagram of a convolutional model." style="zoom: 67%;" />
<p>现在我们将定义模型。了解我们的模型如何由三个 Conv2D 和 MaxPool2D 层块（基础层）和后面的 Dense 层头组成。只需填写适当的参数，我们就可以或多或少地将该图直接转换为 Keras 序列模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">model = keras.Sequential([</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First Convolutional Block</span></span><br><span class="line">    layers.Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">5</span>, activation=<span class="string">&quot;relu&quot;</span>, padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  <span class="comment"># give the input dimensions in the first layer</span></span><br><span class="line">                  <span class="comment"># [height, width, color channels(RGB)]</span></span><br><span class="line">                  input_shape=[<span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span>]),</span><br><span class="line">    layers.MaxPool2D(),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Second Convolutional Block</span></span><br><span class="line">    layers.Conv2D(filters=<span class="number">64</span>, kernel_size=<span class="number">3</span>, activation=<span class="string">&quot;relu&quot;</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    layers.MaxPool2D(),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Third Convolutional Block</span></span><br><span class="line">    layers.Conv2D(filters=<span class="number">128</span>, kernel_size=<span class="number">3</span>, activation=<span class="string">&quot;relu&quot;</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    layers.MaxPool2D(),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Classifier Head</span></span><br><span class="line">    layers.Flatten(),</span><br><span class="line">    layers.Dense(units=<span class="number">6</span>, activation=<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">    <span class="comment"># layers.Dropout(0.2),</span></span><br><span class="line">    layers.Dense(units=<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>),</span><br><span class="line">])</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p><code>Dropout层</code>，用于防止过拟合。Dropout是一种正则化技术，它在训练过程中以指定的概率（这里是0.2）随机将部分神经元的输出置为零，从而减少神经网络对特定神经元的依赖性。这有助于提高模型的泛化能力。</p>
<p>模型很容易过度拟合并且需要一些正则化。我们如果在模型中添加更多大的附加层将使其更容易过度拟合。然而，通过 <code>Dropout</code> 层添加一些正则化有助于防止这种情况发生。</p>
<h3 id="step-3-train">Step 3 - Train</h3>
<p>使用优化器以及适合二元分类的损失和指标对其进行编译</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=tf.keras.optimizers.Adam(epsilon=<span class="number">0.01</span>),</span><br><span class="line">    loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">    metrics=[<span class="string">&#x27;binary_accuracy&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">history = model.fit(</span><br><span class="line">    ds_train,</span><br><span class="line">    validation_data=ds_valid,</span><br><span class="line">    epochs=<span class="number">40</span>,</span><br><span class="line">    verbose=<span class="number">0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>绘制图标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">history_frame = pd.DataFrame(history.history)</span><br><span class="line">history_frame.loc[:, [<span class="string">&#x27;loss&#x27;</span>, <span class="string">&#x27;val_loss&#x27;</span>]].plot()</span><br><span class="line">history_frame.loc[:, [<span class="string">&#x27;binary_accuracy&#x27;</span>, <span class="string">&#x27;val_binary_accuracy&#x27;</span>]].plot();</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">损失函数</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___6_0.png" alt="img"></td>
<td style="text-align:center"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/__results___6_1.png" alt="img"></td>
</tr>
</tbody>
</table>
<p>我们仍然可以通过添加更多的卷积层来改进这个简单的模型，希望创建更好地适应数据集的特征。</p>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉CV-3</title>
    <url>/2023/09/10/University/AI/CV/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>The Sliding Window</h1>
<p>卷积和池化操作有一个共同的特点：它们都是在滑动窗口上执行的。对于卷积，这个“窗口”由内核的尺寸（参数 kernel_size）给出。对于池化，它是池化窗口，由 pool_size 给出。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/LueNK6b.gif" alt="A 2D sliding window." style="zoom: 25%;" />
<p><code>strides</code> 参数表示窗口每一步应移动多远，<code>padding</code> 参数描述我们如何处理输入边缘的像素。</p>
<h2 id="stride">Stride</h2>
<p>窗口每一步移动的距离称为步幅。我们需要指定图像两个维度的步幅：一种用于从左到右移动，一种用于从上到下移动。该动画显示 <code>strides=(2, 2)</code>，每步移动 2 个像素。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/Tlptsvt.gif" alt="Sliding window with a stride of (2, 2)." style="zoom:25%;" />
<p>因为我们希望使用<strong>高质量的特征</strong>进行分类，所以卷积层通常具有步长=(1, 1)。增加步幅意味着我们会<u><strong>错过摘要中潜在的有价值的信息</strong></u>。然而，最大池化层的步幅值几乎总是大于 1，如 (2, 2) 或 (3, 3)，但不能大于窗口本身。</p>
<blockquote>
<p>可以使用 strides=2 来代替 strides=(2, 2) 进行参数设置。</p>
</blockquote>
<h2 id="padding">Padding</h2>
<p>当我们设置 <code>padding='valid'</code> 时，卷积窗口将完全保留在输入内部。缺点是输出会缩小（丢失像素），并且对于较大的内核，缩小得更多。这将限制网络可以包含的层数，特别是当输入尺寸较小时。</p>
<p>另一种方法是使用 <code>padding='same'</code>。这里的技巧是在输入的边界周围填充 0，使用足够的 0 使输出的大小与输入的大小相同。然而，这可以具有削弱边界处像素的影响的效果。下面的动画显示了具有“相同”填充的滑动窗口。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/RvGM2xb.gif" alt="Illustration of zero (same) padding." style="zoom:25%;" />
<blockquote>
<p>当设置 <code>padding='same'</code> 时，意味着要进行 “零填充”（zero-padding）以保持输入和输出特征图的大小相同。</p>
<p>具体来说，如果你有一个输入特征图大小为 <code>HxW</code>（高度 x 宽度），并且应用了一个卷积核（filter）大小为 <code>FxF</code>，其中 <code>F</code> 通常是奇数，然后使用 <code>'same'</code> 填充，那么卷积操作将会在输入特征图的周围填充零，以使输出特征图的大小仍然为 <code>HxW</code>。</p>
</blockquote>
<h2 id="the-receptive-field">The Receptive Field</h2>
<p>追溯某个神经元的所有连接，最终到达输入图像。神经元连接到的所有输入像素都是该神经元的感受野。感受野只是告诉您神经元从输入图像的哪些部分接收信息。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/HmwQm2S.png" alt="Illustration of the receptive field of two stacked convolutions." width=250>
<p>如果你的layer是一个 3×3 的卷积层，那么该层的每个神经元将<strong>从一个 3x3 的像素块中接收输入</strong>（除了可能在边缘处）；再叠加带有 3x3 卷积核的卷积层时，从顶部的神经元回溯连接，你可以看到它与输入中的一个 5x5 像素块（底层）相连：中间层中 3x3 像素块中的每个神经元与一个 3x3 的输入块相连，但它们在一个 5x5 的输入块中重叠。因此，<strong>顶部的神经元具有一个 5x5 的感受野</strong>。</p>
<h2 id="one-dimensional-convolution">One-Dimensional Convolution</h2>
<p><mark>一维卷积</mark>，序列上的卷积就像图像上的卷积一样。区别只是序列上的滑动窗口只有一个方向（从左到右）行进，而不是图像上的两个方向。就像二维一样，挑选出的特征取决于内核中数字的模式。</p>
<h2 id="经典代码">经典代码</h2>
<p>卷积窗口和池化窗口的size、stride and padding：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># YOUR CODE HERE: choose an image</span></span><br><span class="line">image = kaggle_k</span><br><span class="line"></span><br><span class="line"><span class="comment"># YOUR CODE HERE: choose a kernel</span></span><br><span class="line">kernel = sharpen</span><br><span class="line"></span><br><span class="line">visiontools.show_extraction(</span><br><span class="line">    image, kernel,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># YOUR CODE HERE: set parameters</span></span><br><span class="line">    conv_stride=<span class="number">1</span>,</span><br><span class="line">    conv_padding=<span class="string">&#x27;valid&#x27;</span>,</span><br><span class="line">    pool_size=<span class="number">2</span>,</span><br><span class="line">    pool_stride=<span class="number">2</span>,</span><br><span class="line">    pool_padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    subplot_shape=(<span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line">    figsize=(<span class="number">14</span>, <span class="number">6</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移学习技巧：微调</title>
    <url>/2023/10/25/University/AI/CV/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%BE%AE%E8%B0%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>迁移学习技巧：微调</h1>
<blockquote>
<p>详细参考：<a href="https://zh.d2l.ai/chapter_computer-vision/fine-tuning.html#id2">https://zh.d2l.ai/chapter_computer-vision/fine-tuning.html#id2</a></p>
</blockquote>
<h2 id="微调的四个步骤">微调的四个步骤</h2>
<ol>
<li class="lvl-3">
<p>在<strong>源数据集</strong>（例如ImageNet数据集）上<strong>预训练</strong>神经网络模型，即<em><strong>源模型</strong></em>。</p>
</li>
<li class="lvl-3">
<p>创建一个新的神经网络模型，即<em><strong>目标模型</strong></em>。这将<u>复制源模型上的所有模型设计及其参数（输出层除外）</u>。我们假定这些模型参数包含从源数据集中学到的知识，这些知识也将适用于目标数据集。我们还假设源模型的输出层与源数据集的标签密切相关；因此不在目标模型中使用该层。</p>
</li>
<li class="lvl-3">
<p>向目标模型添加输出层，其输出数是目标数据集中的类别数。然后随机初始化该层的模型参数。</p>
</li>
<li class="lvl-3">
<p>在目标数据集（如椅子数据集）上训练目标模型。输出层将从头开始进行训练，而所有其他层的参数将根据源模型的参数进行微调。</p>
</li>
</ol>
<p><img src="https://zh.d2l.ai/_images/finetune.svg" alt="../_images/finetune.svg"></p>
<p>当<strong>目标数据集比源数据集小得多时</strong>，微调有助于提高模型的<em><strong>泛化能力</strong></em>。</p>
<h2 id="实践：-待定">实践：（待定）</h2>
<h2 id="小结">小结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>迁移学习将从源数据集中学到的知识<em><strong>迁移</strong></em>到目标数据集，微调是迁移学习的常见技巧。</p>
</li>
<li class="lvl-2">
<p>除输出层外，目标模型从源模型中复制所有模型设计及其参数，并<u><strong>根据目标数据集对这些参数进行微调</strong></u>。但是，目标模型的输出层需要从头开始训练。</p>
</li>
<li class="lvl-2">
<p>通常，<u>微调参数</u>使用<strong>较小的学习率</strong>，而<u>从头开始训练输出层</u>可以使用<strong>更大的学习率</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉CV-5</title>
    <url>/2023/09/10/University/AI/CV/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV-5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Data Augmentation</h1>
<p>==数据增强（Data Augmentation）==是深度学习和计算机视觉领域中的一种常用技术，用于**<u>扩充训练数据集</u>**。它的主要目的是<u>通过对原始数据集中的样本进行一系列随机变换或扭曲操作，生成新的训练样本，从而增加数据的多样性</u>。数据增强有助于<u><strong>改善模型的泛化能力</strong></u>，减少过拟合，提高模型的性能和鲁棒性。</p>
<h2 id="the-usefulness-of-fake-data">The Usefulness of Fake Data</h2>
<p>提高机器学习模型性能的最佳方法是<u><strong>使用更多数据对其进行训练</strong></u>。模型学习的例子越多，它就越能够识别图像中哪些差异重要，哪些差异不重要。更多数据有助于模型更好地泛化。</p>
<p>获取更多数据的一种简单方法是<u><strong>使用已有的数据</strong></u>。如果我们能够<u><strong>以保留类别的方式转换数据集中的图像</strong></u>，我们就可以<u><strong>教我们的分类器忽略这些类型的转换</strong></u>。例如，无论汽车在照片中朝左还是朝右，都不会改变它是汽车而不是卡车的事实。因此，如果我们用<mark>翻转图像</mark>来增强训练数据，我们的<u>分类器将了解到“左或右”是它应该忽略的差异</u>。</p>
<p>数据增强背后的思想：添加一些看起来相当像真实数据的额外<mark>假数据</mark>，你的分类器将会得到改进。</p>
<h2 id="using-data-augmentation">Using Data Augmentation</h2>
<p>通常，在扩充数据集时会<strong>使用多种转换</strong>。这些可能包括<u><strong>旋转图像、调整颜色或对比度、扭曲图像</strong></u>或许多其他通常组合应用的操作。以下是单个图像可能被转换的不同方式的示例。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/UaOm0ms.png" alt="Sixteen transformations of a single image of a car." style="zoom: 33%;" />
<p>数据增强通常是在线完成的，这意味着图像被输入网络进行训练。回想一下，训练通常是在小批量数据上完成的。以下就是使用数据增强时一批 16 张图像的样子。</p>
<img src="https://storage.googleapis.com/kaggle-media/learn/images/MFviYoE.png" alt="A batch of 16 images with various random transformations applied." style="zoom:33%;" />
<p>但重要的是要记住，并非所有转换都对给定问题有用。最重要的是，<u><strong>无论使用什么转换，都不应该混淆这些类</strong></u>。例如，如果正在训练数字识别器，旋转图像会混淆“9”和“6”。最后，寻找良好增强的最佳方法与大多数机器学习问题相同：尝试看看！</p>
<h2 id="经典代码">经典代码</h2>
<p>Keras 允许您通过两种方式扩充数据。第一种方法是使用 <code>ImageDataGenerator</code> 等函数将其包含在数据管道中。第二种方法是使用 Keras 的预处理层将其包含在模型定义中。这就是我们将采取的方法。</p>
<p>模型定义时进行数据增强：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="comment"># these are a new feature in TF 2.2</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers.experimental <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pretrained_base = tf.keras.models.load_model(</span><br><span class="line">    <span class="string">&#x27;../input/cv-course-models/cv-course-models/vgg16-pretrained-base&#x27;</span>,</span><br><span class="line">)</span><br><span class="line">pretrained_base.trainable = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">model = keras.Sequential([</span><br><span class="line">    <span class="comment"># Preprocessing</span></span><br><span class="line">    preprocessing.RandomFlip(<span class="string">&#x27;horizontal&#x27;</span>), <span class="comment"># flip left-to-right</span></span><br><span class="line">    preprocessing.RandomContrast(<span class="number">0.5</span>), <span class="comment"># contrast change by up to 50%</span></span><br><span class="line">    <span class="comment"># Base</span></span><br><span class="line">    pretrained_base,</span><br><span class="line">    <span class="comment"># Head</span></span><br><span class="line">    layers.Flatten(),</span><br><span class="line">    layers.Dense(<span class="number">6</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><strong>Preprocessing（预处理）</strong>： 这部分是数据预处理步骤，用于在输入图像进入神经网络之前对其进行一些随机变换，以增加数据的多样性。具体的预处理步骤包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>preprocessing.RandomFlip('horizontal')</code>：随机水平翻转图像，模拟图像中的不同视角。</p>
</li>
<li class="lvl-2">
<p><code>preprocessing.RandomContrast(0.5)</code>：随机改变图像的对比度，对比度变化范围在正负50%之间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN之AlexNet</title>
    <url>/2023/05/23/University/AI/PaperLearn/CNN%E4%B9%8BAlexNet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>CNN之AlexNet</h1>
<blockquote>
<p>论文：<em>ImageNet Classification with Deep Convolutional Neural Networks</em></p>
</blockquote>
<h5 id="abstract"><em><strong>Abstract</strong></em></h5>
<p>我们训练了一个大型深度卷积神经网络，将 ImageNet LSVRC-2010 竞赛中的 120 万张高分辨率图像分类为 1000 个不同的类别。在测试数据上，我们实现了 37.5% 和 17.0% 的 top-1 和 top-5 错误率，这比之前的最新技术要好得多。该神经网络具有 6000 万个参数和 650,000 个神经元，由五个卷积层组成，其中一些卷积层之后是最大池化层，以及三个具有最终 1000 路 softmax 的全连接层。为了加快训练速度，我们使用了非饱和神经元和非常高效的 GPU 卷积运算实现。为了减少全连接层的过度拟合，我们采用了一种最近开发的称为“dropout”的正则化方法，该方法被证明非常有效。我们还在 ILSVRC-2012 竞赛中输入了该模型的一个变体，并获得了 15.3% 的前 5 名测试错误率，而第二好的参赛作品达到了 26.2%。</p>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>机器学习</category>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>AlexNet</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT基础</title>
    <url>/2023/10/18/University/AI/ModelLearning/ChatGPT/ChatGPT%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>ChatGPT基础</h1>
<h3 id="gpt模型">GPT模型</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>GPT (Generative Pre-trained Transformer）</strong><br>
GPT是由OpenAI训练的一种基于深度学习技术的自然语言处理模型，该模型是<strong>基于Transformer结构</strong>的生成式预训练模型。</p>
</li>
<li class="lvl-2">
<p><strong>Transformer</strong><br>
Transformer是一种通用的神经网络结构，它可以用于各种序列到序列的任务，如机器翻译、文本摘要、图像生成等。GPT是一种特殊的Transformer，它只使用了Transformer中的解码器部分，一些模型都使用了Transformer，有的使用其中的编码器部分。<br>
<strong>GPT也可以看作是一种神经网络语言模型，它使用了Transformer作为其神经网络结构。</strong></p>
</li>
</ul>
<h3 id="transformer">Transformer⭐️</h3>
<blockquote>
<p>详细见参考：<a href="https://zhuanlan.zhihu.com/p/338817680">https://zhuanlan.zhihu.com/p/338817680</a></p>
<p>更多参考：<a href="https://transformers.run/back/attention/">https://transformers.run/back/attention/</a></p>
</blockquote>
<h4 id="transformer整体概述">Transformer整体概述</h4>
<p>用于中英文翻译的Transformer整体结构：</p>
<img src="https://pic4.zhimg.com/v2-4544255f3f24b7af1e520684ae38403f_r.jpg" alt="img" style="zoom:50%;" />
<p><strong>Transformer 由 Encoder 和 Decoder 两个部分组成</strong>，Encoder 和 Decoder 都包含 6 个 block。</p>
<p><strong>第一步：<strong>获取输入句子的每一个单词的表示向量 <strong>X</strong>，<strong>X</strong>由单词的 Embedding（Embedding就是从原始数据提取出来的</strong>Feature</strong>） 和单词位置的 Embedding 相加得到。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>思考：单词的 Embedding和位置的 Embedding如何获得？</mark></p>
</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-7dd39c44b0ae45d31a3ae7f39d3f883f_r.jpg" alt="img"></p>
<p><strong>第二步：<strong>将得到的单词表示向量矩阵</strong>x</strong>(<strong>X<sub>n*d</sub></strong>，n表示的是句子中单词的个数，d表示的每个单词向量的维度)输入到<strong>Encoder</strong>中，经过6个 Encoder block 后可以得到句子所有单词的编码信息矩阵 <strong>C</strong>。每一个 Encoder block 输出的矩阵维度与输入完全一致。</p>
<img src="https://pic3.zhimg.com/80/v2-45db05405cb96248aff98ee07a565baa_1440w.webp" alt="img" style="zoom:33%;" />
<p><strong>第三步</strong>：将 <strong>Encoder</strong> 输出的编码信息矩阵 <strong>C</strong>传递到 <strong>Decoder</strong> 中，Decoder 依次会根据当前翻译过的<strong>单词 1~ i</strong> 翻译<strong>下一个单词 i+1</strong>，如下图所示。在使用的过程中，翻译到单词 i+1 的时候需要通过 <strong>Mask (掩盖)</strong> 操作遮盖住 i+1 之后的单词。</p>
<p><img src="https://pic2.zhimg.com/v2-5367bd47a2319397317562c0da77e455_r.jpg" alt="img"></p>
<p><strong>Decoder</strong> 接收了 <strong>Encoder</strong> 的编码矩阵 <strong>C</strong>，然后首先输入一个翻译开始符 “<Begin>”，预测第一个单词 “I”；然后输入翻译开始符 “<Begin>” 和单词 “I”，预测单词 “have”，以此类推，如下图所示。</p>
<p><img src="https://pic1.zhimg.com/v2-4616451fe8aa59b2df2ead30fa31dc98_r.jpg" alt="img"></p>
<h4 id="transformer详细架构">Transformer详细架构</h4>
<img src="https://pic4.zhimg.com/v2-f6380627207ff4d1e72addfafeaff0bb_r.jpg" alt="img" style="zoom:50%;" />
<p>上图是论文中 Transformer 的内部结构图，左侧为 Encoder block，右侧为 Decoder block。红色圈中的部分为 <strong>Multi-Head Attention</strong>，是由多个 <strong>Self-Attention</strong>组成的，可以看到 Encoder block 包含一个 Multi-Head Attention，而 Decoder block 包含两个 Multi-Head Attention (其中有一个用到 Masked)。Multi-Head Attention 上方还包括一个 <strong>Add &amp; Norm</strong> 层，<strong>Add</strong> 表示<u>残差连接</u> (Residual Connection) 用于防止网络退化，Norm 表示 Layer Normalization，用于对每一层的激活值进行<strong>归一化</strong>。</p>
<h5 id="encoder-结构">Encoder 结构</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231018153045934.png" alt="image-20231018153045934" style="zoom: 33%;" />
<p>Encoder block 结构由 Multi-Head Attention, <strong>Add &amp; Norm, Feed Forward, Add &amp; Norm</strong> 组成。其中Multi-Head Attention详见下面的“注意力机制”部分。</p>
<h6 id="add-norm">Add &amp; Norm</h6>
<p>Add &amp; Norm 层由 Add 和 Norm 两部分组成，其计算公式如下：</p>
<img src="https://pic3.zhimg.com/v2-a4b35db50f882522ee52f61ddd411a5a_r.jpg" alt="img" style="zoom: 80%;" />
<p>其中 <strong>X</strong>表示 Multi-Head Attention 或者 Feed Forward 的输入，MultiHeadAttention(<strong>X</strong>) 和 FeedForward(<strong>X</strong>) 表示输出 (输出与输入 <strong>X</strong> 维度是一样的，所以可以相加)。</p>
<p><strong>Add</strong>指 <strong>X</strong>+MultiHeadAttention(<strong>X</strong>)，是一种<strong>残差连接</strong>，通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到：</p>
<p><img src="https://pic4.zhimg.com/v2-4b3dde965124bd00f9893b05ebcaad0f_r.jpg" alt="img"></p>
<p><strong>Norm</strong>指 Layer Normalization，通常用于 RNN 结构，Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的（<strong>归一化</strong>），这样可以加快收敛。</p>
<h6 id="feed-forward">Feed Forward</h6>
<p>Feed Forward 层比较简单，是一个两层的全连接层，第一层的<strong>激活函数</strong>为 <strong>Relu</strong>，第二层<strong>不使用激活函数</strong>，对应的公式如下：</p>
<img src="https://pic2.zhimg.com/v2-47b39ca4cc3cd0be157d6803c8c8e0a1_r.jpg" alt="img" style="zoom:80%;" />
<p><strong>X</strong>是输入，Feed Forward 最终得到的输出矩阵的维度与<strong>X</strong>一致。</p>
<h5 id="decoder-结构">Decoder 结构</h5>
<img src="https://pic3.zhimg.com/v2-f5049e8711c3abe8f8938ced9e7fc3da_r.jpg" alt="img" style="zoom: 50%;" />
<p>Decoder block 结构如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>包含两个 Multi-Head Attention 层。</p>
</li>
<li class="lvl-2">
<p>第一个 Multi-Head Attention 层采用了 <strong>Masked</strong> 操作。</p>
</li>
<li class="lvl-2">
<p>第二个 Multi-Head Attention 层的<strong>V，K</strong>矩阵使用 Encoder 的<strong>编码信息矩阵C</strong>进行计算，而<strong>Q</strong>使用上一个 Decoder block 的输出计算。</p>
</li>
<li class="lvl-2">
<p>最后有一个 Softmax 层计算下一个翻译单词的概率。</p>
</li>
</ul>
<h4 id="注意力机制">注意力机制</h4>
<p>Attention 有许多种实现方式，但是最常见的还是 Scaled Dot-product Attention。</p>
<img src="https://transformers.run/assets/img/attention/attention.png" alt="img" style="zoom:50%;" />
<h5 id="self-attention">Self-Attention</h5>
<p>采用Scaled Dot-product Attention实现，在计算的时候需要用到矩阵<strong>Q(查询),K(键值),V(值)</strong>。</p>
<p>Self-Attention 接收的是输入(单词的表示向量x组成的矩阵X) 或者上一个 Encoder block 的输出。而<strong>Q,K,V</strong>正是通过 Self-Attention 的输入进行线性变换得到的。</p>
<p>Self-Attention 的输入用矩阵X进行表示，可以使用线性变阵矩阵<strong>WQ,WK,WV</strong>计算得到<strong>Q,K,V</strong>。计算如下图所示，<strong>注意 X, Q, K, V 的每一行都表示一个单词。</strong></p>
<img src="https://pic3.zhimg.com/80/v2-4f4958704952dcf2c4b652a1cd38f32e_1440w.webp" alt="img" style="zoom: 33%;" />
<p>根据以下公式计算出Self-Attention的输出：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9699a37b96c2b62d22b312b5e1863acd_1440w.webp" alt="img"></p>
<p>公式中计算矩阵<strong>Q</strong>和<strong>K</strong>每一行向量的内积，为了防止内积过大，因此除以**d<sub>k</sub>**的平方根。矩阵Q与K的转置计算得到的矩阵行列维度均为n，n表示的时句子中单词的个数，计算得到的矩阵表示了单词之间的attention强度。</p>
<img src="https://pic2.zhimg.com/80/v2-9caab2c9a00f6872854fb89278f13ee1_1440w.webp" alt="img" style="zoom:50%;" />
<p>得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">QK^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0358em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>之后，使用 Softmax 计算每一个单词对于其他单词的 attention 系数，公式中的 Softmax 是对矩阵的每一行进行 Softmax，即每一行的和都变为 1.</p>
<img src="https://pic1.zhimg.com/80/v2-96a3716cf7f112f7beabafb59e84f418_1440w.webp" alt="img" style="zoom:50%;" />
<p>得到 Softmax 矩阵之后可以和<strong>V</strong>相乘，得到最终的输出<strong>Z</strong>。</p>
<img src="https://pic4.zhimg.com/80/v2-7ac99bce83713d568d04e6ecfb31463b_1440w.webp" alt="img" style="zoom:50%;" />
<p>上图中 Softmax 矩阵的第 1 行表示单词 1 与其他所有单词的 attention 系数，最终<strong>单词 1</strong> 的输出 <strong>Z1</strong> 等于所有单词 i 的值**V<sub>i</sub>**根据 attention 系数的比例加在一起得到，如下图所示：</p>
<img src="https://pic3.zhimg.com/80/v2-27822b2292cd6c38357803093bea5d0e_1440w.webp" alt="img" style="zoom: 80%;" />
<h5 id="multi-head-attention">Multi-Head Attention</h5>
<p>Multi-Head Attention 是由多个 Self-Attention 组合形成的，下图是论文中 Multi-Head Attention 的结构图。</p>
<img src="https://pic2.zhimg.com/v2-b0ea8f5b639786f98330f70405e94a75_r.jpg" alt="img" style="zoom:33%;" />
<p>Multi-Head Attention 包含多个 Self-Attention 层，首先将输入<strong>X</strong>分别传递到 h 个不同的 Self-Attention 中，计算得到 h 个输出矩阵<strong>Z</strong>。如下图是 h=8 时候的情况，此时会得到 8 个输出矩阵<strong>Z</strong>。</p>
<img src="https://pic1.zhimg.com/v2-6bdaf739fd6b827b2087b4e151c560f4_r.jpg" alt="img" style="zoom: 33%;" />
<p>得到 8 个输出矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Z_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">Z_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之后，Multi-Head Attention 将它们拼接在一起 <strong>(Concat)</strong>，然后传入一个<strong>Linear</strong>层，得到 Multi-Head Attention 最终的输出<strong>Z</strong>。</p>
<img src="https://pic4.zhimg.com/v2-35d78d9aa9150ae4babd0ea6aa68d113_r.jpg" alt="img" style="zoom:67%;" />
<p>可以看到 Multi-Head Attention 输出的矩阵<strong>Z</strong>与其输入的矩阵<strong>X</strong>的<strong>维度是一样的</strong>。</p>
<blockquote>
<p>GPT-3的训练使用了情境（上下文）学习（In-context Learning），它是元学习（Meta-learning）的一种，元学习的核心思想在于通过少量的数据寻找一个合适的初始化范围，使得模型能够在有限的数据集上快速拟合，并获得不错的效果。</p>
</blockquote>
<h3 id="in-context-learning">In-context Learning</h3>
<p>“In-context Learning”（上下文学习）是一种自然语言处理（NLP）中的方法，通常用于<strong>训练和微调</strong>大型预训练模型，以使其适应特定的任务或应用场景。这个方法强调将模型放置在特定上下文中，以让它更好地理解和生成与该上下文相关的文本。</p>
<p>下面是&quot;In-context Learning&quot;的一些关键特点和概念：</p>
<ol>
<li class="lvl-3">
<p><strong>特定上下文</strong>：这意味着将模型置于特定的对话、环境或任务中，以模拟真实世界的情境。这可以包括对话历史、任务描述、问题陈述等。</p>
</li>
<li class="lvl-3">
<p><strong>微调模型</strong>：通常，&quot;In-context Learning&quot;涉及微调一个已经进行了大规模预训练的模型，例如GPT（Generative Pre-trained Transformer）模型。微调的目的是使模型更好地适应特定任务，根据上下文生成更相关的文本。</p>
</li>
<li class="lvl-3">
<p><strong>多模态学习</strong>：&quot;In-context Learning&quot;也可以涉及将多个模态的数据（例如文本、图像、音频）结合在一起，以更好地处理多模态任务，例如文本到图像生成或图像到文本生成。</p>
</li>
<li class="lvl-3">
<p><strong>任务细化</strong>：这种方法可用于各种任务，包括自然语言理解、文本生成、问题回答、对话、图像标注等。通过在特定上下文中微调模型，可以使其更好地执行这些任务。</p>
</li>
<li class="lvl-3">
<p><strong>实时决策</strong>：&quot;In-context Learning&quot;还可以用于模拟代理与环境互动，进行实时决策，例如机器人控制、自动驾驶汽车、虚拟助手等领域。</p>
</li>
</ol>
<img src="https://pic2.zhimg.com/v2-76557778e35baee4266048d08f667cc5_r.jpg" alt="img" style="zoom:33%;" />
<p>In Context Learning（ICL）的关键思想是<strong>从类比中学习</strong>。上图给出了一个描述语言模型如何使用 ICL 进行决策的例子。首先，ICL 需要一些示例来形成一个演示上下文。这些示例通常是用自然语言模板编写的。然后 ICL 将查询的问题（即你需要预测标签的 input）和一个上下文演示（一些相关的 cases）连接在一起，形成带有提示的输入，并将其输入到语言模型中进行预测。</p>
<h3 id="meta-learning">Meta-learning</h3>
<blockquote>
<p>元学习Meta Learning，含义为学会学习，即learn to learn，就是带着这种对人类这种“学习能力”的期望诞生的。Meta Learning希望使得模型获取一种“学会学习”的能力，使其可以在获取已有“知识”的基础上快速学习新的任务。</p>
<ul class="lvl-1">
<li class="lvl-2">参考：<a href="https://zhuanlan.zhihu.com/p/136975128">https://zhuanlan.zhihu.com/p/136975128</a></li>
</ul>
</blockquote>
<img src="https://pic4.zhimg.com/v2-23b952fb974edeffa4e28d0065440227_r.jpg" alt="img" style="zoom:33%;" />
<p>机器学习中的Function直接作用于特征和标签，去寻找特征与标签之间的关联；而元学习中的Function是用于寻找新的f，新的f才会应用于具体的任务。</p>
<h5 id="maml与model-pre-training的区别：">MAML与Model Pre-training的区别：</h5>
<img src="https://pic3.zhimg.com/80/v2-fa485a14b8e56279f66c88678924385a_1440w.webp" alt="img" style="zoom: 33%;" />
<h4 id="模型无关元学习-maml">模型无关元学习（MAML）</h4>
<p>“模型无关元学习”（Model-Agnostic Meta-Learning），是一种用于元学习的机器学习算法。MAML 的核心思想是训练一个模型，使其能够快速适应新任务或数据集。与传统的机器学习方法不同，MAML 不专注于学习特定任务，而是关注如何学会学习（learn to learn）。</p>
<h6 id="maml算法流程：">MAML算法流程：</h6>
<p><img src="https://pic1.zhimg.com/v2-eda1034966a79b9f1c30dc6527b57830_r.jpg" alt="img"></p>
<h3 id="提示学习-prompt-learning-和指示学习-instruct-learning">提示学习（Prompt Learning）和指示学习（Instruct Learning）</h3>
<p>Prompt是激发语言模型的<strong>补全能力</strong>，例如根据上半句生成下半句，或是完形填空等。Instruct是激发语言模型的理解能力，它通过给出更明显的指令，让模型去做出正确的行动。</p>
<ol>
<li class="lvl-3">
<p>提示学习：给女朋友买了这个项链，她很喜欢，这个项链太____了。</p>
</li>
<li class="lvl-3">
<p>指示学习：这句话的情感是非常正向的：给女朋友买了这个项链，她很喜欢。</p>
</li>
</ol>
<h3 id="强化学习-reinforcement-learning">强化学习（Reinforcement learning）</h3>
<blockquote>
<p>强化学习是除了<a href="https://zh.wikipedia.org/wiki/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0">监督学习</a>和<a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%9B%A3%E7%9D%A3%E5%AD%B8%E7%BF%92">非监督学习</a>之外的第三种基本的机器学习方法。</p>
</blockquote>
<p>强化学习通过奖励（Reward）机制来指导模型训练，奖励机制可以看做传统模型训练机制的损失函数。</p>
<p>强化学习的思路是通过对奖励的大量采样来拟合损失函数，从而实现模型的训练。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Reinforcement_learning_diagram.svg/1280px-Reinforcement_learning_diagram.svg.png" alt="undefined" style="zoom:25%;" />
<p>强化学习的典型框架：智能体在环境中采取一种行为（Action），环境将其转换为一次回报（Reward）和一种状态（State）表示，随后反馈给智能体（Agent）。</p>
<h4 id="基于人类反馈的强化学习">基于人类反馈的强化学习</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-028a8f676586a8f1dcf9235cb5c06a25_r.jpg" alt="img" style="zoom:33%;" />
]]></content>
      <categories>
        <category>格物致知</category>
        <category>经典模型</category>
        <category>ChatGPT</category>
      </categories>
      <tags>
        <tag>经典模型</tag>
        <tag>ChatGPT</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer基础</title>
    <url>/2023/10/23/University/AI/ModelLearning/ChatGPT/Transformer%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Transformer</h1>
<blockquote>
<p>详细见参考：<a href="https://zhuanlan.zhihu.com/p/338817680">https://zhuanlan.zhihu.com/p/338817680</a></p>
</blockquote>
<h3 id="transformer整体概述">Transformer整体概述</h3>
<p>用于中英文翻译的Transformer整体结构：</p>
<img src="https://pic4.zhimg.com/v2-4544255f3f24b7af1e520684ae38403f_r.jpg" alt="img" style="zoom:50%;" />
<p><strong>Transformer 由 Encoder 和 Decoder 两个部分组成</strong>，Encoder 和 Decoder 都包含 6 个 block。</p>
<p><strong>第一步：<strong>获取输入句子的每一个单词的表示向量 <strong>X</strong>，<strong>X</strong>由单词的 Embedding（Embedding就是从原始数据提取出来的</strong>Feature</strong>） 和单词位置的 Embedding 相加得到。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>思考：单词的 Embedding和位置的 Embedding如何获得？</mark></p>
</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-7dd39c44b0ae45d31a3ae7f39d3f883f_r.jpg" alt="img"></p>
<p><strong>第二步：<strong>将得到的单词表示向量矩阵</strong>x</strong>(<strong>X<sub>n*d</sub></strong>，n表示的是句子中单词的个数，d表示的每个单词向量的维度)输入到<strong>Encoder</strong>中，经过6个 Encoder block 后可以得到句子所有单词的编码信息矩阵 <strong>C</strong>。每一个 Encoder block 输出的矩阵维度与输入完全一致。</p>
<img src="https://pic3.zhimg.com/80/v2-45db05405cb96248aff98ee07a565baa_1440w.webp" alt="img" style="zoom:33%;" />
<p><strong>第三步</strong>：将 <strong>Encoder</strong> 输出的编码信息矩阵 <strong>C</strong>传递到 <strong>Decoder</strong> 中，Decoder 依次会根据当前翻译过的<strong>单词 1~ i</strong> 翻译<strong>下一个单词 i+1</strong>，如下图所示。在使用的过程中，翻译到单词 i+1 的时候需要通过 <strong>Mask (掩盖)</strong> 操作遮盖住 i+1 之后的单词。</p>
<p><img src="https://pic2.zhimg.com/v2-5367bd47a2319397317562c0da77e455_r.jpg" alt="img"></p>
<p><strong>Decoder</strong> 接收了 <strong>Encoder</strong> 的编码矩阵 <strong>C</strong>，然后首先输入一个翻译开始符 “<Begin>”，预测第一个单词 “I”；然后输入翻译开始符 “<Begin>” 和单词 “I”，预测单词 “have”，以此类推，如下图所示。</p>
<p><img src="https://pic1.zhimg.com/v2-4616451fe8aa59b2df2ead30fa31dc98_r.jpg" alt="img"></p>
<h4 id="transformer详细架构">Transformer详细架构</h4>
<img src="https://pic4.zhimg.com/v2-f6380627207ff4d1e72addfafeaff0bb_r.jpg" alt="img" style="zoom:50%;" />
<p>上图是论文中 Transformer 的内部结构图，左侧为 Encoder block，右侧为 Decoder block。红色圈中的部分为 <strong>Multi-Head Attention</strong>，是由多个 <strong>Self-Attention</strong>组成的，可以看到 Encoder block 包含一个 Multi-Head Attention，而 Decoder block 包含两个 Multi-Head Attention (其中有一个用到 Masked)。Multi-Head Attention 上方还包括一个 <strong>Add &amp; Norm</strong> 层，<strong>Add</strong> 表示<u>残差连接</u> (Residual Connection) 用于防止网络退化，Norm 表示 Layer Normalization，用于对每一层的激活值进行<strong>归一化</strong>。</p>
<h5 id="encoder-结构">Encoder 结构</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231018153045934.png" alt="image-20231018153045934" style="zoom: 33%;" />
<p>Encoder block 结构由 Multi-Head Attention, <strong>Add &amp; Norm, Feed Forward, Add &amp; Norm</strong> 组成。其中Multi-Head Attention详见下面的“注意力机制”部分。</p>
<h6 id="add-norm">Add &amp; Norm</h6>
<p>Add &amp; Norm 层由 Add 和 Norm 两部分组成，其计算公式如下：</p>
<img src="https://pic3.zhimg.com/v2-a4b35db50f882522ee52f61ddd411a5a_r.jpg" alt="img" style="zoom: 80%;" />
<p>其中 <strong>X</strong>表示 Multi-Head Attention 或者 Feed Forward 的输入，MultiHeadAttention(<strong>X</strong>) 和 FeedForward(<strong>X</strong>) 表示输出 (输出与输入 <strong>X</strong> 维度是一样的，所以可以相加)。</p>
<p><strong>Add</strong>指 <strong>X</strong>+MultiHeadAttention(<strong>X</strong>)，是一种<strong>残差连接</strong>，通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到：</p>
<p><img src="https://pic4.zhimg.com/v2-4b3dde965124bd00f9893b05ebcaad0f_r.jpg" alt="img"></p>
<p><strong>Norm</strong>指 Layer Normalization，通常用于 RNN 结构，Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的（<strong>归一化</strong>），这样可以加快收敛。</p>
<h6 id="feed-forward">Feed Forward</h6>
<p>Feed Forward 层比较简单，是一个两层的全连接层，第一层的<strong>激活函数</strong>为 <strong>Relu</strong>，第二层<strong>不使用激活函数</strong>，对应的公式如下：</p>
<img src="https://pic2.zhimg.com/v2-47b39ca4cc3cd0be157d6803c8c8e0a1_r.jpg" alt="img" style="zoom:80%;" />
<p><strong>X</strong>是输入，Feed Forward 最终得到的输出矩阵的维度与<strong>X</strong>一致。</p>
<h5 id="decoder-结构">Decoder 结构</h5>
<img src="https://pic3.zhimg.com/v2-f5049e8711c3abe8f8938ced9e7fc3da_r.jpg" alt="img" style="zoom: 50%;" />
<p>Decoder block 结构如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>包含两个 Multi-Head Attention 层。</p>
</li>
<li class="lvl-2">
<p>第一个 Multi-Head Attention 层采用了 <strong>Masked</strong> 操作。</p>
</li>
<li class="lvl-2">
<p>第二个 Multi-Head Attention 层的<strong>V，K</strong>矩阵使用 Encoder 的<strong>编码信息矩阵C</strong>进行计算，而<strong>Q</strong>使用上一个 Decoder block 的输出计算。</p>
</li>
<li class="lvl-2">
<p>最后有一个 Softmax 层计算下一个翻译单词的概率。</p>
</li>
</ul>
<h4 id="注意力机制">注意力机制</h4>
<p>Attention 有许多种实现方式，但是最常见的还是 Scaled Dot-product Attention。</p>
<img src="https://transformers.run/assets/img/attention/attention.png" alt="img" style="zoom:50%;" />
<h5 id="self-attention">Self-Attention</h5>
<p>采用Scaled Dot-product Attention实现，在计算的时候需要用到矩阵<strong>Q(查询),K(键值),V(值)</strong>。</p>
<p>Self-Attention 接收的是输入(单词的表示向量x组成的矩阵X) 或者上一个 Encoder block 的输出。而<strong>Q,K,V</strong>正是通过 Self-Attention 的输入进行线性变换得到的。</p>
<p>Self-Attention 的输入用矩阵X进行表示，可以使用线性变阵矩阵<strong>WQ,WK,WV</strong>计算得到<strong>Q,K,V</strong>。计算如下图所示，<strong>注意 X, Q, K, V 的每一行都表示一个单词。</strong></p>
<img src="https://pic3.zhimg.com/80/v2-4f4958704952dcf2c4b652a1cd38f32e_1440w.webp" alt="img" style="zoom: 33%;" />
<p>根据以下公式计算出Self-Attention的输出：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9699a37b96c2b62d22b312b5e1863acd_1440w.webp" alt="img"></p>
<p>公式中计算矩阵<strong>Q</strong>和<strong>K</strong>每一行向量的内积，为了防止内积过大，因此除以**d<sub>k</sub>**的平方根。矩阵Q与K的转置计算得到的矩阵行列维度均为n，n表示的时句子中单词的个数，计算得到的矩阵表示了单词之间的attention强度。</p>
<img src="https://pic2.zhimg.com/80/v2-9caab2c9a00f6872854fb89278f13ee1_1440w.webp" alt="img" style="zoom:50%;" />
<p>得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">QK^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0358em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>之后，使用 Softmax 计算每一个单词对于其他单词的 attention 系数，公式中的 Softmax 是对矩阵的每一行进行 Softmax，即每一行的和都变为 1.</p>
<img src="https://pic1.zhimg.com/80/v2-96a3716cf7f112f7beabafb59e84f418_1440w.webp" alt="img" style="zoom:50%;" />
<p>得到 Softmax 矩阵之后可以和<strong>V</strong>相乘，得到最终的输出<strong>Z</strong>。</p>
<img src="https://pic4.zhimg.com/80/v2-7ac99bce83713d568d04e6ecfb31463b_1440w.webp" alt="img" style="zoom:50%;" />
<p>上图中 Softmax 矩阵的第 1 行表示单词 1 与其他所有单词的 attention 系数，最终<strong>单词 1</strong> 的输出 <strong>Z1</strong> 等于所有单词 i 的值**V<sub>i</sub>**根据 attention 系数的比例加在一起得到，如下图所示：</p>
<img src="https://pic3.zhimg.com/80/v2-27822b2292cd6c38357803093bea5d0e_1440w.webp" alt="img" style="zoom: 80%;" />
<h5 id="multi-head-attention">Multi-Head Attention</h5>
<p>Multi-Head Attention 是由多个 Self-Attention 组合形成的，下图是论文中 Multi-Head Attention 的结构图。</p>
<img src="https://pic2.zhimg.com/v2-b0ea8f5b639786f98330f70405e94a75_r.jpg" alt="img" style="zoom:33%;" />
<p>Multi-Head Attention 包含多个 Self-Attention 层，首先将输入<strong>X</strong>分别传递到 h 个不同的 Self-Attention 中，计算得到 h 个输出矩阵<strong>Z</strong>。如下图是 h=8 时候的情况，此时会得到 8 个输出矩阵<strong>Z</strong>。</p>
<img src="https://pic1.zhimg.com/v2-6bdaf739fd6b827b2087b4e151c560f4_r.jpg" alt="img" style="zoom: 33%;" />
<p>得到 8 个输出矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Z_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">Z_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之后，Multi-Head Attention 将它们拼接在一起 <strong>(Concat)</strong>，然后传入一个<strong>Linear</strong>层，得到 Multi-Head Attention 最终的输出<strong>Z</strong>。</p>
<img src="https://pic4.zhimg.com/v2-35d78d9aa9150ae4babd0ea6aa68d113_r.jpg" alt="img" style="zoom:67%;" />
<p>可以看到 Multi-Head Attention 输出的矩阵<strong>Z</strong>与其输入的矩阵<strong>X</strong>的<strong>维度是一样的</strong>。</p>
<h3 id="transformer涉及到的相关知识">Transformer涉及到的相关知识</h3>
<blockquote>
<p>batch norm与layer norm参考：<a href="https://zhuanlan.zhihu.com/p/74516930">https://zhuanlan.zhihu.com/p/74516930</a></p>
</blockquote>
<h4 id="batch-norm">batch norm</h4>
<p>Batch 顾名思义是对一个batch进行操作。假设我们有 10行 3列 的数据，即我们的batchsize = 10，每一行数据有三个特征，假设这三个特征是【身高、体重、年龄】。那么BN是针对每一列（特征）进行缩放，例如算出【身高】的均值与方差，再对身高这一列的10个数据进行缩放。体重和年龄同理。这是一种**“列缩放”**。</p>
<h4 id="layer-norm">layer norm</h4>
<p>layer方向相反，它针对的是每一行进行缩放。即只看一笔数据，算出这笔所有特征的均值与方差再缩放。这是一种**“行缩放”**。</p>
<blockquote>
<p>可以发现，针对例子“10行 3列 的数据”：layer normalization 对所有的特征进行缩放，这显得很没道理。我们算出一行这【身高、体重、年龄】三个特征的均值方差并对其进行缩放，事实上会因为特征的量纲不同而产生很大的影响。但是BN则没有这个影响，因为BN是对一列进行缩放，一列的量纲单位都是相同的。</p>
</blockquote>
<h4 id="为什么nlp中常用layer-norm？">为什么NLP中常用layer norm？</h4>
<p>如果我们将一批文本组成一个batch，那么BN的操作方向是，对每句话的<strong>第一个</strong>词进行操作。但语言文本的复杂性是很高的，任何一个词都有可能放在初始位置，且词序可能并不影响我们对句子的理解。而BN是<strong>针对每个位置</strong>进行缩放，这<strong>不符合NLP的规律</strong>。</p>
<p>而LN则是针对一句话进行缩放的，且L<strong>N一般用在第三维度</strong>，如[batchsize, seq_len, dims]中的dims，一般为词向量的维度。这一维度各个特征的量纲应该相同。因此也不会遇到上面因为特征的量纲不同而导致的缩放问题。</p>
<blockquote>
<p>为啥<strong>BN不适合NLP</strong> 是因为NLP模型训练里的每次输入的句子都是多个句子，并且<strong>长度不一</strong>，那么针对每一句的缩放才更加合理，才能表达每个句子之间代表不同的语义表示，这样让模型更加能捕捉句子之间的上下语义关系。如果要用BN，它首先要面临的长度不一的问题。有时候batch size 越小的bn 效果更不好。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-5a52774dde73a4dc86bcd55a88be5d04_r.jpg" alt="img" style="zoom:50%;" />
<p>**Batch Norm：**在不同样本的同一个词位置上的不同的特征维度上做归一化（按照每一个绿色箭头方向做归一化）；</p>
<p>**Layer Norm：**在同一个样本的不同词位置上对词向量（特征维度）做归一化（按照每一个红色箭头方向做归一化）</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>Z轴表示的是<strong>词向量</strong>。</p>
</li>
<li class="lvl-2">
<p>张量表示形式：[batchsize, seqlen, embedding dim]</p>
</li>
</ul>
</blockquote>
<h4 id="multi-head-attention的mask操作">Multi-Head Attention的Mask操作</h4>
<p><img src="https://pic1.zhimg.com/v2-4616451fe8aa59b2df2ead30fa31dc98_r.jpg" alt="img"></p>
<p>Decoder 可以在训练的过程中使用 Teacher Forcing 并且并行化训练，即将正确的单词序列 (<Begin> I have a cat) 和对应输出 (I have a cat <end>) 传递到 Decoder。那么在预测第 i 个输出时，就要将第 i+1 之后的单词掩盖住，<strong>注意 Mask 操作是在 Self-Attention 的 Softmax 之前使用的，下面用 0 1 2 3 4 5 分别表示 &quot;<Begin> I have a cat <end>&quot;。</strong></p>
<p>**第一步：**是 Decoder 的输入矩阵和 <strong>Mask</strong> 矩阵，输入矩阵包含 &quot;<Begin> I have a cat&quot; (0, 1, 2, 3, 4) 五个单词的表示向量，<strong>Mask</strong> 是一个 5×5 的矩阵。在 <strong>Mask</strong> 可以发现单词 0 只能使用单词 0 的信息，而单词 1 可以使用单词 0, 1 的信息，即只能使用之前的信息。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b26299d383aee0dd42b163e8bda74fc8_720w.webp" alt="img"></p>
<blockquote>
<p><strong>Mask矩阵</strong>相当于：不遮挡（绿色）部分为1，遮挡（黄色）部分为0。</p>
</blockquote>
<p><strong>第二步：<strong>接下来的操作和之前的 Self-Attention 一样，通过输入矩阵</strong>X</strong>计算得到<strong>Q,K,V</strong>矩阵。然后计算<strong>Q</strong>和<strong>K<sup>T</sup><strong>的乘积</strong>QK<sup>T</sup></strong>。</p>
<p><img src="https://pic4.zhimg.com/v2-a63ff9b965595438ed0c0e0547cd3d3b_r.jpg" alt="img"></p>
<p>**第三步：**在得到 <strong>QK<sup>T</sup><strong>之后需要进行 Softmax，计算 attention score，我们在 Softmax 之前需要使用</strong>Mask</strong>矩阵遮挡住每一个单词之后的信息，遮挡操作如下：</p>
<p><img src="https://pic2.zhimg.com/v2-35d1c8eae955f6f4b6b3605f7ef00ee1_r.jpg" alt="img"></p>
<p>得到 <strong>Mask</strong> **QK<sup>T</sup>**之后在 <strong>Mask</strong>  **QK<sup>T</sup>**上进行 Softmax，每一行的和都为 1。但是单词 0 在单词 1, 2, 3, 4 上的 attention score 都为 0。</p>
<p>**第四步：**使用 <strong>Mask</strong>  **QK<sup>T</sup>**与矩阵 <strong>V</strong>相乘，得到输出 <strong>Z</strong>，则单词 1 的输出向量 <strong>Z1</strong> 是只包含单词 1 信息的。</p>
<p><img src="https://pic4.zhimg.com/v2-58f916c806a6981e296a7a699151af87_r.jpg" alt="img"></p>
<p><strong>第五步：<strong>通过上述步骤就可以得到一个 Mask Self-Attention 的输出矩阵</strong>Z<sub>i</sub></strong>，然后和 Encoder 类似，通过 Multi-Head Attention 拼接多个输出 <strong>Z<sub>i</sub></strong> 然后计算得到第一个 Multi-Head Attention 的输出<strong>Z</strong>，<strong>Z</strong>与输入<strong>X</strong>维度一样。</p>
<h4 id="mlp-multilayer-perceptron">MLP（Multilayer perceptron）</h4>
<p>多层感知器是一种前向结构的人工神经网络，映射一组输入向量到一组输出向量。MLP可以被看作是一个有向图，由多个的节点层所组成，<strong>每一层都全连接到下一层</strong>。除了输入节点，每个节点都是一个带有非线性激活函数的神经元。</p>
<h4 id="position-encodeing">Position Encodeing</h4>
<p>Transformer 中除了单词的 Embedding，还需要使用位置 Embedding 表示单词出现在句子中的位置。**因为 Transformer 不采用 RNN 的结构，而是使用全局信息，不能利用单词的顺序信息，而这部分信息对于 NLP 来说非常重要。**所以 Transformer 中使用位置 Embedding 保存单词在序列中的相对或绝对位置。</p>
<p>位置 Embedding 用 <strong>PE</strong>表示，<strong>PE</strong> 的维度与单词 Embedding 是一样的。PE 可以通过训练得到，也可以使用某种公式计算得到。在 Transformer 中采用了后者，计算公式如下：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-8b442ffd03ea0f103e9acc37a1db910a_1440w.webp" alt="img" style="zoom:50%;" />
<p>其中，pos 表示单词在句子中的位置，d 表示 PE的维度 (与词 Embedding 一样)，2i 表示偶数的维度，2i+1 表示奇数维度 (即 2i≤d, 2i+1≤d)。使用这种公式计算 PE 有以下的好处：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使 PE 能够适应比训练集里面所有句子更长的句子，假设训练集里面最长的句子是有 20 个单词，突然来了一个长度为 21 的句子，则使用公式计算的方法可以计算出第 21 位的 Embedding。</p>
</li>
<li class="lvl-2">
<p>可以让模型容易地计算出相对位置，对于固定长度的间距 k，<strong>PE(pos+k)</strong> 可以用 <strong>PE(pos)</strong> 计算得到。因为 Sin(A+B) = Sin(A)Cos(B) + Cos(A)Sin(B), Cos(A+B) = Cos(A)Cos(B) - Sin(A)Sin(B)。</p>
</li>
</ul>
<h2 id="transformer-总结">Transformer 总结</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Transformer 与 RNN 不同，可以比较好地并行训练。</p>
</li>
<li class="lvl-2">
<p>Transformer 本身是不能利用单词的顺序信息的，因此需要在输入中添加位置 Embedding，否则 Transformer 就是一个词袋模型了。</p>
</li>
<li class="lvl-2">
<p>Transformer 的重点是 Self-Attention 结构，其中用到的 <strong>Q, K, V</strong>矩阵通过输出进行线性变换得到。</p>
</li>
<li class="lvl-2">
<p>Transformer 中 Multi-Head Attention 中有多个 Self-Attention，可以捕获单词之间多种维度上的相关系数 attention score。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>经典模型</category>
        <category>Transformer</category>
      </categories>
      <tags>
        <tag>经典模型</tag>
        <tag>Transformer</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP模拟考笔记</title>
    <url>/2023/10/18/University/junior/competition/CCF-CSP/CCF-CSP%E6%A8%A1%E6%8B%9F%E8%80%83%E7%AC%AC%E4%B8%80%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="编码注意">编码注意</h3>
<blockquote>
<p>在使用DevC++时，为了使用万能开头（<code>#include&lt;bits/stdc++.h&gt;</code>），必须在编译选项中加入<code>-std=c++11</code>：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307101026639.png" alt="image-20230307101026639"></p>
</blockquote>
<h1>CCF-CSP模拟考笔记</h1>
<h5 id="u-span-style-color-red-特别提醒：-span-编写代码时最好将变量以及数组定义等放在main函数外面-u">⭐️<u><strong><span style="color: red;">特别提醒：</span>编写代码时最好将变量以及数组定义等放在main函数外面</strong></u></h5>
<blockquote>
<p>参考：<a href="https://github.com/richenyunqi/CCF-CSP-and-PAT-solution">richenyunqi/CCF-CSP-and-PAT-solution: CCF CSP和PAT考试题解（使用C++14语法） (github.com)</a></p>
</blockquote>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_53919192/article/details/124893395">(98条消息) CCF-CSP历年真题大全附题解(202212已更)_csp真题_Hulake_的博客-CSDN博客</a></p>
<p>官网模拟题：<a href="http://118.190.20.162/home.page">首页 - 计算机软件能力认证考试系统</a></p>
</blockquote>
<h2 id="第一题">第一题</h2>
<h4 id="202212-1-现值计算">202212-1、现值计算</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302165411891.png" alt="问题描述"></p>
<blockquote>
<p>根据题意有两种集散方式，其中根据题中的最后一句话“<u>将所有款项转换为当前价值后</u>”，因此我们需要利用后面的计算第K年的x元的当前价值的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>i</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x*(1+i)^{-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>计算公式来求解。（依次将每一年的金额转换为当前价值的金额）</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> i;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">double</span> result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j &lt;= n;j++)&#123;</span><br><span class="line">        cin &gt;&gt; q[j];</span><br><span class="line">        result+=q[j]*<span class="built_in">pow</span>(<span class="number">1</span>+i,-j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3f&quot;</span>,result)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网上100分参考代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> i;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">double</span> all;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        cin &gt;&gt; q[j];</span><br><span class="line">        all += q[j] * <span class="built_in">pow</span>(<span class="number">1</span> + i, -j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3f&quot;</span>, all);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202209-1-如此编码">202209-1、如此编码</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230304210937266.png" alt="题目描述"></p>
<blockquote>
<p>由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi mathvariant="normal">%</mi><msub><mi>c</mi><mi>j</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>j</mi></msubsup><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>×</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m \% c_j=\sum_{i=1}^j c_{i-1} \times b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">m</span><span class="mord">%</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2643em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可知有m \% c_3 & =c_0 \times b_1+c_1 \times b_2+c_2 \times b_3 \\，又因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2=a_1*a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6153em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2=c_1*a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6153em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则可以得到\frac{m \% c_3}{c_2} & =\frac{c_0 \times b_1+c_1 \times b_2+c_2 \times b_3 \\}{c_2}=\frac{c_0 \times b_1+c_1 \times b_2 \\}{c_2}+b_3，同时显然可以知道<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>c</mi><mn>0</mn></msub><mo>×</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>c</mi><mn>1</mn></msub><mo>×</mo><msub><mi>b</mi><mn>2</mn></msub><mspace linebreak="newline"></mspace></mrow><msub><mi>c</mi><mn>2</mn></msub></mfrac><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{c_0 \times b_1+c_1 \times b_2 \\}{c_2}&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3413em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mspace mtight newline"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，因此得到以下求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mul=c*a[i];		<span class="comment">//mul就是c[i]，c就是c[i-1]</span></span><br><span class="line">b[i]=<span class="built_in">int</span>((m%mul)/c);</span><br><span class="line">c=mul;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);<span class="comment">//输出结果</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一次85分代码如下：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n+<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//下标从1开始 </span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">c</span>(n,<span class="number">0</span>);<span class="comment">//下标从0开始 </span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(n+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输入每道题的选项数目 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	c[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> mul;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		mul=c[i<span class="number">-1</span>]*a[i];</span><br><span class="line">		c[i]=mul;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> remainder,quotient ;<span class="comment">//定义余数和商 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		remainder=m%c[i];</span><br><span class="line">		quotient=m/c[i]; </span><br><span class="line">		b[i+<span class="number">1</span>]=quotient;</span><br><span class="line">		m=remainder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后100分的代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n+<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//下标从1开始 </span></span><br><span class="line"><span class="comment">//	vector&lt;int&gt;c(n,0);//下标从0开始 </span></span><br><span class="line">	<span class="type">int</span> c=<span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(n+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输入每道题的选项数目 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mul;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		mul=c*a[i];</span><br><span class="line">		b[i]=<span class="built_in">int</span>((m%mul)/c);</span><br><span class="line">		c=mul;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);<span class="comment">//输出结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//网上100分参考代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span>, tc = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">        tc = a[i] * c;</span><br><span class="line">        b[i] = <span class="built_in">int</span>((m % tc) / c);</span><br><span class="line">        c = tc;</span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202206-1-归一化处理">202206-1、归一化处理</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230304170401201.png" alt="问题描述"></p>
<blockquote>
<p>注意最重要的是误差不能超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，其它直接根据公式编写代码即可。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储整数的数组a要定义为double类型如果定义为int类型会导致最后的输出结果的误差大于了10-4 </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt;<span class="built_in">a</span>(<span class="number">1000</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> mean_a;</span><br><span class="line"><span class="type">double</span> D_a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">double</span> mid_sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];  </span><br><span class="line">		mid_sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	mean_a=mid_sum/n;</span><br><span class="line">	</span><br><span class="line">	<span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">		sum+=<span class="built_in">pow</span>(a[j]-mean_a,<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	D_a=<span class="built_in">sqrt</span>(sum/n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">double</span> f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;++k)&#123;</span><br><span class="line">		f=(a[k]-mean_a)/(D_a);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202203-1-未初始化警告">202203-1、未初始化警告</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230305104223205.png" alt="问题描述"></p>
<blockquote>
<p>这道题需要注意的是如果输入右值为0的话，则表示的是右值为常数；主要利用map进行hash映射来判断。</p>
<p><span style="color: red;">PS：map只能初始化大小，不能初始化值 </span></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="type">int</span> key,key1,counts=<span class="number">0</span>;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;<span class="built_in">hash</span>(n);</span><br><span class="line">	cin&gt;&gt;key&gt;&gt;key1;</span><br><span class="line">	<span class="keyword">if</span>(key1==<span class="number">0</span>)</span><br><span class="line">		hash[key1]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		hash[key1]=<span class="number">-1</span>;	<span class="comment">//未初始化 </span></span><br><span class="line">		counts++;</span><br><span class="line">	&#125;</span><br><span class="line">	hash[key]=<span class="number">1</span>;	<span class="comment">//已初始化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;++i)&#123;</span><br><span class="line">		cin&gt;&gt;key&gt;&gt;key1;</span><br><span class="line">		<span class="keyword">if</span>(key1==<span class="number">0</span>||hash[key1]==<span class="number">1</span>)&#123;<span class="comment">//已初始化 </span></span><br><span class="line">			hash[key1]=<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">//未初始化 </span></span><br><span class="line">			hash[key1]=<span class="number">-1</span>;</span><br><span class="line">			counts++;</span><br><span class="line">		&#125;</span><br><span class="line">		hash[key]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,counts);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202112-1-序列查询">202112-1、序列查询</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230305111538519.png" alt="问题描述"></p>
<blockquote>
<p>采用 lower_bound()查找位置下标，如果A集合中存在与N相等的元素，则直接返回的是与N相等的元素的位置下标；如果A集合中不存在与N相等的元素，则返回的是<mark>第一个大于N的元素的位置下标</mark>，因此需要根据题意将位置下标-1。</p>
<p><u><em><strong>lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。</strong></em></u></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,N;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">A</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>,f;</span><br><span class="line">	N=N<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(N&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		f=<span class="built_in">lower_bound</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>(),N)-A.<span class="built_in">begin</span>();<span class="comment">//lower_bound返回一个迭代器</span></span><br><span class="line">		<span class="keyword">if</span>(A[f]!=N)f=f<span class="number">-1</span>;	<span class="comment">//注意如果A[f]的值等于N的值则返回的f不减1</span></span><br><span class="line">		sum+=f;</span><br><span class="line">		N=N<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202109-1-数组推导">202109-1、数组推导</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230305181740827.png" alt="问题描述"></p>
<blockquote>
<p>重点是B数组的单调不降性。同时求最小和时连续出现多个相等元素时最小和加上0。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,min_sum=<span class="number">0</span>,max_sum=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> max_val,tmp;</span><br><span class="line">	cin&gt;&gt;tmp;<span class="comment">//输入数据为不递减 </span></span><br><span class="line">	max_val=tmp;</span><br><span class="line">	min_sum+=tmp;</span><br><span class="line">	max_sum+=tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//从第二个输入整数开始 </span></span><br><span class="line">		cin&gt;&gt;tmp;</span><br><span class="line">		max_sum+=tmp;<span class="comment">//最大和就是输入序列直接求和 </span></span><br><span class="line">		<span class="keyword">if</span>(tmp!=max_val)&#123;<span class="comment">//最大值发生变化 </span></span><br><span class="line">			max_val=tmp;</span><br><span class="line">			min_sum+=tmp; <span class="comment">//当连续出现多个相等元素时，B中可以存在多个0的情况，因此最小和加上0 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max_sum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,min_sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202104-1-灰度直方图">202104-1、灰度直方图</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230305213930289.png" alt="问题描述"></p>
<blockquote>
<p>灰度值只能是[0,L)内的整数，本题要求相同灰度值的像素个数，因此可以采用unordered_map求解。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,L;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;L;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;<span class="built_in">hash</span>(L);</span><br><span class="line">	<span class="type">int</span> M_A;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n*m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;M_A;</span><br><span class="line">		++hash[M_A];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L;++i)&#123;</span><br><span class="line">		cout&lt;&lt;hash[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202012-1-期末预测之安全指数">202012-1、期末预测之安全指数</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307181927537.png" alt="题目描述"></p>
<blockquote>
<p><u>这道题很简单！</u>求和，比较即可。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,w,score,x=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;w&gt;&gt;score;</span><br><span class="line">		x+=w*score;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">max</span>(<span class="number">0</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202009-1-称检测点查询">202009-1、称检测点查询</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230308213827195.png" alt="问题描述"></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/DonquixoteXXXXX/article/details/115420221">(99条消息) CCF-CSP C/C++ 202009-1 称检测点查询 题解_语句应用题设核酸检测数据库中有下面三个采样点(编号,名称,所属街道,类型,地_DonquixoteXXXXX的博客-CSDN博客</a></p>
<p><span style="color: red;">关键：</span>灵活运用sort方法的cmp自定义排序规则。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序规则——升序排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.first==b.first)<span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">	<span class="keyword">return</span> a.first&lt;b.first; <span class="comment">//如果a.first&lt;b.first为true，则表明符合我们的排序规则，不进行位置交换；否则需要进行a，b的位置交换。</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,X,Y;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;X&gt;&gt;Y;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;local[n+<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">double</span> D;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		D=(<span class="built_in">pow</span>(X-x,<span class="number">2</span>)+<span class="built_in">pow</span>(Y-y,<span class="number">2</span>));</span><br><span class="line">		local[i]=make_pair&lt;&gt;(D,i);</span><br><span class="line"><span class="comment">//		cout&lt;&lt;local[i].first&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">sort</span>(local+<span class="number">1</span>,local+n+<span class="number">1</span>,cmp);<span class="comment">//sort对pair排序会默认对pair的first进行排序 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;++i)&#123;</span><br><span class="line">		cout&lt;&lt;local[i].second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202006-1-线性分类器">202006-1、线性分类器</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230311103010237.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">分析：</span></p>
<ol>
<li class="lvl-3">判断点在线的哪一侧可以通过将点坐标代入线表达式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><mi>y</mi><mo>+</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_{1}x+\theta_{1}y+\theta_{0}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>中。</li>
<li class="lvl-3">使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><mi>y</mi><mo>+</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_{1}x+\theta_{1}y+\theta_{0}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>为一个类别，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><mi>y</mi><mo>+</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_{1}x+\theta_{1}y+\theta_{0}&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>为另一个类别。</li>
<li class="lvl-3"><u><em><strong>最好采用结构体来存储点的三维数据。</strong></em></u></li>
</ol>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 3</span><br><span class="line">1 1 A</span><br><span class="line">1 0 A</span><br><span class="line">1 -1 A</span><br><span class="line">2 2 B</span><br><span class="line">2 3 B</span><br><span class="line">0 1 A</span><br><span class="line">3 1 B</span><br><span class="line">1 3 B</span><br><span class="line">2 0 A</span><br><span class="line">0 2 -3</span><br><span class="line">-3 0 2</span><br><span class="line">-3 1 1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一次尝试始终不通过的代码：——原因未知（示例数据可通过）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1001</span>,M=<span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> array_2[N][<span class="number">2</span>];</span><br><span class="line">string array_3[N];</span><br><span class="line">vector&lt;string&gt;<span class="built_in">ans</span>(M,<span class="string">&quot;Yes&quot;</span>);<span class="comment">//初始化全为Yes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">//	int array_2[n][2];</span></span><br><span class="line"><span class="comment">//	string array_3[n];</span></span><br><span class="line">	<span class="type">int</span> other_index=<span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j)&#123;</span><br><span class="line">			cin&gt;&gt;array_2[i][j];	</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;array_3[i];</span><br><span class="line">		<span class="comment">//记录下与第一个点不同类型的第一个点的坐标</span></span><br><span class="line">		<span class="keyword">if</span>(!flag&amp;&amp;array_3[i]!=array_3[<span class="number">0</span>])&#123;<span class="comment">//取另一个类型的第一个点 </span></span><br><span class="line">			other_index=i;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;type&quot;&lt;&lt;array_3[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;other_index:&quot;&lt;&lt;other_index;</span></span><br><span class="line"><span class="comment">//	vector&lt;string&gt;ans(m,&quot;Yes&quot;);//初始化全为Yes</span></span><br><span class="line">	<span class="type">int</span> theta0,theta1,theta2,pre,cur,flag1,flag2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;theta0&gt;&gt;theta1&gt;&gt;theta2;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">			cur=theta1*array_2[j][<span class="number">0</span>]+theta2*array_2[j][<span class="number">1</span>]+theta0;</span><br><span class="line"><span class="comment">//			pre=theta1*array_2[j-1][0]+theta2*array_2[j-1][1]+theta0;</span></span><br><span class="line">			flag1=theta1*array_2[<span class="number">0</span>][<span class="number">0</span>]+theta2*array_2[<span class="number">0</span>][<span class="number">1</span>]+theta0;<span class="comment">//用第一个点的类型以及位于线的位置方向来作为一个标准 </span></span><br><span class="line">			flag2=theta1*array_2[other_index][<span class="number">0</span>]+theta2*array_2[other_index][<span class="number">1</span>]+theta0;<span class="comment">//另一个类型 </span></span><br><span class="line">			<span class="keyword">if</span>(flag1*flag2&gt;<span class="number">0</span>||(cur*flag1&gt;<span class="number">0</span>&amp;&amp;array_3[j]!=array_3[<span class="number">0</span>])||(cur*flag2&gt;<span class="number">0</span>&amp;&amp;array_3[j]!=array_3[other_index]))&#123;<span class="comment">//如果同方向但是不同类型则这条线不能达到划分目的 </span></span><br><span class="line">				ans[i]=<span class="string">&quot;No&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写后100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10001</span>,M=<span class="number">21</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">points</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> fvalue;</span><br><span class="line">	<span class="type">char</span> type;</span><br><span class="line">&#125;pt[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">	<span class="type">int</span> c0,c1,c2;</span><br><span class="line">&#125;li[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">//输入数据 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y&gt;&gt;pt[i].type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;li[i].c0&gt;&gt;li[i].c1&gt;&gt;li[i].c2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">		<span class="type">char</span> ch1,ch2;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//以第一个点来设定标准 </span></span><br><span class="line">		pt[<span class="number">0</span>].fvalue=pt[<span class="number">0</span>].x*li[j].c1+pt[<span class="number">0</span>].y*li[j].c2+li[j].c0;</span><br><span class="line">		<span class="keyword">if</span>(pt[<span class="number">0</span>].fvalue&gt;<span class="number">0</span>&amp;&amp;pt[<span class="number">0</span>].type==<span class="string">&#x27;A&#x27;</span>||pt[<span class="number">0</span>].fvalue&lt;<span class="number">0</span>&amp;&amp;pt[<span class="number">0</span>].type==<span class="string">&#x27;B&#x27;</span>)&#123;<span class="comment">//始终保证ch1在&gt;0的方向 </span></span><br><span class="line">			ch1=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">			ch2=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pt[<span class="number">0</span>].fvalue&gt;<span class="number">0</span>&amp;&amp;pt[<span class="number">0</span>].type==<span class="string">&#x27;B&#x27;</span>||pt[<span class="number">0</span>].fvalue&lt;<span class="number">0</span>&amp;&amp;pt[<span class="number">0</span>].type==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			ch1=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">			ch2=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//遍历i个点 </span></span><br><span class="line">			pt[i].fvalue=pt[i].x*li[j].c1+pt[i].y*li[j].c2+li[j].c0;</span><br><span class="line">			<span class="keyword">if</span>(pt[i].fvalue&gt;<span class="number">0</span>&amp;&amp;pt[i].type!=ch1)&#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(pt[i].fvalue&lt;<span class="number">0</span>&amp;&amp;pt[i].type!=ch2)&#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网上100分参考代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;	<span class="comment">//点结构体</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> sum;	<span class="comment">//计算点带入直线里的值</span></span><br><span class="line">	<span class="type">char</span> type;</span><br><span class="line">&#125;;</span><br><span class="line">point pt[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;	<span class="comment">//直线结构体</span></span><br><span class="line">	<span class="type">int</span> c0,c1,c2;</span><br><span class="line">&#125;;</span><br><span class="line">line ln[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; pt[i].x &gt;&gt; pt[i].y &gt;&gt; pt[i].type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		cin &gt;&gt; ln[i].c0 &gt;&gt; ln[i].c1 &gt;&gt; ln[i].c2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="type">char</span> ch1,ch2;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		pt[<span class="number">0</span>].sum = ln[i].c0 + pt[<span class="number">0</span>].x*ln[i].c1 + pt[<span class="number">0</span>].y*ln[i].c2;		<span class="comment">//以第一个点作为标准</span></span><br><span class="line">		<span class="keyword">if</span>((pt[<span class="number">0</span>].sum&gt;<span class="number">0</span> &amp;&amp; pt[<span class="number">0</span>].type==<span class="string">&#x27;A&#x27;</span>) || (pt[<span class="number">0</span>].sum&lt;<span class="number">0</span> &amp;&amp; pt[<span class="number">0</span>].type==<span class="string">&#x27;B&#x27;</span>))&#123;	<span class="comment">//在直线上方的点的type值设置为ch1</span></span><br><span class="line">			ch1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">			ch2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((pt[<span class="number">0</span>].sum&gt;<span class="number">0</span> &amp;&amp; pt[<span class="number">0</span>].type==<span class="string">&#x27;B&#x27;</span>) || (pt[<span class="number">0</span>].sum&lt;<span class="number">0</span> &amp;&amp; pt[<span class="number">0</span>].type==<span class="string">&#x27;A&#x27;</span>))&#123;	<span class="comment">//在直线上方的点的type值设置为ch1</span></span><br><span class="line">			ch1 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">			ch2 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">			pt[j].sum = ln[i].c0 + pt[j].x*ln[i].c1 + pt[j].y*ln[i].c2;</span><br><span class="line">			<span class="keyword">if</span>(pt[j].sum&gt;<span class="number">0</span> &amp;&amp; pt[j].type==ch2)&#123;		<span class="comment">//如果直线上的点的type值为ch2，说明不能准确分类</span></span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt;endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(pt[j].sum&lt;<span class="number">0</span> &amp;&amp; pt[j].type==ch1)&#123;		<span class="comment">//如果直线下的点的type值为ch1，说明不能准确分类</span></span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt;endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)	<span class="comment">//flag始终为1，说明准确进行了分类</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>CCF-CSP认证</category>
        <category>第一题</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP模拟考笔记</title>
    <url>/2023/10/18/University/junior/competition/CCF-CSP/CCF-CSP%E6%A8%A1%E6%8B%9F%E8%80%83%E7%AC%AC%E4%B8%89%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>CCF-CSP模拟考第三题笔记</h1>
<h2 id="第三题">第三题</h2>
<h4 id="202212-3-jpeg-解码">202212-3、JPEG 解码</h4>
<p>题目：<a href="http://118.190.20.162/view.page?gpid=T158">计算机软件能力认证考试系统</a></p>
<blockquote>
<p><span style="color: red;">分析：</span></p>
<ol>
<li class="lvl-3">
<p>本问题的关键在于要准确地完成矩阵M的填充，由题目所给信息可知，我们可以提前定义矩阵M，并初始化其为全0；</p>
</li>
<li class="lvl-3">
<p>在填充矩阵的过程中应该遵循以下规则：</p>
<ol>
<li class="lvl-6">定义i、j控制填充位置走向；</li>
<li class="lvl-6"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>左上三角形与右下三角形的填充规则是不同的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{左上三角形与右下三角形的填充规则是不同的}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">左上三角形与右下三角形的填充规则是不同的</span></span></span></span>；</li>
<li class="lvl-6">保证i+j&lt;7的条件下：
<ul class="lvl-5">
<li class="lvl-8">当i+j==奇数时，则i++，j–；切换到下一条左斜线时，j不变，i++；</li>
<li class="lvl-8">当i+j==偶数时，则i–，j++；切换到下一条左斜线时，i不变，j++；</li>
</ul>
</li>
<li class="lvl-6">保证7=&lt;i+j&lt;15的条件下：
<ul class="lvl-5">
<li class="lvl-8">当i+j==奇数时，则i++，j–；切换到下一条左斜线时，i不变，j++；</li>
<li class="lvl-8">当i+j==偶数时，则i–，j++；切换到下一条左斜线时，j不变，i++；</li>
</ul>
</li>
<li class="lvl-6">同时注意i、j边界值的处理，什么时候应该切换到下一条左斜线。</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316150544093.png" alt="填充顺序"></p>
</li>
<li class="lvl-3">
<p><u><strong>注意以上思路为解决思路</strong></u>，具体在编程过程中是应该–i还是++i需要根据i、j的实际值进行调整。</p>
</li>
</ol>
<p><span style="color: red;">注意：</span></p>
<ol>
<li class="lvl-3">
<p>经过加 128 后并取整指的是<mark>四舍五入</mark>；这里用round()函数实现，或者用<code>int(x+0.5)</code>实现</p>
</li>
<li class="lvl-3">
<p>计算最终矩阵时如果得到的整数大于 255，则取 255；如果得到的整数小于 0，则取 0。</p>
</li>
</ol>
<p>AC参考：<a href="https://blog.csdn.net/qq_53386338/article/details/129374661">(105条消息) JPEG解码满分题解 | CSP认证202212-3_吴诗豪的博客-CSDN博客</a></p>
</blockquote>
<h6 id="解决代码：">解决代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	100分的代码：（第一次写，所以比较冗余）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAI acos(-1)</span></span><br><span class="line"><span class="type">int</span> Q[<span class="number">8</span>][<span class="number">8</span>];<span class="comment">//量化矩阵</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//扫描数据的个数</span></span><br><span class="line"><span class="type">int</span> T;<span class="comment">//任务</span></span><br><span class="line"><span class="comment">//int m[n];//n个扫描数据 </span></span><br><span class="line"><span class="type">double</span> M[<span class="number">8</span>][<span class="number">8</span>];<span class="comment">//填充矩阵 </span></span><br><span class="line"><span class="type">int</span> _M[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">alpha</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span>/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散余弦逆变换</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">convert_matrix</span><span class="params">(<span class="type">double</span> M[][<span class="number">8</span>],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;<span class="number">8</span>;++u)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;<span class="number">8</span>;++v)&#123;</span><br><span class="line">			sum+=<span class="built_in">alpha</span>(u)*<span class="built_in">alpha</span>(v)*M[u][v]*<span class="built_in">cos</span>(PAI/<span class="number">8</span>*(i+<span class="number">1.0</span>/<span class="number">2</span>)*u)*<span class="built_in">cos</span>(PAI/<span class="number">8</span>*(j+<span class="number">1.0</span>/<span class="number">2</span>)*v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;sum/4&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> sum/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">			cin&gt;&gt;Q[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> m[n];<span class="comment">//n个扫描数据 </span></span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;m[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(M,<span class="number">0</span>,<span class="built_in">sizeof</span>(M));<span class="comment">//赋值全0 </span></span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">true</span>;<span class="comment">//判断是否结束 填充数据</span></span><br><span class="line">	M[<span class="number">0</span>][<span class="number">0</span>]=m[<span class="number">0</span>];<span class="comment">//填充第一个数据在第一个左斜线上 </span></span><br><span class="line">	++j;</span><br><span class="line">	<span class="comment">//左上三角形填充规则： </span></span><br><span class="line">	<span class="keyword">for</span>(;i+j&lt;<span class="number">7</span>;)&#123;<span class="comment">//确保范围在8*8矩阵内 </span></span><br><span class="line">		<span class="keyword">if</span>((i+j)%<span class="number">2</span>!=<span class="number">0</span>)&#123;<span class="comment">//在奇数左斜线上时 </span></span><br><span class="line">			<span class="keyword">while</span>(j!=<span class="number">-1</span>)&#123;<span class="comment">//开始从右上到左下填充 </span></span><br><span class="line">				M[i++][j--]=m[f++];</span><br><span class="line">				<span class="keyword">if</span>(f&gt;=n)&#123;<span class="comment">//保证m不越界,同时减少循环次数</span></span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//转换到下一条左斜线上 </span></span><br><span class="line">			--i;<span class="comment">//因为前面while中有i++,因此多加了一次 </span></span><br><span class="line">			++i; </span><br><span class="line">			j=<span class="number">0</span>;<span class="comment">//将j从-1变为从0开始 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">//在偶数左斜线上时 </span></span><br><span class="line">			<span class="keyword">while</span>(i!=<span class="number">-1</span>)&#123;<span class="comment">//开始从左下到右上填充 </span></span><br><span class="line">				M[i--][j++]=m[f++];</span><br><span class="line">				<span class="keyword">if</span>(f&gt;=n)&#123;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//转换到下一条左斜线上 </span></span><br><span class="line">			--j;</span><br><span class="line">			++j;</span><br><span class="line">			i=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag)&#123;<span class="comment">//结束填充数据</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		<span class="comment">//右上三角形填充规则：</span></span><br><span class="line">        <span class="keyword">for</span>(;<span class="number">7</span>&lt;=i+j&lt;<span class="number">15</span>;)&#123;<span class="comment">//确保范围在8*8矩阵内 </span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>!=<span class="number">0</span>)&#123;<span class="comment">//在奇数左斜线上时 </span></span><br><span class="line">                <span class="keyword">while</span>(i!=<span class="number">8</span>)&#123;<span class="comment">//开始从右上到左下填充 </span></span><br><span class="line">                    M[i++][j--]=m[f++];</span><br><span class="line">                    <span class="keyword">if</span>(f&gt;=n)&#123;<span class="comment">//保证m不越界,同时减少循环次数</span></span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//转换到下一条左斜线上 </span></span><br><span class="line">                --i;<span class="comment">//因为前面while中有i++,因此多加了一次 </span></span><br><span class="line">                j+=<span class="number">2</span>;<span class="comment">//将j拉2个单位回来 </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//在偶数左斜线上时 </span></span><br><span class="line">                <span class="keyword">while</span>(j!=<span class="number">8</span>)&#123;<span class="comment">//开始从左下到右上填充 </span></span><br><span class="line">                    M[i--][j++]=m[f++];</span><br><span class="line">                    <span class="keyword">if</span>(f&gt;=n)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//转换到下一条左斜线上 </span></span><br><span class="line">                --j;<span class="comment">//有j++,因此多加了一次 </span></span><br><span class="line">                i+=<span class="number">2</span>;<span class="comment">//将i拉2个单位回来</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;<span class="comment">//结束填充数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="number">0</span>)&#123;<span class="comment">//输出填充矩阵 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				cout&lt;&lt;M[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T==<span class="number">1</span>)&#123;<span class="comment">//输出量化后的矩阵 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				M[i][j]=M[i][j]*Q[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				cout&lt;&lt;M[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T==<span class="number">2</span>)&#123;<span class="comment">//输出最终解码结果 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				M[i][j]=M[i][j]*Q[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				<span class="type">int</span> res=<span class="built_in">round</span>(<span class="built_in">convert_matrix</span>(M,i,j)+<span class="number">128</span>);<span class="comment">//四舍五入</span></span><br><span class="line">				<span class="keyword">if</span>(res&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">					res=<span class="number">0</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(res&gt;=<span class="number">255</span>)&#123;</span><br><span class="line">					res=<span class="number">255</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				_M[i][j]=res;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				cout&lt;&lt;_M[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;convert_matrix(M,0,3)&lt;&lt;&quot; &quot;&lt;&lt;PAI;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="优化后的代码：">优化后的代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	100分的代码：（参考网上的代码对矩阵填充部分的代码进行优化，使其更简洁）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAI acos(-1)</span></span><br><span class="line"><span class="type">int</span> Q[<span class="number">8</span>][<span class="number">8</span>];<span class="comment">//量化矩阵</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//扫描数据的个数</span></span><br><span class="line"><span class="type">int</span> T;<span class="comment">//任务</span></span><br><span class="line"><span class="type">double</span> M[<span class="number">8</span>][<span class="number">8</span>];<span class="comment">//填充矩阵 </span></span><br><span class="line"><span class="type">int</span> _M[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="comment">//针对蛇形填充——定义4个方向 ：右，左下，下，右上(上三角形);(下三角形)需要交换dx[0]与dy[0]以及dx[2]与dy[2] </span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;<span class="comment">//dx控制列，dy控制行 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">alpha</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span>/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散余弦逆变换</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">convert_matrix</span><span class="params">(<span class="type">double</span> M[][<span class="number">8</span>],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;<span class="number">8</span>;++u)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;<span class="number">8</span>;++v)&#123;</span><br><span class="line">			sum+=<span class="built_in">alpha</span>(u)*<span class="built_in">alpha</span>(v)*M[u][v]*<span class="built_in">cos</span>(PAI/<span class="number">8</span>*(i+<span class="number">1.0</span>/<span class="number">2</span>)*u)*<span class="built_in">cos</span>(PAI/<span class="number">8</span>*(j+<span class="number">1.0</span>/<span class="number">2</span>)*v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">			cin&gt;&gt;Q[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="built_in">memset</span>(M,<span class="number">0</span>,<span class="built_in">sizeof</span>(M));<span class="comment">//赋值全0 </span></span><br><span class="line">	<span class="type">int</span> y=<span class="number">0</span>,x=<span class="number">0</span>,md=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;M[y][x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//循环直到将所有的数据填充到矩阵中 </span></span><br><span class="line">		y+=dy[md];</span><br><span class="line">		x+=dx[md];</span><br><span class="line">		cin&gt;&gt;M[y][x];</span><br><span class="line">		<span class="keyword">if</span>(md==<span class="number">0</span>||md==<span class="number">2</span>)md=(md+<span class="number">1</span>)%<span class="number">4</span>;<span class="comment">//每一次在经过向右或向下操作后，需要转换为左下或右上。 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(md==<span class="number">1</span>||md==<span class="number">3</span>)&#123;<span class="comment">//确保是因下或右上操作</span></span><br><span class="line">			<span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>||x==<span class="number">7</span>||y==<span class="number">7</span>)md=(md+<span class="number">1</span>)%<span class="number">4</span>;<span class="comment">//左下或右上达到矩阵边界之后需要进行操作的切换 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(y==<span class="number">7</span>&amp;&amp;x==<span class="number">0</span>)&#123;<span class="comment">//遍历到了右下三角形，需要交换dx[0]与dy[0]以及dx[2]与dy[2]</span></span><br><span class="line">			<span class="built_in">swap</span>(dx[<span class="number">0</span>],dy[<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">swap</span>(dx[<span class="number">2</span>],dy[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="number">0</span>)&#123;<span class="comment">//输出填充矩阵 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				cout&lt;&lt;M[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T==<span class="number">1</span>)&#123;<span class="comment">//输出量化后的矩阵 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				M[i][j]=M[i][j]*Q[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				cout&lt;&lt;M[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T==<span class="number">2</span>)&#123;<span class="comment">//输出最终解码结果 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				M[i][j]=M[i][j]*Q[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				<span class="type">int</span> res=<span class="built_in">round</span>(<span class="built_in">convert_matrix</span>(M,i,j)+<span class="number">128</span>);<span class="comment">//四舍五入</span></span><br><span class="line">				<span class="keyword">if</span>(res&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">					res=<span class="number">0</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(res&gt;=<span class="number">255</span>)&#123;</span><br><span class="line">					res=<span class="number">255</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				_M[i][j]=res;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">				cout&lt;&lt;_M[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202209-3-防疫大数据">202209-3、防疫大数据</h4>
<p>题目：<a href="http://118.190.20.162/view.page?gpid=T151">计算机软件能力认证考试系统</a></p>
<blockquote>
<p><span style="color: red;">分析</span>：</p>
<ol>
<li class="lvl-3">输入：每一天的所有数据都是一次输入的，而不是分类型进行输入；</li>
<li class="lvl-3">生成风险名单的规则：
<ol>
<li class="lvl-6">该用户在近 7 日内曾经出现在接收到的漫游数据中，并且近 7 日内有到访某个地区的记录；<code>site[r]&amp;&amp;d1&gt;=d-6&amp;&amp;d1&lt;=d</code></li>
<li class="lvl-6">该用户在近 7 日内到访的地区在到访的那一日处于风险状态；<code>d1&gt;=region[r].first</code></li>
<li class="lvl-6">上述存在风险的地区自到访日至生成名单当日持续处于风险状态；<code>region[r].second&gt;=d</code></li>
</ol>
</li>
<li class="lvl-3">设置区域为风险区域的规则：
<ol>
<li class="lvl-6">收到该消息的当日起 7 日内，该地区处于风险状态；</li>
<li class="lvl-6">在 1 日收到地区 1 的风险信息，表示自 1 日（包含）至 8 日（不包含）地区 1 处于风险状态。如果分别在 1 日和 6 日收到地区 1 的风险信息，那么意味着地区 1 自 1 日（包含）至 13 日（不包含）持续处于风险状态。</li>
<li class="lvl-6">如果r区域的风险持续时间是[0,6],也就是[0,7)，那么现在d=7时，也是可以延长持续时间的。（d为当前日期）</li>
</ol>
</li>
<li class="lvl-3">输出：按从小到大排序的存在风险的用户列表。</li>
</ol>
<p>AC参考：<a href="https://blog.csdn.net/qq_42938235/article/details/128160898">(105条消息) 第27次CCF CSP(202209) T3非常详细题解 防疫大数据(C++)_csp 第27次 试题_不择手段也得赢的博客-CSDN博客</a></p>
</blockquote>
<h6 id="解决代码：">解决代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	20分的代码：（完全参照AC参考的思路和代码写的，不知道什么地方出的错）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//天数——0&lt;=n&lt;=1000</span></span><br><span class="line"><span class="type">int</span> ri,mi;<span class="comment">//当日收到的风险地区信息的数量、当日收到的漫游数据的条目数量 </span></span><br><span class="line"><span class="type">int</span> rp;<span class="comment">//风险地区编号 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mes</span>&#123;</span><br><span class="line">	<span class="type">int</span> d,u,r;</span><br><span class="line">&#125;; </span><br><span class="line">vector&lt;mes&gt;message[<span class="number">1010</span>];<span class="comment">//存储漫游消息:vector&lt;mes&gt;message是一个一维数组，那么vector&lt;mes&gt;message[1010]就是一个二维数组 </span></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;site;<span class="comment">//判断区域是否为风险区</span></span><br><span class="line">map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;region;<span class="comment">//存储区域的风险持续时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一个区域为风险区域，是否需要延长风险持续时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setf</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;<span class="comment">//r是区域号，d是目前的日期 </span></span><br><span class="line">	<span class="keyword">if</span>(!site[r])&#123;<span class="comment">//如果不是风险区 </span></span><br><span class="line">		region[r]=&#123;d,d+<span class="number">6</span>&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//是风险区，是否顺延风险持续时间，或者重置风险持续时间 </span></span><br><span class="line">		<span class="keyword">if</span>(region[r].second+<span class="number">1</span>&gt;=d)&#123;<span class="comment">//如果r区域的风险持续时间是[0,6],也就是[0,7)，那么现在d=7时，也是可以延长持续时间的 </span></span><br><span class="line">			region[r].second=d+<span class="number">6</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">//风险区的持续时间已经过去，现在重新设置风险持续时间 </span></span><br><span class="line">			region[r]=&#123;d,d+<span class="number">6</span>&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	site[r]=<span class="literal">true</span>;<span class="comment">//标记为风险区 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否将用户列入风险名单</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> d1,<span class="type">int</span> u,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;<span class="comment">//&lt;d1,u,r&gt;,d为当前日期 </span></span><br><span class="line">	<span class="keyword">if</span>(site[r]&amp;&amp;d1&gt;=d<span class="number">-6</span>&amp;&amp;d1&lt;=d&amp;&amp;d1&gt;=region[r].first&amp;&amp;region[r].second&gt;=d)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;ri&gt;&gt;mi;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=ri;++j)&#123;</span><br><span class="line">			cin&gt;&gt;rp;</span><br><span class="line">			<span class="built_in">setf</span>(rp,i);<span class="comment">//设置风险区持续时间 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=mi;++j)&#123;</span><br><span class="line">			<span class="type">int</span> d,u,r;</span><br><span class="line">			cin&gt;&gt;d&gt;&gt;u&gt;&gt;r;</span><br><span class="line">			<span class="keyword">if</span>(d&lt;=i)message[i].<span class="built_in">push_back</span>(&#123;d,u,r&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//计算每天的风险名单</span></span><br><span class="line">		vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> day=i<span class="number">-6</span>&gt;<span class="number">0</span>?i<span class="number">-6</span>:<span class="number">0</span>;day&lt;=i;day++)&#123;<span class="comment">//遍历前6天以及今天得到的漫游数据 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;message[day].<span class="built_in">size</span>();++k)&#123;<span class="comment">//遍历第day天的所有漫游消息 </span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(message[day][k].d,message[day][k].u,message[day][k].r,day))&#123;</span><br><span class="line">					ans.<span class="built_in">push_back</span>(message[day][k].u);<span class="comment">//添加风险名单 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());<span class="comment">//按照用户编号升序排序 </span></span><br><span class="line">		ans.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>()),ans.<span class="built_in">end</span>());<span class="comment">//删去去重处理后数组最后面的重复部分 </span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;风险名单：&quot;; </span></span><br><span class="line">		cout&lt;&lt;i;<span class="comment">//输出第i天的风险名单 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;ans.<span class="built_in">size</span>();++k)cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans[k];</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202206-3-角色授权">202206-3、角色授权</h4>
<p>题目：<a href="http://118.190.20.162/view.page?gpid=T146">计算机软件能力认证考试系统</a></p>
<blockquote>
<p><span style="color: red;">分析：</span></p>
<ol>
<li class="lvl-3">根据题意可知，本题一定需要用到结构体，并且需要用到结构体数组，存储角色、角色关联以及用户；</li>
<li class="lvl-3">判断一个用户能否执行某个操作的过程是：
<ol>
<li class="lvl-6">检查所有的角色关联的授权对象清单，如果清单中包含该用户的名称，或者该清单中包含该用户所属的某一个用户组的名称，那么选取该角色关联所关联的角色；</li>
<li class="lvl-6">对于所有被选取的角色，判断这些角色是否能对该资源执行该操作，如果所有角色都不能执行该操作，那么不能执行该操作；</li>
<li class="lvl-6">允许执行该操作。</li>
</ol>
</li>
<li class="lvl-3">判断一个角色能否对某个资源执行某个操作的过程是：
<ol>
<li class="lvl-6">检查该角色的操作清单，如果该角色的操作清单中不包含该操作，且该角色的操作清单中也不包含字符串 <code>*</code>，那么不能执行该操作；</li>
<li class="lvl-6">检查该角色的资源种类清单，如果该角色的资源种类清单中不包含该资源的种类，且该角色的资源种类清单中也不包含字符串 <code>*</code>，那么不能执行该操作；</li>
<li class="lvl-6">检查该角色的资源名称清单，如果该角色的资源名称清单中不包含该资源的名称，且该角色的资源名称清单不是空数组，那么不能执行该操作；</li>
<li class="lvl-6">允许执行该操作。</li>
</ol>
</li>
</ol>
<p><span style="color: red;">关键：</span></p>
<ol>
<li class="lvl-3">
<p>当涉及到大量数据的输入时，需要考虑将C++与C的标准输入输出同步机制关闭，这样能够显著提升效率。<code>ios::sync_with_stdio(false);</code></p>
<ul class="lvl-3">
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230318123936083.png" alt="image-20230318123936083"></li>
</ul>
</li>
</ol>
<p>AC参考：<a href="https://blog.csdn.net/qq_51800570/article/details/126876449">(105条消息) 202206-3 CCF 角色授权 （运用stl容器模拟 + 优化 满分题解）_ccfcsp202206-3_一只可爱的小猴子的博客-CSDN博客</a></p>
</blockquote>
<h6 id="解决代码：">解决代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> nv,no,nn,ns,ng;</span><br><span class="line"></span><br><span class="line">map&lt;string,vector&lt;string&gt;&gt;rolecon;<span class="comment">//存储用户绑定有哪些角色</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;rid;<span class="comment">//存储角色名与id的对应关系 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">role</span>&#123;<span class="comment">//角色 </span></span><br><span class="line">	string name;</span><br><span class="line">	set&lt;string&gt;oper;<span class="comment">//set更好查询 </span></span><br><span class="line">	set&lt;string&gt;res_type; </span><br><span class="line">	set&lt;string&gt;res_name;</span><br><span class="line">&#125;;</span><br><span class="line">role role[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断对应角色是否能够执行操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string rname,string oper,string rs_type,string rs_name)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> id=rid[rname];</span><br><span class="line">	<span class="keyword">if</span>(role[id].oper.<span class="built_in">count</span>(<span class="string">&quot;*&quot;</span>)==<span class="number">0</span>&amp;&amp;role[id].oper.<span class="built_in">count</span>(oper)==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(role[id].res_type.<span class="built_in">count</span>(<span class="string">&quot;*&quot;</span>)==<span class="number">0</span>&amp;&amp;role[id].res_type.<span class="built_in">count</span>(rs_type)==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(!role[id].res_name.<span class="built_in">empty</span>()&amp;&amp;role[id].res_name.<span class="built_in">count</span>(rs_name)==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//role初始化 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_role</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;role[i].name;</span><br><span class="line">		rid[role[i].name]=i;<span class="comment">//存储对应下标id </span></span><br><span class="line">		cin&gt;&gt;nv;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nv;++j)&#123;</span><br><span class="line">			string temp;</span><br><span class="line">			cin&gt;&gt;temp;</span><br><span class="line">			role[i].oper.<span class="built_in">emplace</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;no;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;no;++j)&#123;</span><br><span class="line">			string temp;</span><br><span class="line">			cin&gt;&gt;temp;</span><br><span class="line">			role[i].res_type.<span class="built_in">emplace</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;nn;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nn;++j)&#123;</span><br><span class="line">			string temp;</span><br><span class="line">			cin&gt;&gt;temp;</span><br><span class="line">			role[i].res_name.<span class="built_in">emplace</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个用户绑定的角色初始化 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_role_ass</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		string rname;</span><br><span class="line">		cin&gt;&gt;rname;</span><br><span class="line">		cin&gt;&gt;ns;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ns;++j)&#123;</span><br><span class="line">			string kind,name;</span><br><span class="line">			cin&gt;&gt;kind&gt;&gt;name;</span><br><span class="line">			rolecon[name].<span class="built_in">push_back</span>(rname);<span class="comment">//存储用户或是用户组包含的角色名称 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//当涉及到大量数据的输入时，需要考虑将C++与C的标准输入输出同步机制关闭，这样能够显著提升效率 </span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	<span class="built_in">init_role</span>(n);</span><br><span class="line">	<span class="built_in">init_role_ass</span>(m);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;<span class="comment">//处理每一条待授权语句 </span></span><br><span class="line">		string uname;</span><br><span class="line">		cin&gt;&gt;uname&gt;&gt;ng;</span><br><span class="line">		vector&lt;string&gt;uGroup;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ng;++i)&#123;</span><br><span class="line">			string uG;</span><br><span class="line">			cin&gt;&gt;uG;</span><br><span class="line">			uGroup.<span class="built_in">push_back</span>(uG);</span><br><span class="line">		&#125;</span><br><span class="line">		string oper,rs_type,rs_name;</span><br><span class="line">		cin&gt;&gt;oper&gt;&gt;rs_type&gt;&gt;rs_name;</span><br><span class="line">		<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//遍历用户所对应的角色 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rolecon[uname].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(rolecon[uname][i],oper,rs_type,rs_name))&#123;</span><br><span class="line">				flag=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历用户组对应的角色 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;uGroup.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			string uGname=uGroup[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;rolecon[uGname].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(rolecon[uGname][j],oper,rs_type,rs_name))&#123;</span><br><span class="line">					flag=<span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;test&quot;&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202203-3-计算资源调度器">202203-3、计算资源调度器</h4>
<blockquote>
<p><span style="color: red;">分析：</span></p>
<ol>
<li class="lvl-3">定义存储应用i运行在哪些计算结点上：<code>unordered_map&lt;int,vector&lt;int&gt;&gt;ap_node</code>；</li>
<li class="lvl-3">定义存储可用区包含哪些计算结点：<code>vector&lt;int&gt;area_node[N]</code>；</li>
<li class="lvl-3">定义存储每个计算结点包含多少个任务数：<code>unordered_map&lt;int,int&gt;node_num</code>；</li>
<li class="lvl-3">定义存储每个节点在哪个区：<code>int n_adr[N]</code></li>
</ol>
<p>AC参考：<a href="https://blog.csdn.net/qq_51800570/article/details/126864435">(105条消息) 202203-3 CCF 计算资源调度器 （运用stl容器模拟 满分题解）_一只可爱的小猴子的博客-CSDN博客</a></p>
</blockquote>
<h6 id="解决代码：">解决代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	20分的代码：（完全参照AC参考的思路和代码写的，不知道什么地方出的错）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>,M=<span class="number">1010</span>,G=<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n,m,g; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n_adr[N];<span class="comment">//存储每个节点在哪个区</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;area_node[N];<span class="comment">//存储可用区包含哪些计算结点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;ap_node;<span class="comment">//存储应用i运行在哪些计算结点上</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;node_num;<span class="comment">//存储每个计算结点包含多少个任务数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_na</span><span class="params">(<span class="type">int</span> nodeid,<span class="type">int</span> arid)</span></span>&#123;<span class="comment">//计算节点亲和性要求</span></span><br><span class="line">	<span class="keyword">if</span>(arid==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:area_node[arid])&#123;<span class="comment">//nodeid计算结点在arid可用区包含的计算结点中</span></span><br><span class="line">		<span class="keyword">if</span>(nodeid==x)&#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_pa</span><span class="params">(<span class="type">int</span> nodeid,<span class="type">int</span> apid)</span></span>&#123;<span class="comment">//计算任务亲和性要求</span></span><br><span class="line">	<span class="keyword">if</span>(apid==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:ap_node[apid])&#123;</span><br><span class="line">		<span class="keyword">if</span>(n_adr[nodeid]==n_adr[x])&#123;<span class="comment">//nodeid计算结点所在区与apid应用所在计算结点所属的区域一致即可 </span></span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_paa</span><span class="params">(<span class="type">int</span> nodeid,<span class="type">int</span> apid)</span></span>&#123;<span class="comment">//计算任务反亲和性要求</span></span><br><span class="line">	<span class="keyword">if</span>(apid==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:ap_node[apid])&#123;</span><br><span class="line">		<span class="keyword">if</span>(nodeid==x)&#123;<span class="comment">//nodeid计算结点存在于apid应用所在计算结点</span></span><br><span class="line">			flag=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		n_adr[i]=x;</span><br><span class="line">		area_node[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;g;</span><br><span class="line">	<span class="type">int</span> f,a,na,pa,paa,paar;</span><br><span class="line">	<span class="keyword">while</span>(g--)&#123;</span><br><span class="line">		cin&gt;&gt;f&gt;&gt;a&gt;&gt;na&gt;&gt;pa&gt;&gt;paa&gt;&gt;paar;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;f;++k)&#123;<span class="comment">//分配f个任务 </span></span><br><span class="line">			vector&lt;<span class="type">int</span>&gt;res,t;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check_na</span>(i,na)&amp;&amp;<span class="built_in">check_pa</span>(i,pa)&amp;&amp;<span class="built_in">check_paa</span>(i,paa))res.<span class="built_in">push_back</span>(i);<span class="comment">//满足三个要求的计算结点</span></span><br><span class="line">				<span class="keyword">if</span>(!paar&amp;&amp;<span class="built_in">check_na</span>(i,na)&amp;&amp;<span class="built_in">check_pa</span>(i,pa))t.<span class="built_in">push_back</span>(i);<span class="comment">//不考虑任务反亲和性要求</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;!paar) res=t;<span class="comment">//paar=0时，可以不用满足全部三个要求</span></span><br><span class="line">			<span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//如果必须满足三个要求，但是res为空，表明当前任务无法分配 </span></span><br><span class="line">			<span class="keyword">else</span>&#123;<span class="comment">//将过滤后满足要求的结点排序输出 </span></span><br><span class="line">				vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;node;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> x:res)&#123;</span><br><span class="line">					node.<span class="built_in">push_back</span>(&#123;node_num[x],x&#125;);<span class="comment">//存储对应结点的任务数以及对应结点编号 </span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">sort</span>(node.<span class="built_in">begin</span>(),node.<span class="built_in">end</span>());<span class="comment">//进行排序</span></span><br><span class="line">				cout&lt;&lt;node[<span class="number">0</span>].second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">				++node_num[node[<span class="number">0</span>].second];</span><br><span class="line">				area_node[a].<span class="built_in">push_back</span>(node[<span class="number">0</span>].second);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202112-3-登机牌条码">202112-3、登机牌条码</h4>
<p>题目：<a href="http://118.190.20.162/view.page?gpid=T136">计算机软件能力认证考试系统</a></p>
<blockquote>
<p><span style="color: red;">分析：</span></p>
<ol>
<li class="lvl-3">
</li>
</ol>
<p>AC参考：<a href="https://blog.csdn.net/m0_53641110/article/details/123649159">(105条消息) CCF-CSP 202112-3登机牌条码 解题思路+满分题解+详细注释_csp202112-3_只须一笑不须愁X的博客-CSDN博客</a></p>
</blockquote>
<h6 id="解决代码：">解决代码：</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	10分的代码：（应该是40的，不知道什么地方出的错；没有考虑校验码）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;dict;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">int</span> w,s;</span><br><span class="line">	cin&gt;&gt;w&gt;&gt;s;</span><br><span class="line">	string str;</span><br><span class="line">	cin&gt;&gt;str;</span><br><span class="line">	<span class="type">char</span> ch=<span class="number">65</span>;<span class="comment">//+32变小写字母 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">		dict[ch++]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;dataCode;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">1</span>;<span class="comment">//初始为大写——大写：1，小写：-1，数字：0 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> s:str)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isdigit</span>(s))&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag!=<span class="number">0</span>)&#123;</span><br><span class="line">				dataCode.<span class="built_in">push_back</span>(<span class="number">28</span>);<span class="comment">//当前一个字符不是数字时 </span></span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dataCode.<span class="built_in">push_back</span>(s-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s))&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">islower</span>(s))&#123;<span class="comment">//前一个字符不是小写并且当前字符为小写 </span></span><br><span class="line">				<span class="keyword">if</span>(flag!=<span class="number">-1</span>)&#123;</span><br><span class="line">					dataCode.<span class="built_in">push_back</span>(<span class="number">27</span>);<span class="comment">//转小写 </span></span><br><span class="line">					flag=<span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				s-=<span class="number">32</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">isupper</span>(s))&#123;</span><br><span class="line">				<span class="keyword">if</span>(flag!=<span class="number">1</span>&amp;&amp;flag==<span class="number">-1</span>)&#123;<span class="comment">//小写转大写 </span></span><br><span class="line">					dataCode.<span class="built_in">push_back</span>(<span class="number">28</span>);<span class="comment">//先转数字 </span></span><br><span class="line">					dataCode.<span class="built_in">push_back</span>(<span class="number">28</span>);<span class="comment">//再转大写 </span></span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag!=<span class="number">1</span>&amp;&amp;flag==<span class="number">0</span>)&#123;</span><br><span class="line">					dataCode.<span class="built_in">push_back</span>(<span class="number">28</span>);<span class="comment">//数字转大写 </span></span><br><span class="line">				&#125; </span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dataCode.<span class="built_in">push_back</span>(dict[s]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dataCode.<span class="built_in">size</span>()%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//奇数个需要补29 </span></span><br><span class="line">		dataCode.<span class="built_in">push_back</span>(<span class="number">29</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;dataCode.<span class="built_in">size</span>();k+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="type">int</span> cWord=<span class="number">30</span>*dataCode[k<span class="number">-1</span>]+dataCode[k];</span><br><span class="line">		ans.<span class="built_in">push_back</span>(cWord);<span class="comment">//存储两两计算得到的码字 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((ans.<span class="built_in">size</span>()+<span class="number">1</span>)%w!=<span class="number">0</span>)&#123;<span class="comment">//是否需要在最后的码字中加入900 </span></span><br><span class="line">		ans.<span class="built_in">push_back</span>(<span class="number">900</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	cout&lt;&lt;ans.<span class="built_in">size</span>()+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;p:ans)&#123;</span><br><span class="line">		cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>CCF-CSP认证</category>
        <category>第三题</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯真题练习-1</title>
    <url>/2023/10/18/University/junior/competition/lanqiaoCup/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%83%E4%B9%A0(%E7%9C%81%E5%86%B2)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>蓝桥杯真题练习</h1>
<h2 id="第一天">第一天</h2>
<h3 id="真题练习-成绩统计">【真题练习】成绩统计</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230310021139515.png" alt="问题描述"></p>
<blockquote>
<p>这题思路简单，但是对于细节考的很细，最初示例输入之后输出的优秀率始终为42%，原因是因为<code>count_excellent*100/n</code>中的<code>/</code>是整除，要想除之后保留小数必须定义分母或分子中至少一个变量为浮点型（float或double）。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义的round函数，不过cmath库中有封装好的round函数 </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">round</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)(x+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,grade;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> pass_rate=<span class="number">0</span>,excellent_rate=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> count_pass=<span class="number">0</span>,count_excellent=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;grade;</span><br><span class="line">		<span class="keyword">if</span>(grade&gt;=<span class="number">85</span>)&#123;</span><br><span class="line">			count_pass++;</span><br><span class="line">			count_excellent++;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(grade&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">			count_pass++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pass_rate=<span class="built_in">round</span>((<span class="type">double</span>)(count_pass*<span class="number">100</span>/n));</span><br><span class="line">	excellent_rate=<span class="built_in">round</span>((<span class="type">double</span>)(count_excellent*<span class="number">100</span>/n));</span><br><span class="line"><span class="comment">//	cout&lt;&lt;count_pass&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;count_excellent&lt;&lt;endl;</span></span><br><span class="line">	cout&lt;&lt;pass_rate&lt;&lt;<span class="string">&quot;%&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;excellent_rate&lt;&lt;<span class="string">&quot;%&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-排列字母">【真题练习】排列字母</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230310103317552.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<ol>
<li class="lvl-3">暴力解决，手算之后直接输出</li>
<li class="lvl-3">利用set的有序性？（set会对key进行升序排序，<span style="color: red;">但set会自动去重，可以考虑multiset</span>，multiset可以有重复元素，但直接修改multiset的元素会破坏其自动有序性，只能删除一个元素再insert一个元素来达到修改的目的）</li>
<li class="lvl-3">利用sort进行排序（需要重写comp？）</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//multiset实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	multiset&lt;<span class="type">char</span>&gt;myset;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span>&amp;c:s)&#123;</span><br><span class="line">		myset.<span class="built_in">emplace</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;p:myset)&#123;</span><br><span class="line">		cout&lt;&lt;p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;	</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span>&amp;c:s)&#123;</span><br><span class="line">		cout&lt;&lt;c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-纸张尺寸">【真题练习】纸张尺寸</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230310111126480.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<ol>
<li class="lvl-3">判断将长边作为对折边，<code>width&gt;length,swap(length,width)</code>.</li>
<li class="lvl-3">pair类型存储长短边，固定first为长边，second为短边。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;paper[<span class="number">10</span>];</span><br><span class="line">	paper[<span class="number">0</span>].first=<span class="number">1189</span>,paper[<span class="number">0</span>].second=<span class="number">841</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">		paper[i].second=paper[i<span class="number">-1</span>].first/<span class="number">2</span>;</span><br><span class="line">		paper[i].first=paper[i<span class="number">-1</span>].second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> flag=s[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//将字符型转换为整型 </span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;flag&lt;&lt;endl;</span></span><br><span class="line">	cout&lt;&lt;paper[flag].first&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;paper[flag].second;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二天">第二天</h2>
<h3 id="真题练习-特殊时间">【真题练习】特殊时间</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230311094311982.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<ol>
<li class="lvl-3">3个四位数字组成特殊时间。</li>
<li class="lvl-3">可看成3个三位数（9个数都一样），之后在每个三位数中再插入一个数字（向3个三位数中插入的数字都相同）</li>
<li class="lvl-3"><mark>（这里我直接手算算出来，暂时没有想到什么好的方法）</mark></li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="真题练习-卡片">【真题练习】卡片</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230311102620070.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<ol>
<li class="lvl-3">根据题目给出的提示信息可以知道数字<code>1</code>是最先被消耗完的。</li>
<li class="lvl-3">暴力遍历求和看什么时候会消耗完数字<code>1</code>。</li>
<li class="lvl-3">利用while循环以及取余<code>%</code>和整除<code>/</code>操作判断组成当前数字是否会超出给定数字的个数。</li>
<li class="lvl-3">若刚好超出则将数字减1即可得到最大可以拼到的数字（最终结果）。</li>
</ol>
<p>参考：<a href="https://blog.csdn.net/Veyne_/article/details/115916234">(103条消息) 第十二届蓝桥杯 试题 B: 卡片 题解_蓝桥杯卡片问题_Veyne_的博客-CSDN博客</a></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2021</span>;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(num)&#123;</span><br><span class="line">		<span class="type">int</span> remainder=num%<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(!sum[remainder])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		--sum[remainder];</span><br><span class="line">		num/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">1</span>;	<span class="comment">//定义在外面，方便最后输出 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)sum[i]=N;</span><br><span class="line">	<span class="keyword">for</span>(;<span class="built_in">check</span>(k);++k);</span><br><span class="line">	cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网上参考代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N = <span class="number">2021</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];<span class="comment">//存储0-9数字的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;<span class="comment">//判断组成当前数字是否会超出给定数字的个数</span></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        <span class="type">int</span> t = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (!a[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        -- a[t];</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) a[i] = N;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">check</span>(i); i ++) ;</span><br><span class="line">    cout &lt;&lt; i - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-约数个数">【真题练习】约数个数</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230311110954247.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<ol>
<li class="lvl-3">约数，又称因数。这里是求1200000有多少个因数。</li>
<li class="lvl-3">注意1200000以0结尾，那么证明它只能被5或10整除（以此条件可以简化循环结构）。</li>
<li class="lvl-3">一个数的约数必然包括1及其本身。</li>
<li class="lvl-3">约数之间必然是成对出现的：1和1200000，2和600000……，所以我们可以限定遍历到sqrt(1200000)即可。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">1200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> d=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=d;i-=<span class="number">5</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)ans+=<span class="number">2</span>;<span class="comment">//能被i整除，余数为0即为约数 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三天">第三天</h2>
<h3 id="真题练习-数的计算">【真题练习】数的计算</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230313110148037.png" alt="问题描述"></p>
<p><strong>输入描述</strong></p>
<p>输入一个正整数 <em>n</em>。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示具有该性质数的个数。</p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<ol>
<li class="lvl-3">这道题可以递归处理，由于在左边添加的自然数不能比右边大，因此我们有<code>i&lt;=n/2</code>；</li>
<li class="lvl-3">定义递归函数f(x)，再遍历可以在整数n左边可添加的自然数，继续递归：f(i)，并再每次递归之前统计数+1；</li>
<li class="lvl-3">重复操作。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;<span class="comment">//为什么要初始化为1？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//递归终止条件 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x/<span class="number">2</span>;++i)&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="built_in">f</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">f</span>(n);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-数的划分">【真题练习】数的划分</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230313113405736.png" alt="问题描述"></p>
<p><strong>输入描述</strong></p>
<p>输入一行，2 个整数n*,<em>k (6≤</em>n<em>≤200，2≤</em>k*≤6)。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，即不同的分法。</p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<p>这是一个经典的组合问题，可以使用递归或者动态规划来解决。</p>
<p>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 表示将整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 份的方案总数。</p>
<p>首先，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，显然无法分配，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n, k) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p>
<p>其次，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时，只有一种分配方案，即全放在一起，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(n, k) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>最后，考虑一般情况。我们可以钦定其中一份为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，然后对剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的分配，此时方案数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1, k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。另外，我们也可以不选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，而是将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 中的某个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 作为钦定的数，然后对剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的分配，此时方案数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-m, k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。因此，我们可以列出如下的递推式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mi>k</mi><mtext> or </mtext><mi>k</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>&lt;</mo><mi>k</mi><mtext> or </mtext><mi>k</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(n, k) = \begin{cases} 1 &amp; n = k \text{ or } k = 1 \\ 0 &amp; n &lt; k \text{ or } k = 0 \\ f(n-1, k-1) + f(n-2, k-1) + \cdots + f(n-k+1, k-1) &amp; \text{otherwise} \end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord text"><span class="mord"> or </span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord text"><span class="mord"> or </span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这个式子的含义是：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 份的方案总数，等于钦定一份为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，然后将剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 份的方案数，以及钦定一份为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，并将剩下的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 份的方案数，由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的取值范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n-k+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，因此需要将这些情况累加起来。</p>
<p>最终的答案就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。实现时可以使用递归或者动态规划，时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span>。</p>
<p><u><em><strong><mark>将以上分析转换为代码思路：</mark></strong></em></u></p>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>划分</strong>： 此题可以划分为在满足k个数组合等于n时两种情况：包含1、不包含1</p>
</li>
<li class="lvl-2">
<p><strong>状态</strong>： <code>dp[i][j]</code>含义为数字i划分为j部分的划分数</p>
</li>
<li class="lvl-2">
<p><strong>当包含1时</strong>： 划分结果中至少有一个1 = 将n-1分成k-1份的结果（一定存在1，那么我就先划分出一个1，剩下的值无论怎么划分，最终结果中一定存在至少一个1）所以：<code>dp[i][j]=dp[i-1][j-1]+不包含1的划分数</code></p>
</li>
<li class="lvl-2">
<p><strong>当不包含1时</strong>： 划分结果中不存在1 = 将n-k划分为k份的结果（序列中不存在1，则划分结果序列中的数一定都大于等于2，所以等价于对于每一个数都减去1，则剩下的结果一定是n-k划分成k份的结果）不包含1的划分数 = <code>dp[i-j][j]</code></p>
</li>
<li class="lvl-2">
<p><strong>状态转移方程</strong>： <code>dp[i][j] = dp[i-1][j-1] + dp[i-j][j]</code></p>
</li>
</ul>
<p><mark>参考：</mark><a href="https://blog.csdn.net/weixin_43715360/article/details/107504678">(103条消息) 蓝桥杯 数的划分(动态规划分析)_蓝桥杯数的划分_一个很懒的人的博客-CSDN博客</a></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法一：递归(存在大量的重复计算，效率较低，容易超时)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//递归涉及到过多的重复计算，容易超时 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==k||k==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">f</span>(n-k,k)+<span class="built_in">f</span>(n<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">f</span>(n,k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二：动态规划（减少了重复计算过程，提升时间效率）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="type">int</span> dp[n+<span class="number">1</span>][k+<span class="number">1</span>];<span class="comment">//初始化的数组元素没有自动初始化为0，需要使用memset进行初始化值</span></span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//将数组的所有元素都赋初值为0 </span></span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,k);++j)&#123;</span><br><span class="line">			dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i-j][j];<span class="comment">//dp[i-1][j-1]必定包含至少一个1的情况，dp[i-j][j]必定不包含1的情况 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;dp[n][k];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-耐摔指数">【真题练习】耐摔指数</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230313234435361.png" alt="问题描述"></p>
<p><strong>输入描述</strong></p>
<p>一个整数 n（3&lt;n&lt;10000）,表示测试塔的高度。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示最多测试多少次。</p>
<blockquote>
<p><span style="color: red;">思路分析：</span></p>
<ol>
<li class="lvl-3">这里的最佳策略应该是“动态规划”而不是“二分法”，因为每测试一次就有可能损失一部手机，手机的数量是有限的；</li>
<li class="lvl-3">最坏的情况就是朝着测试次数最多的方向发展，也就是max(上楼测试的次数，下楼测试的次数)；</li>
<li class="lvl-3">最佳策略就是要取当前测试次数最少的；</li>
<li class="lvl-3">每个厂家只抽样 3 部手机参加测试</li>
</ol>
<p>参考：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>最优策略就是每次扔手机都从后续测试最少的层数扔出去，扔出去后手机摔坏与否总是往测试最多的方向发展即是最差运气。</p>
</li>
<li class="lvl-2">
<p>至于这个最好的层数只能遍历出来才知道，也是for循环遍历然后找出min(min, max(扔出去被摔坏，扔出去没被摔坏))。</p>
</li>
<li class="lvl-2">
<p>至于最差运气就是指每次扔出去手机的是否被摔坏总是指向要测试最多的方向发展。所以是 max(扔出去被摔坏，扔出去没被摔坏)</p>
</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/weixin_46239370/article/details/105728667">(104条消息) 第九届蓝桥杯——耐摔指数_蓝桥杯摔手机算法_业余算法学徒的博客-CSDN博客</a></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//手机个数有限，不能采用二分法 </span></span><br><span class="line"><span class="comment">//最佳策略：动态规划；最坏运气：一直朝着测试次数最多的方向发展 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">4</span>][n+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">			dp[i][j]=j;<span class="comment">//最坏测试次数永远是当前测试层数(从最高层往下到第一层都摔不坏)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">3</span>;++i)&#123;			<span class="comment">//每个厂家抽样 3 部手机参加测试。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;		<span class="comment">//最高层 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;j;++k)&#123;	<span class="comment">//k为当前层 </span></span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i][j],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k<span class="number">-1</span>]+<span class="number">1</span>,dp[i][j-k]+<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[<span class="number">3</span>][n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种解法：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330185454172.png" alt="image-20230330185454172" style="zoom: 25%;" />
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 耐摔测试 - lanqiao-177</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b[<span class="number">10005</span>], c[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;<span class="comment">// 表示测试塔的高度</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(c[i]&lt;n)&#123;</span><br><span class="line">		i++;<span class="comment">// 1部手机的情况</span></span><br><span class="line">		b[i] = b[i<span class="number">-1</span>] + i;<span class="comment">// 2部手机的情况</span></span><br><span class="line">		c[i] = c[i<span class="number">-1</span>] + b[i<span class="number">-1</span>] + <span class="number">1</span>;<span class="comment">// 3部手机的情况 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四天">第四天</h2>
<h3 id="真题练习-迷宫">【真题练习】迷宫</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321010051538.png" alt="image-20230321010051538"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">本题采用<u><em><strong>广度优先搜索</strong></em></u>；</li>
<li class="lvl-3">根据题目中四个方向的优先级（D&lt;L&lt;R&lt;U）定义方向数组dy,dx；</li>
<li class="lvl-3">定义存储各点到终点的最短距离；</li>
<li class="lvl-3">定义存储四个方向D，L，R，U的char数组，方便后面输出；</li>
<li class="lvl-3">使用bfs时应该从终点往起点遍历，这样能够得到可以从起点到终点的路径，不能从起点到终点的路线在反向遍历的过程中就断了；</li>
<li class="lvl-3">最后从起点开始遍历，找到能够到达终点且字典序最小的最短路径。</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>值得注意的是：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{值得注意的是：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">值得注意的是：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>本题数据输入并不是单个单个的输入，而是一行一行的输入，因此我们如果采用int类型的话不方便处理，而使用char类型则可以将每一行的数据视为一个string字符串，方便将每一个字符输入到矩阵中。</p>
</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//根据四个方向的优先级（D&lt;L&lt;R&lt;U）定义控制方向的行数组dy与列数组dx </span></span><br><span class="line"><span class="type">char</span> m[<span class="number">40</span>][<span class="number">60</span>];<span class="comment">//数组大小要比输入矩阵大 </span></span><br><span class="line"><span class="type">int</span> dist[<span class="number">40</span>][<span class="number">60</span>];</span><br><span class="line"><span class="type">char</span> dir[<span class="number">4</span>]=&#123;<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=<span class="number">30</span>&amp;&amp;x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=<span class="number">50</span>&amp;&amp;m[y][x]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;dist[y][x]==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;<span class="comment">//用队列实现广度优先搜索 </span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//初始化数组为全-1 </span></span><br><span class="line">	dist[<span class="number">30</span>][<span class="number">50</span>]=<span class="number">0</span>;<span class="comment">//&#123;30,50&#125;就是终点 </span></span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">30</span>,<span class="number">50</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;p=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">			<span class="type">int</span> y=p.first+dy[i];</span><br><span class="line">			<span class="type">int</span> x=p.second+dx[i];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(y,x))&#123;<span class="comment">//判断是否符合向前搜索条件 </span></span><br><span class="line">				dist[y][x]=dist[p.first][p.second]+<span class="number">1</span>;<span class="comment">//离终点的距离+1 </span></span><br><span class="line">				q.<span class="built_in">push</span>(&#123;y,x&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">50</span>;++j)&#123;</span><br><span class="line">			cin&gt;&gt;m[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="type">int</span> y=<span class="number">1</span>,x=<span class="number">1</span>;</span><br><span class="line">	string res;</span><br><span class="line">	<span class="keyword">while</span>(y!=<span class="number">30</span>||x!=<span class="number">50</span>)&#123;<span class="comment">//保证到达&#123;30,50&#125;即终点才结束循环</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">			<span class="type">int</span> _y=y+dy[i];</span><br><span class="line">			<span class="type">int</span> _x=x+dx[i];</span><br><span class="line">			<span class="keyword">if</span>(_y&gt;=<span class="number">1</span>&amp;&amp;_y&lt;=<span class="number">30</span>&amp;&amp;_x&gt;=<span class="number">1</span>&amp;&amp;_x&lt;=<span class="number">50</span>&amp;&amp;m[_y][_x]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;dist[_y][_x]==dist[y][x]<span class="number">-1</span>)&#123;</span><br><span class="line">				y=_y;</span><br><span class="line">				x=_x;</span><br><span class="line">				res+=dir[i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;<span class="string">&quot;DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-跳蚱蜢">【真题练习】跳蚱蜢</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321010204690.png" alt="image-20230321010204690"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">采用queue队列实现bfs遍历，由初始态012345678到目标087654321；</li>
<li class="lvl-3">因为蚱蜢很多，跳蚱蜢很复杂，因此建议跳空盘，更好理解；</li>
<li class="lvl-3">注意根据题意知，应该有4中跳法：顺时针跳1步、顺时针跳2步、逆时针跳1步、逆时针跳2步；</li>
<li class="lvl-3">可以采用set和map进行去重以及判断是否达到了最后的目标。</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{注意：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>将反方向的-2到达的位置，转换为正方向下的位置坐标7。<code>int k=(j+9)%9;</code></p>
</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="built_in">node</span>(string ss,<span class="type">int</span> tt)&#123;<span class="comment">//构造函数 </span></span><br><span class="line">		s=ss;</span><br><span class="line">		t=tt;</span><br><span class="line">	&#125;</span><br><span class="line">	string s;<span class="comment">//当前状态,比如：012345678 </span></span><br><span class="line">	<span class="type">int</span> t;<span class="comment">//跳跃次数 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt;q;<span class="comment">//辅助完成bfs </span></span><br><span class="line">map&lt;string,<span class="type">bool</span>&gt;h;<span class="comment">//去重并判断是否达到目标结果 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理函数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;<span class="comment">//采用广度优先搜索 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node now=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		string s=now.s;</span><br><span class="line">		<span class="type">int</span> step=now.t;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">&quot;087654321&quot;</span>)&#123;<span class="comment">//找到最终结果 </span></span><br><span class="line">			cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;step;<span class="comment">//最终结果 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//i是源位置，k是目标位置 </span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">9</span>;++i)&#123;<span class="comment">//找到空盘的位置i</span></span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-2</span>;j&lt;=i+<span class="number">2</span>;++j)&#123;<span class="comment">//四种跳法 </span></span><br><span class="line">			<span class="type">int</span> k=(j+<span class="number">9</span>)%<span class="number">9</span>;	<span class="comment">//将反方向的-2到达的位置，转换为正方向下的位置坐标7</span></span><br><span class="line">			<span class="keyword">if</span>(k==i)<span class="keyword">continue</span>;	<span class="comment">//避免重复计算 </span></span><br><span class="line">			string news=s;</span><br><span class="line">			<span class="comment">//交换位置i与位置k的值 </span></span><br><span class="line">			<span class="built_in">swap</span>(news[i],news[k]);</span><br><span class="line">			<span class="keyword">if</span>(!h[news])&#123;<span class="comment">//不存在此种情况，则添加到h中 </span></span><br><span class="line">				h[news]=<span class="literal">true</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">node</span>(news,step+<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s=<span class="string">&quot;012345678&quot;</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">node</span>(s,<span class="number">0</span>));</span><br><span class="line">	h[s]=<span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-七段码">【真题练习】七段码</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230322105104790.png" alt="image-20230322105104790"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">经典七段码问题，用到邻接矩阵以及回溯法</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 经典七段码问题，用到邻接矩阵以及回溯法 </span></span><br><span class="line"><span class="comment">//int graph[7][7],visit[7];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> graph[][<span class="number">7</span>], <span class="type">int</span> visit[], <span class="type">int</span> n, <span class="type">int</span> i)</span></span>&#123;<span class="comment">// n:7, i:起始边 </span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>;x &lt; n;++x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(graph[i][x] != <span class="number">0</span>&amp;&amp;visit[x] != <span class="number">1</span>)&#123;<span class="comment">// 找到未遍历到的相邻边 </span></span><br><span class="line">			visit[x] = <span class="number">1</span>;</span><br><span class="line">			count += <span class="built_in">backTrack</span>(graph, visit, n, x);<span class="comment">// 递归</span></span><br><span class="line">			visit[x] = <span class="number">0</span>;<span class="comment">// 回溯 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> graph[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> visit[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">backTrack</span>(graph, visit, <span class="number">7</span>, <span class="number">0</span>)/<span class="number">2</span>;<span class="comment">// 除2是因为前面重复计算了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="number">80</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-n皇后问题">【真题练习】N皇后问题</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323004824573.png" alt="image-20230323004824573"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">N皇后问题使用回溯法解决；</li>
<li class="lvl-3">关键是要正确表示左右斜线；（左斜线：k=i+j；右斜线：k=i-j+N-1）</li>
<li class="lvl-3">在每次放置皇后的时候必须保证当前位置的同一行（这里不用定义数组，直接根据递归回溯来限制同一行只能有一个皇后）、同一列（定义bool型的col[N]）以及左右斜线上（定义bool型R[2 * N],L[2 * N]）没有放置过皇后；</li>
<li class="lvl-3">每放置一个位置<code>M[i][j]</code>就更新对应的<code>col[j],R[i-j+N-1],L[i+j]</code>。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> counts = <span class="number">0</span>;<span class="comment">// 计数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">N_queens</span><span class="params">(<span class="type">int</span> i, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;M, <span class="type">int</span> col[], <span class="type">int</span> L[], <span class="type">int</span> R[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; N;++j)&#123;<span class="comment">// 遍历每一行的位置 </span></span><br><span class="line">		<span class="keyword">if</span>(!col[j]&amp;&amp;!R[i-j+N<span class="number">-1</span>]&amp;&amp;!L[i+j])&#123;<span class="comment">// 可放置 </span></span><br><span class="line">			M[i][j] = i+<span class="number">1</span>;<span class="comment">// 放置皇后 </span></span><br><span class="line">			col[j] = L[i+j] = R[i-j+N<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i == N<span class="number">-1</span>)&#123;</span><br><span class="line">				counts++;<span class="comment">// 放置方法加1 </span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">N_queens</span>(i+<span class="number">1</span>, M, col, L, R);</span><br><span class="line">			&#125;</span><br><span class="line">			M[i][j] = <span class="number">0</span>;<span class="comment">// 回溯-去皇后 </span></span><br><span class="line">			col[j] = L[i+j] = R[i-j+N<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">M</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N, <span class="number">0</span>));<span class="comment">// 采用int M[N][N]，不方便给函数传参，这里要用vector动态数组 </span></span><br><span class="line">	<span class="type">int</span> col[N]=&#123;<span class="number">0</span>&#125;, L[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;, R[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;;<span class="comment">// 1则表明存储皇后 </span></span><br><span class="line"><span class="comment">//	count = 0;// 计数 </span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">N_queens</span>(<span class="number">0</span>, M, col, L, R);</span><br><span class="line">	cout&lt;&lt;n;<span class="comment">// 可行解数量 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第五天">第五天</h2>
<h3 id="真题练习-一元三次方程求解">【真题练习】一元三次方程求解</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323145806148.png" alt="image-20230323145806148"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">本题由于范围和进度较小可以使用暴力求解的方式解决；</li>
<li class="lvl-3">二分法，根据根与根之间差的绝对值大于等于1，因此可以简化问题：将[-100,100]划分为200个小区间，在小区间内进行二分搜索。</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{注意：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>涉及到输出精度的问题，尽量使用C的标准输出<code>printf(&quot;%.2lf &quot;, (i+j)/2)</code>，C++的setprecision有点问题；</p>
</li>
</ol>
</blockquote>
<p>解决代码：</p>
<p>1、暴力求解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a*x*x*x+b*x*x+c*x+d;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">double</span> i = <span class="number">-100</span>;i &lt;= <span class="number">100</span>;i += <span class="number">0.01</span>)&#123;</span><br><span class="line">		<span class="type">double</span> j = i + <span class="number">0.01</span>;</span><br><span class="line">		<span class="type">double</span> y1 = <span class="built_in">y</span>(i),y2 = <span class="built_in">y</span>(j);</span><br><span class="line">		<span class="keyword">if</span>(y1*y2 &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, (i+j)/<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、二分法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a*x*x*x+b*x*x+c*x+d;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line"><span class="comment">//	scanf(&quot;%lf%lf%lf%lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d);</span></span><br><span class="line"><span class="comment">//-------------二分法----------------------</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =- <span class="number">100</span>;i &lt;= <span class="number">100</span>;++i)&#123;</span><br><span class="line">		<span class="type">double</span> left = i,right = i+<span class="number">1</span>;</span><br><span class="line">		<span class="type">double</span> y1 = <span class="built_in">y</span>(left),y2 = <span class="built_in">y</span>(right);</span><br><span class="line">		<span class="keyword">if</span>(y1 == <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, left);<span class="comment">// 左端点 </span></span><br><span class="line">		<span class="keyword">if</span>(y1*y2&lt;<span class="number">0</span>)&#123;<span class="comment">// &lt;0表示小区间内存在根 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;++j)&#123;<span class="comment">// 将长度为1的区间划分为100份，也就是每一小份都是0.01 </span></span><br><span class="line">				<span class="type">double</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">y</span>(mid)*<span class="built_in">y</span>(right)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">					left = mid;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					right = mid;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-解立方根">【真题练习】解立方根</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323191417112.png" alt="image-20230323191417112" style="zoom:50%;" />
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">本题简单，使用pow理论上可以求出所有的N次根。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Three_sqrt</span><span class="params">(<span class="type">double</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(N, <span class="number">1.0</span>/<span class="number">3.0</span>);<span class="comment">// 使用pow实现 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T, N;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T;++i)&#123;</span><br><span class="line">		cin&gt;&gt;N;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, <span class="built_in">Three_sqrt</span>(N));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-分巧克力">【真题练习】分巧克力</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323192258783.png" alt="image-20230323192258783" style="zoom:50%;" />
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">定义切出的巧克力的边长为d；</li>
<li class="lvl-3">暴力解的话就是将d从1开始遍历，一直到不能够满足分出k块巧克力为止，复杂度为O(n*d)，<mark>超时</mark>；</li>
<li class="lvl-3">可以使用二分法进行简化，复杂度为O(log<sub>2</sub>d)；</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> h[N],w[N];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> d;<span class="comment">// 最大边长 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否能够满足分巧克力的条件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		num += (h[i]/d)*(w[i]/d);<span class="comment">// 计算每块巧克力能够分为多少块正方形 </span></span><br><span class="line">	&#125;<span class="comment">// (h[i])*(w[i])/(d*d)的形式是不可行的，不符合切巧克力的条件 </span></span><br><span class="line">	<span class="keyword">if</span>(num&gt;=k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;h[i]&gt;&gt;w[i];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> l = <span class="number">1</span>, r = N;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;<span class="comment">// 右移一位，表示除以2，+1:表示向右取整 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;<span class="comment">// 因为前面mid是向右取整的，因此取右边界的时候需要-1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以上步骤也可以使用mid向左取整来解决 </span></span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第六天">第六天</h2>
<blockquote>
<p><mark>C++贪心算法</mark>的基本思想是在每个决策点上，都采取当前最优的选择，从而希望能够得到全局最优解。具体来说，贪心算法通常包含以下步骤：</p>
<ol>
<li class="lvl-3">将问题分解为若干个子问题；</li>
<li class="lvl-3">对每个子问题进行求解，找到它的最优解；</li>
<li class="lvl-3">合并各个子问题的解成原问题的解。</li>
</ol>
<p>在实际应用中，贪心算法常常需要结合具体问题进行设计和优化。因为贪心算法只考虑局部最优解，并不保证得到全局最优解。对于一些问题，贪心算法可以得到最优解，但对于一些复杂问题，贪心算法可能无法得到最优解，此时需要使用其他算法。</p>
</blockquote>
<h3 id="真题练习-翻硬币">【真题练习】翻硬币</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323195906866.png" alt="image-20230323195906866"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<p>通过思考可以发现，我们每次的操作都会满足以下两个特性：</p>
<ol>
<li class="lvl-3">
<p>必要性：只有当被操作的硬币状态和目标状态不同时，才进行操作；</p>
</li>
<li class="lvl-3">
<p>独立性：不会影响已处理好（达到目标状态）的硬币。</p>
</li>
</ol>
<p>显然，满足了必要性和独立性的操作，即最优操作。每次都使用最优操作，那么总的操作次数就会是最少的。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次的操作都会满足以下两个特性：</span></span><br><span class="line"><span class="comment">//1. 必要性：只有当被操作的硬币状态和目标状态不同时，才进行操作；</span></span><br><span class="line"><span class="comment">//2. 独立性：不会影响已处理好（达到目标状态）的硬币。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	cin&gt;&gt;s1;</span><br><span class="line">	cin&gt;&gt;s2;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]!=s2[i])&#123;<span class="comment">// s1[i]经过改变之后必定变为目标态，只对s1[i+1]修改即可 </span></span><br><span class="line">			<span class="keyword">if</span>(s1[i+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>)s1[i+<span class="number">1</span>]=<span class="string">&#x27;o&#x27;</span>; </span><br><span class="line">			<span class="keyword">else</span> s1[i+<span class="number">1</span>]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;num;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-巧克力">【真题练习】巧克力</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323202612029.png" alt="image-20230323202612029"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">第一个是要对输入的n种巧克力进行排序；</li>
<li class="lvl-3">第二个是要将保质期到len的巧克力安排在第len天，如果已经安排，则往前面安排；</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{注意：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>因为本题数据量大，使用int会存储数据溢出，因此可以使用<code>using ll = long long;</code>或者是<code>#define int long long</code>来解决数据溢出的问题；</p>
</li>
<li class="lvl-3">
<p>同时应该注意的是使用<code>#define int long long</code>之后，需要将<code>main()</code>函数的类型从<code>int</code>改为<code>signed</code>，否则会报main函数返回类型错误。</p>
</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">choc</span> &#123;</span><br><span class="line">	<span class="type">int</span> price;<span class="comment">// 巧克力价格</span></span><br><span class="line">	<span class="type">int</span> len;<span class="comment">// 保质期到</span></span><br><span class="line">	<span class="type">int</span> cnt;<span class="comment">// 巧克力数量</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> choc&amp;b) &#123; <span class="comment">// 重载&lt;符号的原因是sort默认就是使用&lt;符号来实现排序的</span></span><br><span class="line">		<span class="keyword">if</span>(price == b.price)<span class="keyword">return</span> len&gt;b.len;<span class="comment">// 价格相等，则按保质期的长度降序</span></span><br><span class="line">		<span class="keyword">return</span> price&lt;b.price;<span class="comment">// 按价格升序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">// 在 #define int long long之后，main()函数不能够再定义为int了，而定义为signed：表示有符号的 </span></span><br><span class="line">	<span class="type">int</span> x, n;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> total = <span class="number">0</span>;<span class="comment">// 存储最后的花费</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">		cin&gt;&gt;a[i].price&gt;&gt;a[i].len&gt;&gt;a[i].cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n);<span class="comment">// 排序</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;date;<span class="comment">// 存储未安排巧克力的日期</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=x; ++i) &#123;</span><br><span class="line">		date.<span class="built_in">emplace</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> per = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(per&lt;=n &amp;&amp; date.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">while</span>(a[per].cnt &amp;&amp; date.<span class="built_in">size</span>() &amp;&amp; *date.<span class="built_in">begin</span>() &lt;= a[per].len) &#123;</span><br><span class="line">			total += a[per].price;</span><br><span class="line">			a[per].cnt--;</span><br><span class="line">			<span class="keyword">auto</span> iter = date.<span class="built_in">upper_bound</span>(a[per].len);<span class="comment">// 在未安排巧克力的日期中找到第一个大于目标值的位置</span></span><br><span class="line">			iter--;</span><br><span class="line">			date.<span class="built_in">erase</span>(iter);<span class="comment">// 安排巧克力之后需要删除</span></span><br><span class="line">		&#125;</span><br><span class="line">		per++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(date.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> cout&lt;&lt;total;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-答疑">【真题练习】答疑</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323235609574.png" alt="image-20230323235609574"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">根据题设条件进行推导，可以知道假设第一个人先进去答疑，第二个人随后进去答疑，可以得到：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>e</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>s</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_1+a_1+e_1&lt;s_2+a_2+e_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，根据这个不等式对输入数据进行排序。</li>
<li class="lvl-3">根据排序好的顺序进行求和，第i个人的对总量的贡献通式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>×</mo><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(n-i+1) \times (s_i+a_i)+(n-i)\times e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230324004352188.png" alt="image-20230324004352188"></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll s, a, e;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">		<span class="keyword">return</span> s+a+e&lt;b.s+b.a+b.e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">vector&lt;node&gt;vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	ll s, a, e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;a&gt;&gt;e;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(&#123;s, a, e&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		ans += (n-i)*(vec[i].s+vec[i].a) + (n-i<span class="number">-1</span>)*vec[i].e;<span class="comment">// 这里的i是从0开始的，推导过程中是从1开始的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-顺子日期">【真题练习】顺子日期</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230324005734448.png" alt="image-20230324005734448"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">首先注意2022年的2月只有28天；</li>
<li class="lvl-3">在2022年份中存在的顺子只可能是012、123；</li>
<li class="lvl-3">枚举2022年份并检查是否存在012、123即可；</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;<span class="comment">// 存储1-12月份的天数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> </span>&#123;</span><br><span class="line">	string s = <span class="built_in">to_string</span>(year);</span><br><span class="line">	<span class="keyword">if</span>(month&lt;<span class="number">10</span>) &#123;</span><br><span class="line">		s += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s += <span class="built_in">to_string</span>(month);</span><br><span class="line">	<span class="keyword">if</span>(day&lt;<span class="number">10</span>) &#123;</span><br><span class="line">		s += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s += <span class="built_in">to_string</span>(day);</span><br><span class="line"><span class="comment">//	for(auto e:s) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;e;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&quot;012&quot;</span>)!=s.npos||s.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>)!=s.npos)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// find函数返回的是npos </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> month=<span class="number">1</span>; month&lt;=<span class="number">12</span>; ++month) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> day=<span class="number">1</span>; day&lt;=nums[month]; ++day) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(<span class="number">2022</span>, month, day)) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="number">14</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-特殊时间">【真题练习】特殊时间</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230324102308249.png" alt="image-20230324102308249"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">共有三个4位数字组成，每个4位数字都只有两个不相等整数组成，不妨设为a，b；</li>
<li class="lvl-3">因此每个4位数字只可能是aaab、aaba、abaa、baaa四种可能，对于year来说，它恒有4种情况；而对于月日以及时分来说需要对以上4种情况判断是否符合实际时间；</li>
<li class="lvl-3">闰年的2月有29天，但是29这两个数字不能够组成合法日期，所以可以直接考虑2月只有28天的情况。</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_md</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> month = num/<span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> day = num%<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span>(month&lt;<span class="number">1</span>||month&gt;<span class="number">12</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(day&lt;<span class="number">1</span>||day&gt;nums[month])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_hm</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> h = num/<span class="number">100</span>;<span class="comment">// 取前两位 </span></span><br><span class="line">	<span class="type">int</span> m = num%<span class="number">100</span>;<span class="comment">// 取后两位 </span></span><br><span class="line">	<span class="keyword">if</span>(h&lt;<span class="number">0</span>||h&gt;<span class="number">23</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;<span class="number">59</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;=<span class="number">9</span>;a++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;=<span class="number">9</span>;b++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">				<span class="type">int</span> N_y = <span class="number">4</span>, N_md = <span class="number">0</span>, N_hm = <span class="number">0</span>;</span><br><span class="line">				<span class="type">int</span> A[] = &#123;a, a, a, a&#125;;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">					A[i] = b;</span><br><span class="line">					<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)num = <span class="number">10</span>*num + A[j];</span><br><span class="line">					N_md += <span class="built_in">check_md</span>(num);</span><br><span class="line">					N_hm += <span class="built_in">check_hm</span>(num);</span><br><span class="line">					A[i] = a;<span class="comment">// 还原 </span></span><br><span class="line">				&#125;</span><br><span class="line">				ans += N_y*N_md*N_hm;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  cout&lt;&lt;<span class="number">212</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-乘积尾零">【真题练习】乘积尾零</h3>
<p><strong><u>题目描述</u></strong></p>
<p><strong>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</strong></p>
<p>如下的 1010 行数据，每行有 1010 个整数，请你求出它们的乘积的末尾有多少个零？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5650 4542 3554 473 946 4114 3871 9073 90 4329 </span><br><span class="line">2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 </span><br><span class="line">9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 </span><br><span class="line">1486 5722 3135 1170 4014 5510 5120 729 2880 9019 </span><br><span class="line">2049 698 4582 4346 4427 646 9742 7340 1230 7683 </span><br><span class="line">5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 </span><br><span class="line">6701 6645 1671 5978 2704 9926 295 3125 3878 6785 </span><br><span class="line">2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 </span><br><span class="line">3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 </span><br><span class="line">689 5510 8243 6114 337 4096 8199 7313 3685 211 </span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">Python可以直接暴力求解；</li>
<li class="lvl-3">C++需要考虑数据溢出问题，因为10=2*5，在所有数中因子为5的个数一定比因子为2的个数少，因此计算因子为5的个数即为尾零的个数。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		<span class="keyword">while</span>(x%<span class="number">5</span>==<span class="number">0</span>) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			x/=<span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-平方和">【真题练习】平方和</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230324150939536.png" alt="image-20230324150939536" style="zoom:50%;" />
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">通过求余和整除得到每一位的数字并判断是否为2、0、1、9，如果有，则直接平方求和；</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll x=<span class="number">1</span>; x&lt;=<span class="number">2019</span>; ++x) &#123;</span><br><span class="line">		ll temp = x;</span><br><span class="line">		<span class="keyword">while</span>(temp&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp%<span class="number">10</span>==<span class="number">2</span>||temp%<span class="number">10</span>==<span class="number">1</span>||temp%<span class="number">10</span>==<span class="number">0</span>||temp%<span class="number">10</span>==<span class="number">9</span>) &#123;</span><br><span class="line">				ans += x*x;<span class="comment">// 平方和</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>真题练习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP模拟考笔记</title>
    <url>/2023/10/18/University/junior/competition/CCF-CSP/CCF-CSP%E6%A8%A1%E6%8B%9F%E8%80%83%E7%AC%AC%E4%BA%8C%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>CCF-CSP模拟考笔记</h1>
<blockquote>
<p>官网模拟题：<a href="http://118.190.20.162/home.page">首页 - 计算机软件能力认证考试系统</a></p>
</blockquote>
<h2 id="第二题">第二题</h2>
<blockquote>
<p>一般会涉及到动态规划以及对应的空间压缩，前缀和进行时间优化，找规律得到共性进行时间优化，存储特殊坐标进行空间优化而不是直接存储整个矩阵……</p>
</blockquote>
<h4 id="202212-2-训练计划">202212-2、训练计划</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230306145523303.png" alt="问题描述"></p>
<blockquote>
<p>100分参考代码：<a href="https://blog.csdn.net/futurech/article/details/129170838">(99条消息) CCF CSP202212-2训练计划【100分】详细注释_Brienzz的博客-CSDN博客</a></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">0 1 0 2 0</span><br><span class="line">1 2 3 2 10</span><br><span class="line">----------</span><br><span class="line">10 5</span><br><span class="line">0 1 2 3 4</span><br><span class="line">1 2 3 2 1</span><br><span class="line">----------</span><br><span class="line">10 7</span><br><span class="line">0 1 0 3 2 3 0</span><br><span class="line">2 1 2 3 1 4 3</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 1 4 1</span><br><span class="line">6 7 8 9 1</span><br><span class="line">----------</span><br><span class="line">1 2 4 7 9</span><br><span class="line">2 3 5 8 10</span><br><span class="line">----------</span><br><span class="line">1 3 1 3  4   3  1</span><br><span class="line">7 9 5 8  10  7  8</span><br></pre></td></tr></table></figure>
<p><span style="color: red;">关键：</span></p>
<ol>
<li class="lvl-3">
<p>正向遍历易求最早开始时间。</p>
</li>
<li class="lvl-3">
<p>反向遍历要注意找到具有依赖关系的后项post存储值的数学表达式。（<code>post[dependency[i]]=-T[i]+post[i]</code>）</p>
</li>
<li class="lvl-3">
<p>是否输出最晚开始时间要看求出的最晚开始时间last数组中是否有小于1的值。若有，则不输出；没有，则输出。</p>
</li>
</ol>
<p><u><em><strong>提醒：</strong></em></u>直接暴力求解最早开始时间就能够得到70分。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写出的代码有问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//网上100分参考代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">365</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p[maxm];</span><br><span class="line"><span class="type">int</span> t[maxm];</span><br><span class="line"><span class="type">int</span> early[maxm];</span><br><span class="line"><span class="type">int</span> last[maxm];</span><br><span class="line"><span class="keyword">typedef</span> multimap&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator Iterator;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    multimap&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rel;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        (p[i],i)表示项目i的依赖项目为p[i],称i是依赖对象,p[i]是被依赖对象</span></span><br><span class="line"><span class="comment">        依赖关系可以用multiset表示 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        rel.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(p[i],i)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//默认最早开始时间满足n天训练 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            early[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            early[i] = early[p[i]]+t[p[i]]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(early[i]+t[i]<span class="number">-1</span>&gt;n) flag = <span class="literal">false</span>;<span class="comment">//最早开始时间不满足n天训练 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;early[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由于满足依赖科目编号p[i]小于当前项目i的编号，因此可以从编号大的开始往前计算最晚开始时间 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//找项目i的被依赖对象，如果项目i没有被依赖对象，则依赖关系(i,p[i])不存在 </span></span><br><span class="line">            pair&lt;Iterator,Iterator&gt; it = rel.<span class="built_in">equal_range</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(it.first==it.second)&#123;<span class="comment">//依赖关系不存在 </span></span><br><span class="line">                last[i] = n - t[i] +<span class="number">1</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//依赖关系存在 </span></span><br><span class="line">                Iterator it1;</span><br><span class="line">                <span class="type">int</span> value = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span>(it1 = it.first;it1 != it.second; ++it1) &#123;</span><br><span class="line"><span class="comment">//                    cout&lt;&lt;it1-&gt;first&lt;&lt;&quot; ==== &quot;&lt;&lt;it1-&gt;second&lt;&lt;&quot;---&quot;;</span></span><br><span class="line">                    value = <span class="built_in">min</span>(value,last[it1-&gt;second]);</span><br><span class="line"><span class="comment">//                    cout&lt;&lt;value&lt;&lt;endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                last[i] = value - t[i];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;last[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            cout&lt;&lt;last[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202209-2-何以包邮？">202209-2、何以包邮？</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230306145706568.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">思路：</span></p>
<ol>
<li class="lvl-3">动态规划（0-1背包问题）</li>
<li class="lvl-3">第一种方法：
<ul class="lvl-3">
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/a5bff9881ddd4843bfa4d14e1f94e636.png" alt="img"></li>
</ul>
</li>
<li class="lvl-3">第二种方法：
<ul class="lvl-3">
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/d22e0b5b862f40b99d585736b3511b68.png" alt="img"></li>
</ul>
</li>
</ol>
<p>参考：<a href="https://blog.csdn.net/qq_51800570/article/details/128965002">(99条消息) 202209-2 CCF 何以包邮？ （01背包解法（两种解法） + 详细思路）_一只可爱的小猴子的博客-CSDN博客</a></p>
<p><span style="color: red;">PS：</span><u><strong>在某些情况下，使用vector定义数组可能会导致空间使用增加。</strong></u></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307092308900.png" alt="image-20230307092308900"></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	0-1动态规划求出在需要删去的书中的最大的价格总和，再将所有书的价格总和减去前面的总和得到的就是最小但是能够包邮的花费。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">//vector&lt;int&gt;a(N);</span></span><br><span class="line"><span class="comment">//vector&lt;vector&lt;int&gt;&gt;f(N+1,vector&lt;int&gt;(M+1,0));</span></span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> a[N]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种解法 ——从 [0，sum-x]区间中选出使得花费最大的，再减去最大的就是最小的 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,x,sum=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sum-x;++j)&#123;<span class="comment">//在[0，sum-x]中求出最大值，那么最后的花费就会最小且满足包邮条件 </span></span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j];<span class="comment">//没选第i本书</span></span><br><span class="line">			<span class="keyword">if</span>(j&gt;=a[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-a[i]]+a[i]);	<span class="comment">//j&gt;=a[i]时才能继续往背包里加东西 </span></span><br><span class="line">			res=<span class="built_in">max</span>(res,f[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum-res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种解法 ——从总的中删去不要的 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,x,sum=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][sum]=sum;<span class="comment">//在容量为sum的情况下最大总价值为sum </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=x;j&lt;=sum;++j)f[<span class="number">0</span>][j]=sum;<span class="comment">//在容量在[x,sum]的情况下，未删去书籍时的初始情况为sum</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> res=INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=x;--j)&#123;<span class="comment">//每一次循环j都会减少，j代表的是最终要支付的金额</span></span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j];<span class="comment">//没删去第i本书 </span></span><br><span class="line">			<span class="keyword">if</span>(j+a[i]&lt;=sum)f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j+a[i]]-a[i]);<span class="comment">//删去第i本书 </span></span><br><span class="line">			<span class="keyword">if</span>(f[i][j]&gt;=x)res=<span class="built_in">min</span>(res,f[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="202206-2-寻宝-大冒险">202206-2、寻宝！大冒险！</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307101335157.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">注意：</span>本题有30%的数据会有很大的绿化图，这样的绿化图不能够直接使用二维数组存储，需要对空间进行优化。采用<code>vector&lt;pair&lt;int,int&gt;&gt;A;</code>对绿化图进行空间优化。</p>
<p>参考：<a href="https://blog.csdn.net/qq_51800570/article/details/126673741">(99条消息) 202206-2 CCF 寻宝！大冒险！ （简单模拟 满分题解）_ccf20220602_一只可爱的小猴子的博客-CSDN博客</a></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//70分代码：——主要是因为绿化图的大小很大的情况下，用二维数组存储是不行的，因此需要进行空间优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">2010</span>,S=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> A[L+<span class="number">1</span>][L+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> B[S+<span class="number">1</span>][S+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,L,S,count=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;</span><br><span class="line"><span class="comment">//	vector&lt;vector&lt;int&gt;&gt;A(L+1,vector&lt;int&gt;(L+1,0));</span></span><br><span class="line"><span class="comment">//	vector&lt;vector&lt;int&gt;&gt;B(S+1,vector&lt;int&gt;(S+1,0));</span></span><br><span class="line">	<span class="type">int</span> x1,y1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">		A[x1][y1]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=S;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=S;++j)&#123;</span><br><span class="line">			cin&gt;&gt;B[i][j];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//在矩阵A的L-S范围内查找树的位置作为藏宝图的B[0][0]，再看A与B之间是否能够匹配（也就是A是否完全包含了B） </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=L;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=L;++j)&#123;</span><br><span class="line">			<span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(A[i][j]==<span class="number">1</span>&amp;&amp;i+S&lt;=L&amp;&amp;j+S&lt;=L)&#123;</span><br><span class="line">				<span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;=S;++x)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;=S;++y)&#123;</span><br><span class="line">						<span class="keyword">if</span>(A[i+x][j+y]==B[x][y])<span class="keyword">continue</span>;</span><br><span class="line">						<span class="keyword">else</span>&#123;</span><br><span class="line">							flag=<span class="literal">false</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(!flag)<span class="keyword">break</span>; </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(flag)++count;</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> s=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> n,L,S;</span><br><span class="line"><span class="comment">//int A[L+1][L+1];//绿化图 </span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;A;<span class="comment">//绿化图 </span></span><br><span class="line"><span class="type">int</span> B[s+<span class="number">1</span>][s+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=S;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=S;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x+i&lt;<span class="number">0</span>||x+i&gt;L||y+j&lt;<span class="number">0</span>||y+j&gt;L)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//藏宝图有部分超过了绿化图，因此不匹配 </span></span><br><span class="line">			<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:A)&#123;<span class="comment">//当前藏宝图B[i][j]的位置与绿化图中树的位置集合A中有一个相等即可 </span></span><br><span class="line">				<span class="keyword">if</span>(x+i==p.first&amp;&amp;y+j==p.second)&#123;</span><br><span class="line">					flag=<span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断藏宝图 B[i][j]是否为一个树并结合前面判断好的关于当前藏宝图的位置是否在集合A中 </span></span><br><span class="line">			<span class="keyword">if</span>((B[i][j]&amp;&amp;!flag)||(!B[i][j]&amp;&amp;flag))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不用考虑 B[i][j]=0以及 flag=false的情况：因为如果 B[i][j]=0则表明其不是一棵树，那么自然不可能存在于集合A中 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;</span><br><span class="line"><span class="comment">//	vector&lt;vector&lt;int&gt;&gt;A(L+1,vector&lt;int&gt;(L+1,0));</span></span><br><span class="line"><span class="comment">//	vector&lt;vector&lt;int&gt;&gt;B(S+1,vector&lt;int&gt;(S+1,0));</span></span><br><span class="line">	<span class="type">int</span> x1,y1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">		A.<span class="built_in">push_back</span>(&#123;x1,y1&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=S;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=S;++j)&#123;</span><br><span class="line">			cin&gt;&gt;B[i][j];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//对绿化图中每一棵树作为藏宝图B[0][0]点，并由此为起点进行一次判断看否能够满足藏宝图的要求 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(A[i].first,A[i].second))&#123;</span><br><span class="line">			++count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202203-2-出行计划">202203-2、 出行计划</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230308165207248.png" alt="问题描述"></p>
<blockquote>
<p>q时刻做核酸之后经过k时刻得到核酸证明，此时q+k时刻能够进入场所的条件是：（q+k）+ci&gt;ti，并且q+k&lt;=ti；</p>
<p>也就是有（q+k）+ci&gt;=ti+1，并且q+k&lt;=ti<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>q应该在区间[ti+1-k-ci,ti-k]中</p>
<p>参考：<a href="https://blog.csdn.net/qq_45936312/article/details/123955952">(99条消息) CSP CCF： 202203-2 出行计划 （C++）_猫娜Lisa的博客-CSDN博客</a></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//70分代码：——运行超时</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//前缀和？ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,k,t,c;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;p[n];</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">q</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;t&gt;&gt;c;</span><br><span class="line">		p[i]=make_pair&lt;&gt;(t,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;q[i];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i]+k+p[j].second&gt;p[j].first&amp;&amp;p[j].first&gt;=q[i]+k)&#123;</span><br><span class="line">				++num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//修改后的100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//前缀和？ </span></span><br><span class="line"><span class="comment">//由（q+k）+ci&gt;=ti+1，并且q+k&lt;=ti得到q的区间[ti+1-k-ci,ti-k]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,k,t,c,q;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">Q</span>(<span class="number">200002</span>,<span class="number">0</span>);<span class="comment">//Q取200002容量的原因是 --Q[r+1]中r就是qi其最大取值可以是200000，所以r+1=200001，所以最多有200002个元素 </span></span><br><span class="line"><span class="comment">//	int Q[200002]=&#123;0&#125;;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;t&gt;&gt;c;</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">max</span>(<span class="number">0</span>,t+<span class="number">1</span>-k-c);<span class="comment">//左边界 </span></span><br><span class="line">		<span class="type">int</span> r=<span class="built_in">max</span>(<span class="number">0</span>,t-k);<span class="comment">//右边界 </span></span><br><span class="line">		++Q[l];<span class="comment">//当左边界小于0时l=0，此时有 ++Q[0]（并且qi&gt;0），表示所有的qi取值都可以进入当前第i个场所，便于后面的求前缀和操作 </span></span><br><span class="line">		--Q[r+<span class="number">1</span>];<span class="comment">//r+1表示的是大于右边界的qi不能够进入当前第i个场所 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200001</span>;++i)&#123;</span><br><span class="line">		Q[i]+=Q[i<span class="number">-1</span>];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line"><span class="comment">//		int q; </span></span><br><span class="line">		cin&gt;&gt;q;</span><br><span class="line">		cout&lt;&lt;Q[q]&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//网上100分参考代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> Q[<span class="number">200002</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> t, c;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;c;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="number">0</span>, t - k - c + <span class="number">1</span>);<span class="comment">//t-k-c+1代表的是qi的左边界，如果左边界为负数，则可以判定当前第i个场所可以进入，因此有下面的++Q[l]操作。当左边界是1，则有++Q[1]</span></span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="number">0</span>, t - k);<span class="comment">//t-k代表的是qi的右边界，如果右边界为负数，则可以判定当前第i个场所不可能进入，因此有下面的--Q[r + 1]操作。当右边界为1，则有--Q[2]表示的是qi取2时是不能够进入当前第i和场所的。</span></span><br><span class="line">        ++Q[l];</span><br><span class="line">        --Q[r + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">200002</span>; ++i) &#123;<span class="comment">//计算数组Q的前缀和</span></span><br><span class="line">        Q[i] += Q[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        cin&gt;&gt;q;</span><br><span class="line">        cout&lt;&lt;Q[q]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202112-2-序列查询新解">202112-2、序列查询新解</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230309151749930.png" alt="问题描述"></p>
<blockquote>
<p>lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。</p>
<p>通过<code>/</code>实现向下取整。</p>
<p>思路参考：<a href="https://blog.csdn.net/Coco091/article/details/123652795?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-123652795-blog-124916645.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-123652795-blog-124916645.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=7">(100条消息) CCF - 202112-2 - 序列查询新解_Coco091的博客-CSDN博客</a></p>
<p>代码参考：<a href="https://blog.csdn.net/qq_21471309/article/details/123296864">(100条消息) 【CCF-CSP】202112-2-序列查询新解100分（读过必懂）_ccf序列查询新解_怪&amp;的博客-CSDN博客</a></p>
<p><span style="color: red;">关键：</span></p>
<ol>
<li class="lvl-3">
<p>因为A[n]&lt;N，所以为了后面方便计算，我们设A[n+1]=N</p>
</li>
<li class="lvl-3">
<p>根据数组A将f(i)划分为多个区间，保证每个区间内的f的值都相同</p>
</li>
<li class="lvl-3">
<p>由数组A划分的多个区间[A[i-1],A[i]-1，这个区间也是f的区间,f在每一个区间之内的值都是i-1</p>
</li>
<li class="lvl-3">
<p>根据示例数据g(i)可以发现g是以r个相同元素递增的等差数列，每r个相同元素的g的右边界就是（g(i)+1）*r-1,并且g的左边界就是j</p>
</li>
<li class="lvl-3">
<p>最后通过<code>delta+=abs(i-1-g(j,r))*length;</code>简化累和计算，提高时间效率</p>
</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//70分代码：——运行超时</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,N,r;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">	r=(<span class="type">int</span>)(N/(n+<span class="number">1</span>));</span><br><span class="line"><span class="comment">//	cout&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">	<span class="type">int</span> delta=<span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">A</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> g,f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">		f=<span class="built_in">lower_bound</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>(),i)-A.<span class="built_in">begin</span>();<span class="comment">//lower_bound返回一个迭代器</span></span><br><span class="line">		<span class="keyword">if</span>(A[f]!=i)f=f<span class="number">-1</span>;	<span class="comment">//注意如果A[f]的值等于N的值则返回的f不减1</span></span><br><span class="line">		g=(<span class="type">int</span>)(i/r);</span><br><span class="line">		delta+=<span class="built_in">abs</span>(g-f);</span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;f&quot;&lt;&lt;f&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;g&quot;&lt;&lt;g&lt;&lt;endl;</span></span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;delta;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//优化后100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">g</span><span class="params">(ll i,ll r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i/r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n,N,r;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">	r=(N/(n+<span class="number">1</span>));</span><br><span class="line"><span class="comment">//	cout&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">	ll delta=<span class="number">0</span>;</span><br><span class="line">	vector&lt;ll&gt;<span class="built_in">A</span>(n+<span class="number">2</span>,<span class="number">0</span>);	<span class="comment">//因为A[n]&lt;N，所以为了后面方便计算，我们设A[n+1]=N</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	A[n+<span class="number">1</span>]=N;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;<span class="comment">//根据数组A将f(i)划分为多个区间，保证每个区间内的f的值都相同 </span></span><br><span class="line">		ll length=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll j=A[i<span class="number">-1</span>];j&lt;=A[i]<span class="number">-1</span>;j+=length)&#123;<span class="comment">//由数组A划分的多个区间[A[i-1],A[i]-1]，这个区间也是f的区间,f在每一个区间之内的值都是i-1 </span></span><br><span class="line">			<span class="type">int</span> index_End=(<span class="built_in">g</span>(j,r)+<span class="number">1</span>)*r<span class="number">-1</span>;<span class="comment">//根据示例数据g(i)可以发现g是以r个相同元素递增的等差数列，每r个相同元素的g的右边界就是（g(i)+1）*r-1,并且g的左边界就是j </span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;index_End&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(index_End&gt;A[i]<span class="number">-1</span>)index_End=A[i]<span class="number">-1</span>;<span class="comment">//确保右边界不会超过N，最大只能取N-1 </span></span><br><span class="line">			length=index_End-j+<span class="number">1</span>;<span class="comment">//更新区间长度 </span></span><br><span class="line">			delta+=<span class="built_in">abs</span>(i<span class="number">-1</span>-<span class="built_in">g</span>(j,r))*length;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;delta;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202109-2-非零段划分">202109-2、非零段划分</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230309173714524.png" alt="问题描述"></p>
<blockquote>
<p>大佬参考：<a href="https://blog.csdn.net/tigerisland45/article/details/120598581">(100条消息) CCF202109-2 非零段划分（100分）【序列处理】_海岛Blog的博客-CSDN博客</a></p>
<p><mark>解法三：差分法</mark>（Difference method）</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>借用岛屿情况来分析这个题。考虑p足够大的情况，所有的数都被海水淹没了，只有0个岛屿。然后，海平面逐渐下降，岛屿数量出现变化。每当一个凸峰出现，岛屿数就会多一个；每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连在一起了，岛屿数减少一个。使用数组sum[]，sum[i] 表示海平面下降到i时，岛屿数量的变化。</p>
</li>
<li class="lvl-2">
<p>差分法是最简洁的解题程序。数组元素D[i]中存储该元素被替换为0时，划分数变化的差分值。最大值则只需要从其前缀和（程序中实际为后缀和）中找出最大值就是所要的结果。</p>
</li>
<li class="lvl-2">
<p>程序代码中，STL算法函数unique()用来去除相邻重复的元素。相邻的重复元素对于结果并不会有任何影响。</p>
</li>
<li class="lvl-2">
<p>语句<code>A[0] = A[n + 1] = 0;</code>用来设置边界值，起辅助计算作用，可以简化程序代码。</p>
</li>
</ul>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">A</span>(n+<span class="number">2</span>,<span class="number">0</span>);<span class="comment">//注意对于vector来说指向第一个元素的迭代器是A.begin(),而对于int A[n+2]来说，指向第一个元素的迭代器是A(这很重要！！！) </span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">D</span>(M+<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//A[i]&lt;=M=10000，D数组存储数量差分数量 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	A[<span class="number">0</span>]=A[n+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//辅助计算</span></span><br><span class="line">	<span class="comment">//去除相邻的重复元素</span></span><br><span class="line">	n=<span class="built_in">unique</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">begin</span>()+n+<span class="number">2</span>)-A.<span class="built_in">begin</span>()<span class="number">-2</span>+<span class="number">1</span>;<span class="comment">//剩下无相邻重复的总元素个数</span></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i<span class="number">-1</span>]&lt;A[i]&amp;&amp;A[i]&gt;A[i+<span class="number">1</span>])++D[A[i]];<span class="comment">//A[i]为山峰则+1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[i<span class="number">-1</span>]&gt;A[i]&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])--D[A[i]];<span class="comment">//A[i]为山谷则-1</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//求后缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=M;i&gt;=<span class="number">1</span>;--i)&#123;<span class="comment">//1&lt;=p&lt;=10000</span></span><br><span class="line">		sum+=D[i],ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//网上100分参考代码：</span></span><br><span class="line"><span class="comment">/* CCF202109-2 非零段划分 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> a[N + <span class="number">2</span>], d[M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//设置边界，不影响1……n个元素的存储，起辅助计算的作用</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">unique</span>(a, a + n + <span class="number">2</span>) - a - <span class="number">1</span>;<span class="comment">//去除相邻且重复的元素的个数——unique左闭右开，并且返回的是去重之后容器中不重复序列的最后一个元素的下一个元素。因此需要将此迭代器减去迭代器a并再减1，得到的是不存在重复的元素个数。（包含了a[0] 与 a[n + 1]）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);<span class="comment">//相当于对d初始化为全0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; a[i] &amp;&amp; a[i] &gt; a[i + <span class="number">1</span>]) d[a[i]]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i] &amp;&amp; a[i] &lt;a[i + <span class="number">1</span>]) d[a[i]]--;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;   <span class="comment">// 差分前缀和即为答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = M; i &gt;= <span class="number">1</span>; i--)	<span class="comment">//从最大的p开始递减遍历</span></span><br><span class="line">        sum += d[i], ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202104-2-邻域均值">202104-2、邻域均值</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230310163100166.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">思路：</span></p>
<ol>
<li class="lvl-3">由Aij构成的领域将会是一个小矩阵，该小矩阵可以通过减去3个矩阵得到。</li>
<li class="lvl-3">将整个矩阵的值求和之后存储在矩阵的最右下位置（这里采用预计算处理）</li>
<li class="lvl-3">二维前缀和</li>
<li class="lvl-3">为了避免<code>/</code>可能带来的错误，我们将除改为乘，即阈值t乘以Aij领域的像素个数再与Aij领域的和进行比较：<code>t*num&gt;=sum</code></li>
</ol>
<p><span style="color: red;">注意：</span></p>
<ol>
<li class="lvl-3">
<p>如果不用前缀和会有许多重复计算，运行时间肯定无法满足</p>
</li>
<li class="lvl-3">
<p>使用前缀和可以很容易地避免多余的重复计算，可以使用行前缀和或是二维前缀和</p>
</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//二维前缀和 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,L,r,t;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;L&gt;&gt;r&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> A[n+<span class="number">1</span>][n+<span class="number">1</span>],psum[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">			cin&gt;&gt;A[i][j];</span><br><span class="line">			psum[i][j]=psum[i<span class="number">-1</span>][j]+psum[i][j<span class="number">-1</span>]-psum[i<span class="number">-1</span>][j<span class="number">-1</span>]+A[i][j];<span class="comment">//二维前缀和 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> counts=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="comment">//			int left=j-r&gt;0?j-r:1;</span></span><br><span class="line"><span class="comment">//			int down=i+r&lt;n+1?i+r:n;</span></span><br><span class="line"><span class="comment">//			int right=j+r&lt;n+1?j+r:n;</span></span><br><span class="line"><span class="comment">//			int up=i-r&gt;0?i-r:1;</span></span><br><span class="line">			<span class="comment">//Aij领域内矩阵的四个角的坐标 </span></span><br><span class="line">			<span class="type">int</span> left=<span class="built_in">max</span>(j-r,<span class="number">1</span>);</span><br><span class="line">			<span class="type">int</span> down=<span class="built_in">min</span>(i+r,n);</span><br><span class="line">			<span class="type">int</span> right=<span class="built_in">min</span>(j+r,n);</span><br><span class="line">			<span class="type">int</span> up=<span class="built_in">max</span>(i-r,<span class="number">1</span>);</span><br><span class="line">			<span class="type">int</span> sum=psum[down][right]-psum[up<span class="number">-1</span>][right]-psum[down][left<span class="number">-1</span>]+psum[up<span class="number">-1</span>][left<span class="number">-1</span>];<span class="comment">//这里要注意下标要减1的情况 </span></span><br><span class="line">			<span class="type">int</span> num=(down-up+<span class="number">1</span>)*(right-left+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(t*num&gt;=sum)++counts;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;counts;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202012-2-期末预测之最佳阈值">202012-2、 期末预测之最佳阈值</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307182808564.png" alt="问题描述"></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_43464088/article/details/112080044">(99条消息) CCF-CSP 202012-2 期末预测之最佳阈值（前缀和、set去重、代码极简）_AngleCavalier的博客-CSDN博客</a></p>
<p><span style="color: red;">关键：</span></p>
<ol>
<li class="lvl-3">
<p>考前缀和的应用</p>
</li>
<li class="lvl-3">
<p>两层for循环暴力求解只能通过70%的数据</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/2021012611454258.jpg" alt="img"></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//70分代码：——运行超时</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">fit_selta</span>(m,<span class="number">0</span>);</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">hash</span>(m);</span><br><span class="line">	<span class="type">int</span> y,result;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;y&gt;&gt;result;</span><br><span class="line">		hash[i]=make_pair&lt;&gt;(y,result);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;m;++i)&#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;hash[i].first&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//	&#125; </span></span><br><span class="line">	<span class="type">int</span> selta,predict,max_num=INT_MIN,max_index;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		selta=hash[i].first;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(hash[j].first&gt;=selta)predict=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> predict=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(predict==hash[j].second)++fit_selta[i];</span><br><span class="line">		&#125;<span class="comment">//确保输出的预测次数最多且selta值最大的值 </span></span><br><span class="line">		<span class="keyword">if</span>(max_num&lt;fit_selta[i]||(max_num==fit_selta[i]&amp;&amp;hash[max_index].first&lt;selta))&#123;</span><br><span class="line">			max_num=fit_selta[i];</span><br><span class="line">			max_index=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;hash[max_index].first;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//100分代码:——关键是利用前缀和进行预处理，减少运行时间,提高效率</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash[m+<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> sum[m+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//注要赋sum[0]的初值 ——也可以写成：int sum[m+1]=&#123;0&#125; </span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">	<span class="type">int</span> y,result;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		cin&gt;&gt;y&gt;&gt;result;</span><br><span class="line">		hash[i]=make_pair&lt;&gt;(y,result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//按照阈值进行升序排序</span></span><br><span class="line">	<span class="built_in">sort</span>(hash+<span class="number">1</span>,hash+<span class="number">1</span>+m);</span><br><span class="line">	<span class="comment">//求前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+hash[i].second;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> max_sum=INT_MIN,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="type">int</span> selta=hash[i].first;<span class="comment">//选定阈值 </span></span><br><span class="line">		<span class="keyword">if</span>(st.<span class="built_in">count</span>(selta))<span class="keyword">continue</span>;<span class="comment">//跳过选定的阈值(set去重，相同阈值得到的正确预测次数相等)</span></span><br><span class="line">		st.<span class="built_in">insert</span>(selta);<span class="comment">//存储已经被选定过的阈值,方便去重操作 </span></span><br><span class="line">		<span class="type">int</span> p1=sum[m]-sum[i<span class="number">-1</span>];<span class="comment">//大于等于阈值selta并且预测结果中为1的个数</span></span><br><span class="line">		<span class="type">int</span> p0=i<span class="number">-1</span>-sum[i<span class="number">-1</span>];<span class="comment">//求小于阈值selta并且预测结果中为0的个数</span></span><br><span class="line">		<span class="type">int</span> all=p1+p0;<span class="comment">//总正确预测次数 </span></span><br><span class="line">		<span class="keyword">if</span>(all&gt;=max_sum)&#123;<span class="comment">//确保是大于等于，如果阈值更大且正确预测次数相同的情况下也需要执行函数体 </span></span><br><span class="line">			max_sum=all;</span><br><span class="line">			ans=selta;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//GitHub上100分参考代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> gg = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    map&lt;gg, array&lt;gg, 2&gt;&gt; r;</span><br><span class="line">    gg mi, y, res;</span><br><span class="line">    cin &gt;&gt; mi;</span><br><span class="line">    <span class="keyword">for</span> (gg i = <span class="number">0</span>; i &lt; mi; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; y &gt;&gt; res;</span><br><span class="line">        r[y][res]++;</span><br><span class="line">    &#125;</span><br><span class="line">    gg p0 = <span class="number">0</span>, p1 = <span class="number">0</span>, ans = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : r) &#123;</span><br><span class="line">        gg t = p0 + mi - p1;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= c) &#123;</span><br><span class="line">            c = t;</span><br><span class="line">            ans = i.first;</span><br><span class="line">        &#125;</span><br><span class="line">        p0 += i.second[<span class="number">0</span>];</span><br><span class="line">        p1 += i.second[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202009-2-风险人群筛查">202009-2、风险人群筛查</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230310172253047.png" alt="image-20230310172253047"></p>
<blockquote>
<p><span style="color: red;">关键：</span>这道题主要是在输入t个时刻的坐标时就进行判断处理是否为逗留还是经过。</p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//连续k个或k个时刻以上位于高危区才算是“逗留” </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k,t,x_l,y_d,x_r,y_u;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k&gt;&gt;t&gt;&gt;x_l&gt;&gt;y_d&gt;&gt;x_r&gt;&gt;y_u;</span><br><span class="line">	<span class="type">int</span> xi,yi,pass_counts=<span class="number">0</span>,stay_counts=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//	vector&lt;int&gt;psum(n,0);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> max_sum=<span class="number">0</span>,p_sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;++j)&#123;</span><br><span class="line">			cin&gt;&gt;xi&gt;&gt;yi;</span><br><span class="line">			<span class="keyword">if</span>((x_l&lt;=xi&amp;&amp;xi&lt;=x_r)&amp;&amp;(y_d&lt;=yi&amp;&amp;yi&lt;=y_u))&#123;</span><br><span class="line">				++p_sum;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				max_sum=<span class="built_in">max</span>(max_sum,p_sum);<span class="comment">//存储连续时刻的最大次数 </span></span><br><span class="line">				p_sum=<span class="number">0</span>;<span class="comment">//非连续则置为0 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		max_sum=<span class="built_in">max</span>(max_sum,p_sum);<span class="comment">//避免出现一个人对应的t个连续时刻都在高危区内而导致的Bug </span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;max_sum: &quot;&lt;&lt;max_sum&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(max_sum&gt;=k)&#123;</span><br><span class="line"><span class="comment">//			cout&lt;&lt;&quot;test&quot;&lt;&lt;endl;</span></span><br><span class="line">			++stay_counts;</span><br><span class="line">			++pass_counts;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(max_sum&gt;<span class="number">0</span>)&#123;<span class="comment">//只要某一个时刻在高危区就算经过 </span></span><br><span class="line">			++pass_counts;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;pass_counts&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;stay_counts;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="202006-2-稀疏向量">202006-2、稀疏向量</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230311163142595.png" alt="问题描述"></p>
<blockquote>
<p><span style="color: red;">分析：</span></p>
<ol>
<li class="lvl-3">根据题目的输入和输出的提示我们只定义vector_u，之后的向量v则在输入时便结合vector_u判断是否具有相同的index，以此少定义一个vector，提升效率。</li>
</ol>
<p><mark>注意：</mark></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>unsigned int的范围是<code>0~65536</code> int的范围是 <code>-32768 ~ +32767</code></p>
</li>
</ul>
<p>输入输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 3 4</span><br><span class="line">4 5</span><br><span class="line">7 -3</span><br><span class="line">10 1</span><br><span class="line">1 10</span><br><span class="line">4 20</span><br><span class="line">5 30</span><br><span class="line">7 40</span><br></pre></td></tr></table></figure>
<p>参考代码：[(103条消息) <a href="https://blog.csdn.net/ftimes/article/details/107527537">满分代码] CCF CSP 202006-2 稀疏向量_江南蜡笔小新的博客-CSDN博客</a></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//60分代码——运行超时：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;<span class="comment">//long long就是long long int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">points</span>&#123;</span><br><span class="line">	ll first,second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(points &amp;p,ll i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i&gt;p.first;<span class="comment">//第一个大于等于i的位值，如果i&gt;p.first为true，则表明当前元素均满足条件；如果为false，则表明不满足判定规则，那么将会返回 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll A=<span class="number">5e5</span>+<span class="number">1</span>,B=<span class="number">5e5</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">points u[A],v[B];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n,a,b;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">//	vector&lt;pair&lt;int,ll&gt;&gt;u(a+1);</span></span><br><span class="line"><span class="comment">//	vector&lt;pair&lt;int,ll&gt;&gt;v(b+1);</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=a;++i)&#123;</span><br><span class="line">		cin&gt;&gt;u[i].first&gt;&gt;u[i].second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=b;++j)&#123;</span><br><span class="line">		cin&gt;&gt;v[j].first&gt;&gt;v[j].second;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>,be,end;</span><br><span class="line">	<span class="comment">//较大的index作为遍历的初始点，这样可以减少遍历的次数</span></span><br><span class="line">	<span class="keyword">if</span>(u[<span class="number">1</span>].first&gt;=v[<span class="number">1</span>].first)&#123;</span><br><span class="line">		be=u[<span class="number">1</span>].first;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		be=v[<span class="number">1</span>].first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//较小的index作为遍历的结束点，这样可以减少遍历的次数</span></span><br><span class="line">	<span class="keyword">if</span>(u[a].first&gt;=v[b].first)&#123;</span><br><span class="line">		end=v[b].first;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		end=u[a].first;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;be:&quot;&lt;&lt;be&lt;&lt;&quot;end:&quot;&lt;&lt;end&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=be;i&lt;=end;++i)&#123;</span><br><span class="line">		ll u_index=<span class="built_in">lower_bound</span>(u,u+a,i,comp)-u;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;u_index:&quot;&lt;&lt;u[u_index].first&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(u[u_index].first!=i)<span class="keyword">continue</span>;<span class="comment">//i不存在u中 </span></span><br><span class="line">		ll v_index=<span class="built_in">lower_bound</span>(v,v+b,i,comp)-v;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;v_index:&quot;&lt;&lt;v[v_index].first&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(v[v_index].first!=i)<span class="keyword">continue</span>;<span class="comment">//i不存在v中 </span></span><br><span class="line">		<span class="keyword">if</span>(u[u_index].first==v[v_index].first)&#123;</span><br><span class="line">			ans+=u[u_index].second*v[v_index].second;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;u[2].first&lt;&lt;u[2].second;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后100分代码：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;<span class="comment">//long long就是long long int </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n,a,b,ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;u;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a;++i)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		u.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line"><span class="comment">//		cout&lt;&lt;u[i].first&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x1,y1,i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b;++j)&#123;<span class="comment">//少定义一个vector，提高效率 </span></span><br><span class="line">		cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;a)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x1&lt;u[i].first)<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(x1&gt;u[i].first)++i;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans+=y1*u[i].second;</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>CCF-CSP认证</category>
        <category>第二题</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯真题练习-2</title>
    <url>/2023/10/18/University/junior/competition/lanqiaoCup/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%83%E4%B9%A0(%E7%9C%81%E5%86%B2)-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>蓝桥杯真题练习</h1>
<h2 id="第七天">第七天</h2>
<blockquote>
<p>动态规划</p>
</blockquote>
<h3 id="真题练习-蓝肽子序列">【真题练习】蓝肽子序列</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325141958053.png" alt="image-20230325141958053"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325145810440.png" alt="image-20230325145810440"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析</mtext><mo>:</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">:</span></span></span></span></p>
<ol>
<li class="lvl-3">一个蓝肽表示方法为：首字母为大写，后面为小写字母；（<mark>一个蓝肽就相当于是一个单词</mark>）</li>
<li class="lvl-3">公共蓝肽子序列的长度为：两个字符串中相同蓝肽的数量；</li>
<li class="lvl-3">本题是经典的最长公共子序列(LCS)的变形题，先将每个蓝肽存储在数组中，再使用动态规划解决；</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">string s1, s2;</span><br><span class="line">string a[N], b[N];</span><br><span class="line"><span class="type">int</span> dp[N][N]; <span class="comment">// 第一个N代表的是第一个字符串s1单词化后的a数组，第二个N代表的是第二个字符串s2单词化后的b数组 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	<span class="comment">// 对蓝肽序列以蓝肽为单位进行处理</span></span><br><span class="line">	<span class="type">int</span> n=<span class="number">0</span>, m=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;s1[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)a[n] += s1[i++];<span class="comment">// 存储首字母 </span></span><br><span class="line">		<span class="keyword">while</span>(s1[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s1[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;<span class="comment">// 存储后面的小写字母 </span></span><br><span class="line">			a[n] += s1[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		n++;<span class="comment">// 存储下一个蓝肽 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s2.<span class="built_in">length</span>();)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s2[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;s2[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)b[m] += s2[i++];<span class="comment">// 存储首字母 </span></span><br><span class="line">		<span class="keyword">while</span>(s2[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s2[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;<span class="comment">// 存储后面的小写字母 </span></span><br><span class="line">			b[m] += s2[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		m++;<span class="comment">// 存储下一个蓝肽 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 动态规划处理</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>])&#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-合唱队形">【真题练习】合唱队形</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325152949236.png" alt="image-20230325152949236"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">本质是最长上升子序列(LIS)问题，但是本题不是单调上升，而是先上升在下降的形式，因此可以先正向运用一次LIS，之后再反向运用一次LIS；</li>
<li class="lvl-3">最后将正向与反向的结果一一对应相加减1(因为自己计算了两次)，再取其中最大的即为队列中的最大人数。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> h[N], dp1[N], dp2[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;h[i];</span><br><span class="line">		dp1[i] = <span class="number">1</span>;</span><br><span class="line">		dp2[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="comment">// 初始化</span></span><br><span class="line">	<span class="comment">//正向遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(h[j]&lt;h[i])&#123;</span><br><span class="line">				dp1[i] = <span class="built_in">max</span>(dp1[i], dp1[j]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;--j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(h[i]&gt;h[j])&#123;</span><br><span class="line">				dp2[i] = <span class="built_in">max</span>(dp2[i], dp2[j]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> max_num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		max_num = <span class="built_in">max</span>(max_num, dp1[i]+dp2[i]<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;n - max_num;<span class="comment">// 需要出列的人数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-字符串编辑距离">【真题练习】字符串编辑距离</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325155123800.png" alt="image-20230325155123800"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>本题与LCS相似当又有很大的不同；</p>
</li>
<li class="lvl-3">
<p>使用编辑距离的方式解决（<span style="color: red;">详见：C++经典问题：编辑距离</span>）；</p>
</li>
<li class="lvl-3">
<p>由于是包含关系，并不是相等关系，所以当S多余T是，不需要进行插入操作。</p>
<p>所以这个题目不考虑插入的那个状态转移即可，<mark>同时本题只计修改字符的次数，不计删除字符的操作次数，因此删除字符的状态转移中不+1</mark>。</p>
</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 99999 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line">string s, t;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s.<span class="built_in">size</span>();++i)dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.<span class="built_in">size</span>();++j)dp[<span class="number">0</span>][j] = INF;<span class="comment">// 这里不能用INT_MAX，因为后面有+1操作，这样会使得INT_MAX+1为负数,那么min求得的就是负数,不是最终答案 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;<span class="comment">// 相同，不做修改 </span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">// 不相同，比较修改和删除方式中最小的修改次数 </span></span><br><span class="line">				dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>, dp[i<span class="number">-1</span>][j]);<span class="comment">// 只计修改字符的次数，不计删除字符的操作次数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第八天">第八天</h2>
<blockquote>
<p>简单数论</p>
</blockquote>
<h3 id="真题练习-阶乘约数">【真题练习】阶乘约数</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325164943787.png" alt="image-20230325164943787"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>正约数是指一个正整数除了自身以外的所有因数。例如，6的正约数是1,2,3。</p>
<p>我们可以利用正约数来求一个数的因数个数和因数之和。例如，对于正整数n，它的因数个数为d(n)，可以通过以下公式计算(约数定理)：</p>
<p>d(n) = (k+1)(l+1)(m+1)…，其中n = 2^k * 3^l * 5^m * …</p>
<p>也就是将n分解质因数后，求出每个质因子的指数并加1，然后将它们相乘即可。</p>
<p>另外，如果我们已知一个正整数n的所有正约数，可以通过以下公式求出它们的和s(n)：</p>
<p>s(n) = (1+a1)(1+a2)(1+a3)…(1+ak)，其中n = p1^a1 * p2^a2 * p3^a3 * …</p>
<p>也就是将n分解质因数后，将每个质因子的指数加1，然后将它们相乘再加1即可。</p>
<p>需要注意的是，这里的正约数不包括1，因为1是所有正整数的因数。</p>
</li>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325165713029.png" alt="image-20230325165713029"></p>
</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">105</span>];<span class="comment">// 默认初始化为全0 </span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)&#123;<span class="comment">// 100的阶乘的因数 </span></span><br><span class="line">		<span class="type">int</span> x = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j*j&lt;=x;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">while</span>(x%j==<span class="number">0</span>)x /= j, cnt[j]++;<span class="comment">// 计算j的幂次 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;<span class="number">1</span>)cnt[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt[i]&gt;<span class="number">0</span>) ans *= (cnt[i]+<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  cout&lt;&lt;<span class="number">39001250856960000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-质因子个数">【真题练习】质因子个数</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325214224869.png" alt="image-20230325214224869"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>首先是要有判断质数的方法；质数只能被1和本身整除，利用这个性质进行试除法判断是否为质数；</p>
</li>
<li class="lvl-3">
<p>直接对数字 n 进行质因数分解即可。 i 从 2 开始枚举判断是否为n的因子：如果 i是因子，则把 n 不断除以 i 直到无法整除为止。最终如果 n!=1 ，说明在最后的 n 为质数，此时答案加 1。</p>
<p>也可以使用大数素数分解——Pollard_rho 算法：这是经典的大数素数分解算法模板，此处不展开赘述，可参考：</p>
<ul class="lvl-3">
<li class="lvl-5">
<p>Miller-Rabin 素性测试：<a href="https://blog.csdn.net/weixin_43914593/article/details/107290663">https://blog.csdn.net/weixin_43914593/article/details/107290663</a></p>
</li>
<li class="lvl-5">
<p>Pollard_rho 大数素数分解：<a href="https://blog.csdn.net/weixin_43914593/article/details/107345370">https://blog.csdn.net/weixin_43914593/article/details/107345370</a></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n, ans = <span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">		<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			num++;</span><br><span class="line">			n /= i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(num&gt;<span class="number">0</span>)ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)ans++;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上代码原理没有看懂???</span></span><br></pre></td></tr></table></figure>
<h3 id="真题练习-等差数列">【真题练习】等差数列</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325223918731.png" alt="image-20230325223918731"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">如何确认等差数列中d的取值，首先将序列所有数升序排序，之后计算相邻两个数之间的差，将得到的所有的差值求最大公约数就是等差数列的d；</li>
<li class="lvl-3">需要注意，如果所有的数相同，它也是等差数列，这种情况下就特殊判断；</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="第九天">第九天</h2>
<blockquote>
<p>思维训练</p>
</blockquote>
<h3 id="真题练习-裁纸刀">【真题练习】裁纸刀</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325233749219.png" alt="image-20230325233749219"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">根据题意易知：<code>4+19+20*21=443</code>；</li>
<li class="lvl-3">这道题的思维很简单，一看就懂。</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> R = <span class="number">20</span>, C = <span class="number">22</span>;<span class="comment">// 定义行和列 </span></span><br><span class="line"><span class="comment">// 边缘必定要裁4刀 </span></span><br><span class="line"><span class="comment">// 20行中行与行之间需要裁1刀，也就是R-1</span></span><br><span class="line"><span class="comment">// 每一行中的22个二维码之间需要裁21刀，也就是C-1</span></span><br><span class="line"><span class="comment">// 所有行就需要R*（C-1） </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;(<span class="number">4</span>+R<span class="number">-1</span>+R*(C<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  cout&lt;&lt;<span class="number">443</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-蛇形填数">【真题练习】蛇形填数</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230325234714697.png" alt="image-20230325234714697"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>左上三角形与右下三角形的填充规则是不同的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{左上三角形与右下三角形的填充规则是不同的}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">左上三角形与右下三角形的填充规则是不同的</span></span></span></span>；但是本题说明了填充的矩阵无限大，也就是说一直填充的都是上三角形，所以只需要用上三角形的填充规则：<u><strong>右，左下，下，右上</strong></u>即可；</li>
<li class="lvl-3">这里可以使用定义方向数组dx与dy的方式或是while循环的方式来解决。</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> M[<span class="number">100</span>][<span class="number">100</span>], row=<span class="number">0</span>, col=<span class="number">0</span>, cnt = <span class="number">1</span>;<span class="comment">// 定义初值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	M[<span class="number">0</span>][<span class="number">0</span>] = cnt++;<span class="comment">// 填第一个数 </span></span><br><span class="line">	<span class="keyword">while</span>(!M[<span class="number">19</span>][<span class="number">19</span>])&#123;<span class="comment">// 还未得到目标值 </span></span><br><span class="line">		<span class="comment">// 向右</span></span><br><span class="line">		M[row][++col] = cnt++;</span><br><span class="line">		<span class="comment">// 向左下</span></span><br><span class="line">		<span class="keyword">while</span>(col)&#123;</span><br><span class="line">			M[++row][--col] = cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 向下</span></span><br><span class="line">		M[++row][col] = cnt++;</span><br><span class="line">		<span class="comment">// 向右上 </span></span><br><span class="line">		<span class="keyword">while</span>(row)&#123;</span><br><span class="line">			M[--row][++col] = cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;M[<span class="number">19</span>][<span class="number">19</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  cout&lt;&lt;<span class="number">761</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-最大降雨量">【真题练习】最大降雨量</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230326000734514.png" alt="image-20230326000734514"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ul class="lvl-1">
<li class="lvl-2">分析，我们先理解题意，我们如果假设每周的中位数是a,b,c,x,e,f,g，这七个数是这七张</li>
<li class="lvl-2">法术符数字上的中位数(即为能量)。降雨量为这七个数的中位数，我们要的是x最大，假设这此时x最大，我们可以看看需要满足什么条件。</li>
<li class="lvl-2">七个数从小到大排列 第四周x后三天要比x大，第五周第六周第七周的后四天都要比x大，所以共要有15个数比x大。</li>
</ul>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">7</span>];</span><br><span class="line"><span class="comment">// 既然是求7周能量的中位数的最大值。那么每周能量的中位数保证最大。</span></span><br><span class="line"><span class="comment">// 从能取得的最大的中位数排起：最大的数和最小的数组合</span></span><br><span class="line"><span class="comment">// 1 2 3 46 47 48 49   =&gt; 中位数46</span></span><br><span class="line"><span class="comment">// 4 5 6 42 43 44 45   =&gt; 中位数42</span></span><br><span class="line"><span class="comment">// 7 8 9 38 39 40 41   =&gt; 中位数38</span></span><br><span class="line"><span class="comment">// 10 11 12 34 35 36 37  =&gt; 中位数34</span></span><br><span class="line"><span class="comment">// 13 14 15 30 31 32 33  =&gt; 中位数30</span></span><br><span class="line"><span class="comment">// 16 17 18 26 27 28 29  =&gt; 中位数26</span></span><br><span class="line"><span class="comment">// 19 20 21 22 23 24 25  =&gt; 中位数22</span></span><br><span class="line"><span class="comment">// 7周能量中位数最大为34</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">49</span> - <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">		a[i] = a[i<span class="number">-1</span>] - <span class="number">4</span>;<span class="comment">// 减去4是因为上一个中位数与当前中位数之间的距离 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;a[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * [][][][a][][][]</span></span><br><span class="line"><span class="comment">  * [][][][b][][][]</span></span><br><span class="line"><span class="comment">  * [][][][c][][][]</span></span><br><span class="line"><span class="comment">  * [][][][max][][][]</span></span><br><span class="line"><span class="comment">  * [][][][d][][][]</span></span><br><span class="line"><span class="comment">  * [][][][e][][][]</span></span><br><span class="line"><span class="comment">  * [][][][f][][][]</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 此题意思为将1至49分为7组数字，求取七组数字中每组数字的中位数所构成的数列的中位数的最大值</span></span><br><span class="line"><span class="comment">  * 即如图所示，最大化[max]</span></span><br><span class="line"><span class="comment">  * 49个数字中需要比[max]大的有[max]行的后三位，d、e、f行的后四位，共3+3*4=15位</span></span><br><span class="line"><span class="comment">  * 结果为：49-15=34</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">  cout &lt;&lt; <span class="number">34</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-排序">【真题练习】排序</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230326003548922.png" alt="image-20230326003548922"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">考虑冒泡排序的复杂度，对于拥有N个字母的字符串，最多需要交换N * (N-1)/2次（完全乱序时）；</li>
<li class="lvl-3">易知N=15时，有15 * 14/2=105，即满足100次交换所需的最短字符串有15个字母；</li>
<li class="lvl-3">要求字典序最小，那么显然要取a~o这15个字典序最小的字母；
<ul class="lvl-3">
<li class="lvl-5">逆向思考，目标字符串经过100次交换后，得到正序字符串abcdefghijklmno，而完全逆序的字符串onmlkjihgfedcba变成正序字符串需要105次交换，那么将完全逆序的字符串交换5次后，便能得到答案。而要求字典序最小，那么将j交换5次提到字符串最前面，就得到了最小的情况。</li>
</ul>
</li>
</ol>
</blockquote>
<p>计算代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n*(n<span class="number">-1</span>)/<span class="number">2</span>&lt;<span class="number">100</span>)n++;</span><br><span class="line">	<span class="type">int</span> m = n*(n<span class="number">-1</span>)/<span class="number">2</span> - <span class="number">100</span>;<span class="comment">// n*(n-1)/2是完全逆序的交换次数，减去100是为了得到需要提前交换的次数，从而使得得到的字符串只需要交换100次 </span></span><br><span class="line">	<span class="type">char</span> array[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">// 得到完全逆序的字符串 </span></span><br><span class="line">		array[i] = <span class="number">97</span> + n - i - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 针对完全逆序的字符串，将其变为符合交换次数刚好为100的字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(array[i]&lt;array[i<span class="number">-1</span>])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(array[i], array[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cout&lt;&lt;array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;jonmlkihgfedcba&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第十天">第十天</h2>
<blockquote>
<p>图论</p>
</blockquote>
<h3 id="真题练习-聪明的猴子">【真题练习】聪明的猴子</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230326235410093.png" alt="image-20230326235410093"></p>
<blockquote></blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="第十一天">第十一天</h2>
<blockquote>
<p>排序算法</p>
</blockquote>
<h3 id="真题练习-双向排序">【真题练习】双向排序</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328192923725.png" alt="image-20230328192923725"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">这里需要注意的是对于p与q的理解：当p=0时表示的是前q个数为降序；当p=1时表示的是从第q位数开始到最后一位数为升序；</li>
<li class="lvl-3">对于60%的数据使用sort函数或是使用权值数组的方式可以解决；</li>
</ol>
</blockquote>
<p>解决算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="第十二天">第十二天</h2>
<blockquote>
<p>组合数学</p>
</blockquote>
<h3 id="真题练习-数列求值">【真题练习】数列求值</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328003645727.png" alt="image-20230328003645727"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">注意如果直接计算的话会发现后面的数值会很大，导致数据溢出，所以根据题意，我们可以简化计算过程，因为只需要求得最后4位数，那么我们就截取所有数对10000的余数，这样就能够既达到目的又不会导致数据溢出。</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">9</span>, c = <span class="number">17</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">20190324</span>;++i)&#123;</span><br><span class="line">		<span class="type">int</span> t = (a+b+c)%<span class="number">10000</span>;</span><br><span class="line">		a = b;<span class="comment">// 往后移动一位 </span></span><br><span class="line">		b = c;</span><br><span class="line">		c = t;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;c;</span><br><span class="line">    <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  	<span class="comment">// cout&lt;&lt;4659;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-杨辉三角">【真题练习】杨辉三角</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328004606139.png" alt="image-20230328004606139"></p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328012445819.png" alt="image-20230328012445819"></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">
<p>因为杨辉三角是一个二项式展开的图形化表示，其中每个数字表示对应二项式系数的值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mo>…</mo><mo>…</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\frac{n\times(n+1)}{2}=1+2+3+……+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">……</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>;</p>
</li>
<li class="lvl-3">
<p>根据N最大可取10亿，因此可以知道该数出现的位置远小于10亿，根据10亿=n*(n+1)/2，可以得到大致的位置范围1~44723(向上取整)；</p>
</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll a[<span class="number">44723</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll N;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	<span class="keyword">if</span>(N==<span class="number">1</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// a[0] = 1,表示的是第1列 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;<span class="number">44723</span>;++i)&#123;<span class="comment">// 控制行 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i/<span class="number">2</span>;j&gt;<span class="number">0</span>;--j)&#123;<span class="comment">// 控制列 </span></span><br><span class="line">			<span class="keyword">if</span>(j==i/<span class="number">2</span>&amp;&amp;i%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">// 只计算左半边即可,不然要超时 </span></span><br><span class="line">				a[j] = a[j<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				a[j] = a[j<span class="number">-1</span>] + a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(a[j]==N)&#123;</span><br><span class="line">				cout&lt;&lt;(i<span class="number">-1</span>)*i/<span class="number">2</span>+j+<span class="number">1</span>;<span class="comment">// 第一次出现的位置 </span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;N*(N+<span class="number">1</span>)/<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="真题练习-组合数问题">【真题练习】组合数问题</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328190553157.png" alt="image-20230328190553157"></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分析：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{分析：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分析：</span></span></span></span></p>
<ol>
<li class="lvl-3">根据定理：C(n,k) = C(n-1,k) + C(n-1,k-1）定义递归函数；</li>
</ol>
</blockquote>
<p>解决代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(n<span class="number">-1</span>,m<span class="number">-1</span>) + <span class="built_in">f</span>(n<span class="number">-1</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(<span class="number">10</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(<span class="number">5</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(<span class="number">5</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>算法</category>
        <category>蓝桥杯</category>
        <category>真题练习</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章练习题</title>
    <url>/2023/05/11/University/junior/course/(IOT)Principles%20and%20Applications%20of%20the%20Internet%20of%20Things/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第一章练习题</h1>
<h3 id="题目：">题目：</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221016212155946.png" alt="image-20221016212155946"></p>
<blockquote>
<p>全书参考：<a href="https://zhuanlan.zhihu.com/p/382165574">物联网工程导论吴功宜 期末复习 目录 - 知乎 (zhihu.com)</a></p>
<p>第一章参考：<a href="https://zhuanlan.zhihu.com/p/381851115">物联网工程导论吴功宜 第1章 物联网概论 期末重点 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="一-单选题">一、单选题</h2>
<p>1.ITU的研究报告《The Internet of Things》发表于©<br>
A.1995年<br>
B.2000年<br>
C.2005年<br>
D.2010年</p>
<p>2.以下关于智慧地球特点的描述中，错误的是(D)<br>
A.将大量传感器嵌入和装备到基础设施与制造业中<br>
B.捕捉运行过程中的各种信息<br>
C,通过计算机分析、处理和发出指令<br>
D.以物联网取代互联网</p>
<blockquote>
<p>“互联网+物联网=智慧地球”</p>
</blockquote>
<p>3.以下关于普适计算特点的描述中，错误的是(B)。<br>
A.核心是“以人为本”<br>
B.重点放在网络安全上<br>
C.强调“无处不在”与“不可见”<br>
D,体现出信息空间与物理空间的融合</p>
<p>4.以下关于CPS特点的描述中，错误的是(D)。<br>
A.“感”是指多感知器协同感知物理世界的状态信息<br>
B.“联”是指连接物理世界与信息世界的各种对象，实现信息交互<br>
C.“知”是指通过对感知信息的智能处理，正确、全面地认知物理世界<br>
D.“控”是指根据正确认知，确定策略，发出指令，指挥传感器控制物理世界</p>
<blockquote>
<p>“控”是指根据正确认知，确定策略，发出指令，指挥执行器处理物理世界的问题</p>
</blockquote>
<p>5.以下不属于物联网三层结构模型的是©。<br>
A.感知层<br>
B.网络层<br>
C.控制层<br>
D.应用层</p>
<p>6.以下关于物联网智能物体的描述中，错误的是(D)。<br>
A.可以是微小的物体，也可以是大的建筑物<br>
B.可以是有生命的，也可以是无生命的<br>
C.必须具有通信与计算能力<br>
D.必须具有控制能力</p>
<p>7.以下关于物联网与互联网区别的描述中，错误的是(B)。<br>
A.互联网提供信息共享与信息交互服务<br>
B.互联网数据主要是通过自动方式获取的<br>
C.物联网提供行业性、专业性、区域性服务<br>
D.物联网是可反馈、可控制的闭环系统</p>
<blockquote>
<p>互联网数据主要是通过人工方式获取的；</p>
<p>物联网数据主要是通过自动方式获取的。</p>
</blockquote>
<p>8.以下关于物联网与“互联网+”的关系的描述中，错误的是(A)。<br>
A.“互联网+”可以理解为“互联网及其应用”<br>
B.“互联网+”是国家战略层面对产业与经济发展思路的一种高度凝练的表述<br>
C.“互联网+”涵盖着互联网、移动互联网与物联网“跨界融合”的丰富内容                         																	   D.“互联网+”覆盖制造业、现代服务业、政府管理、社会公共服务四个主要的领域</p>
<h2 id="二-思考题">二、思考题</h2>
<p>1.请举出一个具有普适计算技术特征的应用示例。</p>
<p>答：3D试衣镜系统。有些商场中放置有3D试衣镜，期望用户能够在3D试衣镜前用手势或语音指令来指示更换不同款式与颜色的衣服，后台的计算机系统将自动根据试衣间摄像头传过来的顾客体态数据，分析该顾客的对服饰的喜好，从而在数据库中挑选出合适的服饰供顾客选择。在挑选衣服的过程中，顾客不需要操作计算机，也不知道计算机在哪里，以及计算机是如何工作的，顾客要做的事就是比较不同服饰的穿着效果，享受购物的乐趣。</p>
<p>2.请举出一个具有CPS技术特征的应用示例。</p>
<p>答：自动泊车系统。自动泊车系统是一种安全、快速地将车辆自动驶入车位的智能泊车辅助系统，它通过超声传感器和图像传感器感知车辆周边的环境信息，识别泊车的车位。汽车的自动泊车过程是由车位识别、轨迹生成与轨迹控制三个阶段组成，如下图所示：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221016235959912.png" alt="image-20221016235959912" style="zoom:50%;" />
<p>3.请结合物联网的应用，解释为什么物联网提供的是行业性、专业性、区域性的服务</p>
<p>答：我国高度重视物联网的研究和发展，政府制定了一系列的发展战略规范，根据规范要求要在智能工业、智能农业、智能交通、智能物流以及智能电网等重点领域开展应用示范，比如：智能物流就是关注如何通过物联网技术解决物流的效率和安全性等问题；智能交通关注的是如何解决一个城市或一个区域的交通拥塞与提高交通安全、效率问题。因此，物联网提供的是行业性、专业性、区域性的服务。</p>
<p>4.请结合物联网的应用，说出你对物联网三层结构模型的理解。</p>
<p>答：</p>
<p>（1）感知层：类比人体的感官，主要负责信息的采集以及物与物之间的信息传输。其中信息采集技术包括了RFID与自动识别技术、条码技术、传感器等；信息传输包括了远近距离数据传输技术、信息采集中间件技术、协同信息处理技术等。感知层是实现物联网全面感知的核心能力，包括了RFID与读写设备、传感器与传感网络节点、GPS终端设备以及智能终端设备等。属于整个物联网产业的上游部分：产品制造。</p>
<p>（2）网络层：类比人体的神经网络，主要是利用无线和有线网络对采集的数据进行编码、认证以及传输。广泛涵盖了移动通信网络中实现物联网的基础设施，包括了广域网与城域网、无线局域网、移动通信网、无线个域网以及无线人体区域网。属于整个物联网产业链的中游部分：系统集成和软件开发。</p>
<p>（3）应用层：类比人体的大脑，主要提供用户与物联网之间的接口，将物联网技术与行业信息化需求相结合，能够针对不同用户、不同行业的应用，实现更加准确和精细的智能化信息管理。属于物联网产业链的下游部分：云计算等应用服务部分。</p>
<p>5.请结合物联网的应用，举出一种常用反馈控制的物联网应用系统的实例。</p>
<p>答：首先反馈控制又叫闭环控制，是按偏差进行控制，当被控量偏离期望值而出现偏差时，将会产生一个控制作用去降低或者消除这个偏差，使控制量与期望值趋于一致。典型的有无人车软件系统：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-83645a608f5e201da04adc02245785da_r.jpg" alt="img"></p>
<blockquote>
<p>控制技术参考：<a href="https://blog.csdn.net/weixin_46112690/article/details/121577181">(77条消息) 【物联网控制技术】－－第一章－－【自动控制】【反馈控制】【调节过程】【系统要求】【典型的外部输入信号】_子衿JDD的博客-CSDN博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>物联网原理与应用</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>物联网原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章练习题</title>
    <url>/2023/05/11/University/junior/course/(IOT)Principles%20and%20Applications%20of%20the%20Internet%20of%20Things/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第三章练习题</h1>
<h2 id="一-单选题">一、单选题</h2>
<p>1.以下关于计算机网络“分组交换”特点的描述中，错误的是(B)。<br>
A.分组交换适合突发性强的计算机数据通信的需求<br>
B.分组交换在发送数据之前需要事先建立线路连接❌<br>
C.分组头部带有源地址与目的地址<br>
D.分组数据最大长度确定</p>
<blockquote>
<p>分组交换在发送数据之前不需要事先建立线路连接，因为分组交换采用的是存储转发的方式传输数据。</p>
</blockquote>
<p>2.以下关于P地址的描述中，错误的是©<br>
A.IP协议与网络规模的矛盾突出表现在IP地址上<br>
B.IP协议有两个版本：IPv4与IPv6<br>
C.IPv4地址已经分配出大约50%❌<br>
D.IPv6地址能够满足物联网大量节点接入的需求</p>
<blockquote>
<p>IPv4地址已经被分配完毕</p>
</blockquote>
<p>3.以下关于IPv6地址的描述中，错误的是(B)。<br>
A.大规模物联网的应用需要大量的IP地址<br>
B.IPv6的地址长度定为64位❌<br>
C.可以提供超过2<sup>128</sup>(3.4×10<sup>38</sup>)个地址<br>
D.地球表面每一平方米平均可以获得的IP地址数量为6.65×10<sup>23</sup></p>
<blockquote>
<p>IPv6的地址长度为128位，地址数量是IPv4的2<sup>96</sup>倍</p>
</blockquote>
<p>4.智能医疗应用为计算机网络增加的一种网络类型是(D)。<br>
A.局域网<br>
B.城域网<br>
C.个人区域网<br>
D.人体区域网 ✔️</p>
<blockquote>
<p>物联网智能医疗应用对计算机网络提出了新的需求，促进（人体区域网(Body Area Network,BAN)的发展。物联网智能医疗的需求主要表现在以下两点：第一，智能医疗应用系统需要将人体携带的传感器或移植到人体内的生物传感器节点组成人体区域网，将采集到的人体生理信号（如温度、血糖、血压、心跳等参数），以及人体活动或动作信号、人所在的环境信息，通过无线方式传送到附近的基站。因此，用于智能医疗的个人区域网是一种<mark>无线人体区域网(WBAN)</mark>。第二，智能医疗应用系统不需要有很多节点，<u>节点之间的距离一般在1米左右</u>，<u>节点之间的最大传输速率为10Mbs</u>。无线个人区域网又称为无线个人传感器网络(WBSN)。</p>
</blockquote>
<p>5.以下关于WBAN特点的描述中，错误的是©。<br>
A.用于健康医疗监控<br>
B.节点之间的距离一般在1米左右<br>
C.节点之间的传输速率最大为1Mbps❌																																								D.2012年，IEEE批准的标准是EEE802.15.6</p>
<blockquote>
<p>无线人体区域网（WBAN）：节点之间的最大传输速率为10Mbs</p>
</blockquote>
<p>6.以下关于蜂窝移动通信网小区制特点的描述中，错误的是©<br>
A.将一个大区制覆盖的区域划分成多个小区<br>
B.多个小区组成一个区群<br>
C.在每个小区只设立一个基站❌<br>
D.小区内的手机与基站建立无线链路</p>
<blockquote>
<p>在每个小区设立一个（或几个）基站</p>
<p>详见：PDF标签102</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021210226810.png" alt="image-20221021210226810" style="zoom:33%;" />
</blockquote>
<p>7.以下关于蜂窝移动通信网络特点的描述中，错误的是(D)。<br>
A.无线信道是手机与基站之间的无线“空中接口”<br>
B.基站通过空中接口的下行信道向手机发送语音、数据与信令<br>
C.手机通过空中接口的上行信道向基站发送语音、数据与信令信号<br>
D.根据手机硬件与软件、APP的发展水平可以划分出手机的1G到5G❌</p>
<blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021210106825.png" alt="image-20221021210106825" style="zoom:50%;" />
<p>1G~5G的发展是根据移动通信技术的发展来看的</p>
</blockquote>
<p>8.以下关于移动通信网中M2M通信特点的描述中，错误的是(D)。<br>
A.物联网控制中心计算机远程控制智能路灯属于M2M通信<br>
B.M2M中的“机器”可以是传统的机器，也可以是物联网智能硬件<br>
C.WMMP协议是支持移动通信网中“机器与机器”交互的通信协议<br>
D.未来用于人与人通信的手机数量可能仅占整个移动通信网终端数的很小一部分❌</p>
<blockquote>
<p>手机将占主要部分</p>
<p>详见：PDF标签105</p>
</blockquote>
<p>9.以下关于5G指标的描述中，错误的是(D)。<br>
A.连接数密度为每平方公里可以支持100万个在线设备<br>
B.允许用户最大的移动速度为每小时500公里<br>
C.单用户理论的峰值速率常规情况为10Gbps<br>
D.端-端延时可以达到100ms❌</p>
<blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021210615261.png" alt="image-20221021210615261" style="zoom: 50%;" />
<p>详见：PDF标签108</p>
</blockquote>
<p>10.以下关于NB-IoT特点的描述中，错误的是©。<br>
A.广覆盖、大规模、低功耗、低成本<br>
B.单个小区支持10万个移动终端接入<br>
C.终端模块待机时间可长达1年❌<br>
D.只占用大约180kHz的带宽</p>
<blockquote>
<p>窄带物联网（NB-IoT）</p>
<p>终端模块待机时间可长达10年，而造价仅5美元左右</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021210721133.png" alt="image-20221021210721133" style="zoom:50%;" />
</blockquote>
<h2 id="二-思考题">二、思考题</h2>
<p>1.什么要研究分组交换网技术？</p>
<p>电话交换网是相当脆弱的，电话交换系统中的任一交换机或连接交换机的一条中继线路损坏，尤其是关键长途电话局交换机如果遭到破坏，就可能导致整个系统通信中断。并且电话交换网可靠性差。而分组交换网技术采用网状拓扑结构，任意两个节点之间都有多条传输路径，即使网络中的某个节点或者线路损坏，依然可以通过其它路径进行数据传输；同时分组交换网技术采用分组交换的数据传输方式，通过存储转发克服了电话交换网可靠性差的特点，分组方式避免传输报文过长导致出错概率的增加，路由选择算法的自适应能力能够可选择的绕过故障的结点。</p>
<p>2.为什么说IPv6协议将成为物联网核心协议之一？</p>
<p>IPv6具有巨大的空间地址、新的协议格式、有效的分级寻找和路由结构、地址自动适应、内置的安全机制；IPv6地址能够满足未来大规模物联网终端设备接入的需求，比如：大量的传感器、RFID读写设备、智能移动终端设备、智能机器人都可以获得IPv6地址。除此之外，IPv6协议能够适应物联网智能工业、智能农业、智能交通、智能医疗、智能物流、智能家居等领域的应用。</p>
<p>3.为什么说进入5G时代，受益最大的是物联网？</p>
<p>因为物联网中存在一些对带宽、延时与可靠性有高要求的物联网应用在4G网络中无法实现。</p>
<p>物联网规模的超常规发展，大量物联网应用系统将部署在山区、森林、水域等偏僻地区。很多物联网感知与控制节点密集部署在大楼内部、地下室、地铁与隧道中，4G网络与技术已难以适应，只能寄希望于5G网络与技术。</p>
<p>物联网涵盖智能工业、智能农业、智能交通、智能医疗与智能电网等各个行业，业务类型多、业务需求差异性大。尤其是在智能工业的工业机器人与工业控制系统中，节点之间的感知数据与控制指令传输必须保证是正确的，延时必须在毫秒量级，否则就会造成工业生产事故。无人驾驶汽车与智能交通控制中心之间的感知数据与控制指令传输尤其要求准确性，延时必须控制在毫秒量级，否则就会造成车毁人亡的重大交通事故。5G技术的成熟和应用将使很多物联网应用的带宽、可靠性与延时的瓶颈得到解决。</p>
<p>5G技术的发展与应用将大大推动物联网“万物互联”的进程，因此说进入5G时代，受益最大的是物联网。</p>
<p>4.请举出两个典型的物联网应用移动通信网M2M（机器对机器）的例子。</p>
<p>自动贩卖机：通过对货物终端的监控，将实时销售数据对货物进行调配</p>
<p>车载定位：车载终端由控制器模块、GPS、无线模块、视频图像处理设备及信息采集设备等组成。车载GPS导航终端通过GPS模块接收导航信息，并可以通过无线模块实时更新地图。车载终端通过车辆信息采集设备收集车辆状况信息通过无线模块上传给管理系统，从而车辆防盗系统可以实现与用户终端进行交互。</p>
<p>5.请举出两个典型的物联网应用移动通信网NB-IoT的例子。</p>
<p>烟感器：<br>
NB-IoT支持海量连接，传感器实时检测烟雾，一旦烟雾浓度超标就会通过NB-IoT直接发送信息到后台，同时NB-IoT低功耗，待机时间长，可降低安装和维护成本；另外信号穿透力强，可覆盖楼宇偏僻角落。</p>
<p>共享单车智能锁：</p>
<p>NB-IoT保证了单车在-40℃到85℃的严酷环境下，智能锁仍然能正常工作；同时解决了功耗高、电池使用寿命短的问题，电池使用寿命可以达到2-3年，可、支撑整辆单车的使用生命周期；NB-IoT模组成本低，拉低整车成本；IoT平台的引入将可以更有效的管理共享单车，并有望引入新的商业模式。</p>
<blockquote>
<p>更多参考：<a href="https://blog.csdn.net/weixin_38498942/article/details/104652658">(77条消息) NB-IOT经典案例_weixin_38498942的博客-CSDN博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>物联网原理与应用</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>物联网原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章练习题</title>
    <url>/2023/05/11/University/junior/course/(IOT)Principles%20and%20Applications%20of%20the%20Internet%20of%20Things/%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第六章练习题</h1>
<blockquote>
<p>参考：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/20200721231044922.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200721231103252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODQ0NDQ5,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221023175449310.png" alt="image-20221023175449310"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221111192757562.png" alt="image-20221111192757562"></p>
<p>参考：</p>
<p>（1）数据采集：固定读写器、手持读写器、RFID标签（文字补充RFID标签放哪，数据库中有哪些信息，每隔多久或什么时候读取或更新信息）</p>
<p>（2）服务：数据管理、访问控制、安全审计组件</p>
<p>（3）业务应用：有哪些管理即系统有哪些应用功能（文字细节补充每个管理具体干什么事情）</p>
<p>（4）展示模块：展示给人看的有哪些模块，如人员管理、信息查询等</p>
</blockquote>
<h2 id="思考题">思考题</h2>
<p>1.请试着设计一套蔬菜大棚滴灌智能控制系统的架构和控制流程图。</p>
<p>蔬菜大棚滴灌智能控制系统的架构：</p>
<p>（1）数据采集：光照强度传感器、湿度传感器、二氧化碳传感器、温度传感器，将以上传感器放到蔬菜大棚中进行光照、湿度、二氧化碳含量以及温度的信息采集，并将以上信息存入到环境因子数据库中。</p>
<p>（2）服务：数据管理、访问控制、安全审计组件</p>
<p>（3）业务应用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>环境因子监测管理：通过传感器收集相关环境因子信息；</p>
</li>
<li class="lvl-2">
<p>蔬菜种类信息管理：记录蔬菜大棚中种的蔬菜的种类以及每一阶段的蔬菜生长情况；</p>
</li>
<li class="lvl-2">
<p>滴灌控制管理：结合环境因子信息以及蔬菜的种类以及对应的生长情况信息计算滴灌量以及滴灌面积从而进行合理滴灌。</p>
</li>
</ul>
<p>（4）展示模块：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>蔬菜信息管理模块：蔬菜品种信息查询、蔬菜生长信息查询</p>
</li>
<li class="lvl-2">
<p>环境因子管理模块：环境因子录入、环境因子分析、历史环境因子查询</p>
</li>
<li class="lvl-2">
<p>滴灌信息管理模块：滴灌量以及速度控制、滴灌历史信息查询</p>
</li>
</ul>
<p>系统架构图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221111203615843.png" alt="image-20221111203615843" style="zoom:50%;" />
<p>控制流程图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221111202405111.png" alt="image-20221111202405111" style="zoom:50%;" />
<p>2.请试着设计一套教室照明节能智能控制系统的架构和控制流程图。</p>
<p>3.请试着设计一套用RFID定位机场候机乘客的系统，并说明你所采用的定位与位置服务的方法与原理。</p>
<p>4.请试着设计一套智能电表从接收用户购电通知、用电计量、电费计算、手机缴费、缴费提示的控制流程图。</p>
<p>5.试着设计一套利用公交车实时、移动采集城市温度、湿度、氧气与二氧化碳浓度、噪声、PM2.5与污染物等参数的智能环境监测系统解决方案。</p>
<p>6.试着设计一套使用智能手机监控家庭安全监控视频探头的系统架构，并说明如何实现自动识别与报警的功能。</p>
<p>7.试着设计一套智能冰箱，说明智能冰箱的功能、采用哪些传感器、各种传感器的作用，以及采用什么样的通信和控制方式。</p>
<p>8.请分析无人超市使用了哪些物联网智能技术，阐述你对无人超市的发展有哪些新的设想。</p>
<p>9.综合练习：根据你对物联网概念与关键技术的学习，参考本章对物联网典型应用案例的分析，结合自己的认识与体验，选取一个你感兴趣的领域，按以下要求完成物联网应用课题的概念性设计。<br>
(1)课题名称<br>
(2)系统功能<br>
(3)研究的意义与应用前景<br>
(4)系统设计的特点与创新点<br>
(5)如果你今后想研发这个项目，那么需要继续学习和掌握哪些知识与技能</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>物联网原理与应用</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>物联网原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章练习题</title>
    <url>/2023/05/11/University/junior/course/(IOT)Principles%20and%20Applications%20of%20the%20Internet%20of%20Things/%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第五章练习题</h1>
<h2 id="一-单选题">一、单选题</h2>
<p>1.以下不属于网络空间安全研究的是(D)<br>
A.领土<br>
B.领海<br>
C.领空<br>
D.水下</p>
<blockquote>
<p>详见PDF标签133</p>
</blockquote>
<p>2.以下关于OSI安全体系结构的描述中，错误的是(B)<br>
A.安全攻击<br>
B.入侵检测❌<br>
C.安全服务<br>
D.安全机制</p>
<blockquote>
<p>网络安全体系结构的三个概念：</p>
<ul class="lvl-1">
<li class="lvl-2">安全攻击
<ul class="lvl-3">
<li class="lvl-4">被动攻击</li>
<li class="lvl-4">主动攻击
<ul class="lvl-5">
<li class="lvl-6">截获数据</li>
<li class="lvl-6">篡改或重放数据</li>
<li class="lvl-6">伪造数据</li>
</ul>
</li>
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104190720765.png" alt="image-20221104190720765" style="zoom:50%;" />
</li>
</ul>
</li>
<li class="lvl-2">安全服务</li>
<li class="lvl-2">安全机制</li>
</ul>
</blockquote>
<p>3.以下不属于主动攻击的是(A)<br>
A.窃听或监视数据❌<br>
B.篡改或重放数据<br>
C.伪造数据<br>
D.截获数据</p>
<blockquote>
<p>见上一题的分析</p>
</blockquote>
<p>4.以下不属于X.800规定的五类安全服务的是(D)<br>
A.认证与防抵赖<br>
B.访问控制与数据完整性<br>
C.数据机密性<br>
D.安全攻击❌</p>
<blockquote>
<p>X.800规定的五类安全服务：</p>
<ol>
<li class="lvl-3">认证(Authentication):提供对通信实体和<u>数据来源的认证</u>与<u>身份鉴别</u>。</li>
<li class="lvl-3">访间控制(Access Control):通过对用户身份认证和用户权限的确认，防止未授权用户非法使用系统资源。</li>
<li class="lvl-3">数据机密性(Data Confidentiality:防止数据在传输过程中被泄露或被窃听。</li>
<li class="lvl-3">数据完整性(Data Integrity):确保接收的数据与发送数据的一致性，防止数据被修改、插入、删除或重放。</li>
<li class="lvl-3">入防抵赖(Non-Reputation)：确保数据由特定的用户发出，证明由特定的一方接收，防止发送方在发送数据后否认，或接收方在收到数据后否认现象的发生。</li>
</ol>
<p>网络安全机制的八项基本内容：</p>
<ol>
<li class="lvl-3">
<p>加密(Encryption)</p>
</li>
<li class="lvl-3">
<p>数字签名(Digital Signature)</p>
</li>
<li class="lvl-3">
<p>访问控制(Access Control)</p>
</li>
<li class="lvl-3">
<p>数据完整性(Data Integrity)</p>
</li>
<li class="lvl-3">
<p>认证（Authentication)</p>
</li>
<li class="lvl-3">
<p>流量填充(Traffic Padding)</p>
</li>
<li class="lvl-3">
<p>路由控制(Routing Control)</p>
</li>
<li class="lvl-3">
<p>公证(Notarization)</p>
</li>
</ol>
</blockquote>
<p>5.以下不属于网络安全模型规定的四项基本任务的是©<br>
A.设计用于对数据加密与解密的算法<br>
B.对传输的数据进行加密<br>
C.规定用户身份认证方法❌<br>
D.对接收的加密数据进行解密</p>
<blockquote>
<p>网络安全模型规定的四项基本任务：</p>
<p>1)设计用于对数据加密与解密的算法。<br>
2)对传输的数据进行加密。<br>
3)对接收的加密数据进行解密。<br>
4)制定加密、解密的密钥分发与管理协议。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104192050222.png" alt="image-20221104192050222" style="zoom:50%;" />
</blockquote>
<p>6.以下不属于用户对网络安全需求的是(B)<br>
A.可用性与机密性<br>
B.认证性❌<br>
C.完整性与可控性<br>
D.不可否认性</p>
<blockquote>
<p>用户对网络安全需求：</p>
<p>(1)可用性可用性是指在可能发生突发事件（如停电、自然灾害、事故或攻击等）情况下，计算机网络仍然处于正常运转状态，用户可以使用各种网络服务。<br>
(2)机密性机密性是指保证网络中的数据不被非法截获或非授权用户访问，保护敏感数据和涉及个人隐私信息的安全。<br>
(3)完整性完整性是指保证数据在网络中传输、存储的完整，没有被修改、插入或删除。<br>
(4)不可否认性不可否认性是指确认通信双方的身份真实性，防止出现否认已发送或已接收的数据的现象。<br>
(5)可控性可控性是指能够控制与限定网络用户对主机系统、网络服务与网络信息资源的访问和使用，防止非授权用户读取、写入、删除数据。</p>
</blockquote>
<p>7.以下不属于DDoS攻击组成层次的是©<br>
A.攻击控制层<br>
B.攻击服务器层<br>
C.攻击路由控制层❌<br>
D.攻击执行器层</p>
<blockquote>
<p>典型的网络攻击：</p>
<ol>
<li class="lvl-3">分布式拒绝服务攻击（DDos）
<ul class="lvl-3">
<li class="lvl-5">体系结构：
<ul class="lvl-5">
<li class="lvl-7">攻击控制层</li>
<li class="lvl-7">攻击服务器层</li>
<li class="lvl-7">攻击执行器层</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">拒绝服务攻击（Dos）</li>
<li class="lvl-3">僵尸网络攻击（botnet）</li>
</ol>
</blockquote>
<p>8.以下关于对RFID系统的攻击方法的描述中，错误的是(D)<br>
A.窃听与跟踪攻击<br>
B.中间人攻击与灭活标签攻击<br>
C.欺骗、重放与克隆攻击<br>
D.病毒与分布式拒绝服务攻击❌</p>
<blockquote>
<p>对RFID系统的攻击方法：</p>
<ol>
<li class="lvl-3">窃听与跟踪攻击</li>
<li class="lvl-3">中间人攻击</li>
<li class="lvl-3">欺骗、重放与克隆攻击</li>
<li class="lvl-3">破解与篡改攻击</li>
<li class="lvl-3">干扰与拒绝服务攻击</li>
<li class="lvl-3">灭活标签攻击</li>
<li class="lvl-3">病毒攻击</li>
</ol>
</blockquote>
<p>9.以下不属于物联网网络安全的新动向的是(D)<br>
A.计算机病毒成为攻击物联网的工具<br>
B.物联网工业控制系统成为新的攻击重点<br>
C.网络信息搜索功能将演变成攻击物联网的工具<br>
D.防火墙难以控制内部用户对系统资源的非授权访问❌</p>
<blockquote>
<p>物联网网络安全的新动向：</p>
<ol>
<li class="lvl-3">计算机病毒成为攻击物联网的工具</li>
<li class="lvl-3">物联网工业控制系统成为新的攻击重点</li>
<li class="lvl-3">网络信息搜索功能将演变成攻击物联网的工具</li>
</ol>
</blockquote>
<p>10.对物联网具有威胁的BrickerBot病毒攻击属于©<br>
A.拒绝服务(DoS)攻击<br>
B.分布式拒绝服务(DDoS)攻击<br>
C.永久拒绝服务(PDoS)攻击✔️<br>
D.僵尸网络(botnet)攻击</p>
<blockquote>
<p>详见PDF标签149</p>
</blockquote>
<h2 id="二-思考题">二、思考题</h2>
<p>1.试通过物联网与互联网的比较，选择一个例子来说明你认为物联网网络安全的最主要的特殊性表现在什么地方。</p>
<p>答：物联网：即“万物相连的互联网”，是互联网基础上的延伸和扩展的网络，将各种信息传感设备与网络结合起来而形成的一个巨大网络，实现任何时间、任何地点，人、机、物的互联互通。</p>
<p>互联网：又称国际网络，指的是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连，形成逻辑上的单一巨大国际网络。</p>
<p>物联网是在互联网的基础上发展来的，所以互联网是物联网的基础；物联网是互联网的延伸，因此物联网的安全也是互联网安全的延伸，物联网和互联网的关系是密不可、相辅相成的。但是物联网和互联网在网络的组织形态、网络功能及性能上的要求都是不同的，物联网对实时性、安全可信性、资源保证等方面有很高的要求。</p>
<p>物联网与互联网的安全方面的关系：</p>
<p>(1)物联网安全不是全新的概念;</p>
<p>(2)物联网安全比互联网安全多了感知层;</p>
<p>(3)传统互联网的安全机制可以应用到物联网;</p>
<p>(4)物联网安全比互联网安全更复杂</p>
<p>物联网网络安全的最主要的特殊性表现在：网络攻击者可以利用互联网病毒开展对物联网的DDoS攻击。针对互联网的病毒也能应用到物联网上</p>
<p>2.为什么说对工业控制系统的网络攻击会给物联网带来极大威胁？</p>
<p>答：工业控制系统是一种专用系统。</p>
<ol>
<li class="lvl-3">
<p>随着物联网在工业中的广泛应用，很多大型企业在生产过程中采用了智能控制技术。这些大型企业除了生产民用产品之外，也必然涉及军用产品的生产。对工业控制系统的网络攻击可能会导致国家机密信息的泄露。</p>
</li>
<li class="lvl-3">
<p>随着物联网应用的发展，智能控制技术将逐步应用到智慧城市的智能楼宇自动控制、电梯系统联动与控、城市供电与供水控制，以及其他与国计民生相关的领域。对工业控制系统的网络攻击会导致社会混乱。</p>
</li>
<li class="lvl-3">
<p>未来大量设备都将连接到物联网，所有队物联网的攻击都可能会威胁个人人身安全以及社会安全稳定。</p>
</li>
</ol>
<p>3.请列出两个威胁RFID应用系统安全的实际例子。</p>
<p>答：</p>
<p>1.RFID欺骗：攻击者可以盗取RFID标签的身份信息和存储的数据之后，冒充该标签的合法身份去欺骗读写器。</p>
<p>2.RFID灭活：攻击者可以通过灭活标签的工具将标签提前杀死，从而方便盗取贵重商品。</p>
<p>3.RFID跟踪：通过读取标签上的内容，可以获取目标的运动轨迹。当标签进入读取器的读取范围时可记录当前目标位置。</p>
<p>4.试分析僵尸物联网病毒DDoS与PDoS攻击的形式和后果有哪些不同。</p>
<p>答：</p>
<p>形式：</p>
<p>DDoS就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务，主要针对软件。</p>
<p>PDoS是指通过一系列指令清除路由器与物联网终端设备中的所有文件破坏存储器，并切断设备网络链接，主要针对硬件。</p>
<p>后果：</p>
<p>DDoS攻击下的目标的网络服务难以支持，严重时可能会造成系统的崩溃。</p>
<p>PDoS是一种严重破坏系统的攻击，需要更换或重新安装硬件。</p>
<p>5.结合自己的切身体会，找出一个在物联网应用中涉及个人隐私的问题，并提出相应的解决方法。</p>
<p>答：就拿基于RFID的位置服务涉及到的个人隐私来说，在众多传感器、摄像头等物联网设备的加持下，可以很容易分析出每个人的位置信息以及行动轨迹，根据对行动轨迹的分析就能够了解到这个人平时的一些习惯爱好以及喜欢的商品，并能够将这个人的信息提供给商家等，商家就可以通过短信或是社交平台给该特定人群推销商品等，这样虽然能够大大提高商业服务的针对性和效率，但是却会侵犯个人的隐私。</p>
<p>针对这样的情况，个人建议是做好物联网设备信息采集的规范性以及合法性，确保采集的信息被用在合法用途；不能过分的干涉目标群体的私人生活或是对目标群体进行强引导或是强干预，针对相关违法侵犯隐私的行为处以重罚；进一步提升物联网安全技术，降低被攻击而造成的信息泄露的风险。</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>物联网原理与应用</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>物联网原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章练习题</title>
    <url>/2023/05/11/University/junior/course/(IOT)Principles%20and%20Applications%20of%20the%20Internet%20of%20Things/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第二章练习题</h1>
<h3 id="一-单选题">一、单选题</h3>
<p>1.以下关于<mark>二维条码</mark>特点的描述中，错误的是(D)<br>
A.高密度编码，信息容量大、容错能力强、纠错能力强<br>
B.可以表示声音、签字、指纹、掌纹信息<br>
C.可以表示多种语言文字<br>
D.可以表示视频信息❌</p>
<blockquote>
<p>一维条码和二维条码：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221023172430819.png" alt="image-20221023172430819" style="zoom: 67%;" />
<p>一维条码只是在一个方向（一般是水平方向）表达信息，而在垂直方向不表达任何信息。</p>
<p>二维条码的特点：</p>
<ol>
<li class="lvl-3">
<p>高密度编码、信息容量大；</p>
</li>
<li class="lvl-3">
<p>编码的范围广；</p>
</li>
<li class="lvl-3">
<p>容错能力强；</p>
</li>
<li class="lvl-3">
<p>纠错能力强；</p>
</li>
<li class="lvl-3">
<p>保密性好；</p>
</li>
<li class="lvl-3">
<p>成本低。</p>
</li>
</ol>
</blockquote>
<p>2.以下关于RFID标签特点的描述中，错误的是(A)																																						A.所有RFD标鉴都可以读取与写入数据❌<br>
B.RFID标签是由RFID芯片、天线与电路组成<br>
C,RFD读写器读取标签的距离可以从几厘米到上百米<br>
D.RFID读写器可以在黑暗的环境中读取RFID标签数据</p>
<blockquote>
<p><mark>定义</mark>：RFID又称为“射频标签”或“电子标签（tag)”,是利用<code>无线射频信号空间耦合</code>的方式来实现<code>无接触的</code>标签信息<code>自动传输与识别</code>的技术。</p>
<p>RFID标签结构：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221023173353221.png" alt="image-20221023173353221"></p>
<p>RFID标签有存储数据的RFID芯片、天线与电路组成。</p>
<p>RFID标签工作原理：</p>
<ol>
<li class="lvl-3">
<p>被动式RFID标签工作原理：</p>
<ol>
<li class="lvl-6">也称无源RFID标签，读写器向标签传递能量、标签向读写器发送标签信息的过程</li>
<li class="lvl-6">双向通信的距离称为：可读范围或作用范围</li>
<li class="lvl-6">优点：
<ul class="lvl-5">
<li class="lvl-8">体积小</li>
<li class="lvl-8">重量轻</li>
<li class="lvl-8">价格低</li>
<li class="lvl-8">使用寿命长的优点</li>
</ul>
</li>
<li class="lvl-6">缺点：
<ul class="lvl-5">
<li class="lvl-8">读写距离较短</li>
<li class="lvl-8">存储数据较少</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<p>主动式RFID标签的工作原理：</p>
<ol>
<li class="lvl-6">也称有源RFID标签，内部配置电池供电</li>
<li class="lvl-6">读写器向RFID标签发送读写指令，RFID标签向读写器发送标识信息的过程</li>
<li class="lvl-6">优点：
<ul class="lvl-5">
<li class="lvl-8">读写距离较远</li>
<li class="lvl-8">存储数据较多</li>
<li class="lvl-8">受电磁场的干扰相对较小</li>
</ul>
</li>
<li class="lvl-6">缺点：
<ul class="lvl-5">
<li class="lvl-8">比较大、比较重</li>
<li class="lvl-8">价格较高、维护成本较高</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<p>半主动RFID标签</p>
<ol>
<li class="lvl-6">在没有读写器访问的时候，内置的电池只为芯片内很少的电路供电。只有在读写器访问时，内置电池向RFD芯片供电，以增加标签的读写距离，提高通信的可靠性。</li>
<li class="lvl-6">半主动式RFID标签一般用在可重复使用的集装箱和物品的跟踪上。</li>
<li class="lvl-6">优点：
<ul class="lvl-5">
<li class="lvl-8">综合了被动式RFID标签与主动式RFID标签两者的优点</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>RFID标签分类：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221023175221865.png" alt="image-20221023175221865"></p>
</blockquote>
<p>3.以下关于EPC码是由四个数字字段组成的描述中，结误的是(D)<br>
A,第一个字段是版本号，表示产品编码所采用的EPC版本<br>
B.第二个字段是域名管理值，标识生产厂商国家<br>
C.第三个字段是对象分类值，标识产品类型<br>
D,第四个字段是序列号值，标识一类产品❌</p>
<blockquote>
<p><u>EPC码的四个数字字段：</u></p>
<ul class="lvl-1">
<li class="lvl-2">版本号，表示产品编码所采用的EPC版本</li>
<li class="lvl-2">域名管理值，标识生产厂商国家</li>
<li class="lvl-2">对象分类值，标识产品类型</li>
<li class="lvl-2">序列号值，<u>标识每一件产品</u></li>
</ul>
</blockquote>
<p>4.以下关于EPC-961型第码可以标识的产品总数量的描述中，错误的是(D)。<br>
A.可以标识出8个板本号<br>
B.可以标识出2.68亿个不同的厂商<br>
C.可以为每一个厂商提供多达1.68×10<sup>7</sup>类产品<br>
D.每一类产品可以有6.87亿件❌</p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221023175915452.png" alt="image-20221023175915452"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221111215715575.png" alt="image-20221111215715575"></p>
</blockquote>
<p>5.以下关于传感器特点的描述中，错误的是©。<br>
A.由敏感元件与转换元件组成<br>
B.能感知到被测量的物理量<br>
C,一种传感器的形状可以不相同，但是测量精度是相同的❌<mark>？</mark><br>
D.要能够满足感知信息的传输、处理、存储、显示、记录和控制的要求</p>
<blockquote>
<p>传感器的特点：</p>
<ol>
<li class="lvl-3">由敏感元件与转换元件组成</li>
<li class="lvl-3">能感知到被测量的信息</li>
<li class="lvl-3">能将感知和检测到的信息按照一定的规律变成电信号输出</li>
<li class="lvl-3">能够满足感知信息的传输、处理、存储、显示、记录和控制的要求</li>
</ol>
</blockquote>
<p>6.以下关于传感器分类方法的捕述中，错误的是(A)<br>
A,根据传感器地址分类❌<br>
B.根常传感器工作原理分类<br>
C根需传感器感知的对象分类<br>
D,根据传感器的应用领城分类</p>
<blockquote>
<p>传感器分类方法：</p>
<ol>
<li class="lvl-3">据传感器功能分类</li>
<li class="lvl-3">根据传感器工作原理分类</li>
<li class="lvl-3">根据传感器感知的对象分类</li>
<li class="lvl-3">根据传感器的应用领域分类</li>
</ol>
<p>常见传感器分类：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221023175449310.png" alt="image-20221023175449310"></p>
</blockquote>
<p>7.以下不属于力传感器的是(B)。<br>
A.力矩传感器																																																							B.磁传感器❌<br>
C.黏度传感器<br>
D.密度传悠器</p>
<blockquote>
<p>磁传感器和力传感器是统一分类等级。</p>
<p>常见传感器分类：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221023175449310.png" alt="image-20221023175449310"></p>
</blockquote>
<p>8.以下关于Ad hoc 网络特点的描述中，错误的是©<br>
A.自组织<br>
B.多跳传输<br>
C.主从结构❌<br>
D.无线信道</p>
<blockquote>
<p>IEEE将无线自组网定义为一种特殊的自组织、对等、多跳、无线移动网络，它是在无线分组网的基础上发展起来的。</p>
<p>Ad hoc 网络采用的是一种不需要基站的对等结构的移动通信方式。</p>
<p>Ad hoc 网络具有以下几个主要特点：</p>
<ol>
<li class="lvl-3">
<p>自组织与独立组网</p>
</li>
<li class="lvl-3">
<p>无中心控制节点</p>
</li>
<li class="lvl-3">
<p>多跳路由</p>
</li>
<li class="lvl-3">
<p>动态拓扑</p>
</li>
<li class="lvl-3">
<p>能量限制</p>
</li>
</ol>
</blockquote>
<p>9.以下不属于无线传感器网络节点的是(D)。<br>
A.传感器节点																																																							B.汇聚节点<br>
C.管理节点<br>
D.路由节点❌</p>
<blockquote>
<p>无线传感器网络简称：传感网。</p>
<p>无线传感器网络由3种节点组成：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>无线传感器节点</p>
</li>
<li class="lvl-2">
<p>汇聚节点</p>
</li>
<li class="lvl-2">
<p>管理结点</p>
</li>
</ul>
<p>无线传感器节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>汇聚节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>管理结点</p>
</blockquote>
<p>10.以下关于无线传感器网络特点的描述中。错误的是(B)<br>
A.网铬规模大<br>
B.以网络为中心❌<br>
C,灵活的自组织能力<br>
D.拓扑结构的动态变化</p>
<blockquote>
<p>无线传感器网络特点：</p>
<ol>
<li class="lvl-3">网铬规模大</li>
<li class="lvl-3">灵活的自组织能力</li>
<li class="lvl-3">拓扑结构的动态变化</li>
<li class="lvl-3">以数据为中心</li>
</ol>
</blockquote>
<p>11.以下关于位置信息函盖要素的描述中，错误的是(D)<br>
A.空间<br>
B.时间<br>
C.对象<br>
D.时序❌</p>
<blockquote>
<p>位置信息函盖三要素：</p>
<ol>
<li class="lvl-3">空间</li>
<li class="lvl-3">时间</li>
<li class="lvl-3">对象</li>
</ol>
</blockquote>
<p>12.以下关于GPS的基本工作原理的描述中，错误的是(D)</p>
<p>A.基于电磁波在自由空间的传输速度C=1×10<sup>8</sup>米/秒<br>
B.测量信号从卫星发送到被测量点的电磁波传输时间<br>
C.利用3颗卫星到被测量点的距离计算出被测量点的坐标<br>
D.通过第4颗卫星计算出电磁波传播速度误差，以提高定位精度❌</p>
<blockquote>
<p>详见PDF标签60（时钟误差）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221111222718162.png" alt="image-20221111222718162" style="zoom:50%;" />
</blockquote>
<p>13.以下不属于北斗卫星导航系统功能的是©<br>
A.定位<br>
B.导航<br>
C.电话❌<br>
D.通信</p>
<blockquote>
<p>北斗卫星导航系统四大功能：</p>
<ol>
<li class="lvl-3">定位</li>
<li class="lvl-3">导航</li>
<li class="lvl-3">授时</li>
<li class="lvl-3">通信</li>
</ol>
</blockquote>
<p>14.以下关于北斗卫星导航系统的主要技术参数的描述中，错误的是(D)<br>
A.定位精度可以达到10米<br>
B.测速精度可以达到0.2米/秒<br>
C.时间同步精度可以达到10纳秒<br>
D.系统的最大用户数是5400户/小时❌</p>
<blockquote>
<p>目前，北斗卫星导航系统的主要技术参数为：</p>
<ul class="lvl-1">
<li class="lvl-2">定位精度可以达到10m</li>
<li class="lvl-2">测速精度可以达到0.2m/s。</li>
<li class="lvl-2">时间同步精度可以达到10ns。</li>
<li class="lvl-2">用户终端具有双向短报文通信能力，一次可以传送40一60个汉字短报文。</li>
<li class="lvl-2">系统的最大用户数是540 000户/小时</li>
</ul>
</blockquote>
<p>15.以下关于嵌入式系统特点的描述中，错误的是©<br>
A.针对某些特定的应用<br>
B.专用的计算机系统<br>
C.剪裁计算机的硬件❌<br>
D.适应对计算机功能、可靠性、成本、体积、功耗的要求</p>
<blockquote>
<p>嵌入式系统（嵌入式计算机系统）特点：</p>
<ol>
<li class="lvl-3">一种专用的计算机系统</li>
<li class="lvl-3">针对某些特定的应用</li>
<li class="lvl-3">剪裁计算机的<mark>硬件与软件</mark></li>
<li class="lvl-3">适应对计算机功能、可靠性、成本、体积、功耗的要求</li>
</ol>
</blockquote>
<p>16.以下关于智能硬件共性特点的描述中，错误的是©<br>
A.计算十通信<br>
B.智能十控制<br>
C.RFID十传感器❌<br>
D.大数据+云计算</p>
<blockquote>
<p>智能硬件共性特点：</p>
<ul class="lvl-1">
<li class="lvl-2"><u>互联网+传感器</u>+<u>计算+通信</u>+<u>智能+控制</u>+大数据+云计算</li>
<li class="lvl-2">核心是：智能技术</li>
</ul>
</blockquote>
<p>17.以下不属于物联网智能硬件的人机交互技术研究的是(A)<br>
A.桌面交互❌<br>
B.人脸识别<br>
C.虚拟现实<br>
D,增强现实</p>
<blockquote>
<p>物联网智能硬件的人机交互技术研究：</p>
<ol>
<li class="lvl-3">虚拟交互技术</li>
<li class="lvl-3">人脸识别技术</li>
<li class="lvl-3">虚拟现实与增强现实技术</li>
</ol>
</blockquote>
<p>18.以下不属于生物特征识别的内容是(D)<br>
A.指纹识别<br>
B.人脸识别<br>
C.虹膜识别<br>
D.频率识别❌</p>
<blockquote>
<p>生物特征识别：</p>
<ol>
<li class="lvl-3">指纹识别</li>
<li class="lvl-3">虹膜识别</li>
<li class="lvl-3">人脸识别</li>
</ol>
</blockquote>
<p>19.以下关于可穿戴计算设备特征的描述中，错误的是©<br>
A.以人为本<br>
B.人机合一<br>
C.通用性❌<br>
D.专属化</p>
<blockquote>
<p>可穿戴计算设备特征：</p>
<ol>
<li class="lvl-3">以人为本</li>
<li class="lvl-3">人机合一</li>
<li class="lvl-3">专属化</li>
<li class="lvl-3">个性化</li>
</ol>
</blockquote>
<p>20.以下关于第四代机器人特征的描述中，错误的是(B)<br>
A.人工智能<br>
B.不能复制❌<br>
C.自动组装<br>
D.从机器人网络向“云机器人”方向演进</p>
<blockquote>
<p>第四代机器人的主要特征：</p>
<ol>
<li class="lvl-3">具有人工智能</li>
<li class="lvl-3">自我复制</li>
<li class="lvl-3">自动组装</li>
<li class="lvl-3">从机器人网络向“云机器人”方向演进</li>
</ol>
</blockquote>
<h3 id="二-思考题">二、思考题</h3>
<p>1.请解释无源RFID标签工作原理。</p>
<p>答：对于无源RFID标签，当RFID标签接近读写器时，RFID标签处于读写器天线辐射形成的近场范围内。RFID标签天线通过电磁感应产生感应电流，感应电流驱动RFID芯片电路。芯片电路通过RFID标签天线将存储在标签中的标识信息发送给读写器，读写器天线再将接收到的标识信息发送给主机。无源标签的工作过程就是读写器向标签传递能量，标签向读写器发送标签信息的过程读写器与标签之间能够双向通信的距离称为“可读范围”或“作用范围”。</p>
<p>2.请试着设计一个阅览室图书自动借阅系统，并说明系统工作原理。</p>
<p>答：自动借阅系统大致包含一下内容：</p>
<ol>
<li class="lvl-3">
<p>借出排行榜</p>
</li>
<li class="lvl-3">
<p>新增图书</p>
</li>
<li class="lvl-3">
<p>查看图书</p>
</li>
<li class="lvl-3">
<p>删除图书</p>
</li>
<li class="lvl-3">
<p>借出图书</p>
</li>
<li class="lvl-3">
<p>归还图书</p>
</li>
<li class="lvl-3">
<p>退出</p>
</li>
</ol>
<p>而实现自动借阅图书的关键在于利用RFID技术将RFID标签嵌入到每一本图书之中。以下利用场景法展示系统的工作原理：</p>
<p>在终端借阅图书时，经过个人信息的验证之后点击查看借出排行榜选择自己感兴趣的书，或是直接搜索指定图书，系统显示图书是否可借出，如果可借则可以点击借阅按钮，之后系统显示图书位置，拿到图书之后再终端进行扫描，在扫描过程中图书的RFID标签处于读写器天线辐射形成的近场范围内，RFID标签天线通过电磁感应产生感应电流，感应电流驱动RFID芯片电路，芯片电路通过RFID标签天线将存储在标签中的标识信息发送给读写器，读写器天线再将接收到的标识信息发送给主机，之后再通过读写器将特定信息写入RFID标签中，此时即可将图书带出借阅室而不会触发警报；</p>
<p>在终端归还图书时，经过个人信息的验证之后点击归还图书按钮，可以查看到自己的图书借阅信息，选择归还图书，之后将图书在终端进行扫描，同样是RFID标签处于读写器的可读写范围内，读写器先读取RFID标签的信息，并将信息上传主机进行处理，之后将特定信息通过读写器写入RFID标签之中，归还图书成功，最后退出系统。</p>
<p>3.请试者设计一个小区地下车库不停车电子收费系统(ETC),并解释系统工作原理。</p>
<p>答：小区地下车库不停车电子收费系统的关键技术在于通过安装在车辆挡风玻璃上的车载电子标签与在ETC车道上的微波天线之间进行的专用短程通讯，利用计算机联网技术与银行进行后台结算处理。</p>
<p>因此在ETC系统中需要使用到图像传感器（用来识别车辆的车牌号或者对车辆进行拍照）、RFID标签技术（无源RFID标签即可）。图像传感器可以记录下出入小区地下车库车辆的图像信息，保障小区的安全；RFID标签技术主要是车辆挡风玻璃上的车载电子标签，车主通过提前往改标签中写入数据信息，在经过ETC通道的时候车道上的RFID读写器识别到车辆的电子标签，并读取其中的信息上传主机进行信息识别，如汽车ID号、车型等信息和数据库中相应信息进行比较判断，根据不同情况来控制管理系统产生不同的动作，如计算机收费管理系统从该车的预付款项账户中扣除此次应交的过路费，扣费成功之后返回指令，升起起降杆，从而放行车辆。</p>
<p>4.设想一下，一部智能手机需要用到哪几种传感器？为什么？</p>
<p>答：光线传感器：根据环境光自动调整手机屏幕的亮度；</p>
<p>距离传感器：可以检测手机是否贴在耳朵上正在打电话，以便自动熄灭屏幕达到省电的目的；</p>
<p>图像传感器：面部识别；</p>
<p>指纹传感器：指纹识别解锁；</p>
<p>气压传感器：可用于海拔高度测量、导航辅助等；</p>
<p>声音传感器：手机话筒。</p>
<p>5.智能手机的接近传感器有助于节约电能。请找到你所使用的手机安装接近传感器的位置。</p>
<p>答：在手机的上顶边出的一个小孔（非副麦克风）就是接近传感器。</p>
<p>6.试着设计一个用于煤矿工人井下定位的矿井地下无线传感器网络系统结构方案，并阐述设计的基本思路。</p>
<p>答：煤矿井的环境复杂，需要对矿井的风速、矿尘含量、温度、湿度、氧气、硫化氢和二氧化碳等参数进行检测。现在通过对矿井构建地下无线传感器网络系统结构，利用传感器节点体积小并且整个网络只需要部署一次的优势将有效解决矿井结构复杂且部分坑道空间狭小的难题；同时无线传感器网络的结点数量大，分布的密度高，每个节点都能够检查到局部的环境信息，并将信息汇总到基站，因此能够有效避免通信链路发生故障时容易导致监测系统瘫痪的危险，同时分布密度高的网络结点也能够提供更全面、更高精度的数据；同时每一个无线传感器结点本身都具有一定的计算能力和存储能力，可以很好地处理矿井中复杂的环境变量监测。传感器节点还具有无线通信的能力，可以在节点间进行协同监控。节点的计算能力和无线通信能力使得传感器网络能够重新编程和重新部署，对环境变化、传感器网络自身变化以及网络控制指令做出及时反应。即使矿井结构遭到破坏，仍能自动恢复组网，传递信息，为矿难救助等提供重要信息。</p>
<p>7.请试者设计一套能够在自行车拐弯时实现变道提示、周边车辆过近报警的智能安全警示系统，说明设计的思路与采用的技术。</p>
<p>答：本智能安全警示系统主要用到：距离传感器、超声波传感器、红外线传感器。</p>
<p>首先当系统检测到自行车准备转弯时，通过超声波传感器检测自行车变道后方是否有车辆或是障碍物，如果检测到车辆或是障碍物就发出预警提示自行车驾驶员注意车辆或是障碍物；当周围车辆离自行车较近时，距离传感器和红外线传感器检测到周围车辆过近，然后系统将提示自行车驾驶员注意车距。</p>
<p>8.请试若设计一套“公交车刷脸支付”系统，说明设计的思路与需要注意的问题。</p>
<p>答：在“公交车刷脸支付”系统需要使用生物识别技术中的人脸识别技术、图像传感器、红外线传感器（夜间）。</p>
<p>乘客在白天乘坐公交车时，通过通过摄像头采集图像信息，之后通过图像传感器和人脸识别技术提取图像人脸特征并自动识别、匹配完成刷脸支付操作，夜间时红外线传感器则能够有效地增强人脸识别的准确率。</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>物联网原理与应用</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>物联网原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章练习题</title>
    <url>/2023/05/11/University/junior/course/(IOT)Principles%20and%20Applications%20of%20the%20Internet%20of%20Things/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第四章练习题</h1>
<h2 id="一-单选题">一、单选题</h2>
<p>1.以下关于物联网数据特征的描述中，错误的是©<br>
A.海量<br>
B.动态<br>
C.离散❌<br>
D.关联</p>
<blockquote>
<p>物联网数据特征：</p>
<ul class="lvl-1">
<li class="lvl-2">海量</li>
<li class="lvl-2">多态</li>
<li class="lvl-2">动态</li>
<li class="lvl-2">关联</li>
</ul>
</blockquote>
<p>2.以下不属于云计算服务类型的是(B)<br>
A.IaaS<br>
B.BaaS❌<br>
C.PaaS<br>
D.SaaS</p>
<blockquote>
<p>云计算服务类型分为三类：</p>
<ul class="lvl-1">
<li class="lvl-2">基础设施即服务（IaaS,infrastructure）</li>
<li class="lvl-2">平台即服务（PaaS,Plarform）</li>
<li class="lvl-2">软件即服务（SaaS,Software）</li>
</ul>
<p>详见PDF标签117</p>
</blockquote>
<p>3.以下关于云计算特征的描述中，错误的是©<br>
A.按需服务与资源池化<br>
B.泛在接入与服务可计费<br>
C.开发标准与移动服务❌<br>
D.快速部署与高可靠性</p>
<blockquote>
<p>详见PDF标签118</p>
<p>云计算特征：</p>
<ol>
<li class="lvl-3">
<p>按需服务</p>
</li>
<li class="lvl-3">
<p>资源池化</p>
</li>
<li class="lvl-3">
<p>泛在接入</p>
</li>
<li class="lvl-3">
<p>服务可计费</p>
</li>
<li class="lvl-3">
<p>快速部署</p>
</li>
<li class="lvl-3">
<p>高可靠性</p>
</li>
</ol>
</blockquote>
<p>4.以下关于数据量单位的描述中，错误的是(B)<br>
A.1GB=2<sup>30</sup>B<br>
B.1TB=2<sup>50</sup>B❌<br>
C.1ZB=2<sup>70</sup>B<br>
D.1DB=2<sup>100</sup>B</p>
<blockquote>
<p>数据量单位与换算关系：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028201445217.png" alt="image-20221028201445217" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028201109471.png" alt="image-20221028201109471" style="zoom:50%;" />
</blockquote>
<p>5.以下关于数据量换算关系的描述中，错误的是(D)<br>
A.1YB=1024 ZB<br>
B.1YB=1024×1024EB<br>
C.1YB=1024×1024×1024PB<br>
D.1YB=1024×1024×1024×1024GB❌</p>
<blockquote>
<p>记忆顺序：DNYZEPTGMK(Bb)</p>
</blockquote>
<p>6.以下关于数据量增长维度的描述中，错误的是(D)<br>
A.数据的数量<br>
B.数据的增长速度<br>
C.数据的种类<br>
D.数据的实时性❌</p>
<blockquote>
<p>数据量增长维度：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028202259545.png" alt="image-20221028202259545" style="zoom:50%;" />
<p>详见PDF标签124</p>
</blockquote>
<p>7.以下不属于大数据与数据挖掘特点的描述中，错误的是©<br>
A.数据挖掘是大数据数据分析的基础<br>
B.数据挖掘是从大量数据中提取出有价值的信息和知识的过程<br>
C.数据挖掘包括历史性分析与预测性分析❌<br>
D.对于同一组数据的数据挖掘结果，不同的人有不同的认知角度与使用价值（从书上的例子中可以看出）</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>数据挖掘是大数据数据分析的基础</p>
</li>
<li class="lvl-3">
<p>数据挖掘是从大量数据中提取出有价值的信息和知识的过程</p>
</li>
<li class="lvl-3">
<p>数据挖掘包括描述性分析与预测性分析</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028203048029.png" alt="image-20221028203048029" style="zoom:50%;" />
</blockquote>
<p>8.以下不属于大数据5V特征的描述中，错误的是©<br>
A.准确性<br>
B.大价值<br>
C.随机性❌<br>
D.多样性</p>
<blockquote>
<p>大数据&quot;5V&quot;特征：</p>
<ul class="lvl-1">
<li class="lvl-2">大体量(Volume): 数据量达到数百TB到数百PB,甚至是EB的规模。</li>
<li class="lvl-2">多样性(Variety:    数据呈现各种格式与各种类型。</li>
<li class="lvl-2">时效性(Velocity): 数据需要在一定的时间限度下得到及时处理。</li>
<li class="lvl-2">准确性(Veracity): 处理结果要保证一定的准确性。</li>
<li class="lvl-2">大价值(Value):      分析挖掘的结果可以带来重大的经济效益与社会效益。</li>
</ul>
</blockquote>
<h2 id="二-思考题">二、思考题</h2>
<p>1.请用例子说明你对物联网“数据、信息与知识”之间关系的理解。</p>
<p>答：比如书上啤酒与尿布例子中可以知道，通过对超市销售记录数据进行分析能够从中发现消费者买尿布的同时也大概率会买啤酒的信息，通过对得到的信息进行进一步地调查能够得到为什么购买啤酒与购买尿布之间具备关系的知识。由此得到可以从大量数据中提取出一些非常有价值的信息和知识，这个过程就是数据挖掘。</p>
<p>2.举出3个能够说明物联网数据关联性的例子。</p>
<p>答：比如：</p>
<ol>
<li class="lvl-3">
<p>超市中啤酒与尿布的销售数据：购买尿布的年轻父亲，多半同时会顺便购买啤酒；</p>
</li>
<li class="lvl-3">
<p>某地区发生干旱后会提升霍乱发生的概率：微软大数据研究院的人员构建的预警系统发现某个地方干旱几年之后霍乱发生概率会增加；</p>
</li>
<li class="lvl-3">
<p>流感病毒感染率与感冒药物的销售率：流感疾病的概率上升会致使感冒药的销售数量增加。</p>
</li>
</ol>
<blockquote>
<p><em><strong>网上参考：</strong></em></p>
<p><strong><u>关联性</u>：</strong></p>
<p>在物联网中，数据之间有着千丝万缕的联系。物联网数据的关联性可以从以下两个方面理解：</p>
<p>第一，<mark>时间关联性</mark>。即同一时刻的数据照相，数据是同一时刻为系统所产生的，它反映的是系统在这一时刻的状态。从数据世界角度来看，这个系统就是这一时刻的数据集合。</p>
<p>第二，<mark>流程关联性</mark>。即一个点的数据经过一定时间后影响第二个点数据的产生，它体现的是系统动态的流程展示。</p>
<p>个人理解：数据间的关联性就是数据之间的相互影响或者是单方面的影响。</p>
</blockquote>
<p>3.如何理解用户“可以像使用水、电一样按需购买和使用云计算资源”？</p>
<p>答：就如同我们日常生活中使用水电一样，首先充值一定金额作为水电费，然后当费用快用完时再根据自己的需求选择继续充值续费还是不再充值使用。云计算资源也如同水电一样，会根据使用的量进行计费，我们同样选择充值一定金额来使用一定的云计算资源，当费用快要耗尽时可以继续充值一定金额继续使用云计算资源，这样可以使得用户完全根据自己的需求购买云计算资源并使用，不会造成云计算资源的大量浪费，对于合理充分利用计算资源具有十分重要的积极意义。</p>
<p>4.请结合生活中的例子说明你对数据挖掘作用的理解。</p>
<p>答：通过对往年土地农作物产量以及各区域土地的环境因素（如土壤水分、土壤温度、空气温度、空气湿度、光照强度、植物养分含量等参数）的数据进行收集，综合进行分析能够知道在下一播种季应该在哪些地方播种什么作物，有效利用土地资源使得农作物出产最多并且不对环境产生破坏。因此数据挖掘能够针对过去探寻规律，并能够面向未来预测趋势。</p>
<p>5.请结合生活中的例子说明大数据对于物联网应用的重要性。</p>
<p>答：就智慧交通而言，一个城市中具有数不清的道路以及十字路口，如何合理地规划每一个十字路口的红绿灯使得城市道路始终保持相对通畅，特别是在上下班高峰期时的道路规划是一个十分重要的问题。通过将遍布城市的各种传感器实时收集到的城市道路信息汇总到中央系统进行大数据的分析和处理，能够合理地在不同时间段对道路红绿灯进行调整，从而保证了城市道路的通畅，在很大程度上提升了市民的出行体验以及降低了道路交通事故的发生概率。因此我们单从大数据在智慧交通中的作用就能知道大数据对于物联网应用的重要性。</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>物联网原理与应用</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>物联网原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>keras基础</title>
    <url>/2023/05/11/University/junior/course/Scientific%20Computing%20and%20Mathematical%20Modeling/keras%E4%BB%A3%E7%A0%81%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>keras基础</h1>
<blockquote>
<p>官方文档：<a href="https://keras.io/zh/">主页 - Keras 中文文档</a></p>
</blockquote>
<h3 id="mnist加载数据">mnist加载数据</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line">(X_train, y_train), (X_test, y_test) = mnist.load_data(<span class="string">&quot;/data/shixunfiles/8a61469f7ea1b51cbae51d4f78837e45_1637892731181.npz&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>根据指定路径下载数据</p>
</li>
</ol>
<h3 id="reshape">reshape</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 将图像摊平为向量</span></span><br><span class="line">X_train = X_train.reshape(<span class="number">60000</span>, <span class="number">784</span>)</span><br><span class="line">X_test = X_test.reshape(<span class="number">10000</span>, <span class="number">784</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">X_train = X_train / <span class="number">255</span></span><br><span class="line">X_test = X_test / <span class="number">255</span></span><br><span class="line">y_train = np_utils.to_categorical(y_train, <span class="number">10</span>)</span><br><span class="line">y_test_h = np_utils.to_categorical(y_test, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>a.reshape(shape) ： 不改变numpy数组a的元素，返回一个shape形状的数组，原数组a不变</p>
</li>
<li class="lvl-3">
<p><u>区别于keras.layers的Reshape层，两者作用相同，但不是同一个东西</u>。</p>
</li>
</ol>
<h3 id="sequential-顺序模型">Sequential 顺序模型</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/getting-started/sequential-model-guide/">Sequential 顺序模型指引 - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="comment"># 序列模型</span></span><br><span class="line">model = models.Sequential()</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>可以通过将网络层实例的列表传递给 <code>Sequential</code> 的构造器，来创建一个 <code>Sequential</code> 模型；</p>
</li>
<li class="lvl-3">
<p>也可以简单地使用 <code>.add()</code> 方法将各层添加到模型中。</p>
</li>
<li class="lvl-3">
<p>对于顺序模型中的第一层（且只有第一层，因为下面的层可以自动地推断尺寸）需要接收关于其输入尺寸的信息。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面的代码片段是等价的</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">32</span>, input_shape=(<span class="number">784</span>,)))</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">32</span>, input_dim=<span class="number">784</span>))</span><br></pre></td></tr></table></figure>
<h3 id="inputlayer输入层">InputLayer输入层</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> InputLayer</span><br><span class="line"><span class="comment"># 输入层</span></span><br><span class="line">model.add(InputLayer(input_shape=(img_size_flat,)))</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>输入层采用 InputLayer 进行定义， InputLayer 只用于<strong>接收数据</strong>，不对数据做任何处理。</p>
</li>
<li class="lvl-3">
<p>可以包装现有张量 (传递 input_tensor 参数)或创建占位符张量 (传递参数 input_shape 和可选的 dtype )</p>
</li>
</ol>
<h3 id="conv2d卷积层">Conv2D卷积层</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/backend/#conv2d">后端 Backend - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="comment"># 具有ReLu激活和最大池化的卷积层1</span></span><br><span class="line">model.add(Conv2D(kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, filters=<span class="number">16</span>,</span><br><span class="line">                 padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;layer_conv1&#x27;</span>))</span><br><span class="line">model.add(MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具有ReLu激活和最大池化的卷积层2</span></span><br><span class="line">model.add(Conv2D(kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, filters=<span class="number">36</span>,</span><br><span class="line">                 padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;layer_conv2&#x27;</span>))</span><br><span class="line">model.add(MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keras.backend.conv2d(x, kernel, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&#x27;valid&#x27;</span>, data_format=<span class="literal">None</span>, dilation_rate=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>x</strong>: 张量或变量。</p>
</li>
<li class="lvl-2">
<p><strong>kernel</strong>: 核张量。</p>
</li>
<li class="lvl-2">
<p><strong>strides</strong>: 步长元组。</p>
</li>
<li class="lvl-2">
<p><strong>padding</strong>: 字符串，<code>&quot;same&quot;</code> 或 <code>&quot;valid&quot;</code>。</p>
</li>
<li class="lvl-2">
<p><strong>data_format</strong>: 字符串，<code>&quot;channels_last&quot;</code> 或 <code>&quot;channels_first&quot;</code>。 对于输入/卷积核/输出，是否使用 Theano 或 TensorFlow/CNTK数据格式。</p>
</li>
<li class="lvl-2">
<p><strong>dilation_rate</strong>: 2 个整数的元组。</p>
</li>
</ul>
<h3 id="maxpooling2d最大池化">MaxPooling2D最大池化</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/layers/pooling/#maxpooling2d">池化层 Pooling - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> MaxPooling2D</span><br><span class="line">model.add(MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keras.layers.MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="literal">None</span>, padding=<span class="string">&#x27;valid&#x27;</span>, data_format=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>pool_size</strong>: 整数，或者 2 个整数表示的元组， 沿（垂直，水平）方向缩小比例的因数。 （2，2）会把输入张量的两个维度都缩小一半。 如果只使用一个整数，那么两个维度都会使用同样的窗口长度。</p>
</li>
<li class="lvl-2">
<p><strong>strides</strong>: 整数，2 个整数表示的元组，或者是 <code>None</code>。 表示步长值。 如果是 <code>None</code>，那么默认值是 <code>pool_size</code>。</p>
</li>
<li class="lvl-2">
<p><strong>padding</strong>: <code>&quot;valid&quot;</code> 或者 <code>&quot;same&quot;</code> （区分大小写）。</p>
</li>
<li class="lvl-2">
<p><strong>data_format</strong>: 字符串，<code>channels_last</code> (默认)或 <code>channels_first</code> 之一。 表示输入各维度的顺序。 <code>channels_last</code> 代表尺寸是 <code>(batch, height, width, channels)</code> 的输入张量， 而 <code>channels_first</code> 代表尺寸是 <code>(batch, channels, height, width)</code> 的输入张量。 默认值根据 Keras 配置文件 <code>~/.keras/keras.json</code> 中的 <code>image_data_format</code> 值来设置。 如果还没有设置过，那么默认值就是 “channels_last”。</p>
</li>
</ul>
<h3 id="flatten">Flatten</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/layers/core/#flatten">核心网络层 - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Flatten</span><br><span class="line"><span class="comment"># 将卷积层的输出拉直</span></span><br><span class="line">model.add(Flatten())</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keras.layers.Flatten(data_format=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>data_format</strong>：一个字符串，其值为 <code>channels_last</code>（默认值）或者 <code>channels_first</code>。它表明输入的维度的顺序。此参数的目的是当模型从一种数据格式切换到另一种数据格式时保留权重顺序。<code>channels_last</code> 对应着尺寸为 <code>(batch, ..., channels)</code> 的输入，而 <code>channels_first</code> 对应着尺寸为 <code>(batch, channels, ...)</code> 的输入。默认为 <code>image_data_format</code> 的值，你可以在 Keras 的配置文件 <code>~/.keras/keras.json</code> 中找到它。如果你从未设置过它，那么它将是 <code>channels_last</code></p>
</li>
</ul>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">                 input_shape=(<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>), padding=<span class="string">&#x27;same&#x27;</span>,))</span><br><span class="line"><span class="comment"># 现在：model.output_shape == (None, 64, 32, 32)</span></span><br><span class="line"></span><br><span class="line">model.add(Flatten())</span><br><span class="line"><span class="comment"># 现在：model.output_shape == (None, 65536)</span></span><br></pre></td></tr></table></figure>
<h3 id="dense完全连接层">Dense完全连接层</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/layers/core/#dense">核心网络层 - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="comment"># 具有ReLu激活的完全连接层</span></span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一个全连接层，具有softmax激活，用于分类</span></span><br><span class="line">model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keras.layers.Dense(units, activation=<span class="literal">None</span>, use_bias=<span class="literal">True</span>, kernel_initializer=<span class="string">&#x27;glorot_uniform&#x27;</span>, bias_initializer=<span class="string">&#x27;zeros&#x27;</span>, kernel_regularizer=<span class="literal">None</span>, bias_regularizer=<span class="literal">None</span>, activity_regularizer=<span class="literal">None</span>, kernel_constraint=<span class="literal">None</span>, bias_constraint=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>units</strong>: 正整数，输出空间维度。</p>
</li>
<li class="lvl-2">
<p><strong>activation</strong>: 激活函数 。 若不指定，则不使用激活函数 (即，「线性」激活: <code>a(x) = x</code>)。</p>
</li>
<li class="lvl-2">
<p><strong>use_bias</strong>: 布尔值，该层是否使用偏置向量。</p>
</li>
<li class="lvl-2">
<p><strong>kernel_initializer</strong>: <code>kernel</code> 权值矩阵的初始化器 。</p>
</li>
<li class="lvl-2">
<p><strong>bias_initializer</strong>: 偏置向量的初始化器 。</p>
</li>
<li class="lvl-2">
<p><strong>kernel_regularizer</strong>: 运用到 <code>kernel</code> 权值矩阵的正则化函数。</p>
</li>
<li class="lvl-2">
<p><strong>bias_regularizer</strong>: 运用到偏置向的的正则化函数。</p>
</li>
<li class="lvl-2">
<p><strong>activity_regularizer</strong>: 运用到层的输出的正则化函数 (它的 “activation”)。</p>
</li>
<li class="lvl-2">
<p><strong>kernel_constraint</strong>: 运用到 <code>kernel</code> 权值矩阵的约束函数。</p>
</li>
<li class="lvl-2">
<p><strong>bias_constraint</strong>: 运用到偏置向量的约束函数。</p>
</li>
</ul>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作为 Sequential 模型的第一层</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">32</span>, input_shape=(<span class="number">16</span>,)))</span><br><span class="line"><span class="comment"># 现在模型就会以尺寸为 (*, 16) 的数组作为输入，</span></span><br><span class="line"><span class="comment"># 其输出数组的尺寸为 (*, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第一层之后，你就不再需要指定输入的尺寸了：</span></span><br><span class="line">model.add(Dense(<span class="number">32</span>))</span><br></pre></td></tr></table></figure>
<h3 id="compile模型编译">compile模型编译</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=Adam(lr=<span class="number">1e-3</span>),</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ol>
<li class="lvl-4">
<p>优化器 optimizer</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-5">
<p>rmsprop</p>
</li>
<li class="lvl-5">
<p>adagrad</p>
</li>
<li class="lvl-5">
<p>Optimizer 类的实例</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>损失函数 loss</p>
<ul class="lvl-2">
<li class="lvl-5">categorical_crossentropy：多分类交叉熵</li>
<li class="lvl-5">binary_crossentropy：二分类交叉熵</li>
<li class="lvl-5">mse</li>
</ul>
</li>
<li class="lvl-3">
<p>评估标准 metrics</p>
<ul class="lvl-2">
<li class="lvl-5">一般设为<code>accuracy</code></li>
</ul>
</li>
</ol>
<h3 id="fit模型训练">fit模型训练</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/models/model/#fit">函数式 API - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># epochs设置为1，batch_size设置为128</span></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model.fit(X_train, y_train, epochs=<span class="number">1</span>, batch_size=<span class="number">128</span>,</span><br><span class="line">          validation_split=<span class="number">1</span>/<span class="number">12</span>, verbose=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fit(self, x=<span class="literal">None</span>, y=<span class="literal">None</span>, batch_size=<span class="literal">None</span>, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, callbacks=<span class="literal">None</span>, validation_split=<span class="number">0.0</span>, validation_data=<span class="literal">None</span>, shuffle=<span class="literal">True</span>, class_weight=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>, initial_epoch=<span class="number">0</span>, steps_per_epoch=<span class="literal">None</span>, validation_steps=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>x：输入数据。如果模型只有一个输入，那么x的类型是numpy数组，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array。</p>
</li>
<li class="lvl-2">
<p>y：标签，numpy 数组。如果模型有多个输出，可以传入一个numpy 数组的list。</p>
</li>
<li class="lvl-2">
<p>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个</p>
</li>
<li class="lvl-2">
<p>batch的样本会被计算一次梯度下降，使目标函数优化一步。</p>
</li>
<li class="lvl-2">
<p>epochs：整数，训练终止时的epoch值，训练将在达到该epoch值时停止</p>
</li>
<li class="lvl-2">
<p>verbose：<u>日志显示</u>，0：为不在标准输出流输出日志信息，1：为输出进度条记录，2：为每个epoch输出一行记录</p>
</li>
<li class="lvl-2">
<p>validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。</p>
</li>
</ul>
<h3 id="evaluate模型评估">evaluate模型评估</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/models/model/#evaluate">函数式 API - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 评估与预测性能指标</span></span><br><span class="line">result = model.evaluate(X_test, y_test_h, verbose=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;loss &quot;</span>, result[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;acc &quot;</span>, result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">evaluate(x=<span class="literal">None</span>, y=<span class="literal">None</span>, batch_size=<span class="literal">None</span>, verbose=<span class="number">1</span>, sample_weight=<span class="literal">None</span>, steps=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>x</strong>: 测试数据的 Numpy 数组（如果模型只有一个输入）， 或者是 Numpy 数组的列表（如果模型有多个输入）。 如果模型中的输入层被命名，你也可以传递一个字典，将输入层名称映射到 Numpy 数组。 如果从本地框架张量馈送（例如 TensorFlow 数据张量）数据，x 可以是 <code>None</code>（默认）。</p>
</li>
<li class="lvl-2">
<p><strong>y</strong>: 目标（标签）数据的 Numpy 数组，或 Numpy 数组的列表（如果模型具有多个输出）。 如果模型中的输出层被命名，你也可以传递一个字典，将输出层名称映射到 Numpy 数组。 如果从本地框架张量馈送（例如 TensorFlow 数据张量）数据，y 可以是 <code>None</code>（默认）。</p>
</li>
<li class="lvl-2">
<p><strong>batch_size</strong>: 整数或 <code>None</code>。每次评估的样本数。如果未指定，默认为 32。</p>
</li>
<li class="lvl-2">
<p><strong>verbose</strong>: 0 或 1。日志显示模式。 0 = 安静模式，1 = 进度条。</p>
</li>
<li class="lvl-2">
<p><strong>sample_weight</strong>: 测试样本的可选 Numpy 权重数组，用于对损失函数进行加权。 您可以传递与输入样本长度相同的扁平（1D）Numpy 数组（权重和样本之间的 1:1 映射）， 或者在时序数据的情况下，传递尺寸为 <code>(samples, sequence_length)</code> 的 2D 数组，以对每个样本的每个时间步施加不同的权重。 在这种情况下，你应该确保在 <code>compile()</code> 中指定 <code>sample_weight_mode=&quot;temporal&quot;</code>。</p>
</li>
<li class="lvl-2">
<p><strong>steps</strong>: 整数或 <code>None</code>。 声明评估结束之前的总步数（批次样本）。默认值 <code>None</code>。</p>
</li>
</ul>
<h3 id="predict预测">predict预测</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/models/model/#predict">函数式 API - Keras 中文文档</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预测</span></span><br><span class="line">predict = model.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 predict: &quot;</span>, predict)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predict(x, batch_size=<span class="literal">None</span>, verbose=<span class="number">0</span>, steps=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>x</strong>: 输入数据，Numpy 数组 （或者 Numpy 数组的列表，如果模型有多个输出）。</p>
</li>
<li class="lvl-2">
<p><strong>batch_size</strong>: 整数。如未指定，默认为 32。</p>
</li>
<li class="lvl-2">
<p><strong>verbose</strong>: 日志显示模式，0 或 1。</p>
</li>
<li class="lvl-2">
<p><strong>steps</strong>: 声明预测结束之前的总步数（批次样本）。默认值 <code>None</code>。</p>
</li>
</ul>
<h3 id="argmax">argmax</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/backend/#argmax">后端 Backend - Keras 中文文档</a></p>
</blockquote>
<p>返回指定轴的最小值的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">predict = np.argmax(predict, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2 predict: &quot;</span>, predict)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keras.backend.argmin(x, axis=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>x</strong>: 张量或变量。</p>
</li>
<li class="lvl-2">
<p><strong>axis</strong>: 执行归约操作的轴。</p>
</li>
</ul>
<h3 id="保存-删除-加载模型">保存、删除、加载模型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">model2.save(path_model)</span><br><span class="line"><span class="comment"># 删除模型</span></span><br><span class="line"><span class="keyword">del</span> model2</span><br><span class="line"><span class="comment"># 加载模型3</span></span><br><span class="line">model3 = models.load_model(path_model)</span><br></pre></td></tr></table></figure>
<h3 id="summary输出各层信息">summary输出各层信息</h3>
<p>summary()方法查看模型架构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到层</span></span><br><span class="line">model3.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出样例：</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line">Layer (<span class="built_in">type</span>)                 Output Shape              Param <span class="comment">#   </span></span><br><span class="line">=================================================================</span><br><span class="line">embedding_1 (Embedding)      (<span class="literal">None</span>, <span class="number">20</span>, <span class="number">8</span>)             <span class="number">80000</span>     </span><br><span class="line">_________________________________________________________________</span><br><span class="line">flatten_1 (Flatten)          (<span class="literal">None</span>, <span class="number">160</span>)               <span class="number">0</span>         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_1 (Dense)              (<span class="literal">None</span>, <span class="number">1</span>)                 <span class="number">161</span>       </span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">80</span>,<span class="number">161</span></span><br><span class="line">Trainable params: <span class="number">80</span>,<span class="number">161</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">_________________________________________________________________</span><br></pre></td></tr></table></figure>
<h3 id="layers模型各层">layers模型各层</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="comment"># layers下标索引根据add()添加的先后顺序决定</span></span><br><span class="line">layer_input = model3.layers[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># layers[1]:model.add(Reshape(img_shape_full))</span></span><br><span class="line">layer_conv1 = model3.layers[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># layers[3]:model.add(MaxPooling2D(pool_size=2, strides=2))</span></span><br><span class="line">layer_conv2 = model3.layers[<span class="number">4</span>]</span><br><span class="line"><span class="comment"># layers[5]:model.add(MaxPooling2D(pool_size=2, strides=2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># layers[6]:model.add(Flatten())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># layers[7]:model.add(Dense(128, activation=&#x27;relu&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># layers[8]:model.add(Dense(num_classes, activation=&#x27;softmax&#x27;))</span></span><br></pre></td></tr></table></figure>
<h3 id="get-weights获得权重">get_weights获得权重</h3>
<blockquote>
<p>官方参考：<a href="https://keras.io/zh/layers/about-keras-layers/#keras">关于 Keras 网络层 - Keras 中文文档</a></p>
</blockquote>
<p><code>layer.get_weights()</code>: 以含有Numpy矩阵的列表形式返回层的权重。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卷积权重</span></span><br><span class="line">weights_conv1 = layer_conv1.get_weights()[<span class="number">0</span>]</span><br><span class="line">weights_conv2 = layer_conv2.get_weights()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="backend">backend</h3>
<blockquote>
<p>参考：<a href="https://www.w3cschool.cn/tensorflow_python/tf_keras_backend_function.html">TensorFlow函数教程：tf.keras.backend.function_w3cschool</a></p>
</blockquote>
<p><code>backend.function</code>输出值为 Numpy 数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend</span><br><span class="line"><span class="comment"># 卷积层输出一</span></span><br><span class="line">output_conv1 = backend.function(</span><br><span class="line">        inputs=[layer_input.<span class="built_in">input</span>], outputs=[layer_conv1.output])</span><br><span class="line">layer_output1 = output_conv1([np.array([image1])])[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(layer_output1.shape)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.backend.function(</span><br><span class="line">    inputs,</span><br><span class="line">    outputs,</span><br><span class="line">    updates=<span class="literal">None</span>,</span><br><span class="line">    name=<span class="literal">None</span>,</span><br><span class="line">    **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>inputs：占位符张量列表。</p>
</li>
<li class="lvl-2">
<p>outputs：输出张量列表。</p>
</li>
<li class="lvl-2">
<p>updates：更新操作列表。</p>
</li>
<li class="lvl-2">
<p>name：String，函数名称。</p>
</li>
<li class="lvl-2">
<p>**kwargs：需要传递给 <code>tf.Session.run</code> 的参数。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>科学计算与数学建模</category>
      </categories>
      <tags>
        <tag>keras</tag>
        <tag>科学计算与数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章（项目沟通管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/10-%E9%A1%B9%E7%9B%AE%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目沟通管理</h1>
<h3 id="学习目标">学习目标</h3>
<p>①<strong>了解项目中良好沟通的重要性。</strong></p>
<p>②<strong>沟通的相关概念。</strong></p>
<p>③<strong>论述<mark>沟通管理的主要过程</mark>。</strong></p>
<p>④<strong>描述如何管理沟通，包括沟通的技术、媒介和绩效报告。</strong></p>
<p>⑤<strong>讨论监督沟通的方法。</strong></p>
<p>⑥<strong>列出改善项目沟通的各种方法。</strong></p>
<h3 id="沟通管理的过程">沟通管理的过程</h3>
<ol>
<li class="lvl-3">
<p>规划沟通管理</p>
</li>
<li class="lvl-3">
<p>管理沟通</p>
</li>
<li class="lvl-3">
<p>监督沟通（控制沟通）</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230615162109497.png" alt="image-20230615162109497"></p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年期末总结</title>
    <url>/2023/05/11/University/junior/course/Scientific%20Computing%20and%20Mathematical%20Modeling/%E5%BC%80%E5%8D%B7%E5%AE%9D%E5%85%B8plus+/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>科学计算与数学建模期末总结</h1>
<p>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断 1分*10个</span><br><span class="line">单选 2分*5个</span><br><span class="line">多选 3分*10个</span><br><span class="line">简答 10分*3个</span><br><span class="line">综合简答 1个*20分</span><br></pre></td></tr></table></figure>
<p>[TOC]</p>
<h2 id="必考">必考</h2>
<h3 id="考-cnn-通道数与filter个数相等">考.CNN.通道数与filter个数相等</h3>
<blockquote>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221007084324665.png" alt="image-20221007084324665"></p>
<p>新的图片的通道数 与 卷积过程中的filter个数的关系  <strong>相等</strong></p>
</blockquote>
<h3 id="考-隐空间和特征空间的关系">考.隐空间和特征空间的关系</h3>
<blockquote>
<p>在深度学习中，隐空间和特征空间是两个重要的概念，它们之间有一定的关系。</p>
<p>特征空间是指输入数据经过特征提取之后所构成的空间。在深度学习中，我们通常会将输入数据通过多层神经网络进行变换和抽象，最终得到一个更加抽象、更有意义的特征表示。这个特征表示的空间就是特征空间。在特征空间中，每个数据样本都被表示为一个向量，这个向量的每个维度代表了某个特征的值，因此特征空间中的每个维度都对应着某种意义，如像素值、颜色等。</p>
<p>隐空间是指神经网络中的隐藏层输出所构成的空间。隐藏层是神经网络中的一层，其输出是由输入数据经过一系列非线性变换和激活函数处理得到的。隐空间中的每个维度都代表了神经元的输出值，这些神经元可以认为是在对输入数据进行某种高级抽象和表示。因此，隐空间的维度往往比特征空间的维度更高，同时隐空间中的每个维度往往难以解释。</p>
<p>隐空间和特征空间之间的关系通常体现在神经网络的训练过程中。在训练过程中，神经网络通过不断地调整参数，使得隐空间中的表示可以更好地捕捉数据的特征，并能够将不同类别的数据样本分开。同时，隐空间的输出也可以被进一步处理和解释，得到更加有意义的特征表示，从而提高神经网络在各种任务中的表现。因此，隐空间和特征空间是深度学习中两个非常重要的概念，它们之间的关系对于深度学习算法的理解和优化都有着重要的意义。</p>
</blockquote>
<h3 id="考-神经网络为什么deep不fat">考.神经网络为什么Deep不Fat</h3>
<blockquote>
<p>可以使用更少的数据产生同样的效果</p>
</blockquote>
<blockquote>
<p>神经网络通常会随着深度的增加而变得更加复杂和强大，而随着网络的宽度增加而变得更加庞大和容易过拟合。这就是为什么神经网络通常被描述为“deep而不fat”，即增加深度而不是增加宽度可以更好地提高网络性能的原因。</p>
<p>一方面，增加网络的深度可以使得网络能够学习到更加抽象和高层次的特征表示，从而提高网络的表现能力。这是因为深度网络可以通过层与层之间的非线性变换来逐渐组合和学习输入数据的不同抽象特征。随着网络的深度增加，网络能够更好地理解和表示数据之间的关系，并且可以通过逐层的学习来提高整个网络的表示能力。</p>
<p>另一方面，增加网络的宽度会使得网络的参数数量增加，从而容易导致过拟合。在过拟合的情况下，神经网络在训练数据上的表现很好，但在测试数据上表现较差。这是因为过拟合的网络过于适应了训练数据的噪声和特异性，而无法泛化到新的数据上。因此，在设计神经网络时，需要权衡网络的深度和宽度，以便在提高性能的同时避免过拟合。</p>
<p>总之，增加网络的深度可以提高网络的表现能力，而增加网络的宽度则容易导致过拟合。在神经网络的设计和优化中，我们需要综合考虑这两个因素，以便得到更加高效和准确的网络结构。</p>
</blockquote>
<h3 id="考-对比常见模型的建模三部曲">考.对比常见模型的建模三部曲</h3>
<blockquote>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230218015553982.png" alt="image-20230218015553982"></p>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230218015630174.png" alt="image-20230218015630174"></p>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230218015655491.png" alt="image-20230218015655491"></p>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230218015711073.png" alt="image-20230218015711073"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218015719284.png" alt="image-20230218015719284"></p>
</blockquote>
<h2 id="17级-换老师-参考价值低">17级（换老师，参考价值低）</h2>
<h2 id="选择题">选择题</h2>
<h3 id="梯度下降">梯度下降</h3>
<p>神经网络中的梯度下降方法：</p>
<ol>
<li class="lvl-3">
<p>A.梯度下降方法是利用数值优化中对待优化函数求导能够获敢函数变化最快方向的信息从而逐步更新函数参数的方法</p>
</li>
<li class="lvl-3">
<p>B.在神经网络中，参数是待定的，要找到最恰当拟合输入输出数据的函数，就需要构建损失函数</p>
</li>
<li class="lvl-3">
<p>D.相比于对神经网络中每个参数直接求梯度，采用<mark>反向传播算法的效率更高</mark></p>
</li>
</ol>
<h3 id="sigmoid激活函数">sigmoid激活函数</h3>
<p>A.采用sigmoid激活函数的单个神经元本质上起到了二分类的作用——❌</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>sigmoid激活函数也称<mark>S型生长曲线</mark></p>
</li>
</ul>
<p>Sigmoid函数的特性与优缺点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Sigmoid函数的输出范围是0到1。由于输出值限定在0到1，因此它对每个神经元的输出进行了归一化。</p>
</li>
<li class="lvl-2">
<p>用于将预测概率作为输出的模型。由于概率的取值范围是0到1，因此Sigmoid函数非常合适</p>
</li>
<li class="lvl-2">
<p>梯度平滑，避免跳跃的输出值</p>
</li>
<li class="lvl-2">
<p>函数是可微的。这意味着可以找到任意两个点的Sigmoid曲线的斜率</p>
</li>
<li class="lvl-2">
<p>明确的预测，即非常接近1或0。</p>
</li>
<li class="lvl-2">
<p>函数输出不是以0为中心的，这会降低权重更新的效率</p>
</li>
<li class="lvl-2">
<p>Sigmoid函数执行指数运算，计算机运行得较慢。</p>
</li>
</ul>
<p>关于sigmoid激活函数的相关描述：</p>
<p>B.采用sigmoid激活函数的神经网络可以看成由多个逻辑回归模型叠加而成<br>
C.神经网络的参数由所有神经元连接的权重和偏差组成<br>
D.一个结构确定的神经网络对应一组函数集合，而该神经网络的参数确定后就只对应一个函数。</p>
<h3 id="全连接前馈神经网络">全连接前馈神经网络</h3>
<ol>
<li class="lvl-3">
<p>一般由多层神经元连接而成</p>
</li>
<li class="lvl-3">
<p>每层有多个神经元</p>
</li>
<li class="lvl-3">
<p>从输入到输出各层之间的神经元连接都是沿着从输入层到输出层的方向</p>
</li>
<li class="lvl-3">
<p>两相邻层的神经元之间两两互相有连接</p>
</li>
</ol>
<h3 id="关于梯度下降和反向传播算法的正确说法">关于梯度下降和反向传播算法的正确说法</h3>
<ol>
<li class="lvl-3">
<p>反向传播算法相比于直接对每个参数求梯度，计算效率更高</p>
</li>
<li class="lvl-3">
<p>随机梯度下降运行速度要比梯度下降快</p>
</li>
<li class="lvl-3">
<p>在反向传播算法中，反向传递过程可以看成一个没有激活函数的反向的神经网络</p>
</li>
<li class="lvl-3">
<p>随机梯度下降相对于梯度下降，损失函数会呈现较强的抖动</p>
</li>
</ol>
<h3 id="keras">Keras</h3>
<ol>
<li class="lvl-3">
<p>Keras实现神经网络需要首先创建模型对象</p>
</li>
<li class="lvl-3">
<p>在Keras中通过模型对象添加一个网络层的方法是add方法</p>
</li>
<li class="lvl-3">
<p>在Keras中要进行模型训练，需要调用模型的fit方法</p>
</li>
<li class="lvl-3">
<p>在Keras中添加一个网络层可以不需要设置输入维度和输出维度</p>
</li>
</ol>
<h3 id="卷积神经网络cnn">卷积神经网络CNN</h3>
<blockquote>
<p>一种特殊的深层前馈网络</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>convolution layer（卷积）</p>
<ul class="lvl-2">
<li class="lvl-5">filter：过滤器，相当于神经元，每一个filter关注的范围不同，也叫<mark>卷积核</mark></li>
<li class="lvl-5">(其中每一个filter其实就等同于是fully connect layer里面的一个neuron)</li>
<li class="lvl-5">一个filter就代表了一个channel</li>
</ul>
</li>
<li class="lvl-3">
<p>max pooling layer（池化）</p>
<ul class="lvl-2">
<li class="lvl-5">将经过卷积得到的maxtrix划分成新maxtrix并取每个划分区域的最大值</li>
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/chapter21-18.png" alt=""></li>
</ul>
</li>
<li class="lvl-3">
<p>flatten layer（）</p>
<ul class="lvl-2">
<li class="lvl-5"><mark>feature map拉直</mark>，拉直之后就可以丢到fully connected feedforward netwwork</li>
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/chapter21-22.png" alt=""></li>
</ul>
</li>
</ol>
<blockquote>
<p>假设第一层filter有2个，第二层的filter在考虑这个imput时是会考虑深度的，并不是每个channel分开考虑，而是一次考虑所有的channel。所以<mark>convolution有多少个filter，output就有多少个filter</mark>(convolution有25个filter，output就有25个filter。只不过，这25个filter都是一个立方体)</p>
</blockquote>
<h4 id="卷积-in-keras">卷积 in Keras</h4>
<p><strong>model.add(Convolution2D</strong>( <strong>25, 3, 3</strong>)</p>
<p>25代表有25个filter，3 *3代表filter是一个3 *3的matrix</p>
<p><strong>Input_shape=(28,28,1)</strong></p>
<p>假设我要做手写数字辨识，<mark>input是28 *28的image，每个pixel都是单一颜色</mark>。所以input_shape是(1,28,28)。如果是黑白图为1(blacj/white)，如果是彩色的图时为3(每个pixel用三个值来表述)。</p>
<p><strong>MaxPooling2D(( 2, 2 ))</strong></p>
<p>2,2表示把2*2的feature map里面的pixel拿出来，选择max value</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/chapter21-24.png" style="zoom:50%;" />
<blockquote>
<p>第二次的Convolution中的filter的大小是3*3但是每个filter的深度是上一次Convolution的filter数25，因此每个filter的参数个数为25 * 3 * 3 = 225</p>
</blockquote>
<h4 id="实例习题">实例习题</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230212115701358.png" alt="image-20230212115701358"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230212123449580.png" alt="image-20230212123449580"></p>
<h4 id="应用">应用</h4>
<ol>
<li class="lvl-3">
<p>围棋AlphaGo</p>
</li>
<li class="lvl-3">
<p>语音</p>
</li>
<li class="lvl-3">
<p>文本</p>
</li>
<li class="lvl-3">
<p>虽然文本和语音是一维的时序数据，但是可以用卷积神经网络</p>
</li>
<li class="lvl-3">
<p>类激活图(class activation map)可视化方法是指对输入图像<mark>生成类激活的热力图</mark></p>
</li>
<li class="lvl-3">
<p>卷积神经网络一定会用到池化层</p>
</li>
<li class="lvl-3">
<p>从空白输入图像开始，将梯度上升应用于已训练好的卷积神经网络输入图像的值，从而让某个过滤器的响应最大化，这样可以通过可视化的形式观察卷积神经网络学到的过滤器</p>
</li>
</ol>
<h3 id="cnn与gcn">CNN与GCN</h3>
<h6 id="比较卷积神经网络cnn和图卷积神经网络gcn的异同">比较卷积神经网络CNN和图卷积神经网络GCN的异同</h6>
<ol>
<li class="lvl-3">
<p>CNN 和GCN 都是通过对空间的卷积操作提取数据的空间相关性，但<mark>CNN只能适用于规整的网格型数据</mark>，而GCN能够适用于更具一般性的图结构数据。</p>
</li>
<li class="lvl-3">
<p>CNN 的卷积操作本质上是将矩阵转化为向量后的向量内积，而GCN 的卷积本质上是傅里叶/小波变换在图结构数据上的拓展。</p>
</li>
<li class="lvl-3">
<p>GCN 的卷积操作由<u>邻居节点消息发送、节点的消息接收、节点信息融合</u>，以及节点信息更新组成，而<mark>CNN可以看成GCN 卷积操作在网格型图上的一种特例</mark>。</p>
</li>
<li class="lvl-3">
<p>CNN 的池化操作一般是<mark>平均池化或最大池化</mark>，GCN 的池化比较复杂，涉及到图结构数据中节点到聚类中心的分配。</p>
</li>
</ol>
<h3 id="图神经网络gcn">图神经网络GCN</h3>
<p>GCN的卷积运算包含以下步骤：</p>
<ol>
<li class="lvl-3">
<p>节点消息传播</p>
</li>
<li class="lvl-3">
<p>节点消息接收</p>
</li>
<li class="lvl-3">
<p>节点信息融合</p>
</li>
</ol>
<h3 id="词嵌入模型">词嵌入模型</h3>
<p>关于词嵌入模型的正确说法：</p>
<ol>
<li class="lvl-3">
<p>在多语言嵌入模型中，来自不同语言的具有相似语义信息的词汇可以得到类似的嵌入表达</p>
</li>
<li class="lvl-3">
<p>在多领域嵌入模型中，来自不同领域（文本、图像、语音等）的具有相似语义信息的实体可以得到类似的嵌入表达</p>
</li>
<li class="lvl-3">
<p>词嵌入模型没有考虑词汇在句子中的先后关系</p>
</li>
<li class="lvl-3">
<p>英语词汇的时态关系在词嵌入模型中可以保留</p>
</li>
</ol>
<h2 id="判断题"><mark>判断题</mark></h2>
<p>1.反向传播算法由前向和向传递两个阶段构成✔️<br>
2.mini-batch相比于随机梯度下降(SGG)优势在于可以通过GPU进行并行处理✔️</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>是的，mini-batch相比于随机梯度下降(SGD)的一个优势是可以通过GPU进行并行处理。</p>
<p>在SGD中，每个样本都被用于更新模型参数，因此每个样本都需要进行一次前向传递和一次反向传递。这种逐个样本处理的方式不利于GPU并行计算，因为GPU在进行计算时需要同时处理多个数据。因此，SGD难以充分利用GPU的并行计算能力，导致训练速度较慢。</p>
<p>相比之下，mini-batch将一部分数据样本组成一个batch，然后用这个batch进行一次前向传递和一次反向传递，从而更新模型参数。这样做的好处是，GPU可以同时处理batch中的多个数据，从而充分利用GPU的并行计算能力，加速模型训练。</p>
<p>因此，使用mini-batch进行模型训练可以在一定程度上提高训练速度，并且更适合使用GPU进行并行计算。</p>
</li>
</ul>
</blockquote>
<p>3.由CNN构成的分类模型一般不包含全连接层❌<br>
4.相比于浅层神经网络，深层神经网络实际上利用了模块化的思想✔️<br>
5.在图像识别和语音识别中，深层神经网络模型训练后都发现越是靠近输入层的神经元学出的特征越是抽象❌<br>
6.<mark>词嵌入</mark>是一种<u>无需损失函数（？）</u>的<mark>无监督学习模型</mark>❌</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Word2Vec模型是一种无需损失函数的无监督学习模型</p>
</li>
<li class="lvl-2">
<blockquote>
<p>词嵌入是一种用于将单词转换为低维向量表示的技术。通常情况下，词嵌入是通过训练一个神经网络模型来学习单词向量的。因此，词嵌入模型可以是有监督学习模型也可以是无监督学习模型，具体取决于模型的训练方式。</p>
<p>其中一种广泛使用的无监督学习模型是Word2Vec，该模型使用了跳字模型（Skip-gram）和连续词袋模型（CBOW）来学习单词向量。这些模型的训练过程是无监督的，因为它们不需要标注的标签或者目标，只需要使用输入的文本数据就可以完成模型训练。因此，Word2Vec模型是一种无需损失函数的无监督学习模型，它通过最大化一个特定的目标函数来学习单词向量，通常是最大化文本数据中单词序列的联合概率分布。</p>
<p>然而，还有其他一些词嵌入模型，如GloVe和FastText，它们可能采用不同的训练方法或目标函数，有些可能是有监督学习模型或半监督学习模型。因此，是否需要损失函数和监督信号，以及模型是否为无监督学习模型，取决于具体的词嵌入模型。</p>
</blockquote>
</li>
</ul>
<p>7,全连接前馈神经网络DN从数据相关性角度来看，实际上是检测数据在一维空间上的全局相关性或全局模式✔️<br>
8.从数据相关性角度来看，GCN检测的是数据在离散的非欧高维空间上节点与其邻居节点空间邻域结构上的相关性✔️<br>
9.从数据相关性角度来看，RNN检测的是数据在一维时序数据上的空间相关性✔️<br>
10.从各隐藏层神经元的视野域等角度来看，CNN隐藏层每个神经元的视野域是其每个输入神经元视野域的并集✔️<br>
11.神经网络从计算上可以看成矩阵运算和非线性运算的多次叠加而组成的复合函数，且网络叠加的层次可看成复合函数的嵌套深度了✔️<br>
12.随机梯度下降运行速度要比梯度下降慢❌<br>
13.深层神经网络和浅层神经网络从对函数的表示能力角度来看是差不多的，但对于同样的机器学习任务，深层神经网络相对于浅层神经网络效率上更高✔️<br>
14,词嵌入模型中输出的即为词汇的嵌入表示✔️</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>词嵌入模型中输出的即为词汇的嵌入表示吗？是的，词嵌入模型的输出就是每个词汇的嵌入表示。词嵌入模型是一种将词汇映射到低维空间中的向量表示的技术，它将词汇表示为连续的低维向量，也称为嵌入向量或词嵌入（Word Embedding）。</p>
<p>在词嵌入模型中，通常使用神经网络或矩阵分解等方法来训练模型。训练过程中，模型会学习到每个词汇的嵌入向量，这些嵌入向量可以用于表示词汇的语义信息、上下文信息等，有利于词汇的文本处理和语言模型的建立等任务。</p>
<p>在自然语言处理（NLP）中，词嵌入模型已经成为了一种基本的技术，被广泛应用于各种任务中，如情感分析、机器翻译、文本分类、问答系统等。</p>
</li>
</ul>
</blockquote>
<p>15.深度自编码器的解码器和编码器必须是对称的❌<br>
16.在基于卷积的自编码器中卷积运算和反卷积运算实际上是同一种运算✔️</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>在基于卷积的自编码器（Convolutional Autoencoder）中，卷积运算和反卷积运算是不同的运算，它们在实现上有所不同，但是它们的目的都是提取和还原图像的特征。</p>
<p>卷积运算和反卷积运算的区别主要体现在其运算过程中卷积核的使用方式上。卷积运算通过将一个卷积核在输入图像上滑动并进行点积计算，从而提取出输入图像的特征。反卷积运算则是将卷积核在输出特征图上滑动，并通过填充（padding）和步长（stride）的设置，将输出特征图的大小还原为输入图像的大小。</p>
<p>因此，卷积运算和反卷积运算虽然实现上不同，但它们都是一种类似的局部连接和参数共享的操作。在基于卷积的自编码器中，卷积运算用于提取图像特征，反卷积运算用于通过特征图还原原始图像。为了提高自编码器的性能，通常还需要加入池化层、上采样层等其他操作，以实现更高效和更精确的特征提取和还原。</p>
</li>
</ul>
</blockquote>
<h2 id="简答题">简答题</h2>
<h3 id="深度学习的本质是什么？">深度学习的本质是什么？</h3>
<blockquote>
<p>深度学习是一种人工智能领域中的机器学习方法，其本质是通过构建深度神经网络来学习数据中的复杂模式和规律。与传统机器学习方法不同，深度学习算法不需要手动提取特征，而是通过多层神经元对数据进行逐层抽象和表示学习，从而自动发现和提取有用的特征。</p>
<p>在深度学习中，神经网络通常包括多个隐藏层，每个隐藏层都由多个神经元组成，每个神经元将上一层的输出作为输入，并根据一定的权重和偏置进行计算，最终输出到下一层。通过不断地调整网络的权重和偏置，使得网络输出的结果与真实值之间的误差最小化，从而实现模型的优化和训练。</p>
<p>深度学习的本质是利用大量的数据和计算能力，自动发现并利用数据中的模式和规律，从而实现对复杂问题的准确建模和预测。通过不断增加神经网络的深度和复杂度，深度学习已经在多个领域取得了突破性的进展，例如图像识别、语音识别、自然语言处理等。</p>
</blockquote>
<h3 id="深度学习训练阶段的三个基本步骤？">深度学习训练阶段的三个基本步骤？</h3>
<blockquote>
<p>深度学习的训练通常可以分为以下三个基本步骤：</p>
<ol>
<li class="lvl-3">正向传播（Forward Propagation）：通过将输入数据喂给神经网络，让其从第一层开始逐层向前计算，直到计算出网络的输出值，这个过程就称为正向传播。在正向传播过程中，每个神经元会根据其输入和权重计算输出，并将输出传递到下一层，最终得到神经网络的输出。</li>
<li class="lvl-3">反向传播（Backward Propagation）：反向传播是深度学习中最关键的一个步骤。在反向传播中，先计算出神经网络输出的误差，然后从输出层开始逐层向后传递，通过链式法则计算每个神经元的误差贡献，并根据误差梯度调整每个神经元的权重和偏置。</li>
<li class="lvl-3">权重更新：在反向传播过程中，计算出了每个神经元的误差贡献，但并没有立即更新权重和偏置。为了避免过拟合，通常使用随机梯度下降（Stochastic Gradient Descent, SGD）等优化算法来更新权重和偏置，使得神经网络的误差逐渐减小，最终收敛到最优解。</li>
</ol>
<p>这三个步骤通常是交替进行的，即先进行一次正向传播和反向传播来计算误差梯度，然后再根据梯度更新权重和偏置。这个过程会不断迭代，直到神经网络的误差收敛到一个满意的水平或者达到预定的迭代次数。</p>
</blockquote>
<h3 id="为什么第一个步骤-正向传播-是必要的？">为什么第一个步骤(正向传播)是必要的？</h3>
<blockquote>
<p>在深度学习中，正向传播是必要的步骤之一，因为它是神经网络中的信息传递和计算过程，是得到神经网络输出的第一步。</p>
<p>正向传播的过程可以理解为神经网络的前向运算，将输入数据从第一层输入到神经网络中，通过一系列非线性变换，逐层提取数据中的特征，最终得到神经网络的输出。在这个过程中，每个神经元都会根据其输入和权重计算输出，同时将输出传递到下一层，最终得到输出层的输出。正向传播的结果即为神经网络的预测值。</p>
<p>正向传播的结果将会被用于计算预测值与真实值之间的误差，并进一步用于反向传播更新神经网络的权重和偏置。因此，正向传播不仅是得到神经网络输出的第一步，还是训练神经网络所必须的步骤之一。</p>
<p>此外，正向传播也有助于理解神经网络中的信息流和非线性变换，有助于理解神经网络的计算过程和特征提取能力。正向传播的结果可以用于可视化神经网络的隐藏层特征，有助于理解神经网络中所学到的特征和模式。</p>
</blockquote>
<h3 id="无监督模型不需要人工标注标签-是否无法完成第二个步骤-反向传播-？为什么？">无监督模型不需要人工标注标签，是否无法完成第二个步骤(反向传播)？为什么？</h3>
<blockquote>
<p>无监督学习模型也需要进行反向传播，但是与有监督学习不同，它不需要标签作为目标输出，而是通过学习数据的内在结构来调整神经网络的权重。</p>
<p>在无监督学习中，通常会使用一些自编码器（autoencoder）等无监督学习模型，通过自编码器将输入数据压缩成低维的特征向量，然后再将特征向量解码为与输入数据相同的维度。在训练过程中，无监督学习模型需要最小化重构误差，即输入数据与解码后的数据之间的差异。</p>
<p>在反向传播中，无监督学习模型会计算重构误差对于神经网络参数（包括权重和偏置）的梯度，并根据梯度调整网络参数，从而使得神经网络的重构误差逐渐减小。这个过程与有监督学习中的反向传播类似，但是无监督学习模型的反向传播不需要使用标签来计算误差。</p>
<p>需要注意的是，无监督学习的反向传播过程中并不会计算输出与目标之间的误差，而是使用一些不同的损失函数来衡量模型的性能，如重构误差、对比损失等。因此，虽然无监督学习不需要标签来进行训练，但它仍然需要进行反向传播来更新神经网络的权重和偏置。</p>
</blockquote>
<h3 id="第三个步骤-权重更新-所用的主要算法的基本原理？">第三个步骤(权重更新)所用的主要算法的基本原理？</h3>
<blockquote>
<p>第三个步骤中使用的主要算法是随机梯度下降（Stochastic Gradient Descent，SGD），它是深度学习中最基本和最常用的优化算法之一。</p>
<p>SGD的基本原理是根据损失函数的梯度信息来调整神经网络的权重和偏置，从而使得损失函数最小化。在每一轮训练中，SGD从训练集中随机选择一小批数据（称为mini-batch），计算这些数据的损失函数关于神经网络参数的梯度，然后使用梯度来更新神经网络参数，从而使得损失函数逐渐减小。</p>
<p>SGD的更新公式如下：</p>
<p>W = W - learning_rate * dW</p>
<p>其中，W表示神经网络的权重矩阵，dW表示损失函数关于权重矩阵的梯度，learning_rate表示学习率，它控制着每次参数更新的大小。</p>
<p>SGD有很多变体，如动量（Momentum）、AdaGrad、RMSProp、Adam等，它们都是在SGD的基础上做出的改进，用于加快模型训练、提高模型性能等。其中，动量算法（Momentum）通过加入一个动量项来平滑梯度下降的过程，加快收敛速度；AdaGrad算法可以自适应地调整学习率，从而更好地适应不同的参数；RMSProp算法通过对梯度进行平均来调整学习率，可以减少梯度的方差，从而更加稳定；Adam算法则结合了动量和自适应学习率的思想，具有更好的性能和收敛速度。</p>
<p>总之，SGD是深度学习中非常重要的优化算法，它通过使用梯度信息来调整神经网络的参数，使得损失函数最小化，从而实现对神经网络的训练和优化。同时，SGD的一些改进算法也可以帮助深度学习模型更快地收敛、更好地适应不同的数据分布和损失函数形式。</p>
</blockquote>
<h3 id="cnn图像识别所考虑的三个准则分别是？">CNN图像识别所考虑的三个准则分别是？</h3>
<blockquote>
<p>1、局部性准则</p>
<p>2、参数共享准则</p>
<p>3、子采样准则</p>
</blockquote>
<h3 id="三个准则分别靠cnn的哪些网络层所实现的？">三个准则分别靠CNN的哪些网络层所实现的？</h3>
<blockquote>
<p>在CNN中，三个准则通常通过不同的网络层来实现：</p>
<ol>
<li class="lvl-3">局部性准则 - 卷积层</li>
<li class="lvl-3">参数共享准则 -  卷积层</li>
<li class="lvl-3">子采样准则 - 池化层</li>
</ol>
</blockquote>
<h3 id="第2问中的各个网络层所起到的作用分别是什么？">第2问中的各个网络层所起到的作用分别是什么？</h3>
<blockquote>
<ol>
<li class="lvl-3">
<p>卷积层 (Convolutional Layers)：卷积层是CNN中最重要的层之一，它通过卷积运算来提取图像的特征。卷积层通常位于网络的前几层，它们可以检测图像中的低级特征，例如边缘、角、颜色等等。</p>
</li>
<li class="lvl-3">
<p>池化层 (Pooling Layers)：池化层通常紧随卷积层之后，用于降低特征图的维度和参数数量，同时可以帮助网络对图像的平移、缩放等变换具有一定的不变性。池化层通常使用最大池化或平均池化来实现。</p>
</li>
<li class="lvl-3">
<p>全连接层 (Fully Connected Layers)：全连接层通常位于网络的最后一层，用于将特征图映射到类别标签上。全连接层中的每个神经元都与前一层的所有神经元相连，每个输出神经元对应一个类别标签。全连接层通常使用softmax激活函数来计算每个类别的概率分布。</p>
</li>
</ol>
</blockquote>
<h3 id="keras程序理解">Keras程序理解</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Keras实现CNN</p>
</li>
</ul>
<h4 id="使用mnist数据集训练了一个简单的cnn模型">使用MNIST数据集训练了一个简单的CNN模型</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入Keras和一些其他必要的库</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D, Flatten, Dense</span><br><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()</span><br><span class="line"><span class="comment"># 将数据集reshape成4D张量</span></span><br><span class="line">x_train = x_train.reshape((x_train.shape[<span class="number">0</span>], <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">x_test = x_test.reshape((x_test.shape[<span class="number">0</span>], <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 数据归一化</span></span><br><span class="line">x_train = x_train / <span class="number">255.0</span></span><br><span class="line">x_test = x_test / <span class="number">255.0</span></span><br><span class="line"><span class="comment"># 将标签one-hot编码</span></span><br><span class="line">y_train = keras.utils.to_categorical(y_train)</span><br><span class="line">y_test = keras.utils.to_categorical(y_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型:</span></span><br><span class="line"><span class="comment"># 首先定义了一个Sequential模型，然后依次添加了卷积层Conv2D和池化层MaxPooling2D，最后是全连接层Dense</span></span><br><span class="line">model = Sequential() <span class="comment"># 首先定义了一个Sequential模型</span></span><br><span class="line"><span class="comment"># 对于Conv2D和MaxPooling2D，</span></span><br><span class="line"><span class="comment"># 第一个参数表示卷积核（或池化窗口）的数量，</span></span><br><span class="line"><span class="comment"># 第二个参数表示卷积核的大小。</span></span><br><span class="line">model.add(Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))<span class="comment"># 序列模型加入32个*3*3大小的卷积核的卷积层（输入的形状28x28的灰度图像。在后续层中，输入形状会自动推断。激活函数使用ReLU）</span></span><br><span class="line">model.add(MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))<span class="comment"># 序列模型加入一个池化窗口大小2*2的池化层</span></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))<span class="comment"># 序列模型加入64个*3*3大小的卷积核的卷积层（激活函数使用ReLU）</span></span><br><span class="line">model.add(MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))<span class="comment"># 序列模型加入一个池化窗口大小2*2的池化层</span></span><br><span class="line">model.add(Flatten())<span class="comment"># 把多维的输入一维化，用在从卷积层到全连接层的过渡</span></span><br><span class="line"><span class="comment"># 在全连接层中，我们添加了两个Dense层。</span></span><br><span class="line">model.add(Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))<span class="comment"># 第一个Dense层有64个神经元，使用ReLU激活函数；</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))<span class="comment"># 第二个Dense层有10个神经元，使用softmax激活函数，表示输出10个类别的概率。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])<span class="comment"># 使用adam优化器、交叉熵损失函数和准确率作为评估指标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">10</span>, batch_size=<span class="number">32</span>, validation_data=(x_test, y_test))<span class="comment">#使用训练集x_train和y_train来训练模型，指定了10个epoch，每个batch大小为32。同时，我们还使用了测试集x_test和y_test来验证模型的性能。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用测试集评估模型</span></span><br><span class="line">test_loss, test_acc = model.evaluate(x_test, y_test)<span class="comment"># 使用测试集x_test和y_test来评估模型的性能，并输出测试集的准确率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, test_acc)</span><br></pre></td></tr></table></figure>
<h4 id="真题-用卷积神经网络进行mnist手写数字识别">真题.用卷积神经网络进行MNIST手写数字识别</h4>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230219211742477.png" alt="image-20230219211742477"></p>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230219211759114.png" alt="image-20230219211759114"></p>
<p>其它基本与上面demo一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(train_images,train_labels).(test_images.test_labels)=mnist.load_data() <span class="comment"># 加载mnist数据集</span></span><br><span class="line">train_images = train_images.reshape((<span class="number">60000.28</span><span class="number">.28</span><span class="number">.1</span>)) <span class="comment"># # 将数据集reshape成4D张量：6万张训练图片，数据维度转化，增加了通道维度</span></span><br><span class="line">train_images = train_images.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span> <span class="comment"># 归一化：将像素的值标准化至0到1的区间内。</span></span><br><span class="line"></span><br><span class="line">train_labels = to_categorical(train_labels) <span class="comment"># 将标签one-hot编码：将类别向量转换为二进制(只有0和1)的矩阵类型表示</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Keras实现神经网络</p>
</li>
</ul>
<h4 id="用神经网络实现手写体数字识别">用神经网络实现手写体数字识别</h4>
<p>书37页</p>
<h3 id="深度学习中单个神经元与线性回归-逻辑回归-分类问题之间的关系？">深度学习中单个神经元与线性回归，逻辑回归，分类问题之间的关系？</h3>
<blockquote>
<p>单个神经元是深度学习的基本构建块之一，通常用于解决分类问题。在深度学习中，单个神经元通常包括输入、权重、偏差和激活函数。单个神经元将输入值加权求和，加上偏差，然后将该总和传递给激活函数，以产生输出。</p>
<p>线性回归和逻辑回归也是解决分类问题的基本算法之一。在线性回归中，我们试图找到一个最适合数据的线性函数，该函数可以将输入变量映射到连续的输出变量。而在逻辑回归中，我们试图找到一个最适合数据的Sigmoid函数，该函数可以将输入变量映射到一个二元输出变量（0或1）。</p>
<p>从形式上看，单个神经元的计算过程与线性回归和逻辑回归非常相似。事实上，可以将线性回归和逻辑回归看作是一种特殊类型的神经网络，其中只有一个神经元。通过组合多个这样的神经元，我们可以构建更复杂的神经网络，以解决更复杂的分类问题。</p>
</blockquote>
<h3 id="独热编码的概念？">独热编码的概念？</h3>
<blockquote>
<p>独热编码（One-Hot Encoding）是一种将分类数据转换为计算机可处理格式的编码方式。它将每个分类值映射到一个整数值，然后将这些整数值用一个二进制向量表示，其中只有一个位置是 1，其余位置都是 0。这个唯一的位置对应于整数值，表示该分类值的存在。</p>
<p>例如，假设有一个颜色变量，可能的取值为 “red”、“green” 和 “blue”。将这些取值转换为独热编码将得到：</p>
<table>
<thead>
<tr>
<th>颜色</th>
<th>red</th>
<th>green</th>
<th>blue</th>
</tr>
</thead>
<tbody>
<tr>
<td>red</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>green</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>blue</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>通过使用独热编码，可以将分类变量转换为计算机可以处理的形式，并可以在机器学习模型中使用这些编码变量。</p>
</blockquote>
<h3 id="词嵌入模型的工作原理？">词嵌入模型的工作原理？</h3>
<blockquote>
<p>词嵌入模型是一种将自然语言文本中的单词映射到实数值向量的技术。它能够捕捉单词之间的语义和上下文关系，并为自然语言处理（NLP）任务提供了有用的表示。</p>
<p>词嵌入模型的工作原理可以分为以下几个步骤：</p>
<ol>
<li class="lvl-3">
<p>数据预处理：首先需要对文本进行预处理，例如分词、去除停用词等。</p>
</li>
<li class="lvl-3">
<p>建立词汇表：将预处理后的文本中所有的单词建立一个词汇表，每个单词对应一个唯一的整数标识。</p>
</li>
<li class="lvl-3">
<p>训练模型：通过对大量的语料库进行训练，词嵌入模型可以学习到每个单词的向量表示。其中，最常用的词嵌入模型是 Word2Vec 和 GloVe。</p>
</li>
<li class="lvl-3">
<p>应用模型：训练好的模型可以用于不同的NLP任务，例如情感分析、文本分类、命名实体识别等。</p>
</li>
</ol>
<p>Word2Vec 模型使用两种不同的架构进行训练，分别为连续词袋模型（CBOW）和Skip-Gram模型。CBOW模型根据上下文单词来预测当前单词，而Skip-Gram模型则根据当前单词来预测上下文单词。GloVe模型则是基于全局统计信息进行训练，将单词之间的共现信息转换为向量表示。</p>
<p>总之，词嵌入模型利用机器学习算法将自然语言中的单词映射到低维向量空间中，从而能够有效地捕捉单词之间的语义和上下文关系。</p>
</blockquote>
<h3 id="词嵌入模型中为什么语义相近的词汇通常有相似的嵌入表示？">词嵌入模型中为什么语义相近的词汇通常有相似的嵌入表示？</h3>
<blockquote>
<p>在词嵌入模型中，语义相近的词汇通常会被赋予相似的嵌入表示，这是因为词嵌入模型是基于语料库中的上下文信息进行训练的，而语义相近的单词通常会在上下文中出现在类似的语境中。</p>
<p>例如，在一个包含 “apple”、“orange” 和 “banana” 的语料库中，这些单词可能会在 “水果” 的上下文中出现，因此它们会被认为在语义上相近。如果我们使用 Word2Vec 模型进行训练，它会学习到将这些单词映射到低维向量空间中的向量表示。由于它们在上下文中的共现信息相似，所以它们在向量空间中的距离也会比较接近。</p>
<p>另外，词嵌入模型还可以通过使用负采样（Negative Sampling）等技术来调整单词之间的相似度。通过在训练过程中引入噪声单词，并使嵌入向量在某些方向上更多地适应噪声单词，我们可以更好地调整词向量的相似度，并更准确地捕捉单词之间的语义关系。</p>
<p>因此，词嵌入模型之所以能够为语义相近的单词学习到相似的向量表示，是因为它利用了语料库中单词的上下文信息，并通过训练过程中的优化算法来调整单词之间的相似度。</p>
</blockquote>
<h3 id="从网络结构-输入数据形式和数据之间的关联-提取数据特征的相关性-各隐藏层神经-dnn-cnn-rnn-gcn异同？">从网络结构，输入数据形式和数据之间的关联，提取数据特征的相关性，各隐藏层神经、DNN，CNN，RNN，GCN异同？</h3>
<p>DNN(深度神经网络)，CNN(卷积神经网络)，RNN(循环神经网络)，GCN(图卷积神经网络)</p>
<blockquote>
<p>神经网络是一种用于机器学习和深度学习的模型，它由输入层、隐藏层和输出层组成。隐藏层是神经网络的核心，它可以提取数据的特征并将其转化为更高层次的表示。神经网络的结构可以根据不同的任务和数据类型进行优化。</p>
<p>以下是一些不同类型的神经网络以及它们之间的区别：</p>
<ol>
<li class="lvl-3">
<p>DNN（深度神经网络）：DNN由多个隐藏层组成，每个隐藏层都包含多个神经元，每个神经元都与上一层的所有神经元相连。DNN通常用于处理结构化数据，如数字或文本，其输入数据形式通常是向量或矩阵。</p>
</li>
<li class="lvl-3">
<p>CNN（卷积神经网络）：CNN通过使用卷积层和池化层提取输入数据的特征，以适应图像、视频和语音等非结构化数据的处理。卷积层会对输入数据进行局部卷积操作，以提取输入数据的局部特征，而池化层则会对卷积层的输出进行降采样，以减少数据的维度。CNN的输入数据形式通常是图像、音频或视频等多维数组。</p>
</li>
<li class="lvl-3">
<p>RNN（循环神经网络）：RNN的隐藏层神经元之间形成循环结构，使得前一时刻的输出可以作为当前时刻的输入。这使得RNN适用于处理序列数据，如时间序列、自然语言和音频数据。RNN通过使用门控单元（如LSTM或GRU）来解决长期依赖问题，以避免梯度消失或梯度爆炸的问题。</p>
</li>
<li class="lvl-3">
<p>GCN（图卷积网络）：GCN是一种用于处理图数据的神经网络，其输入数据通常是节点和边的列表。GCN通过使用卷积层来学习节点的嵌入表示，以提取图的结构信息和节点之间的关系。GCN还使用池化层来减少节点的数量，以适应更大的图。</p>
</li>
</ol>
<p>总的来说，不同类型的神经网络适用于不同类型的数据和任务，它们通过不同的方式提取和处理数据的特征，并将其转化为更高层次的表示。</p>
</blockquote>
<h3 id="单个神经元作用小-多个大？">单个神经元作用小，多个大？</h3>
<blockquote>
<p>单个神经元作用小的原因在于它只能对输入数据做出非常简单的线性变换和激活操作，很难对复杂的模式和特征进行捕捉。而多个神经元可以通过组合和并行处理不同的输入特征，提取更复杂的特征表示，从而更好地完成任务。</p>
<p>具体来说，多个神经元的组合可以实现更复杂的非线性函数，能够学习更丰富的特征表示。同时，隐藏层的深度越多，神经元的数量也越多，神经网络的表达能力也会更加强大。这意味着神经网络可以对数据进行更深入的学习和建模，从而更准确地预测结果。</p>
<p>此外，多个神经元还可以通过并行处理输入数据的不同方面来提高效率和准确性。比如，在图像分类任务中，一个神经元可能专门处理边缘特征，另一个神经元则处理颜色和纹理特征，多个神经元的组合可以更好地捕捉图像中的多个方面特征。</p>
<p>因此，多个神经元通常可以提高神经网络的表达能力和性能，使其更好地适应复杂的数据和任务。</p>
</blockquote>
<h3 id="现有深度学习模型的局限性？">现有深度学习模型的局限性？</h3>
<blockquote>
<p>深度学习模型已经在许多领域中取得了显著的进展，如图像识别、自然语言处理、语音识别等。然而，深度学习模型仍然存在一些局限性：</p>
<ol>
<li class="lvl-3">数据需求量大：深度学习模型需要大量的标注数据来进行训练，而这些数据往往需要人工标注，成本较高。缺乏足够的数据可能会导致过拟合，从而影响模型的性能。</li>
<li class="lvl-3">模型复杂性高：深度学习模型通常由多个层和大量的参数组成，需要消耗大量的计算资源和时间进行训练。此外，模型结构的设计和调整也需要高度的专业知识和经验。</li>
<li class="lvl-3">可解释性差：深度学习模型通常是黑盒模型，其决策过程和内部表示难以理解和解释。这使得深度学习模型在某些需要解释和可靠性保证的场景中受到限制，如医疗诊断和司法决策等。</li>
<li class="lvl-3">对抗攻击易受影响：深度学习模型容易受到对抗性样本的攻击，即对模型输入进行微小的修改，可以使模型做出错误的决策。这对于安全性和可靠性的场景来说是一项重要的挑战。</li>
<li class="lvl-3">数据分布偏差：深度学习模型在训练过程中可能会受到数据分布偏差的影响，即训练集与实际应用场景的数据分布不一致，从而影响模型的泛化能力。</li>
<li class="lvl-3">缺乏因果关系：深度学习模型通常只能捕捉数据之间的相关性，而难以建立因果关系。这意味着深度学习模型可能无法解释事件之间的因果关系，从而在一些决策和预测场景中受到限制。</li>
</ol>
<p>以上是深度学习模型目前存在的一些局限性，这些局限性需要通过不断的研究和技术创新来解决，以进一步提高深度学习模型的性能和可靠性。</p>
</blockquote>
<h3 id="分别通过dnn-cnn-gcn刻画城市各个路段的车速的空间相关性？">分别通过DNN，CNN，GCN刻画城市各个路段的车速的空间相关性？</h3>
<blockquote>
<p>针对城市路段的车速数据，可以使用不同的神经网络架构来刻画其空间相关性，包括深度神经网络（DNN），卷积神经网络（CNN）和图卷积网络（GCN）。以下是每种神经网络架构的示例用法：</p>
<p>1、DNN（深度神经网络）：</p>
<p>深度神经网络是一种前馈神经网络，其目的是从输入数据中学习一个映射函数，以预测目标变量。在此场景下，输入是车速数据，目标变量是城市各个路段的车速空间相关性。具体来说，可以使用多层感知器（MLP）模型，该模型具有多个隐藏层，并使用非线性激活函数来建模输入数据中的复杂关系。通过使用DNN，可以学习路段之间的非线性依赖性，并预测城市中各个路段之间的车速相关性。</p>
<p>2、CNN（卷积神经网络）：</p>
<p>卷积神经网络是一种专门用于处理具有网格结构输入数据的神经网络，如图像和时间序列数据。在城市路段的车速数据中，可以将每个路段的车速数据视为时间序列数据，并使用卷积神经网络来刻画空间相关性。在这种情况下，CNN可以看作是一种序列模型，其中每个路段的车速数据作为序列中的一个时间步骤。通过使用CNN，可以学习城市中不同路段之间的时空相关性，并预测路段之间的车速相关性。</p>
<p>3、GCN（图卷积神经网络）：</p>
<p>图卷积神经网络是一种专门用于处理图数据的神经网络，其中节点之间的连接形成了一个图结构。在城市路段的车速数据中，可以将每个路段视为图中的一个节点，并使用车速数据中的空间关系来建立图的连接。使用GCN，可以学习城市中不同路段之间的空间相关性，并预测路段之间的车速相关性。</p>
</blockquote>
<h1>科学计算与数学建模</h1>
<h4 id="课程学习内容：">课程学习内容：</h4>
<p>机器学习基础、线性回归、偏差和方差、梯度下降、分类、逻辑回归</p>
<p>深度学习概述、反向传播和<strong>Keras</strong>编程、卷积神经网络CNN</p>
<p>为何需要深层次的网络、自编码器、词嵌入模型、循环神经网络</p>
<p><strong>Meta Learning</strong>、<strong>AE attack</strong></p>
<h2 id="一-线性回归">一、线性回归</h2>
<p>线性模型假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>w</mi><mo separator="true">⋅</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y = b + w·x_{cp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7306em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> <mark>可以猜测很多模型（得到线性模型函数集）</mark>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>:</mo><mi>y</mi><mo>=</mo><mn>10.0</mn><mo>+</mo><mn>9.0</mn><mo separator="true">⋅</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub><mspace linebreak="newline"></mspace><msub><mi>f</mi><mn>2</mn></msub><mo>:</mo><mi>y</mi><mo>=</mo><mn>9.8</mn><mo>+</mo><mn>9.2</mn><mo separator="true">⋅</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub><mspace linebreak="newline"></mspace><msub><mi>f</mi><mn>3</mn></msub><mo>:</mo><mi>y</mi><mo>=</mo><mo>−</mo><mn>0.8</mn><mo>−</mo><mn>1.2</mn><mo separator="true">⋅</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub><mspace linebreak="newline"></mspace><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo></mrow><annotation encoding="application/x-tex">f_1: y = 10.0 + 9.0·x_{cp} \\
f_2: y = 9.8 + 9.2·x_{cp} \\
f_3: y = - 0.8 - 1.2·x_{cp} \\
···
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10.0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9305em;vertical-align:-0.2861em;"></span><span class="mord">9.0</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9305em;vertical-align:-0.2861em;"></span><span class="mord">9.2</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">0.8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9305em;vertical-align:-0.2861em;"></span><span class="mord">1.2</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mpunct">⋅⋅⋅</span></span></span></span></span></p>
<p><strong>问题转换为：从猜测的函数集中找到合适的y=b+w·<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex"> x_{cp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>函数刻画以上所有数据集的模型</strong></p>
<p>如何找到最合适的函数</p>
<h3 id="引入-损失函数">引入_损失函数</h3>
<blockquote>
<p>损失函数**L(f)<strong>是函数</strong>f=b+w·<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex"> x_{cp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>**的函数</p>
<p>input:a function	output:how bad it is</p>
<p>常见L(f)的定义方法——<strong>估计误差</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">L</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="normal">L</mi><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msup><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>n</mi></msup><mo>−</mo><mrow><mo fence="true">(</mo><mi>b</mi><mo>+</mo><mi>w</mi><mo>⋅</mo><msubsup><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow><mi>n</mi></msubsup><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\mathrm{L}(f) &amp;=\mathrm{L}(w, b) \\
&amp;=\sum_{n=1}^{N}\left(\hat{y}^{n}-\left(b+w \cdot x_{c p}^{n}\right)\right)^{2}
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8954em;vertical-align:-2.1977em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6977em;"><span style="top:-5.6861em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord mathrm">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span><span style="top:-3.1977em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1977em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6977em;"><span style="top:-5.6861em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span><span style="top:-3.1977em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1977em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul class="lvl-1">
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\hat{y}^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>真正数值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>w</mi><mo>⋅</mo><msubsup><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow><mi>n</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b+w \cdot x_{c p}^{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1331em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为当前函数的预测数值</p>
</li>
<li class="lvl-2">
<p>将每一只宝可梦（真正数值-预测数值）的平方和就是估测误差</p>
</li>
</ul>
</blockquote>
<p><strong>问题转换为：从猜测的函数集中找到损失函数L(f)最小的函数</strong></p>
<p>求出所有可能的模型的损失函数太费时</p>
<h3 id="引入-梯度下降">引入_梯度下降</h3>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo>=</mo><mi>arg</mi><mo>⁡</mo><msub><mrow><mi>min</mi><mo>⁡</mo></mrow><mi>f</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{*}=\arg \min _{f} L(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>w</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo separator="true">,</mo><msup><mi>b</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>arg</mi><mo>⁡</mo><munder><mrow><mi>min</mi><mo>⁡</mo></mrow><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></munder><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>arg</mi><mo>⁡</mo><munder><mrow><mi>min</mi><mo>⁡</mo></mrow><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mn>10</mn></munderover><msup><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>n</mi></msup><mo>−</mo><mrow><mo fence="true">(</mo><mi>b</mi><mo>+</mo><mi>w</mi><mo>⋅</mo><msubsup><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow><mi>n</mi></msubsup><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
w^{*}, b^{*} &amp;=\arg \min _{w, b} L(w, b) \\
&amp;=\arg \min _{w, b} \sum_{n=1}^{10}\left(\hat{y}^{n}-\left(b+w \cdot x_{c p}^{n}\right)\right)^{2}
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.3964em;vertical-align:-2.4482em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9482em;"><span style="top:-5.9093em;"><span class="pstrut" style="height:3.8011em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.92em;"><span class="pstrut" style="height:3.8011em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4482em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9482em;"><span style="top:-5.9093em;"><span class="pstrut" style="height:3.8011em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8882em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span><span style="top:-2.92em;"><span class="pstrut" style="height:3.8011em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8882em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4482em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>表示当函数L(f)取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>f</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">f=f^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>的时候，得到L(f)取值范围的最小值</p>
</blockquote>
<p><strong>问题转换为：求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo separator="true">,</mo><msup><mi>b</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">w^{*}, b^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>使得L(f)取值范围的最小值</strong></p>
<p>先从最简单的只有一个参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>入手，定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mo>∗</mo></msup><mo>=</mo><mi>a</mi><mi>r</mi><mi>g</mi><mtext> </mtext><mi><munder><mo><mi mathvariant="normal"><mi>min</mi><mo>⁡</mo></mi><mo>⁡</mo></mo><mi>x</mi></munder></mi><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w^* = arg\ \underset{x}{\operatorname{\min}} L(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.45em;vertical-align:-0.7em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mop"><span class="mop">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span></p>
<p><strong>问题转换为：求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">w^{*}, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span>使得L(w)取值范围的最小值</strong></p>
<blockquote>
<p>引入一个概念 学习率 ：移动的步长</p>
<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221005230548704.png" alt="image-20221005230548704" style="zoom: 33%;" />
<ul class="lvl-1">
<li class="lvl-2">
<p>步骤1：随机选取一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">w^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li class="lvl-2">
<p>步骤2：计算微分，也就是当前的斜率，根据斜率来判定移动的方向</p>
<ul class="lvl-3">
<li class="lvl-4">小于0向右移动（<strong>减少</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>）</li>
<li class="lvl-4">大于0向左移动（<strong>增加</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>）</li>
</ul>
</li>
<li class="lvl-2">
<p>步骤3：根据学习率移动</p>
</li>
<li class="lvl-2">
<p>重复步骤2和步骤3，直到找到最低点</p>
</li>
</ul>
<p>以上步骤能找到极小点，而在回归中极小点就是唯一最小点（No local optimal，疑问🤔️后面会讲）</p>
<p><mark>计算</mark></p>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>w</mi></mrow></mfrac><mo fence="true">∣</mo></mrow><mrow><mi>w</mi><mo>=</mo><msup><mi>w</mi><mn>0</mn></msup></mrow></msub></mrow><annotation encoding="application/x-tex">\left.\frac{d L}{d w}\right|_{w=w^{0}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2798em;vertical-align:-0.3997em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1227em;"><span style="top:-2.3003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3997em;"><span></span></span></span></span></span></span></span></span></span></strong></p>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mn>1</mn></msup><mo>←</mo><msup><mi>w</mi><mn>0</mn></msup><mo>−</mo><msub><mrow><mi>η</mi><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>w</mi></mrow></mfrac><mo fence="true">∣</mo></mrow><mrow><mi>w</mi><mo>=</mo><msup><mi>w</mi><mn>0</mn></msup></mrow></msub></mrow><annotation encoding="application/x-tex">w^{1} \leftarrow w^{0}-\left.\eta \frac{d L}{d w}\right|_{w=w^{0}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2798em;vertical-align:-0.3997em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1227em;"><span style="top:-2.3003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3997em;"><span></span></span></span></span></span></span></span></span></span></strong></p>
</blockquote>
<p>又当同时考虑两个参数的时候</p>
<blockquote>
<p><mark>计算</mark></p>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo fence="true">∣</mo></mrow><mrow><mi>w</mi><mo>=</mo><msup><mi>w</mi><mn>0</mn></msup><mo separator="true">,</mo><mi>b</mi><mo>=</mo><msup><mi>b</mi><mn>0</mn></msup></mrow></msub><mo separator="true">,</mo><msub><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>b</mi></mrow></mfrac><mo fence="true">∣</mo></mrow><mrow><mi>w</mi><mo>=</mo><msup><mi>w</mi><mn>0</mn></msup></mrow></msub><mo separator="true">,</mo><mi>b</mi><mo>=</mo><msup><mi>b</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">\left.\frac{\partial L}{\partial w}\right|_{w=w^{0}, b=b^{0}},\left.\frac{\partial L}{\partial b}\right|_{w=w^{0}}, b=b^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4159em;vertical-align:-0.5358em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1227em;"><span style="top:-2.3003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1227em;"><span style="top:-2.3003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></strong></p>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mn>1</mn></msup><mo>←</mo><msup><mi>w</mi><mn>0</mn></msup><mo>−</mo><msub><mrow><mi>η</mi><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo fence="true">∣</mo></mrow><mrow><mi>w</mi><mo>=</mo><msup><mi>w</mi><mn>0</mn></msup><mo separator="true">,</mo><mi>b</mi><mo>=</mo><msup><mi>b</mi><mn>0</mn></msup></mrow></msub><mspace width="1em"/><msup><mi>b</mi><mn>1</mn></msup><mo>←</mo><msup><mi>b</mi><mn>0</mn></msup><mo>−</mo><msub><mrow><mi>η</mi><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>b</mi></mrow></mfrac><mo fence="true">∣</mo></mrow><mrow><mi>w</mi><mo>=</mo><msup><mi>w</mi><mn>0</mn></msup><mo separator="true">,</mo><mi>b</mi><mo>=</mo><msup><mi>b</mi><mn>0</mn></msup></mrow></msub></mrow><annotation encoding="application/x-tex">w^{1} \leftarrow w^{0}-\left.\eta \frac{\partial L}{\partial w}\right|_{w=w^{0}, b=b^{0}} \quad b^{1} \leftarrow b^{0}-\left.\eta \frac{\partial L}{\partial b}\right|_{w=w^{0}, b=b^{0}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4159em;vertical-align:-0.5358em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1227em;"><span style="top:-2.3003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4159em;vertical-align:-0.5358em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1227em;"><span style="top:-2.3003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5358em;"><span></span></span></span></span></span></span></span></span></span></strong></p>
<p>同理No local optimal无局部最优</p>
<p>整理成一个简介的公式，即梯度</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi><mi>L</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>b</mi></mrow></mfrac></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mtext> gradient </mtext></mrow><annotation encoding="application/x-tex">\nabla L=\left[\begin{array}{l}
\frac{\partial L}{\partial w} \\
\frac{\partial L}{\partial b}
\end{array}\right] \text { gradient }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">∇</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4802em;vertical-align:-0.9901em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4901em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3699em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9901em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord"> gradient </span></span></span></span></span></p>
</blockquote>
<p>以上操作就可以得到线性回归的损失函数最小模型</p>
<p><strong>小插曲：如何评价模型？</strong></p>
<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221006203707421.png" alt="image-20221006203707421" style="zoom: 50%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>10</mn></mfrac><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msup><mi>e</mi><mi>n</mi></msup><mo separator="true">,</mo><mtext>其中</mtext><msup><mi>e</mi><mi>n</mi></msup><mtext>为点到模型的距离</mtext></mrow><annotation encoding="application/x-tex">\frac{N}{10} \sum_{n=1}^{N} e^{n},其中e^{n}为点到模型的距离</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">其中</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">为点到模型的距离</span></span></span></span></p>
<p>一般训练集会比测试集的小，因为原本模型求解损失函数最小就是基于训练集的</p>
<p>是否有更好的1元N次线性模型</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>b</mi><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><mo>⋅</mo><msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">y=b+w_{1} \cdot x_{c p}+w_{2} \cdot\left(x_{c p}\right)^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5945em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5945em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2401em;vertical-align:-0.2861em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>同理通过梯度下降求解最小损失函数时的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo separator="true">,</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b,w_{1},w_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>…还可以使用更高次方的模型</p>
<p>在训练集上面表现更为优秀的模型，为什么在测试集上效果反而变差了</p>
<p><strong>小插曲：过拟合问题的出现？</strong></p>
<blockquote>
<p>如图所示，每一个模型结果都是一个集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mtext>次模型包</mtext><mo>⊇</mo><mn>4</mn><mtext>次模型</mtext><mo>⊇</mo><mn>3</mn><mtext>次模型</mtext></mrow><annotation encoding="application/x-tex">5次模型包 \supseteq  4次模型 \supseteq  3次模型</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord">5</span><span class="mord cjk_fallback">次模型包</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊇</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord">4</span><span class="mord cjk_fallback">次模型</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊇</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord cjk_fallback">次模型</span></span></span></span>所以<mark>在4次模型里面找到的最佳模型，肯定不会比5次模型里面找到更差</mark></p>
<p>将错误率结果图形化展示，发现3次方以上的模型，已经出现了过拟合的现象：</p>
<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221006205944392.png" alt="image-20221006205944392" style="zoom: 50%;" />
</blockquote>
<p>优化</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Step1优化：2个input的四个线性模型是合并到一个线性模型中</p>
</li>
<li class="lvl-2">
<p>Step2优化：如果希望模型更强大表现更好（更多参数，更多input）</p>
</li>
<li class="lvl-2">
<p>Step3优化：加入正则化</p>
<ul class="lvl-2">
<li class="lvl-4">更多特征，但是权重 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 可能会使某些特征权值过高，仍旧导致overfitting，所以加入正则化<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221006211713472.png" alt="image-20221006211713472" style="zoom:50%;" />
<ul class="lvl-4">
<li class="lvl-6"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>越小，越平滑的function。但过小又回成水平线。需要调参<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span>,找到最合适的<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221006212324682.png" alt="image-20221006212324682" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二-偏差与方差">二、偏差与方差</h2>
<h3 id="数据模型的复杂度">数据模型的复杂度</h3>
<p>考虑的数据模型越复杂，训练效果越好，而预测可能出现过拟合现象。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/方差与偏差.jpeg" alt="方差与偏差" style="zoom: 50%;" />
<h4 id="textcolor-red-考-方差与偏差和模型的复杂关系是什么"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>方差与偏差和模型的复杂关系是什么</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.方差与偏差和模型的复杂关系是什么}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">方差与偏差和模型的复杂关系是什么</span></span></span></span></h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>来自ChatGPT</p>
</li>
</ul>
<p>方差和偏差是评估机器学习模型性能的两个重要指标。它们之间存在一定的关系，特别是与模型复杂度有关。</p>
<p>偏差是指模型的预测值与真实值之间的差异，它衡量的是模型的拟合能力。偏差大的模型容易欠拟合，即对训练数据的拟合不够好，而对测试数据的预测能力也会较差。</p>
<p>方差是指模型预测值的变化范围，它衡量的是模型的泛化能力。方差大的模型容易过拟合，即对训练数据的拟合过于好，而对测试数据的预测能力较差。</p>
<p>在模型复杂度较低时，偏差通常很高，方差很低。这是因为简单的模型可能无法很好地拟合数据，因此在不同的训练数据上得到的预测结果差别不大，方差较小。但是，在不同的训练数据上得到的预测结果与真实值之间的差距较大，偏差较高。</p>
<p>随着模型复杂度的增加，偏差逐渐降低，方差逐渐增加。这是因为复杂的模型可以更好地拟合数据，因此在不同的训练数据上得到的预测结果与真实值之间的差距较小，偏差较低。但是，复杂的模型也容易过拟合，即对训练数据的拟合过于好，而对测试数据的预测能力较差，方差较高。</p>
<p>因此，选择合适的模型复杂度可以在偏差和方差之间取得平衡，从而达到较好的预测性能。一般而言，可以使用交叉验证等技术来帮助选择合适的模型复杂度。</p>
</blockquote>
<h4 id="textcolor-red-考-判断-如果你的模型甚至不能拟合训练样本-那么你就有很大的偏差"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>判断</mtext><mo>−</mo><mtext>如果你的模型甚至不能拟合训练样本，那么你就有很大的偏差</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.判断-如果你的模型甚至不能拟合训练样本，那么你就有很大的偏差}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">判断</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">如果你的模型甚至不能拟合训练样本，那么你就有很大的偏差</span></span></span></span></h4>
<blockquote>
<p><mark>正确</mark>：欠拟合，大偏差</p>
<p>以下ppt前一页即是考试题的解释</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220920173540229.png" alt="image-20220920173540229" style="zoom: 25%;" />
<p>欠拟合：对训练样本的一般性质尚未学好。在训练集及测试集上的表现都不好。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>偏差大</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>低拟合简单的模型会有大的偏差，小的方差；重建你的模型，比如增加更多的特征，换个复杂模型</p>
</li>
<li class="lvl-2">
<p>过拟合复杂的模型会有小的偏差，大的方差；增加数据没法增加数据时=&gt;规则化，</p>
</li>
</ul>
</blockquote>
<h4 id="欠拟合与过拟合">欠拟合与过拟合</h4>
<p>欠拟合：对训练样本的一般性质尚未学好。在训练集及测试集上的表现都不好。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>偏差大</p>
<p>过拟合：训练集的训练效果好，但是测试集上的效果不好。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>方差大</p>
<h5 id="解决路线">解决路线</h5>
<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230202194701119.png" alt="image-20230202194701119" style="zoom: 67%;" />
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>训练集loss</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>大 -&gt;</p>
<ul class="lvl-5">
<li class="lvl-6">
<p>model bias问题</p>
<ul class="lvl-7">
<li class="lvl-8">增加模型复杂度</li>
</ul>
</li>
<li class="lvl-6">
<p>optimization问题</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>小 -&gt; 测试集loss</p>
<ul class="lvl-5">
<li class="lvl-6">
<p>大 -&gt;</p>
<ul class="lvl-7">
<li class="lvl-8">
<p>overfitting问题</p>
<ul class="lvl-9">
<li class="lvl-10">更多训练数据</li>
<li class="lvl-10">数据扩展</li>
<li class="lvl-10">降低模型弹性</li>
</ul>
</li>
<li class="lvl-8">
<p>mismatch问题</p>
<ul class="lvl-9">
<li class="lvl-10">（训练集与测试集分布差得多）</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-6">
<p>小 -&gt; success</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="注意">注意</h3>
<ul class="lvl-1">
<li class="lvl-2">
<p>model够不够大</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>一个建议判断方法</p>
<ul class="lvl-5">
<li class="lvl-6">
<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20230202194741271.png" alt="image-20230202194741271" style="zoom: 67%;" />
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>overfitting的极端例子</p>
<ul class="lvl-3">
<li class="lvl-4">x当做输入的时候,我们就去比对这个x,有没有出现在训练集裡面,如果x有出现在训练集裡面,就把它对应的ŷ当做输出,如果x没有出现在训练集裡面,就输出一个随机的值</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="神经网络neural-network">神经网络Neural Network</h3>
<p>神经网络的基础：神经元</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020113246762.png" alt="image-20221020113246762" style="zoom:50%;" />
<h4 id="激活函数">激活函数</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020113339209.png" alt="image-20221020113339209" style="zoom:50%;" />
<h5 id="神经网络">神经网络</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020113611322.png" alt="image-20221020113611322" style="zoom:50%;" />
<p>多个神经元组成一个隐藏层，多个隐藏层以及输入和输出层构成了一个神经网络：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020115610406.png" alt="image-20221020115610406" style="zoom:50%;" />
<h5 id="textcolor-red-课后作业-神经网络泛化-2022-9-23"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>课后作业</mtext><mi mathvariant="normal">.</mi><mtext>神经网络泛化</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{课后作业.神经网络泛化}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">课后作业</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">神经网络泛化</span></span></span></span>-2022-9-23</h5>
<h3 id="神经网络为什么不会一直过拟合-反而有良好的泛化能力"><mark>神经网络为什么不会一直过拟合，反而有良好的泛化能力。</mark></h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>来自CharGPT</p>
</li>
</ul>
<p>神经网络之所以能够在训练数据上进行良好的拟合，同时又具有较好的泛化能力，是由于神经网络本身具有一些特性和训练方法可以避免过拟合并提高泛化能力。以下是一些可能的原因：</p>
<ol>
<li class="lvl-3">
<p>参数共享：神经网络中的参数通常是共享的，即多个神经元使用相同的权重，这样可以使得网络更加简单，降低过拟合的风险。</p>
</li>
<li class="lvl-3">
<p>正则化：正则化是一种降低模型复杂度的方法，它通过在损失函数中添加惩罚项来避免模型过度拟合训练数据。在神经网络中，L1正则化和L2正则化都可以有效地降低模型复杂度，并提高泛化能力。</p>
</li>
<li class="lvl-3">
<p>数据增强：数据增强是通过一些变换方法扩充原始训练数据的方法。通过数据增强，可以使得训练数据更加丰富多样，从而提高模型的泛化能力。</p>
</li>
<li class="lvl-3">
<p>集成学习：集成学习是将多个不同的模型进行组合以获得更好的泛化能力的方法。在神经网络中，常见的集成学习方法包括Dropout和Bagging等。</p>
</li>
<li class="lvl-3">
<p>停止训练的时机：神经网络的训练过程通常会进行多个epoch，但是在一定程度上，过多的训练容易导致过拟合。因此，可以设置一些停止训练的条件，如达到一定的训练次数或者验证集误差不再下降等，以避免过度拟合。</p>
</li>
</ol>
<p>综上所述，神经网络能够在训练数据上获得良好的拟合效果并具有较好的泛化能力，是由于神经网络具有一些特性和训练方法可以避免过拟合，并提高泛化能力。</p>
</blockquote>
<blockquote>
<p>偏向于拟合光滑函数，从而捕获到数据中出现的全局性结构而不是过度拟合单个样本。</p>
<ul class="lvl-1">
<li class="lvl-2">泛化能力（generalization ability）是指机器学习算法对新鲜样本的适应能力。</li>
</ul>
</blockquote>
<h3 id="linear-regression-线性回归">Linear Regression（线性回归）</h3>
<h4 id="step-1-model">Step 1: Model</h4>
<blockquote>
<p>建立模型</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020121437926.png" alt="image-20221020121437926" style="zoom:50%;" />
<h4 id="step-2-goodness-of-function">Step 2: Goodness of Function</h4>
<blockquote>
<p>评判方程的效果好坏</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020122319077.png" alt="image-20221020122319077" style="zoom: 150%;" />
<h4 id="step-3-best-function">Step 3: Best Function</h4>
<blockquote>
<p>通过梯度下降的方式选出最好的方程式</p>
</blockquote>
<p>1️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020122614363.png" alt="image-20221020122614363" style="zoom:50%;" />
<p>2️⃣先单独考虑一个变量的梯度</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020123116925.png" alt="image-20221020123116925"  />
<p>3️⃣之后考虑多个变量的梯度</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020123234604.png" alt="image-20221020123234604" style="zoom:50%;" />
<p>得到的梯度如下：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020124419692.png" alt="image-20221020124419692"></p>
<p>示意图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020124605173.png" alt="image-20221020124605173" style="zoom: 67%;" />
<p>梯度下降可能会收敛到局部最优：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020124806461.png" alt="image-20221020124806461" style="zoom:50%;" />
<h4 id="计算平均误差">计算平均误差</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020125549475.png" alt="image-20221020125549475" style="zoom:50%;" />
<blockquote>
<p>分别计算Training Data和Testing Data的平均误差，之后比价两者的平均误差发现后者的平均误差一般比前者的平均误差大，毕竟函数式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>w</mi><mo>⋅</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y=b+w\cdot x_{cp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是由Training Data训练得到的。</p>
</blockquote>
<p>以上一次方程的误差较大，这个时候我们可以采用高次多项式来拟合数据：</p>
<p>比如：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020130102700.png" alt="image-20221020130102700"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020130121830.png" alt="image-20221020130121830"></p>
<p>越复杂的模型对Training Data的平均误差越小，但是对Testing Data的平均误差却可能很大，这就是过拟合：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020130335681.png" alt="image-20221020130335681" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020130503210.png" alt="image-20221020130503210" style="zoom:50%;" />
<blockquote>
<p>我们应该选择对Training Data和Testing Data的平均误差都很小，且两者的平均误差相差不大的模型。</p>
</blockquote>
<h5 id="regulation规整化-正则化">Regulation规整化（正则化）</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221020144310277.png" alt="image-20221020144310277" style="zoom: 50%;" />
<blockquote>
<p>正则化可以解决过拟合问题：通过使权重衰减，降低实际结果与预测结果之差的累和对整体结果的影响，从而使得方程的曲线更加的光滑，而一般认为光滑的方程更可能是正确的。</p>
<p>参考：<a href="https://blog.csdn.net/jialibang/article/details/108991631">(77条消息) 正则化为什么可以防止过拟合_jk英菲尼迪的博客-CSDN博客_正则化为什么能防止过拟合</a></p>
</blockquote>
<h3 id="logistic-regression-逻辑回归">Logistic Regression（逻辑回归）</h3>
<h5 id="什么是生成模型？">什么是生成模型？</h5>
<blockquote>
<p>计算一个给定的x是属于哪个类型的，比较P(C_1|x)和P(C_ 2 | x)的值，哪个类别的概率大x就属于哪个类别。</p>
<p>P(C_1|x)和P(C_ 2 | x)的值将从训练集中获得。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028231017004.png" alt="image-20221028231017004"></p>
</blockquote>
<p>监督学习方法可以分为生成方法（generative approach）和判别方法（discriminative approach）。所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。生成方法由数据学习联合概率分布，然后求出条件概率分布作为预测的模型，即生成模型。</p>
<h3 id="机器学习的三步骤：">机器学习的三步骤：</h3>
<ol>
<li class="lvl-3">
<p>定义模型</p>
</li>
<li class="lvl-3">
<p>定义损失函数——方法：梯度下降</p>
</li>
<li class="lvl-3">
<p>进行函数求解</p>
</li>
</ol>
<h4 id="1-梯度下降">1️⃣梯度下降</h4>
<blockquote>
<p>梯度下降参考：<a href="https://zhuanlan.zhihu.com/p/68468520">梯度下降算法（Gradient Descent)的原理和实现步骤 - 知乎 (zhihu.com)</a></p>
<p>多次求解求平均得到平滑曲线。</p>
</blockquote>
<p><strong>梯度下降的目的，就是为了最小化损失函数。</strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-79eecd15feeaececb8a1b651ed88b6be_r.jpg" alt="preview"></p>
<blockquote>
<p>此时如果求出A点的梯度  ，便可以知道如果我们向右移动，可以使损失函数的值变得更小。</p>
</blockquote>
<h5 id="学习率">学习率</h5>
<p>如果学习率 α 设置得过大，有可能我们会错过损失函数的最小值；如果设置得过小，可能我们要迭代式子非常多次才能找到最小值，会耗费较多的时间。因此，在实际应用中，我们需要为学习率 α 设置一个合适的值。</p>
<h5 id="设置学习率的两种方法">设置学习率的两种方法</h5>
<blockquote>
<p>学习率衰减参考：<a href="https://www.jianshu.com/p/7311e7151661">机器学习 | 优化——调整学习率 - 简书 (jianshu.com)</a></p>
<p>概述：</p>
<p>学习率在一开始要保持大些来保证收敛速度，在收敛到最优点附近时要小些以避免来回震荡。</p>
<p>实例：</p>
<p>E.g. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>t</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> decay: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>η</mi><mi>t</mi></msup><mo>=</mo><mi>η</mi><mi mathvariant="normal">/</mi><msqrt><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msqrt></mrow><annotation encoding="application/x-tex">\eta^t=\eta / \sqrt{t+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.988em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1156em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8656em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-2.8256em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1744em;"><span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p><strong>Adagrad算法</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>←</mo><msup><mi>w</mi><mi>t</mi></msup><mo>−</mo><mfrac><mi>η</mi><msqrt><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>t</mi></msubsup><msup><mrow><mo fence="true">(</mo><msup><mi>g</mi><mi>i</mi></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mfrac><msup><mi>g</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">w^{t+1} \leftarrow w^t-\frac{\eta}{\sqrt{\sum_{i=0}^t\left(g^i\right)^2}} g^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8769em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.6232em;vertical-align:-0.8296em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.4491em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0585em;"><span class="svg-align" style="top:-3.4286em;"><span class="pstrut" style="height:3.4286em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8365em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-2.8971em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="minner mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7571em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8645em;"><span style="top:-2.9042em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.0305em;"><span class="pstrut" style="height:3.4286em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5429em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.5429em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3981em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">η</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8296em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mtext> |First derivative| </mtext><mtext> Second derivative </mtext></mfrac></mrow><annotation encoding="application/x-tex">\frac{\text { |First derivative| }}{\text { Second derivative }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> Second derivative </span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> |First derivative| </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>通过一阶衍生物的绝对值除以二阶衍生物得到最好的步长。</p>
<blockquote>
<p>EI会议：1、2、3阶——分数降低或者不算</p>
</blockquote>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>搞清论文问题和研究是方向</mtext><mi mathvariant="normal">/</mi><mtext>算法的改进点等。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{搞清论文问题和研究是方向/算法的改进点等。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">搞清论文问题和研究是方向</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">算法的改进点等。</span></span></span></span></p>
</blockquote>
<h5 id="textcolor-red-课后作业-协方差矩阵σ相同accuracy增加-2022-9-27"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>课后作业</mtext><mi mathvariant="normal">.</mi><mtext>协方差矩阵</mtext><mi mathvariant="normal">Σ</mi><mtext>相同</mtext><mi>a</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>y</mi><mtext>增加</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{课后作业.协方差矩阵Σ相同accuracy增加}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">课后作业</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">协方差矩阵</span><span class="mord" style="color:red;">Σ</span><span class="mord cjk_fallback" style="color:red;">相同</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">cc</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">cy</span><span class="mord cjk_fallback" style="color:red;">增加</span></span></span></span>-2022-9-27</h5>
<p>思考Σ相同的时候，accuracy为什么会增加？</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220927173552056.png" alt="image-20220927173552056" style="zoom:50%;" />
<blockquote>
<p>协方差矩阵Σ 是一个对称矩阵，协方差矩阵，因而决定了多维高斯分布的形状。协方差矩阵Σ是和输入特征（大小）的平方成正比，所以当特征很多的时候，协方差矩阵是可以增长很快的。此时考虑到模型参数过多时候就容易过拟合，而共用协方差矩阵的话会使得参数变少，过拟合变弱了，准确率也就上升了。</p>
<p><mark>模型参数过多，就容易发生过拟合，共用协方差矩阵使得参数变少，过拟合的程度变弱了，准确率也就上升了。</mark></p>
</blockquote>
<h4 id="启动函数-激活函数-：将范围限定在-0-1">启动函数（激活函数）：将范围限定在[0,1]</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220930081913017.png" alt="image-20220930081913017" style="zoom:50%;" />
<h6 id="交叉熵函数定义：">交叉熵函数定义：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220930083755084.png" alt="image-20220930083755084" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220930083930554.png" alt="image-20220930083930554" style="zoom: 50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221004160947492.png" alt="image-20221004160947492" style="zoom:50%;" />
<h5 id="textcolor-red-课后作业-逻辑回归分界线-2022-9-30"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>课后作业</mtext><mi mathvariant="normal">.</mi><mtext>逻辑回归分界线</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{课后作业.逻辑回归分界线}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">课后作业</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">逻辑回归分界线</span></span></span></span>-2022-9-30</h5>
<p>能否找一条线将四个区分出来</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220930094126581.png" alt="image-20220930094126581" style="zoom:33%;" />
<blockquote>
<p>不能，逻辑回归的分界线是一条直线，而一条直线是不能将红蓝两类分开的，所以需要对特征进行转换，通过特征转换使得能够通过直线分开的红蓝两个特征。</p>
<p>转换为更有利于后面分类的特征。</p>
</blockquote>
<h2 id="六-深度学习">六、深度学习</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221004163212224.png" alt="image-20221004163212224" style="zoom:33%;" />
<p>神经网络：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>多少层</p>
</li>
<li class="lvl-2">
<p>每层多少神经元</p>
</li>
</ul>
<blockquote>
<p>分类问题使用交叉熵定义激活函数。</p>
<p>交叉熵：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221004165848429.png" alt="image-20221004165848429" style="zoom:50%;" />
</blockquote>
<h4 id="梯度下降">梯度下降</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>随机梯度下降法的第一步是随机化整个数据集</p>
</li>
<li class="lvl-2">
<p>计算梯度</p>
</li>
<li class="lvl-2">
<p>不断反复，更新参数，直到得到最好的参数使得损失函数的值最小</p>
</li>
</ul>
<blockquote>
<p>具体流程：θ是一组包含权重和偏差的参数集合，随机找一个初试值，接下来计算一下每个参数对应偏微分，得到的一个偏微分的集合∇<em>L</em>就是梯度,有了这些偏微分，我们就可以不断更新梯度得到新的参数，这样不断反复进行，就能得到一组最好的参数使得损失函数的值最小。</p>
</blockquote>
<h3 id="textcolor-red-考-反向传播增加梯度下降效率"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>反向传播增加梯度下降效率</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.反向传播增加梯度下降效率}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">反向传播增加梯度下降效率</span></span></span></span></h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>来自ChatGPT</p>
</li>
</ul>
<p>反向传播是一种有效的训练神经网络的方法，可以通过计算网络参数对损失函数的梯度来进行梯度下降优化。</p>
<p>梯度下降是一种常用的优化方法，它通过沿着损失函数的负梯度方向更新网络参数，从而使得损失函数逐渐减小。然而，对于深度神经网络等复杂模型，损失函数往往具有大量的参数，使得梯度计算非常困难，从而导致优化过程非常缓慢。</p>
<p>反向传播通过使用链式法则，将损失函数的梯度从输出层向输入层依次传递，从而计算每个网络参数对于损失函数的梯度，从而加速了梯度下降的过程。具体来说，反向传播可以在一次前向传播计算中计算出所有权重的梯度，从而使得梯度下降的更新更加高效。</p>
<p>此外，反向传播的计算速度也得到了很大的提升，这主要得益于现代计算机的并行计算能力以及深度学习框架的优化。通过在计算图上高效地计算梯度，反向传播可以在较短的时间内完成整个神经网络的梯度计算，从而大大提高了梯度下降的效率。</p>
<p>因此，反向传播在训练深度神经网络等复杂模型时，可以大大加快梯度下降的速度，提高模型的训练效率和性能。</p>
</blockquote>
<blockquote>
<p>为什么使用反向传播可以增加梯度下降的效率？</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221004171211792.png" alt="image-20221004171211792" style="zoom: 50%;" />
<p>先前向传播计算链式求导得到输出值：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221004172415410.png" alt="image-20221004172415410" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221004173135758.png" alt="image-20221004173135758" style="zoom:50%;" />
<p>之后将得到的值依次往前面带入得到</p>
</blockquote>
<p>sigmod函数可以作为激活函数，也是逻辑回归函数</p>
<h3 id="卷积神经网络">卷积神经网络</h3>
<blockquote>
<p>看网课参考：</p>
</blockquote>
<h3 id="textcolor-red-考-convolution-maxpooling计算"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mi>C</mi><mi>o</mi><mi>n</mi><mi>v</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext>计算</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.Convolution MaxPooling计算}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">v</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">x</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">P</span><span class="mord mathnormal" style="color:red;">oo</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">in</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord cjk_fallback" style="color:red;">计算</span></span></span></span></h3>
<p>现有k * K的图片以及w* w的filter,使用filter最后能够得到的图片的大小？（可以推导出通用表达式）</p>
<blockquote>
<p>包含1、2、3</p>
</blockquote>
<h6 id="1-convolution计算过程：">1、Convolution计算过程：</h6>
<p>1️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221007082531184.png" alt="image-20221007082531184" style="zoom:50%;" />
<p>2️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221007082634487.png" alt="image-20221007082634487" style="zoom:50%;" />
<h6 id="2-max-pooling">2、Max Pooling</h6>
<p>选出每个框中的最大元素作为该框的代表元素：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221007084033973.png" alt="image-20221007084033973" style="zoom:50%;" />
<p>经过Max Pooling之后，得到2 * 2的图片矩阵</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221007084331076.png" alt="image-20221007084331076" style="zoom:50%;" />
<blockquote>
<p>在CNN中，<mark>不一定需要Max Pooling步骤</mark>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可能会出一个判断题！</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{可能会出一个判断题！}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可能会出一个判断题！</span></span></span></span></p>
</blockquote>
<h6 id="3-flatten">3、Flatten</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221007084550253.png" alt="image-20221007084550253" style="zoom:50%;" />
<hr>
<h6 id="keras">Keras</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221007090017917.png" alt="image-20221007090017917" style="zoom:50%;" />
<h3 id="textcolor-red-考-convolution-maxpooling计算"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mi>C</mi><mi>o</mi><mi>n</mi><mi>v</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext>计算</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.Convolution MaxPooling计算}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">v</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">x</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">P</span><span class="mord mathnormal" style="color:red;">oo</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">in</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord cjk_fallback" style="color:red;">计算</span></span></span></span></h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221007091052106.png" alt="image-20221007091052106" style="zoom:50%;" />
<blockquote>
<p>假设我们input一个1 *28 * 28的image，你就可以写model.add(Convolution2D( 25, 3, 3, Input_shape=(28,28,1)))。通过convplution以后得到output是25 *26 26(25个filter，通过3 *3得到26 * 26)。然后做max pooling，2 *2一组选择 max value得到 25 *13 * 13</p>
<p>然后在做一次convolution，假设我在这选50个filter，每一个filter是3 *3时，那么现在的channel就是50。13 *13的image通过3 *3的filter，就成11 *11，然后通过2 *2的Max Pooling，变成了50 *5 *5</p>
<p>在第一个convolution layer里面，每一个filter有9个参数，在第二个convolution layer里面，虽然每一个filter都是3 *3，但不是3 *3个参数，<mark>因为它input channel 是25个，所以它的参数是3 *3 *25(225)</mark>。</p>
</blockquote>
<p>CNN的三个特点：</p>
<ol>
<li class="lvl-3">
<p>局部感知，简单来说，卷积核的大小一般小于输入图像的大小（如果等于则是全连接），因此卷积提取出的特征会更多地关注局部 —— 这很符合日常我们接触到的图像处理。而每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。</p>
</li>
<li class="lvl-3">
<p>参数共享，参数共享最大的作用莫过于很大限度地减少运算量了。</p>
</li>
<li class="lvl-3">
<p>多核，一般我们都不会只用一个卷积核对输入图像进行过滤，因为一个核的参数是固定的，其提取的特征也会单一化。这就有点像是我们平时如何客观看待事物，必须要从多个角度分析事物，这样才能尽可能地避免对该事物产生偏见。我们也需要多个卷积核对输入图像进行卷积。</p>
</li>
</ol>
<p>CNN的应用：</p>
<ol>
<li class="lvl-3">
<p>图片</p>
</li>
<li class="lvl-3">
<p>语音</p>
</li>
<li class="lvl-3">
<p>文本</p>
</li>
</ol>
<h4 id="深度学习的模块化">深度学习的模块化</h4>
<p>问题1：为什么变高比变宽好呢？</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011164416400.png" alt="image-20221011164416400" style="zoom:50%;" />
<p>1️⃣直接利用四个训练集去训练分类器</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011163822838.png" alt="image-20221011163822838" style="zoom:50%;" />
<p>2️⃣先训练第一层分类器（base Classifier），再训练第二层分类器</p>
<ul class="lvl-0">
<li class="lvl-2">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011164008381.png" alt="image-20221011164008381" style="zoom:50%;" />
</li>
<li class="lvl-2">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011164109653.png" alt="image-20221011164109653" style="zoom:50%;" />
</li>
</ul>
<p>问题2：深度学习和模组化有什么关系？</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011164454264.png" alt="image-20221011164454264" style="zoom:50%;" />
<h4 id="普遍性定理">普遍性定理</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011170600015.png" alt="image-20221011170600015" style="zoom:50%;" />
<h3 id="textcolor-red-考-一隐藏层表所有函数而多层"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>一隐藏层表所有函数而多层</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.一隐藏层表所有函数而多层}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">一隐藏层表所有函数而多层</span></span></span></span></h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>来自ChatGPT</p>
</li>
</ul>
<p>虽然理论上一个具有足够数量的神经元的单层神经网络可以表示所有函数，但在实际应用中，使用多层神经网络可以更好地解决一些实际问题。以下是一些可能的原因：</p>
<ol>
<li class="lvl-3">
<p>更强的表达能力：深层神经网络具有更强的表达能力，可以更好地拟合具有复杂结构的数据。多层神经网络可以通过将低级特征组合成更高级别的特征，来学习数据中的更抽象的表示。</p>
</li>
<li class="lvl-3">
<p>更好的泛化能力：深层神经网络可以通过训练过程中的参数共享、正则化等方式来避免过拟合，并且具有更好的泛化能力。与单层神经网络相比，深层神经网络通常能够更好地适应新的数据，从而获得更好的泛化性能。</p>
</li>
<li class="lvl-3">
<p>更高的效率：深层神经网络通常可以通过并行计算等方式来加速模型训练和推断过程，从而在实际应用中具有更高的效率。此外，深层神经网络通常具有更少的神经元数量，因此可以更快地处理大规模数据集。</p>
</li>
</ol>
<p>综上所述，尽管单层神经网络在理论上可以表示所有函数，但深层神经网络在实际应用中通常具有更好的表达能力、泛化能力和效率，因此在许多领域中得到广泛的应用。</p>
</blockquote>
<blockquote>
<p>一个隐藏层就可以表示所有函数，为什么要使用多层？</p>
<p>回：但是这个理论没有告诉我们的是，它只告诉我们可能性，但是它没有告诉我们说要做到这件事情到底有多有效率。没错，你只要有够多的参数，hidden layer够宽，你就可以描述任何的function。但是这个理论没有告诉我们的是，当我们用这一件事(我们只用一个hidde layer来描述function的时候)它其实是没有效率的。当你有more layer(high structure)你用这种方式来描述你的function的时候，它是比较有效率的。</p>
</blockquote>
<h5 id="无监督学习-深度自编码器">无监督学习-深度自编码器</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221011173843036.png" alt="image-20221011173843036" style="zoom: 50%;" />
<blockquote>
<p>Auto-encoder包含：</p>
<ul class="lvl-1">
<li class="lvl-2">编码</li>
<li class="lvl-2">解码</li>
</ul>
</blockquote>
<h6 id="recap-pca">Recap PCA</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014080432006.png" alt="image-20221014080432006" style="zoom:50%;" />
<h6 id="deep-auto-encoder">Deep Auto-encoder</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014080448278.png" alt="image-20221014080448278" style="zoom:50%;" />
<h6 id="deep-auto-encoder对噪声点的处理">Deep Auto-encoder对噪声点的处理</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014080904171.png" alt="image-20221014080904171" style="zoom:50%;" />
<p>使用像素级的欧式距离进行计算的到的结果图片中的内容差距较大</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014082534044.png" alt="image-20221014082534044" style="zoom:50%;" />
<h6 id="cnn-unpooling">CNN UnPooling</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014083346537.png" alt="image-20221014083346537" style="zoom:50%;" />
<h6 id="cnn-deconvolution">CNN Deconvolution</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014083956044.png" alt="image-20221014083956044" style="zoom:50%;" />
<blockquote>
<p>对输入进行扩充，然后放入到一个新的convolution里面，最后实现deconvolution</p>
</blockquote>
<h5 id="深度学习和流形">深度学习和流形</h5>
<p>流行的本质就是很多欧式空间粘贴在一起构成的空间</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014091113179.png" alt="image-20221014091113179" style="zoom: 33%;" />
<p>深度学习的主要目的和功能之一就是学习编码映射和解码映射</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将带噪声的图像进行傅里叶变换</p>
<ul class="lvl-2">
<li class="lvl-4">在频域滤波，去除高频分量</li>
</ul>
</li>
<li class="lvl-2">
<p>之后通过傅里叶的逆变换得到去噪之后的图片</p>
</li>
</ul>
<p>局限性</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>必须具有流行</p>
</li>
<li class="lvl-2">
<p>不同的类型需要不同的流行</p>
</li>
<li class="lvl-2">
<p>深度学习仍属于弱人工智能</p>
</li>
</ul>
<h3 id="textcolor-red-考-深度学习有效性的几何解释"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>深度学习有效性的几何解释</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.深度学习有效性的几何解释}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">深度学习有效性的几何解释</span></span></span></span></h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014093604606.png" alt="image-20221014093604606" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014093617698.png" alt="image-20221014093617698" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221014093708338.png" alt="image-20221014093708338" style="zoom:50%;" />
<h6 id="胞腔分解和等价类">胞腔分解和等价类</h6>
<h3 id="textcolor-red-考-胞腔分解与等价类"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>胞腔分解与等价类</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.胞腔分解与等价类}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">胞腔分解与等价类</span></span></span></span></h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>每一个胞腔对应于一个类</p>
</li>
<li class="lvl-2">
<p>所有彼此等价的点构成了背景空间中的一个胞腔</p>
</li>
<li class="lvl-2">
<p>编码映射诱导了胞腔的分解</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>来自ChatGPT</p>
</li>
</ul>
<p>胞腔分解和等价类是拓扑学中两个重要的概念，它们之间存在一定的关系。</p>
<p>胞腔分解是指将一个拓扑空间分解为一系列胞腔的并集，其中胞腔是指具有像拓扑结构的单元。胞腔分解是一种重要的拓扑空间描述方法，通常用于研究空间的拓扑性质。</p>
<p>等价类是指具有相同等价关系的元素组成的集合，其中等价关系是指满足自反性、对称性和传递性的关系。在拓扑学中，我们可以定义一个等价关系，使得空间中的点可以被分类为不同的等价类。这些等价类可以表示空间的拓扑结构，例如空间的连通性、同伦类型等。</p>
<p>在拓扑学中，一个空间的胞腔分解可以用于定义一个等价关系，使得空间中的点可以被分类为不同的等价类。具体来说，如果两个点可以通过一个或多个胞腔连通，则这些点被视为等价的。这种等价关系称为同伦等价，即这些点可以通过同伦变形相互转换，它们具有相同的同伦类型。</p>
<p>因此，胞腔分解和等价类是密切相关的，胞腔分解提供了一种描述空间拓扑结构的方法，而等价类则可以表示拓扑结构中的不同同伦类型。通过胞腔分解，我们可以研究空间的拓扑性质，并将其分类为不同的同伦类型。</p>
</blockquote>
<h3 id="textcolor-red-考-单词上下文互预测"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>单词上下文互预测</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.单词上下文互预测}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">单词上下文互预测</span></span></span></span></h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221025164317392.png" alt="image-20221025164317392" style="zoom:50%;" />
<blockquote>
<p>考试题为此页PPT的内容</p>
</blockquote>
<h3 id="rnn">RNN</h3>
<p>循环神经网络（Recurrent Neural Network，RNN）是一种用于处理序列数据的神经网络。相比一般的神经网络来说，他能够处理序列变化的数据。比如某个单词的意思会因为上文提到的内容不同而有不同的含义，RNN就能够很好地解决这类问题。</p>
<h4 id="lstm">LSTM</h4>
<p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p>
<p>下图存在Input Gate（输入门）、Output Gate（输出门）、Forget Gate（遗忘门）：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021081347103.png" alt="image-20221021081347103" style="zoom:50%;" />
<blockquote>
<p>forget gate打开的时候代表的是记得，关闭的时候代表的是遗忘。</p>
<p>三个门均存在以下规则：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>当输入通过sigmod函数之后得到的值为0时，表明该门是关闭的；</p>
</li>
<li class="lvl-2">
<p>当输入通过sigmod函数之后得到的值为1时，表明该门是开启的；</p>
</li>
</ul>
</blockquote>
<h3 id="textcolor-red-考-lstm过程-门计算"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mi>L</mi><mi>S</mi><mi>T</mi><mi>M</mi><mtext>过程</mtext><mi mathvariant="normal">.</mi><mtext>门计算</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.LSTM过程.门计算}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord mathnormal" style="color:red;">L</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">STM</span><span class="mord cjk_fallback" style="color:red;">过程</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">门计算</span></span></span></span></h3>
<blockquote>
<img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221021082133328.png" alt="image-20221021082133328" style="zoom:50%;" />
<p>x1是输入</p>
<p>x2 = 1 ,输入<strong>将</strong>被写入memory</p>
<p>x2 = <mark>-1</mark> ,<strong>将</strong>置零memory</p>
<p>x3 = 1 ,<strong>立即</strong>输出memory</p>
<p><img src="https://ressmatthew-picture-cloud-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20221021090718248.png" alt="image-20221021090718248"></p>
<blockquote>
<p>Forget gate门</p>
<ul class="lvl-2">
<li class="lvl-2">= 1,保留记忆</li>
<li class="lvl-2">= 0, 遗忘memory</li>
</ul>
</blockquote>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021083024030.png" alt="image-20221021083024030" style="zoom:50%;" />
<blockquote>
<p>需要掌握以上计算步骤。</p>
</blockquote>
<p>原始的神经元的输入和输出：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021090704835.png" alt="image-20221021090704835" style="zoom: 25%;" />
<p>将原来简单的neuron换成LSTM：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021090729363.png" alt="image-20221021090729363" style="zoom:33%;" />
<blockquote>
<p>LSTM需要的参数量(假设你现在用的neural的数目跟LSTM是一样的)是一般neural network的四倍。</p>
</blockquote>
<h6 id="lstm基本流程图：">LSTM基本流程图：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021091934708.png" alt="image-20221021091934708" style="zoom:50%;" />
<h6 id="对lstm改进：">对LSTM改进：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021091913677.png" alt="image-20221021091913677" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>x<sup>t</sup>是当前状态</p>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/32085405">人人都能看懂的LSTM - 知乎 (zhihu.com)</a></p>
</blockquote>
<h4 id="怎么学rnn">怎么学RNN</h4>
<p>问题：为什么RNN会有这种奇特的特性。有人会说，是不是来自sigmoid function，我们之前讲过Relu activation function的时候，讲过一个问题gradient vanish，这个问题是从sigmoid function来的，RNN会有很平滑的error surface是因为来自于gradient vanish，这问题我是不认同的。等一下来看这个问题是来自sigmoid function，你换成Relu去解决这个问题就不是这个问题了。跟大家讲个秘密，一般在train neural network时，一般很少用Relu来当做activation function。为什么呢？其实你把sigmoid function换成Relu，其实在RNN performance通常是比较差的。所以activation function并不是这里的关键点。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021093445621.png" alt="image-20221021093445621" style="zoom:33%;" />
<p>RNN training的问题其实来自它把同样的东西在transition的时候反复使用。所以这个w只要一有变化，它完全由可能没有造成任何影响，一旦造成影响，影响都是天崩地裂的(所以gradient会很大，gradient会很小)。</p>
<blockquote>
<p>单个样本可能会发生梯度消失的问题。</p>
</blockquote>
<h3 id="textcolor-red-考-为什么lstm能够解决梯度消失的问题"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>为什么</mtext><mi>L</mi><mi>S</mi><mi>T</mi><mi>M</mi><mtext>能够解决梯度消失的问题</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.为什么LSTM能够解决梯度消失的问题}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">为什么</span><span class="mord mathnormal" style="color:red;">L</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">STM</span><span class="mord cjk_fallback" style="color:red;">能够解决梯度消失的问题</span></span></span></span></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>memory和输入时相加的</p>
</li>
<li class="lvl-2">
<p>这种累加效果一直存在，直到遗忘门关闭才会消失</p>
</li>
</ul>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>来自ChatGPT</p>
</li>
</ul>
<p>LSTM（Long Short-Term Memory）是一种常用的循环神经网络（RNN）结构，相对于传统的 RNN，LSTM 可以更好地解决梯度消失的问题。LSTM 之所以能够解决梯度消失的问题，主要有以下两个原因：</p>
<ol>
<li class="lvl-3">
<p>长期记忆机制：传统的 RNN 中，当网络层数很多时，由于在反向传播时每一层的梯度会相乘，因此当梯度较小时，多层网络的梯度会变得非常小，从而导致梯度消失。而 LSTM 通过引入长期记忆机制，可以更好地处理长期依赖性，从而避免梯度消失问题的发生。在 LSTM 中，通过门控单元的机制，可以控制信息的流动和保留，从而能够更好地处理长序列数据。</p>
</li>
<li class="lvl-3">
<p>反向传播中的梯度削减：另一个原因是 LSTM 的反向传播过程中，对梯度的处理方式有所改进。在 LSTM 的反向传播中，使用了一个特殊的误差反向传播算法（Backpropagation through time, BPTT），它可以在一定程度上避免梯度爆炸。当梯度过大时，LSTM 会通过削减梯度的方式，使梯度的范数不超过一个预设的值。这个预设的值可以通过裁剪梯度（gradient clipping）的方式来实现，从而避免梯度爆炸的问题。</p>
</li>
</ol>
<p>综上所述，LSTM 通过引入长期记忆机制和反向传播中的梯度削减，可以更好地解决梯度消失和梯度爆炸的问题，从而能够更好地处理长序列数据。</p>
</blockquote>
<p>首先将原始数据通过CNN或RNN提取出重要特征之后再放入到以下图中：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221025162922359.png" alt="image-20221025162922359"></p>
<h3 id="图片搜索和语言搜索">图片搜索和语言搜索</h3>
<p>图片搜索类似图片是用CNN</p>
<blockquote>
<p>图片搜索使用CNN提取特征</p>
<p>语音搜索使用RNN提取向量</p>
</blockquote>
<h3 id="textcolor-red-考-图片搜索和语言搜索提取比较"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>图片搜索和语言搜索提取比较</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.图片搜索和语言搜索提取比较}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">图片搜索和语言搜索提取比较</span></span></span></span></h3>
<blockquote>
<p>主图片<strong>CNN</strong>提取<strong>特征</strong></p>
<p>从图片CNN提取特征</p>
<p>比较</p>
</blockquote>
<blockquote>
<p>主语音<strong>RNN</strong>提取<strong>向量</strong></p>
<p>从语音RNN提取向量</p>
<p>比较</p>
</blockquote>
<p>基于注意力的模型（Attension-based Model）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221025170837297.png" alt="image-20221025170837297" style="zoom:50%;" />
<p>最简易的基于注意力的模型V1</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221025171009500.png" alt="image-20221025171009500" style="zoom:50%;" />
<p>基于注意力的模型V2</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221025171033162.png" alt="image-20221025171033162" style="zoom:50%;" />
<p>machine阅读理解</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221025171654756.png" alt="image-20221025171654756" style="zoom:50%;" />
<h4 id="rnn-structured-learning">RNN &amp; Structured learning</h4>
<h3 id="深度学习的攻防">深度学习的攻防</h3>
<h5 id="motivation">Motivation</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>期望机器学习的分类器对恶意的或非恶意的错误input具有一定的鲁棒性</p>
</li>
<li class="lvl-2">
<p>恶意软件检测以及网络入侵检测（spam malware intrusion detection）</p>
</li>
</ul>
<h5 id="noise像素点attack">noise像素点attack</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028083946316.png" alt="image-20221028083946316" style="zoom:50%;" />
<h3 id="textcolor-red-考-无目标攻击和目标攻击公式"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考</mtext><mi mathvariant="normal">.</mi><mtext>无目标攻击和目标攻击公式</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考.无目标攻击和目标攻击公式}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考</span><span class="mord" style="color:red;">.</span><span class="mord cjk_fallback" style="color:red;">无目标攻击和目标攻击公式</span></span></span></span></h3>
<blockquote>
<p>Non-target Attack：公式如上图所示</p>
<p>Targeted Attack：公式如上图所示</p>
</blockquote>
<h5 id="constraint">Constraint</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028085925008.png" alt="image-20221028085925008" style="zoom:50%;" />
<h5 id="attack的实现方式">Attack的实现方式</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028092228643.png" alt="image-20221028092228643" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028092155726.png" alt="image-20221028092155726" style="zoom:50%;" />
<h5 id="attack-approaches">Attack Approaches</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221028092832191.png" alt="image-20221028092832191" style="zoom:50%;" />
<h5 id="white-box与black-box">White Box与Black Box</h5>
<blockquote>
<p>白盒攻击：在知道模型的情况下对模型进行攻击（此时清楚算法的参数、结构等）</p>
<p>黑盒攻击：在不知道模型的情况下对模型进行攻击（此时不知道任何模型的结构或是参数）</p>
</blockquote>
<h4 id="黑盒攻击">黑盒攻击</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221101162010977.png" alt="image-20221101162010977" style="zoom: 50%;" />
<blockquote>
<p>通过寻找图片样本输入到待攻击模型中训练之后得到结果，将训练的样本和结果用来训练自己的模型，这个时候可以训练出功能与待攻击模型相似的可知具体模型结构的自建模型，此时能够对自建模型进行attack的对抗样本也很有可能对待攻击模型产生相同的攻击效果。</p>
</blockquote>
<p>通过待攻击模型得到的结果来训练自己模型的详细过程：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221101165240517.png" alt="image-20221101165240517"></p>
<h3 id="defense">Defense</h3>
<p>Two types：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>被动防御（passive defense）</p>
<ul class="lvl-2">
<li class="lvl-4">方式一：加入一个过滤器（Filter）
<ul class="lvl-4">
<li class="lvl-6">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221101172424920.png" alt="image-20221101172424920" style="zoom:50%;" />
</li>
</ul>
</li>
<li class="lvl-4">方式二：判断max(d1,d2)&gt;T</li>
<li class="lvl-4">方式三：resizing layer in CNN
<ul class="lvl-4">
<li class="lvl-6">原始图片在resizing过程中的稳定性好</li>
<li class="lvl-6">对抗样本在resizing过程中的稳定差</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>主动防御（proactive defense）</p>
<ul class="lvl-2">
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221101173503967.png" alt="image-20221101173503967" style="zoom:50%;" />
</li>
</ul>
</li>
</ul>
<h2 id="meta-learning">Meta Learning</h2>
<p>Meta Learning=learn to learn</p>
<p>Machine Learning：寻找函数f的能力</p>
<p>Meta Learning：寻找函数f的函数F的能力</p>
<h4 id="textcolor-red-12周上实验课"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mn>12</mn><mtext>周上实验课</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{12周上实验课}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord" style="color:red;">12</span><span class="mord cjk_fallback" style="color:red;">周上实验课</span></span></span></span></h4>
<h3 id="meta-learning流程">Meta Learning流程</h3>
<p>确定函数F（建立模型）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104081912906.png" alt="image-20221104081912906" style="zoom:50%;" />
<blockquote>
<p>最后返回的函数f是一个结构（网络结构）。</p>
<p>F&lt;NS,Init,Update&gt;</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>NS：Network Structure</p>
</li>
<li class="lvl-2">
<p>Init：初始化</p>
</li>
<li class="lvl-2">
<p>Update：更新</p>
</li>
</ul>
</blockquote>
<p>定义函数F的好坏</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104083014964.png" alt="image-20221104083014964" style="zoom: 67%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104083512570.png" alt="image-20221104083512570" style="zoom:50%;" />
<p>定义损失函数F，并找到最好的损失函数</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104083452206.png" alt="image-20221104083452206" style="zoom:50%;" />
<h4 id="maml">MAML</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104090226044.png" alt="image-20221104090226044" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104091213991.png" alt="image-20221104091213991" style="zoom:50%;" />
<h4 id="model-pre-training">Model Pre-training</h4>
<blockquote>
<p>先有大数据训练集训练得到NS，之后再将NS作为参数并使用小数据量的数据集进一步调整NS</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104091857201.png" alt="image-20221104091857201" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104093925342.png" alt="image-20221104093925342" style="zoom:50%;" />
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>科学计算与数学建模</category>
      </categories>
      <tags>
        <tag>科学计算与数学建模</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一章（# 项目风险管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/11-%E9%A1%B9%E7%9B%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目风险管理</h1>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230615163239833.png" alt="image-20230615163239833" style="zoom:50%;" />
<h3 id="项目风险管理的过程">项目风险管理的过程</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230615163746957.png" alt="image-20230615163746957" style="zoom:50%;" />
<h2 id="本章小结">本章小结</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230615170153097.png" alt="image-20230615170153097" style="zoom:50%;" />
<ol>
<li class="lvl-3">
<p>1</p>
</li>
<li class="lvl-3">
<p>风险定量</p>
</li>
<li class="lvl-3">
<p>偏好型</p>
</li>
<li class="lvl-3">
</li>
<li class="lvl-3">
<p>风险承受度</p>
</li>
</ol>
<hr>
<ol>
<li class="lvl-3">
<p>做案例分析</p>
</li>
<li class="lvl-3">
<p>课堂快速测试</p>
</li>
<li class="lvl-3">
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章（项目管理概述）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/1-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目管理概述</h1>
<h5 id="人类活动特点：">⭐️人类活动特点：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>目的性：为了达到预期的目的而活动。</p>
</li>
<li class="lvl-2">
<p>依存性：分工越来越细，依存越来越紧密 。</p>
</li>
<li class="lvl-2">
<p>知识性：在实践与经验中学习，形成知识体系。</p>
</li>
</ul>
<p>⭐️作业（Operations 运作 运营）：连续不断、周而复始的活动，如企业日常的生产产品的活动、财务人员的日常记账工作等。</p>
<p>⭐️项目（Projects）：临时性的、一次性的活动，如企业新产品开发、企业的技术改造活动企业信息系统的开发等。</p>
<h6 id="项目是实现企业发展战略的载体">项目是实现企业发展战略的载体</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230427160706301.png" alt="image-20230427160706301" style="zoom:50%;" />
<h5 id="span-style-color-red-项目与作业的区别-span"><span style="color: red;">⭐️项目与作业的区别</span></h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230427160339987.png" alt="image-20230427160339987" style="zoom:50%;" />
<h3 id="项目的定义：">项目的定义：</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>项目都是有明确且具体的目标；</p>
</li>
<li class="lvl-2">
<p>项目是指为完成特定目标所需要完成的任务，具有一次性；</p>
</li>
<li class="lvl-2">
<p>项目都有须明确界定的工作范围；</p>
</li>
<li class="lvl-2">
<p>项目是一项有待完成的任务，有特定的环境与要求；</p>
</li>
<li class="lvl-2">
<p>项目是指一个过程，而不是指过程终结后所形成的结果；</p>
</li>
<li class="lvl-2">
<p>在一定的组织机构、利用有限的人力、物力、财力在规定的时间内完成任务；</p>
</li>
<li class="lvl-2">
<p>任务要满足一定的性能、质量、数量、技术指标等要求；</p>
</li>
</ul>
<h4 id="项目的三维约束">项目的三维约束</h4>
<p><u><strong>范围</strong></u>、<u><strong>时间</strong></u>和<u><strong>成本</strong></u></p>
<h3 id="管理的概念">管理的概念</h3>
<p>管理是社会组织中，为了实现预期目标，以人为中心进行的<u><strong>协调活动</strong></u>。</p>
<h5 id="管理五个重要观点：">管理五个重要观点：</h5>
<p>1）管理的目的是为了实现预期目标</p>
<p>2）管理的本质是协调</p>
<p>3）协调产生于社会组织中</p>
<p>4）协调的中心是人</p>
<p>5）协调的方法是多种多样性</p>
<h3 id="项目管理">项目管理</h3>
<h4 id="项目管理的定义">项目管理的定义</h4>
<p>⭐️项目管理就是把各种知识、技能、手段和技术应用于项目活动之中，以达到项目的要求。</p>
<p><u><em><strong><mark>项目经理</mark>是负责实现项目目标的个人</strong></em></u></p>
<p>不存在项目与项目之间的比较，因为每个项目都是独一无二的，目标不均衡的，所以无法进行比较，但作业可以。——根据项目与作业之间的区别</p>
<h5 id="项目管理与其它管理学科的关系">项目管理与其它管理学科的关系</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504162203916.png" alt="image-20230504162203916" style="zoom:50%;" />
<h4 id="项目管理知识体系">⭐️项目管理知识体系</h4>
<blockquote>
<p>指要使用的<u><em><strong>理论、方法和工具</strong></em></u>等一系列内容的总称。</p>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504160415769.png" alt="image-20230504160415769"></p>
<p>三部分组成：</p>
<ol>
<li class="lvl-3">
<p>项目干系人</p>
</li>
<li class="lvl-3">
<p>10大知识领域</p>
</li>
<li class="lvl-3">
<p>工具与技术</p>
</li>
</ol>
<h5 id="项目管理过程">项目管理<mark>过程</mark></h5>
<p>项目从开始到结束是通过一系列项目管理活动进行的，即项目管理过程</p>
<h3 id="软件的定义">软件的定义</h3>
<p>软件（software）是计算机系统中与硬件(hardware)相互依存的另一部分，它是<u><strong>程序(program)、数据(data)和文档(document)</strong></u>的完整集合。</p>
<p><u><em><strong><span style="color: red;">项目管理、项目群管理和项目组合管理对企业发展起到了什么作用或贡献？三者之间有什么联系？</span></strong></em></u></p>
<blockquote>
<p>项目管理：单个的项目管理</p>
<p>项目群管理：将相互之间关联的项目协同起来一起管理</p>
<p>项目组合管理：对由<strong>项目</strong>和<strong>项目群</strong>有机组合的整体所开展的管理</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><mark>战术目标：项目管理</mark></p>
</li>
<li class="lvl-2">
<p><mark>战略目标：项目组合管理</mark></p>
</li>
<li class="lvl-2">
<p>控制成本：项目与项目群管理有利于控制项目成本</p>
</li>
<li class="lvl-2">
<p>提升效率：优化工作流程，提高协助能力</p>
</li>
<li class="lvl-2">
<p>创新：提升企业竞争力</p>
</li>
<li class="lvl-2">
<p>降低风险：</p>
</li>
</ul>
</blockquote>
<h4 id="项目群-program">⭐️项目群（program）</h4>
<p>项目群（program）：<strong>多个相互关联项目的集合</strong></p>
<p>基本特征：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>相互关联</p>
</li>
<li class="lvl-2">
<p>每个项目相互间有一定的相似性</p>
</li>
</ul>
<h3 id="项目群管理-program-management">项目群管理（program Management）</h3>
<p>项目群管理（program Management）：一组相互关联的项目，使用<strong>协同方法进行管理来获得收益和进行控制</strong>，而这种收益和控制在单独管理这些项目时是不易获得的。</p>
<p>项目群管理强调：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>集成（如IT项目的弱电集成项目）</p>
</li>
<li class="lvl-2">
<p>协同与资源优化</p>
</li>
</ul>
<h3 id="项目组合管理">⭐️项目组合管理</h3>
<p>项目组合管理——<strong>对由项目和项目群有机组合的整体所开展的管理。</strong></p>
<p>项目组合的目的——<strong>实现组织战略和愿景</strong>，也称战略项目组合。</p>
<p>项目组合管理强调：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>战略目标（宏观）</p>
</li>
<li class="lvl-2">
<p>项目组合的投资回报</p>
</li>
<li class="lvl-2">
<p>资源约束下的项目选择</p>
</li>
</ul>
<h6 id="项目管理和项目组合管理的不同之处：">项目管理和项目组合管理的不同之处：</h6>
<p>最主要的区别在各自致力于达到的目标上，<mark>战术目标</mark>还是<mark>战略目标</mark>。（战术目标<u><strong>更具体,时间短</strong></u>；战略目标重点强调一组织的长期目标）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504161858259.png" alt="image-20230504161858259" style="zoom:50%;" />
<h5 id="项目经理的作用">项目经理的作用</h5>
<p><u><em><strong>项目经理是为项目的成功策划和执行负总责的人</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>管理能力</p>
</li>
<li class="lvl-2">
<p>领导能力</p>
</li>
</ul>
<h6 id="主要职责">主要职责</h6>
<p>项目经理<mark>首要职责</mark>是在<strong>预算范围内按时优质地领导项目小组完成全部项目工作内容，并使客户满意</strong></p>
<blockquote>
<p>项目经理最终要的是：“沟通”。</p>
</blockquote>
<h2 id="课堂讨论与测试">课堂讨论与测试</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504164316034.png" alt="image-20230504164316034" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504164329941.png" alt="image-20230504164329941" style="zoom: 33%;" />
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章（项目管理与信息技术环境）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/2-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目管理与信息技术环境</h1>
<h5 id="理解项目情境时涉及的因素：">理解项目情境时涉及的因素：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>应用系统方法</p>
</li>
<li class="lvl-2">
<p>组织</p>
</li>
<li class="lvl-2">
<p>管理利益相关者</p>
</li>
<li class="lvl-2">
<p>产品生命周期和项目环境匹配</p>
</li>
<li class="lvl-2">
<p>IT项目的情景</p>
</li>
</ul>
<p>系统：是由若干个可以<u><strong>相互区别、相互联系而又相互作用</strong></u>的要素所组成, 在一定的层次结构形式中分布, 在给定的环境约束下, 为达到**<u>整体的目的</u>**而存在的<u><strong>有机集合体</strong></u>。</p>
<h3 id="系统方法">系统方法</h3>
<p>描述一种在解决复杂问题时所需的<u><strong>整体性和分析性</strong></u>的方法</p>
<p>包括三部分</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong><u>系统哲学</u></strong></em> - 将事情作为系统考虑的整体模型</p>
</li>
<li class="lvl-2">
<p><u><em><strong>系统分析</strong></em></u> - 解决问题的方法（需要定义系统的范围、将其分解为各个组成部分，然后识别和估计问题、机会、约束和需求）</p>
</li>
<li class="lvl-2">
<p><u><em><strong>系统管理</strong></em></u> - 解决与系统的创建、维持和变更相关的<mark>业务上</mark>（费用）、<mark>技术上</mark>和<mark>组织上</mark>的问题</p>
</li>
</ul>
<h4 id="系统管理">⭐️系统管理</h4>
<p><u><em><strong>业务（Business）、技术（Technology）、组织（Organization）</strong></em></u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504171901132.png" alt="image-20230504171901132" style="zoom:50%;" />
<h3 id="组织">⭐️组织</h3>
<p>组织是指一个有明确目标并通过<u><strong>规划、协调、分配资源和聚集人力</strong></u>等手段实现这些目标的实体。</p>
<p>组织环境：影响组织的元素等。（是指对一个组织的经营、管理和发展产生影响的所有因素和条件）</p>
<h5 id="四个框架">⭐️四个框架</h5>
<table>
<thead>
<tr>
<th>结构框架</th>
<th>人力资源框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>用来解决组织结构化的问题着眼于不同部门的角色、责任，以满足最高管理层设定的目标和政策， <br /><span style="color: red;"> 重点用于协调、控制  </span></td>
<td>重点在于促成组织需求和个人需求之间的<span style="color: red;">平衡与协调</span></td>
</tr>
<tr>
<td><strong>政治框架</strong></td>
<td><strong>标志框架</strong></td>
</tr>
<tr>
<td>处理组织和人的政治问题  假定组织是由各种人和利益集团组成的联合体 <br /><span style="color: red;">冲突和权力是中心问题</span></td>
<td>主要指与事件相关的符号和含义 <br /><span style="color: red;">文化很重要  </span></td>
</tr>
</tbody>
</table>
<h4 id="组织结构">⭐️组织结构</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><em><strong>职能型</strong></em></u> – 职能经理向CEO汇报</p>
</li>
<li class="lvl-2">
<p><u><em><strong>项目型</strong></em></u> – 项目经理对CEO负责</p>
</li>
<li class="lvl-2">
<p><u><em><strong>矩阵型</strong></em></u> --介于职能型组织和项目型组织之间. 需要向两个或多个上级汇报, <u><strong>弱矩阵、平衡矩阵和强矩阵</strong></u></p>
</li>
</ul>
<h5 id="组织结构对项目的影响">组织结构对项目的影响</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504173431442.png" alt="image-20230504173431442" style="zoom:50%;" />
<h4 id="组织文化">组织文化</h4>
<h6 id="组织文化的10个特征">组织文化的10个特征</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>成员认同</p>
</li>
<li class="lvl-2">
<p>强调群体</p>
</li>
<li class="lvl-2">
<p>关注员工</p>
</li>
<li class="lvl-2">
<p>单位整合</p>
</li>
<li class="lvl-2">
<p>控制</p>
</li>
<li class="lvl-2">
<p>风险容忍</p>
</li>
<li class="lvl-2">
<p>奖励标准</p>
</li>
<li class="lvl-2">
<p>冲突容忍</p>
</li>
<li class="lvl-2">
<p>过程——结果导向</p>
</li>
<li class="lvl-2">
<p>基于开放的系统</p>
</li>
</ul>
<h4 id="项目生命周期">⭐️项目生命周期</h4>
<p>生命周期：项目都需要经历一个从**<u>开始到结束的时间过程</u>**，项目工作在这一过程中呈现出一定的<u><strong>阶段性</strong></u>的特征。</p>
<h4 id="项目阶段">项目阶段</h4>
<p>阶段：几个基本的阶段包括:</p>
<p>1）概念 Conceive     2) 开发 Develop</p>
<p>3）实施 Execute        4) 收尾 Finish</p>
<p>(简称C ．Ｄ．Ｅ．Ｆ阶段)</p>
<p>说明：前两个阶段(概念和开发)主要工作是做计划，称做<strong>项目可行性阶段</strong>。后两个阶段(实施和收尾)主要是开展实际工作，称做<strong>项目获取阶段</strong>。</p>
<h5 id="项目生命周期基本框架">项目生命周期基本框架</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508142544919.png" alt="项目生命周期基本框架"></p>
<blockquote>
<p>每个阶段结束之后需要进行<mark>项目管理评审</mark></p>
</blockquote>
<table>
<thead>
<tr>
<th>【项目生命周期中的资源投入】</th>
<th>【项目生命周期中的风险级别】</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508143351866.png" alt="image-20230508143351866"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508143402124.png" alt="image-20230508143402124"></td>
</tr>
<tr>
<td><strong>【利益相关者对项目的影响】</strong></td>
<td></td>
</tr>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508143512271.png" alt="image-20230508143512271"></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="每个阶段的交付成果">每个阶段的交付成果</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508143614259.png" alt="image-20230508143614259"></p>
<h5 id="系统开发项目可遵循的-生命周期-：">系统开发项目可遵循的“生命周期”：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>预测生命周期 – 项目的范围可以清晰描述, 项目进度时间表和费用可以被预测</p>
</li>
<li class="lvl-2">
<p>自适应软件开发生命周期 – 项目是任务驱动、基于组件的, 使用基于时间的周期来满足目标日期</p>
</li>
</ul>
<blockquote>
<p>在确定使用哪种生命周期时，两个重要因素：</p>
<ul class="lvl-1">
<li class="lvl-3">需求的变化程度</li>
<li class="lvl-3">有用成果的交付频率</li>
</ul>
</blockquote>
<p><u><em><strong>在什么情况下，要知道选择什么模型？</strong></em></u></p>
<h4 id="项目管理评审">⭐️项目管理评审</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>评审</p>
</li>
<li class="lvl-2">
<p>标志</p>
</li>
<li class="lvl-2">
<p>目的</p>
</li>
</ul>
<p><strong>项目管理评审的<mark>目的</mark>是要判断项目是否应该继续、重新定位或终止</strong></p>
<h5 id="三种离岸外包">三种离岸外包</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>ITO</strong></u>（Information Technology Outsourcing）是指将IT业务流程外包给第三方服务提供商。这些服务可能包括软件开发、网络管理、数据管理、技术支持等。</p>
</li>
<li class="lvl-2">
<p><u><strong>BPO</strong></u>（Business Process Outsourcing）是指将企业的非核心业务流程外包给第三方服务提供商。这些服务可能包括客户服务、财务和会计服务、人力资源管理等。</p>
</li>
<li class="lvl-2">
<p><u><strong>KPO</strong></u>（Knowledge Process Outsourcing）是指将需要高度专业知识和技能的业务流程外包给第三方服务提供商。这些服务可能包括市场研究、数据分析、知识管理等。</p>
</li>
</ul>
<h3 id="虚拟团队">⭐️虚拟团队</h3>
<h2 id="课堂快速测试">课堂快速测试</h2>
<ol>
<li class="lvl-3">
<p>可交付成果；</p>
</li>
<li class="lvl-3">
<p>终止点；</p>
</li>
<li class="lvl-3">
<p>矩阵型；</p>
</li>
<li class="lvl-3">
<p>标志框架；</p>
</li>
<li class="lvl-3">
<p>业务、技术、组织</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章（项目管理过程组）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/3-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目管理过程组</h1>
<h4 id="过程定义">过程定义</h4>
<p><strong>过程</strong>–是为实现某个特定目标而进行的一系列活动。</p>
<h3 id="项目管理过程组定义">项目管理过程组定义</h3>
<p>**项目管理过程组：**是从启动到计划、执行、控制和收尾的一系列活动。</p>
<h5 id="五大过程组：">五大过程组：</h5>
<ol>
<li class="lvl-3">
<p>启动过程：是识**<u>别、评价、确定、开始</u>**一个新的项目或者<u><strong>开始一个项目的一个新阶段</strong></u>的过程。</p>
</li>
<li class="lvl-3">
<p>计划过程：包括制订和维护一个可执行的计划，以保证项目满足组织的要求。</p>
</li>
<li class="lvl-3">
<p>实施（执行）过程：包括协调人力和其他资源来执行项目的计划，以产生项目或者项目阶段的产品、服务或者结果。</p>
</li>
<li class="lvl-3">
<p>监控过程：包括有规律地<u><strong>测量和监视项目进程</strong></u>以保证项目团队能够满足项目目标。</p>
</li>
<li class="lvl-3">
<p>收尾/终止过程：包括<u><strong>对项目或者项目阶段的正式验收</strong></u>，并有效地终止，使项目或项目阶段任务有序、圆满的完成。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508152116145.png" alt="image-20230508152116145" style="zoom:50%;" />
<p><u><em><strong>全过程：在项目生命周期的每一个阶段都存在项目管理过程组。</strong></em></u></p>
<p>⭐️形成一个项目章程(第4章)和选择一位项目经理<u><strong>标志着项目的开始</strong></u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508153258223.png" alt="image-20230508153258223" style="zoom: 33%;" />
<blockquote>
<p><mark>实施过程</mark>和<mark>监控过程</mark>贯穿整个过程</p>
</blockquote>
<h4 id="过程组与知识领域之间的关系">过程组与知识领域之间的关系</h4>
<p>⭐️虚拟团队<mark>计划过程</mark>与<mark>监控过程</mark>贯穿全部知识领域（详见：以下的关系表）</p>
<p><mark>项目集成管理</mark>包含了全部5个过程组</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511160523275.png" alt="image-20230511160523275" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511160625082.png" alt="image-20230511160625082" style="zoom:50%;" />
<h3 id="项目的预启动与启动">项目的预启动与启动</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>启动项目包括<mark>识别和开始</mark>一个新项目或者项目阶段</p>
</li>
<li class="lvl-2">
<p>一些组织还使用了一个<mark>预启动阶段</mark>, 而其他组织将诸如开发商业轮论证案例等工作作为启动阶段的一部分</p>
</li>
<li class="lvl-2">
<p>主要的目的是正式选择并开始项目(<strong>战略目标</strong>、 高回报率)</p>
</li>
</ul>
<h4 id="项目预启动">项目预启动</h4>
<p>主要包括以下任务：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>决定项目的范围、时间和成本的约束因素</p>
</li>
<li class="lvl-2">
<p>确定项目发起人</p>
</li>
<li class="lvl-2">
<p>选择项目经理</p>
</li>
<li class="lvl-2">
<p>为项目开发一个商业论证</p>
</li>
<li class="lvl-2">
<p>与项目经理开会讨论项目管理过程以及预期成果</p>
</li>
<li class="lvl-2">
<p>确定项目是否应该分成两个或以上小项目</p>
</li>
</ul>
<h4 id="项目启动">项目启动</h4>
<p>主要任务：<mark>识别</mark>利益相关者和<mark>制定</mark>项目章程</p>
<h5 id="项目章程">项目章程</h5>
<p><strong>项目章程</strong>的<mark>主要作用</mark>是<u><strong>正式宣布项目存在，粗略规定范围并任命项目经理等</strong></u>。</p>
<p>项目章程的<mark>主要内容</mark>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515143838763.png" alt="image-20230515143838763" style="zoom:50%;" />
<p>项目章程的<mark>输入和输出</mark>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515144032942.png" alt="image-20230515144032942" style="zoom:50%;" />
<h3 id="项目计划">项目计划</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>明确项目范围，优化目标，为实现目标制定行动方案的一组过程。被用来制定成功完成项目或者阶段的行动方案。</p>
</li>
<li class="lvl-2">
<p>项目计划的主要目的是<mark>指导项目的执行</mark>。（<strong><u>多轮反馈 渐进明细</u></strong>）</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511163626352.png" alt="image-20230511163626352" style="zoom:50%;" />
<h3 id="项目实施">项目实施</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>采取必要的行动以确保完成项目计划中的活动。</p>
</li>
<li class="lvl-2">
<p>项目实施总是花费最多的时间和资源。</p>
</li>
<li class="lvl-2">
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试题：里程碑占用的时间资源？（占用资源为</mtext><mn>0</mn><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试题：里程碑占用的时间资源？（占用资源为0）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试题：里程碑占用的时间资源？（占用资源为</span><span class="mord" style="color:red;">0</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span></p>
<h3 id="项目监控">项目监控</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>针对项目目标<mark>衡量进展情况的过程</mark></p>
</li>
<li class="lvl-2">
<p>监控是否与计划有偏离, 并采取纠正措施使项目进展与计划相符</p>
</li>
<li class="lvl-2">
<p>影响所有的过程组, 贯穿整个项目周期</p>
</li>
<li class="lvl-2">
<p>输出包括绩效报告、变更请求和对不同计划的更新</p>
</li>
</ul>
<h3 id="项目收尾">项目收尾</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>涉及获得利益相关者和客户对最终产品和服务的接受认可</p>
</li>
<li class="lvl-2">
<p>即使项目在完成之前就被取消了, 仍要有正式地终止项目和经验总结, 这对改善今后的项目很重要</p>
</li>
<li class="lvl-2">
<p>输出包括项目文件和经验总结, 这些是组织过程资产的一部分</p>
</li>
<li class="lvl-2">
<p>大部分项目也包含有一份最终报告、以及给赞助者和高层领导的介绍</p>
</li>
</ul>
<h2 id="课堂快速测试">课堂快速测试</h2>
<ol>
<li class="lvl-3">
<p>过程</p>
</li>
<li class="lvl-3">
<p>实施过程</p>
</li>
<li class="lvl-3">
<p>计划过程</p>
</li>
<li class="lvl-3">
<p>项目监控</p>
</li>
<li class="lvl-3">
<p>项目管理方法论</p>
</li>
</ol>
<h2 id="课堂讨论">课堂讨论</h2>
<p><span style="color: red;">2、简述5个项目管理过程组分别做什么工作？团队应该在哪个过程花费最多的时间？为什么？</span></p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章（项目范围管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/5-%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目范围管理</h1>
<h2 id="项目需求与范围管理的重要性">项目需求与范围管理的重要性</h2>
<h3 id="成功的三要素">成功的三要素</h3>
<p>对于<u><strong>企业需求</strong></u>、<u><strong>管理理论</strong></u>、<u><strong>竞争压力</strong></u>（<u><strong>核心竞争力</strong></u>）三要素的有效把握才是成功地定义软件需求和确定项目范围的基本保证！</p>
<h5 id="三类人的获取">三类人的获取</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong>需求专家</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>咨询专家</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>概要设计专家</strong></em></p>
</li>
</ul>
<h5 id="三要素的把握">三要素的把握</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong>企业需求</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>管理理论</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>竞争压力</strong></em></p>
</li>
</ul>
<p>讨论题：产品范围与项目范围的区别</p>
<h2 id="项目范围管理相关概念">项目范围管理相关概念</h2>
<h3 id="项目范围">项目范围</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>范围</mark>是指开展<u><strong>项目产品</strong></u>所包括的所有工作及产生这些产品经过的所有过程。</p>
</li>
<li class="lvl-2">
<p>为交付某项具有特定特征和功能的产品所必须完成的工作。</p>
</li>
<li class="lvl-2">
<p>指项目包含且只包含所需要完成的工作（PMBOK）。</p>
</li>
</ul>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>产品范围----刻画某产品或服务所包含的特性和功能。</p>
</li>
<li class="lvl-2">
<p>产品描述－－产品文件（规格、型号、功能、技术文档）</p>
</li>
</ul>
</blockquote>
<h4 id="项目范围与产品范围的关系">项目范围与产品范围的关系</h4>
<p>==<u>项目范围的定义</u>==以其组成的所有产品范围定义为基础，但又不限于产品范围，还包括为实现这些产品范围内的工作必须要做的管理工作（进度管理等）。</p>
<p>衡量标准：产品范围的完成对照产品要求；项目范围的完成对照项目计划</p>
<p>可能一个产品的范围很大，我们只是将其中的一部分作为项目，这时，<u><em><strong>项目范围与产品范围就是交叉关系</strong></em></u></p>
<h3 id="项目范围管理">⭐️项目范围管理</h3>
<p>项目范围管理<strong>是指对项目包括什么与不包括什么的定义与控制过程。</strong></p>
<h5 id="项目范围管理的作用">⭐️项目范围管理的作用</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>为项目实施提供任务范围的框架</p>
</li>
<li class="lvl-2">
<p>对项目的实施提供有效的控制</p>
</li>
<li class="lvl-2">
<p>为项目最终交付提供依据</p>
</li>
</ul>
<blockquote>
<p><em><strong>用于确保项目组和项目干系人对作为项目结果的项目产品以及生产这些产品所用到的过程有一个共同的理解。</strong></em></p>
</blockquote>
<h3 id="项目范围管理的过程">⭐️项目范围管理的过程</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518162905237.png" alt="image-20230518162905237" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>范围规划</p>
</li>
<li class="lvl-2">
<p>收集需求</p>
</li>
<li class="lvl-2">
<p>定义范围</p>
</li>
<li class="lvl-2">
<p>创建WBS</p>
</li>
<li class="lvl-2">
<p>确认范围</p>
</li>
<li class="lvl-2">
<p>范围控制</p>
</li>
</ul>
<h3 id="项目范围管理的主要工作">项目范围管理的主要工作</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518163024775.png" alt="image-20230518163024775" style="zoom: 67%;" />
<h4 id="项目范围管理包括六个主要过程">项目范围管理包括六个主要过程</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>范围规划</p>
</li>
<li class="lvl-2">
<p>收集需求</p>
</li>
<li class="lvl-2">
<p>范围定义</p>
</li>
<li class="lvl-2">
<p>工作结构分解</p>
</li>
<li class="lvl-2">
<p>范围验证</p>
</li>
<li class="lvl-2">
<p>范围控制</p>
</li>
</ul>
<h2 id="1范围规划和范围管理计划">1范围规划和范围管理计划</h2>
<h3 id="范围计划编制">范围计划编制</h3>
<p><strong>编写范围管理计划应遵守“SMART”原则</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Specific</p>
</li>
<li class="lvl-2">
<p>Measurable</p>
</li>
<li class="lvl-2">
<p>Achievable</p>
</li>
<li class="lvl-2">
<p>Result driven/Relevant</p>
</li>
<li class="lvl-2">
<p>Timing</p>
</li>
</ul>
<h5 id="输出">输出</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>范围管理计划</p>
</li>
<li class="lvl-2">
<p>需求管理计划</p>
</li>
</ul>
<p><em><strong><u>范围管理计划是项目管理计划的组成部分，描述将如何定义、制定、监督、控制和确认项目范围。</u></strong></em></p>
<p><u><em><strong>需求管理计划是项目管理计划的组成部分，描述将如何分析、记录和管理项目和产品需求。</strong></em></u></p>
<h2 id="2收集需求">2收集需求</h2>
<p><mark>收集需求</mark>（Collect Requirement）是为实现项目目标而确定、记录并管理干系人的需要和需求的过程，其作用是为定义和管理项目范围（包括产品范围）奠定基础。且仅开展一次或仅在项目的预定义点开展。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518164355880.png" alt="image-20230518164355880" style="zoom: 50%;" />
<h2 id="3范围定义和项目范围说明书">3范围定义和项目范围说明书</h2>
<p><mark>范围定义</mark>就是制定详细的项目范围说明书，供将来的项目决策作为依据的过程。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518170019191.png" alt="image-20230518170019191" style="zoom:50%;" />
<h2 id="4创建工作分解结构-wbs">4创建工作分解结构(WBS)</h2>
<p>工作分解结构是一种<u><strong>以结果为导向</strong></u>的分析方法，用于分析项目所涉及到的工作，所有这些工作构成了项目的整个范围。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>以<u><strong>可交付成果</strong></u>为导向</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518170116594.png" alt="image-20230518170116594" style="zoom:50%;" />
<h3 id="wbs的作用">WBS的作用</h3>
<p>⭐️<u><em><strong>WBS有层次，没有层次的不是WBS</strong></em></u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518171731036.png" alt="image-20230518171731036" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>参与者快速定位</p>
</li>
<li class="lvl-2">
<p>对全局进行把控</p>
</li>
</ul>
<h5 id="范围基线">⭐️范围基线⭐️</h5>
<p>范围基线：<u><strong>项目范围说明书</strong></u>及<u><strong>相关的WBS</strong></u>、<u><strong>WBS词典</strong></u>构成，是实现项目范围目标的绩效的依据。</p>
<h6 id="wbs词典">WBS词典</h6>
<p>WBS词典是一种用于描述和定义WBS各个组成部分的文档或工具。它是对WBS元素的详细描述，包括每个工作包或任务的名称、编号、描述、责任人、工作量、预算等信息。</p>
<h2 id="5范围验证和范围核实">5范围验证和范围核实</h2>
<p>项目范围核实是指进入项目实施阶段以后，项目利益相关者对项目范围的正式认可和接受（或可以进入下一阶段）的过程。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518173008822.png" alt="image-20230518173008822" style="zoom:50%;" />
<h2 id="6范围控制">6范围控制</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>范围控制是指控制项目范围的变更</p>
</li>
<li class="lvl-2">
<p>范围控制的目的是对那些引起项目范围变化的因素施加影响，确保变更能依据集成变成控制建立的程序有序进行</p>
</li>
</ul>
<h3 id="项目蔓延问题">项目蔓延问题</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518173401278.png" alt="image-20230518173401278" style="zoom:50%;" />
<h3 id="范围变更控制过程">范围变更控制过程</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518174028844.png" alt="image-20230518174028844" style="zoom:50%;" />
<h2 id="课堂快速测试">课堂快速测试</h2>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章（项目集成管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/4-%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目集成管理</h1>
<p>⭐️<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515140437481.png" alt="image-20230515140437481" style="zoom: 33%;" /></p>
<h2 id="什么是项目集成管理">什么是项目集成管理</h2>
<p>1、项目集成管理任务是在项目生命周期中协调所有其他项目管理知识领域所涉及的过程。</p>
<p>​		－－它确保项目所有的组成要素在<u><strong>恰当的时间、正确的地方、合适的人物</strong></u>结合在一起，以成功地完成项目。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511172149710.png" alt="image-20230511172149710" style="zoom:33%;" />
<p>2、具体内容：项目集成管理<mark>围绕</mark>项目计划进行，主要过程有：<u><strong>计划制定</strong></u>、<u><strong>计划执行</strong></u>和<u><strong>计划变更控制</strong></u>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511172302030.png" alt="image-20230511172302030" style="zoom:33%;" />
<p>3、关键：集成管理是实现<u><strong>整体项目成功</strong></u>的关键。</p>
<p>4、项目经理的主要任务:是作好项目的集成管理，特别是:</p>
<p>​	1)<strong>主动控制</strong>项目的人员、计划、工作。</p>
<p>​	2)<strong>及时协调</strong>各项目目标之间或人员之间的冲突。</p>
<p>​	3)<strong>适时认真</strong>向高层汇报重要的项目信息。</p>
<h3 id="项目集成管理的主要工作">⭐️项目集成管理的主要工作</h3>
<p>(1) <u><strong>制定项目章程</strong></u>。它是指与项目利益相关者一起合作，制定正式批准项目的文件——章程。</p>
<p>(2) <u><strong>创建初步的项目范围说明书</strong></u>。它是指通过与项目利益相关者的合作，尤其是与项目产品、服务或其他产出的用户合作，开发出总体的范围要求。这个过程的目的便是建立初步的项目范围说明书。</p>
<p>(3) <u><strong>制定项目管理计划</strong></u>。这个阶段涉及协调所有计划要付出的努力，创建一份一致、连贯的文件——项目管理计划。</p>
<p>(4) <u><strong>指导和管理项目实施</strong></u>。这涉及通过实施项目管理计划中的活动，来执行项目管理计划。这个阶段主要完成交付物、变更请求、工作绩效信息、被实施的变更请求、纠正措施、预防措施和缺陷修复。</p>
<p>(5) <u><strong>监控项目工作</strong></u>。这涉及监督项目工作是否符合项目的绩效目标。这个阶段主要<u>完成惩治和预防措施建议</u>、<u>缺陷修复建议</u>以及<u>变更请求</u>。</p>
<p>(6) <u><strong>整体变更控制</strong></u>。它涉及对影响项目交付物和组织运营资产的所有变更做好协调工作。这个阶段的任务包括被批准和被拒绝的变更请求、被批准的纠正和预防措施、被批准和生效的缺陷修复、交付物、项目管理计划和项目范围说明书的更新。</p>
<p>(7) <u><strong>项目收尾</strong></u>。它涉及完成所有的项目活动，从而式结束项目。这个阶段包括最终产品、服务或者成果，行政上和合同上的终止于续，以及对组织运营资产的更新。</p>
<h3 id="项目集成管理的思想">项目集成管理的思想</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511173359466.png" alt="image-20230511173359466" style="zoom:50%;" />
<h2 id="战略计划和项目选择">战略计划和项目选择</h2>
<h3 id="swot">SWOT</h3>
<p>&quot;SWOT&quot;是一种商业分析工具，其名称代表着Strengths（优势）、Weaknesses（劣势）、Opportunities（机会）和Threats（威胁）。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SWOT 即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要<u><strong>内部优势、劣势和外部的机会和威胁</strong></u>等，通过调查列举出来，并依照<u><strong>矩阵形式排列</strong></u>，然后用<u><strong>系统分析</strong></u>的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p>
</li>
<li class="lvl-2">
<p>运用这种方法，可以对研究对象所处的情景进行<u><strong>全面、系统、准确</strong></u>的研究，从而根据研究结果制定相应的<u><strong>发展战略、计划以及对策</strong></u>等。</p>
</li>
</ul>
<h3 id="识别有潜力的项目">识别有潜力的项目</h3>
<h4 id="筛选信息技术项目过程-重点">⭐️筛选信息技术项目过程（重点⭐️）</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515141208580.png" alt="筛选信息技术项目过程" style="zoom:50%;" />
<p>⭐️<u>识别</u>潜在项目<u>之后</u>，还必须<mark>进行筛选</mark>，下面是4种筛选方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>注重<u><strong>整个组织的需求</strong></u>；——标准：“<mark>需求、资金和意愿</mark>”。</p>
</li>
<li class="lvl-2">
<p>将IT<u><strong>项目进行分类</strong></u>；——依据：优先级、时间、动机</p>
</li>
<li class="lvl-2">
<p>进行净现值等<u><strong>财务分析</strong></u>；</p>
</li>
<li class="lvl-2">
<p>运用<u><strong>加权评分模</strong></u>型。</p>
</li>
</ul>
<h4 id="对it项目进行分类">⭐️对IT项目进行分类</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于<mark>优先级</mark>的分类：将待选项目按高、中、低三个次序进行整体综合排序，首先进行最重要的项目。</p>
</li>
<li class="lvl-2">
<p>基于<mark>时间</mark>的分类：基于时间的考虑筛选项目，可能是完成项目所需的工期时间，也可能是项目必须满足的截止日期；</p>
</li>
<li class="lvl-2">
<p>基于<mark>动机</mark>的分类</p>
<ul class="lvl-2">
<li class="lvl-4"><mark>问题、机会、（上级）指令</mark></li>
<li class="lvl-4">机会：评价项目是否可以<u><strong>解决某个问题</strong></u>，或是<u><strong>抓住某种机会</strong></u>，或迎合某个<u><strong>指示要求</strong></u>；</li>
</ul>
</li>
</ul>
<h4 id="净现值分析">净现值分析⭐️</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>净现值分析( net present value analysis)是计算项目<u><strong>预期净货币收益和损失</strong></u>的方法，将当前时间点之后的所有未来预期现金流入和流出都做折现计算。</p>
</li>
<li class="lvl-2">
<p>只考虑那些能产生<u><strong>正净现值的项目</strong></u>（项目回报超过了资金成本）</p>
<ul class="lvl-2">
<li class="lvl-4">优先选择净现值大的项目</li>
</ul>
</li>
</ul>
<p>折现因子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>r</mi><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{(1+r)^t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7253em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>第t年现金流：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">A_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span style="color: red;">净现值(NPV)：</span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1...</mn><mi>n</mi></mrow></munder><mfrac><msub><mi>A</mi><mi>t</mi></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>r</mi><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sum_{t=1...n} \frac{A_t}{(1+r)^t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.6274em;vertical-align:-1.2671em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1...</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7196em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><mark>折现率</mark>( discount rate)是用来将未来现金流折现的利率，也称作资本化率或资本机会成本。</p>
<h4 id="投资回报率-投资回报">投资回报率/投资回报</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>选择项目时候另外一个重要的财务考虑因素便是投资回报。</p>
</li>
<li class="lvl-2">
<p>投资回报率/投资回报(retum on investment , ROI) 是项目的收益减去成本后，再除以成本的结果。</p>
</li>
</ul>
<p><span style="color: red;">投资回报率（ROI）：</span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mtext>总的折现收益</mtext><mo>−</mo><mtext>总的折现成本</mtext></mrow><mtext>总的折现成本</mtext></mfrac></mrow><annotation encoding="application/x-tex">\frac{总的折现收益-总的折现成本}{总的折现成本}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总的折现成本</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总的折现收益</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">总的折现成本</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h2 id="项目管理计划">项目管理计划</h2>
<blockquote>
<p><mark>项目管理计划</mark>(project management plan) 用来<u><strong>协调所有项目计划文件</strong></u>和帮助<u><strong>引导项目的执行与控制</strong></u>。</p>
</blockquote>
<h3 id="项目管理计划的制定">⭐️项目管理计划的制定</h3>
<p>1.定义：项目计划是一个用来<u><strong>协调</strong></u>所有其他计划，以<u><strong>指导项目执行和控制</strong></u>的可操作的文件。</p>
<p>2.关系：项目计划与项目执行应该是<u><strong>相互渗透</strong></u>的,谁负责做这件事，就该由谁来做这个计划。</p>
<p>3.⭐️内容：一个项目计划主要包括：<u><strong>整体介绍、组织描述、管理程序、技术程序、任务范围、时间进度、经费预算</strong></u>等。</p>
<h3 id="项目管理计划的主要内容">项目管理计划的主要内容</h3>
<ol>
<li class="lvl-3">
<p>整体介绍或概述</p>
</li>
<li class="lvl-3">
<p>组织情况描述</p>
</li>
<li class="lvl-3">
<p>项目的管理和方法</p>
</li>
<li class="lvl-3">
<p>项目任务</p>
</li>
<li class="lvl-3">
<p>项目进度</p>
</li>
<li class="lvl-3">
<p>项目预算</p>
</li>
<li class="lvl-3">
<p>利益相关者分析</p>
</li>
</ol>
<h3 id="项目管理计划的执行">项目管理计划的执行</h3>
<p>项目计划的实施的工具和方法：</p>
<p>① 项目管理流程</p>
<p>② 工作授权系统</p>
<p>③ 状态审查会议（项目进度碰头会）</p>
<p>④ 项目管理软件</p>
<p>积极的领导和强大的团队合作是项目管理成功的关键。</p>
<h3 id="监控项目">监控项目</h3>
<h5 id="变更请求中的缺陷补救作用">变更请求中的缺陷补救作用</h5>
<blockquote>
<p>在变更请求中，缺陷补救的作用是解决或修复已经发现的缺陷或问题。当在项目或产品开发过程中发现了缺陷或问题时，变更请求可以被提出以寻求对其进行补救。</p>
<p>以下是缺陷补救在变更请求中的几个重要作用：</p>
<ol>
<li class="lvl-3">
<p>问题解决：缺陷补救的主要目的是解决已经发现的问题。通过变更请求，可以提出相应的修复措施，确保问题得到解决，从而提高项目或产品的质量和可靠性。</p>
</li>
<li class="lvl-3">
<p>客户满意度提升：及时处理和修复缺陷可以增加客户满意度。当客户发现缺陷并提出变更请求时，快速响应并解决问题可以增加客户对组织的信任和满意度。</p>
</li>
<li class="lvl-3">
<p>风险降低：未解决的缺陷可能对项目或产品产生负面影响，并引发进一步的问题。通过及时采取缺陷补救措施，可以减少潜在的风险，并避免问题进一步扩大化。</p>
</li>
<li class="lvl-3">
<p>过程改进：通过分析和处理变更请求中的缺陷，可以识别问题的根本原因，并采取适当的措施来改进开发过程。这有助于组织避免类似的问题在未来的项目中再次发生，提高整体效率和质量。</p>
</li>
</ol>
<p>——GPT</p>
</blockquote>
<h3 id="集成变更控制">⭐️集成变更控制</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>集成变更控制( integrated change control) 涉及在<u>整个项目的生命周期</u>中<u><strong>识别、估计和管理变更</strong></u>。</p>
</li>
<li class="lvl-2">
<p>⭐️集成变更控制的<mark>主要目的是</mark>:</p>
<p>(1)控制可能造成变更的因素，以确保变更都是有益的。</p>
<p>(2)确认变更已经发生。</p>
<p>(3)管理发生的变更。</p>
</li>
</ul>
<h4 id="流程">流程</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515151435244.png" alt="image-20230515151435244" style="zoom:50%;" />
<blockquote>
<p><u><strong>变更请求</strong></u>是<u>监控项目</u>的输出</p>
</blockquote>
<h4 id="变更控制系统">⭐️变更控制系统⭐️</h4>
<p>变更控制系统是一个正式的、文档化的过程。描述了正式的项目文件可能改变的时间和方式。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515151747652.png" alt="image-20230515151747652" style="zoom:50%;" />
<h3 id="终止项目">终止项目</h3>
<h4 id="项目集成管理的最后一步">项目集成管理的最后一步</h4>
<p>必须要有活动收尾，并向适当的人员交付已完成或取消的工作。主要成果如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>行政收尾程序</p>
</li>
<li class="lvl-2">
<p>合同收尾程序</p>
</li>
<li class="lvl-2">
<p>最终产品、服务或者成果</p>
</li>
<li class="lvl-2">
<p>组织过程资产更新</p>
</li>
</ul>
<p>过程资产：项目团队以实用方式提供的一份包括项目文档、项目终止文件和历史信息的清单。</p>
<h2 id="课堂快速测试">课堂快速测试</h2>
<h2 id="课堂讨论">课堂讨论</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515154749077.png" alt="image-20230515154749077" style="zoom:50%;" />
<p>存在的问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>没有进行项目集成管理</p>
</li>
<li class="lvl-2">
<p>没有考虑项目管理计划的7个方面（从这7个方面来进行分析）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章（项目进度管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/6-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6(%E6%97%B6%E9%97%B4)%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目进度管理</h1>
<blockquote>
<p>考点：</p>
<ul class="lvl-1">
<li class="lvl-2"><u><strong>关键路径</strong></u>分析方法</li>
<li class="lvl-2">运用<u><strong>网络图</strong></u>和活动间的依赖关系进行活动排序
<ul class="lvl-3">
<li class="lvl-4">双代号网络图</li>
</ul>
</li>
<li class="lvl-2">制定项目进度计划的过程</li>
</ul>
</blockquote>
<p>工程类项目：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>质量</p>
</li>
<li class="lvl-2">
<p>时间</p>
</li>
<li class="lvl-2">
<p>投资</p>
</li>
</ul>
<h5 id="时间的四项独特性">时间的四项独特性</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>供给毫无弹性：无法开源</p>
</li>
<li class="lvl-2">
<p>无法蓄积：无法节流</p>
</li>
<li class="lvl-2">
<p>无法取代：任何一项活动都有赖于时间的堆砌，时间是<u><strong>任何活动不可或缺</strong></u>的<u>基本资源</u>。</p>
</li>
<li class="lvl-2">
<p>无法失而复得</p>
</li>
</ul>
<h2 id="项目进度计划的重要性">项目进度计划的重要性</h2>
<p>大多数项目都有一个规定的交付日期，这是因为<u><strong>需求、市场环境</strong></u></p>
<h3 id="项目生命周期内冲突的强度">项目生命周期内冲突的强度</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230522151334399.png" alt="image-20230522151334399" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>项目需要在<u><strong>一定的时间和预算成本</strong></u>内完成实现一定的可交付物的工作,并使客户满意,因此项目的重要特征之一是<u><strong>具有具体的时间期限</strong></u>。</p>
</li>
<li class="lvl-2">
<p>为了使项目能够按时完成,在项目开始之前编制一份<u><strong>项目活动的进度计划</strong></u>是非常有必要的。进度计划就是使项目的每项活动的<u><strong>开始及结束时间具体化</strong></u>的计划。</p>
</li>
</ul>
<h3 id="项目进度管理">项目进度管理</h3>
<p><mark>项目进度管理</mark>就是要采用一定的方法,对项目范围所包括的<u><strong>活动及其相互关系</strong></u>进行分析,对各项活动所需要的<u><strong>时间和资源</strong></u>进行估算,并在项目的时间期限内<u><strong>合理地安排和控制活动的开始和结束时间</strong></u>。 显然, <mark>项目时间管理的意义</mark>就是<u><strong>保证项目按照时间期限在预算成本内完成项目全部可交付物工作。</strong></u></p>
<p><span style="color: red;">项目计划 </span></p>
<p>是指导项目实施和控制的一系列纲领性文件，是经高层管理批准的项目正式文档。</p>
<p><span style="color: red;">进度计划 </span></p>
<p>是表达项目中<u><strong>各项工作（活动）的开展顺序、开始及完成时间及相互衔接关系</strong></u>的计划。进度计划是进度控制和管理的依据；同时引导项目其他类型的计划工作。</p>
<p><span style="color: red;">项目进度计划制定 </span></p>
<p>是根据项目的目标，在项目确定的范围内、依据确定的需求和质量标准、并在项目成本预算许可下，<u><strong>制定出一个周密的项目活动安排的过程</strong></u>。</p>
<h4 id="项目进度管理过程">项目进度管理过程</h4>
<p><mark>进度跟踪与控制</mark>：在项目的执行和实施过程中，经常检查实际进度是否按计划要求进行，若出现偏差，便要及时找出原因，采取必要的补救措施或调整、修改原计划，直至项目完成的过程。</p>
<p><mark>项目进度管理</mark>包括为确保项目按时完成所需要的各个过程：</p>
<p><u><strong>规划进度管理</strong></u>、<u><strong>定义活动</strong></u>、<u><strong>活动排序</strong></u>、<u><strong>估算活动持续时间</strong></u>、<u><strong>项目进度计划编制</strong></u>、以及<u><strong>进度跟踪与控制过程</strong></u>等。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230522152251879.png" alt="image-20230522152251879" style="zoom:50%;" />
<h2 id="1规划进度管理">1规划进度管理</h2>
<p><mark>规划进度管理</mark>：确定将用于计划、执行和控制项目进度的<u><strong>政策、流程和文档</strong></u>。</p>
<p>进度管理计划一般包括以下信息：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>项目进度模型的开发</u>：包括持续时间的估算、依赖关系和其他用来生成项目进度的信息。</p>
</li>
<li class="lvl-2">
<p><u>准确度和计量单位</u>：小时、天等</p>
</li>
<li class="lvl-2">
<p><u>控制阈值</u>：建立偏差阈值</p>
</li>
<li class="lvl-2">
<p>绩效评估规则</p>
</li>
<li class="lvl-2">
<p>报告格式</p>
</li>
<li class="lvl-2">
<p>过程描述：如何执行所有的进度管理过程</p>
</li>
</ul>
<h2 id="2定义活动">2定义活动</h2>
<p><mark>定义活动</mark>是<u><strong>识别和记录</strong></u>为完成<u><strong>项目可交付成果</strong></u>而须<u><strong>采取的具体行动的过程</strong></u>。</p>
<h5 id="主要作用">主要作用</h5>
<p>本过程的<mark>主要作用</mark>是，将工作包分解为进度活动，作为对项目工作进行进度估算、规划、执行、监督和控制的基础。</p>
<p>①<u><strong>活动或任务</strong></u>：是项目进行期间需要完成的<u><strong>工作单元</strong></u>，它们有预期的<u><strong>历时、成本和资源要求</strong></u>。</p>
<p>②<u><strong>定义活动的目标</strong></u>：是确保对项目范围有**<u>一个完整的理解</u>**。</p>
<p>③<u><strong>定义活动的主要依据</strong></u>：是<u><strong>项目章程、范围说明书、WBS和项目预算信息</strong></u>。</p>
<p>示例：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230522153130633.png" alt="image-20230522153130633" style="zoom:50%;" />
<blockquote>
<p><mark>活动定义过程</mark>识别处于WBS最下层叫做<u><strong>工作包的可交付成果</strong></u></p>
<ul class="lvl-1">
<li class="lvl-2"><em><strong>活动是对wbs的可交付成果的进一步划分</strong></em></li>
</ul>
</blockquote>
<h5 id="导致结果">导致结果</h5>
<p>①定义活动通常导致<u><strong>制定更加详细的工作分解结构</strong></u>。</p>
<p>②定义活动产生一些<u><strong>辅助性的详细资料</strong></u>，它将重要的产品信息、与具体活动相关的假设和约束条件形成相应的文件。</p>
<p>③在转移到活动排序过程以前，项目团队应该与项目干系人一起，<u><strong>审查修订</strong></u>的工作分解结构和依据资料。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230522153620213.png" alt="image-20230522153620213" style="zoom:50%;" />
<blockquote>
<p>⭐️分解用于<u><strong>活动定义</strong></u>时，最后结果是Activities(活动)；分解用于<u><strong>范围定义</strong></u>时，最后结果为Deliverables(可交付成果)</p>
</blockquote>
<p><mark>滚动式规划</mark>：在项目生命周期的不同阶段，工作的详细程度会有所不同。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在早期的战略规划阶段，信息尚不够明确，工作只能分解到已知的详细水平；随着了解到更多的信息，近期即将实施的工作包就可以分解到具体的活动。</p>
</li>
</ul>
<h5 id="span-style-color-red-u-输出-u-span"><span style="color: red;"><u><em><strong>输出</strong></em></u></span></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>活动清单：包括项目将要进行的所有计划活动。</p>
</li>
<li class="lvl-2">
<p>活动属性：每项活动所具有的多种属性，用来扩充对活动的描述，活动属性随时间演进。</p>
</li>
<li class="lvl-2">
<p>里程碑清单：项目中重要时点或者事件，列出了所有项目里程碑，并指明每个里程碑是强制性的。</p>
</li>
</ul>
<h2 id="3活动排序">3活动排序</h2>
<p><mark>活动排序</mark>涉及详细审查WBS中的活动、详细的产品说明书、假设和约束条件，以决定活动之间的相互关系。它也涉及评价活动之间依赖关系的原因、及各种依赖关系。</p>
<h5 id="依赖关系-四种">依赖关系（四种）</h5>
<p><mark>依赖关系或关系</mark>反映了项目活动或任务的顺序。一个<u><strong>没有明确活动之间关系</strong></u>的项目是不可能成功的。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>强制依赖关系（硬逻辑关系）</strong></u>是项目工作固有的特性(行业逻辑）。</p>
</li>
<li class="lvl-2">
<p><u><strong>自由依赖关系（软逻辑关系）</strong></u>是由项目团队来定义的(是否签字）。</p>
</li>
<li class="lvl-2">
<p><u><strong>外部依赖关系</strong></u> 涉及项目与非项目活动之间的关系（操作系统供应商）。</p>
</li>
<li class="lvl-2">
<p><u><strong>内部依赖关系</strong></u> 涉及项目活动之间的关系（在项目团队控制之内）。</p>
</li>
</ul>
<h5 id="四种依赖关系类型">四种依赖关系类型</h5>
<p>四种依赖关系类型：确定了活动之间存在某种依赖关系（强制的，自由的，或者外部的等）之后，接下来必须确定依赖关系的类型。活动之间存在<u><strong>四种依赖关系类型</strong></u>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>完成-开始（FS-Finished Start）：==从活动（紧前活动）==必须完成后，==到活动（紧后活动）==才能开始。</p>
</li>
<li class="lvl-2">
<p>开始-开始（SS）：从活动开始后，到活动才能开始。</p>
</li>
<li class="lvl-2">
<p>完成-完成（FF）：到活动完成前，从活动必须完成。</p>
</li>
<li class="lvl-2">
<p>开始-完成（SF）：从活动必须开始后，到活动才能完成。</p>
</li>
</ul>
<h5 id="活动排序概念">活动排序概念</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>排列活动顺序是<mark>识别和记录</mark><u><strong>项目活动之间的关系</strong></u>的过程。</p>
</li>
<li class="lvl-2">
<p>是<u><strong>识别项目活动清单中各项活动的依赖关系</strong></u>，它的<mark>主要依据</mark>是<u><strong>已识别的活动清单</strong></u>。根据<u><strong>活动清单和依赖关系</strong></u>，<u>安排项目活动的顺序和先后关系</u>。</p>
</li>
<li class="lvl-2">
<p><mark>本过程的主要作用</mark>是<u><strong>定义工作之间的逻辑顺序</strong></u>，以便在既定的所有项目制约因素下获得最高的效率。</p>
</li>
</ul>
<h5 id="提前量和滞后量">提前量和滞后量</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>提前量是相对于紧前活动，紧后活动可以<u>提前的时间量</u>。</p>
</li>
<li class="lvl-2">
<p>滞后量是相对于紧前活动，紧后活动需要<u>推迟的时间量</u>。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525161844959.png" alt="image-20230525161844959" style="zoom:33%;" />
<h4 id="项目网络图">⭐️项目网络图</h4>
<h5 id="箭线图法-adm-双代号网络-aoa">⭐️箭线图法(ADM)-双代号网络(AOA)</h5>
<p>①项目网络图 ：项目网络图是<u><strong>项目活动之间的逻辑关系或排序</strong></u>的<em><strong>图形显示</strong></em>。</p>
<p>②表示方法：使用<u><strong>箭线图法(ADM)</strong></u>或<u><strong>双代号网络图法(AOA)</strong></u>编制的网络图如图所示。 AOA是用箭线表示活动，用节点的连接点反映活动顺序的网络制图技术。<mark>节点</mark>简单的<u><strong>表示活动的<mark>开始和结束</mark></strong></u>。</p>
<p><u><em><strong>双代号网络图法(AOA)示例</strong></em></u>：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162032690.png" alt="双代号网络图法(AOA)示例"></p>
<blockquote>
<p><mark>缺点：</mark></p>
<ul class="lvl-1">
<li class="lvl-2">只能表示FS一种活动依赖关系</li>
</ul>
</blockquote>
<h6 id="虚活动">⭐️虚活动</h6>
<p>作用：辅助排序使用</p>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162511167.png" alt="image-20230525162511167" style="zoom: 33%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162559410.png" alt="image-20230525162559410" style="zoom:33%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p><u><em><strong>只有双代号网络图法（AOA）中采用“虚活动”。</strong></em></u></p>
</blockquote>
<h5 id="前导图法-pdm-单代号网络-aon">⭐️前导图法(PDM)-单代号网络(AON)</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162941631.png" alt="image-20230525162941631" style="zoom:50%;" />
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525163017244.png" alt="image-20230525163017244"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525163026046.png" alt="image-20230525163026046"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p><mark>PDM法的优点：</mark></p>
<p>①大多数项目管理软件使用PDM法</p>
<p>②PDM法<u><strong>避免了使用虚活动</strong></u>(没有历时、不占用资源的活动)</p>
<p>③PDM法<u><strong>反映了任务之间的各种依赖关系</strong></u></p>
</blockquote>
<p><mark>附：活动资源估计</mark>（本过程必须放在<u><strong>活动持续时间估计</strong></u>之前）</p>
<p><em><strong><u>分析和识别项目的资源需求，确定项目所需<mark>投入资源的种类</mark>、估计<mark>资源的数量</mark>和<mark>资源投入的时间</mark>。</u></strong></em></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525163533034.png" alt="image-20230525163533034" style="zoom:33%;" />
<h2 id="4估算活动持续时间">4估算活动持续时间</h2>
<p><mark>估算活动持续时间</mark>是<em><strong>根据资源估算</strong></em>的结果，<u>估算</u><u><strong>完成单项活动所需工作时段数</strong></u>的过程。</p>
<p><mark>本过程的主要作用是</mark>，确定<u><strong>完成每个活动所需花费的时间量</strong></u>。</p>
<p><u><strong>历时估算</strong></u>：估算完成项目<u><strong>每项活动所需要的时间</strong></u>（hour，day， week）。<mark>历时</mark>包括活动消耗的<u><strong>实际时间</strong></u>，加上<u><strong>间歇时间</strong></u>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525163832654.png" alt="image-20230525163832654" style="zoom:50%;" />
<h5 id="历时">历时</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525163856653.png" alt="image-20230525163856653" style="zoom:33%;" />
<h4 id="三点估算-一个选择题">三点估算（一个选择题）</h4>
<p>是一种<u><strong>期望平均工期法</strong></u>。</p>
<p><mark>PERT方法</mark>对每个活动的工期有3种估计：</p>
<p>1）乐观的</p>
<p>2）最可能的</p>
<p>3）悲观的</p>
<p>并假设<em><strong>活动工期</strong></em>服从贝塔分布。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525164138805.png" alt="image-20230525164138805" style="zoom:33%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525164202234.png" alt="image-20230525164202234" style="zoom:50%;" />
<h2 id="5制定进度计划">5制定进度计划</h2>
<p><mark>制定进度计划</mark>是<u><strong>分析活动顺序</strong></u>、<u><strong>持续时间</strong></u>、<u><strong>资源需求</strong></u>和<u><strong>进度制约因素</strong></u>，创建进度模型，从而落实<u><strong>项目执行和监控</strong></u>的过程。</p>
<p><mark>本过程的主要作用</mark>是，为完成项目活动而制定<u><strong>具有计划日期的进度模型</strong></u>。</p>
<p>制定进度计划的最终目标是：建立一个<em><strong>现实的</strong></em>项目进度计划，为<u><strong>监控项目的时间进展情况</strong></u>提供一个基础。</p>
<p>制定进度计划的方法是：<u><strong>应用定义、排序、历时估算</strong></u>等过程得到的结果，制定进度计划，<u>决定项目的开始日期和完成日期</u>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525170143217.png" alt="image-20230525170143217" style="zoom:50%;" />
<blockquote>
<p>⭐️关键路径法（掌握）</p>
</blockquote>
<h5 id="进度计划编制">进度计划编制</h5>
<p><mark>进度计划编制</mark>：就是根据进度管理前几个过程的结果所进行的分析和项目计划的编制，<mark>产生经批准的<u>项目进度计划</u></mark>，以便<u><strong>作为项目进度管理的基线</strong></u>。</p>
<blockquote>
<p>项目计划要确定项目活动的起始时间和完成时间。同时要考虑其它因素的影响。</p>
<p><u><em><strong>进度计划中的几个时间参数和相关术语</strong></em></u>：</p>
<ul class="lvl-1">
<li class="lvl-4">
<p>ES：最早开始</p>
</li>
<li class="lvl-4">
<p>EF：最早完成</p>
</li>
<li class="lvl-4">
<p>LS：最晚开始</p>
</li>
<li class="lvl-4">
<p>LF：最晚完成</p>
</li>
</ul>
</blockquote>
<h5 id="浮动时间">浮动时间</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525170128574.png" alt="image-20230525170128574" style="zoom:50%;" />
<p><u><strong>进度压缩</strong></u>：在<u><strong>不缩减项目范围的前提下</strong></u>，<u>缩短或加快进度工期</u>，以满足进度制约因素、强制日期和其他进度目标。</p>
<h3 id="关键路径法">⭐️关键路径法</h3>
<p><mark>关键路径法（CPM）</mark>：这种进度网络分析技术<u><strong>在不考虑任何资源限制的情况下</strong></u>，根据制定的<u><strong>网络顺序逻辑关系</strong></u>和<u><strong>单一历时估算</strong></u>，沿进度网络路径使用<u><strong>顺推与逆推法</strong></u>，计算出所有活动的<u>最早开始ES、最早结束EF、最晚开始LS和最晚完成LF日期</u>。用来<u><em>预测整个项目的持续时间</em></u>。</p>
<blockquote>
<p><mark>其核心</mark>是<u><strong>计算浮动时间</strong></u>，确定哪些活动的进度安排灵活性最小。</p>
</blockquote>
<p><mark>关键路径</mark>：指决定项目最早完成时间的一系列活动，是<u><strong>通过网络图的最长路径</strong></u>，其<u><strong>浮动时间最少</strong></u>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong>关键路径是可以变化的</strong></em>，如果对路径进行压缩可能会导致最终的项目完成时间减少，从而导致<u>最长时间路径</u>（关键路径）改变。</p>
</li>
<li class="lvl-2">
<p>是项目完成的最短完成时间</p>
</li>
</ul>
<p>⭐️<mark>计算关键路径</mark>：把通过网络图的每个路径上的所有<u>活动持续时间累加起来</u>，最长的路径就是关键路径。</p>
<h4 id="关键路径的特点">关键路径的特点</h4>
<p>①关键路径是<mark>最长的路径（图中时间累和最多的路径）</mark>。（见PDM图）</p>
<p>②关键路径反映了项目所花费的最短的时间。</p>
<p>③关键路径上的活动超时，总体进度就要拖延。</p>
<p>④关键路径只与项目的时间有关与关键活动无关。</p>
<p>⑤关键路径它与选择最短的路径无关。</p>
<p>⑥一个项目可能会有超过一条的关键路径。</p>
<p>⑦一个项目的关键路径可能会发生变化。</p>
<h4 id="正推法">正推法</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525171126367.png" alt="image-20230525171126367" style="zoom:50%;" />
<blockquote>
<p>DU：持续时间</p>
</blockquote>
<h4 id="逆推法">逆推法</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525171556192.png" alt="image-20230525171556192" style="zoom:50%;" />
<h4 id="关键路径来缩短项目进度">关键路径来缩短项目进度</h4>
<p>在进度计划制订后，可能项目结束日期不满足要求，需要进一步缩短进度计划的项目工期。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以采用<mark>赶工</mark>（Crashing,<u><strong>通过增加资源</strong></u>）</p>
</li>
<li class="lvl-2">
<p>或<mark>快速跟进</mark>（Fast tracking,<u><strong>通过并行施工</strong></u>）等方法。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525173658694.png" alt="image-20230525173658694" style="zoom:50%;" />
<blockquote>
<p><mark>赶工</mark>：通过增加资源，是为了以最少的成本代价获得最大限度的进度压缩。（关键路径上）</p>
<p><mark>快速跟进</mark>：并行执行那些通常以顺序方式执行的活动。</p>
</blockquote>
<h4 id="关键路径法的应用">关键路径法的应用</h4>
<p>① 利用关键路径分析<u><strong>平衡进度计划</strong></u></p>
<p>② <u><strong>缩短</strong></u><mark>关键路径</mark>上的<u><strong>活动历时</strong></u> （重点在关键路径）</p>
<p>③ 关注与及时更新关键路径数据</p>
<h3 id="跟踪甘特图">跟踪甘特图</h3>
<blockquote>
<p>补充：</p>
<p><mark>跟踪甘特图</mark>：用于显示项目的实际时间</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>显示计划和实际的项目进度信息</p>
</li>
</ul>
</blockquote>
<h3 id="关键链进度计划">关键链进度计划</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>是一种进度计划方式，在创建项目进度时候，考虑资源的限制性，并且为了保护项目的完成日期，将缓冲也包括进来。</p>
</li>
<li class="lvl-2">
<p>稀有资源的可用性。</p>
</li>
</ul>
<h2 id="6进度控制">6进度控制</h2>
<p><mark>控制进度</mark>是<strong>监督项目状态</strong>，以<strong>更新项目进度和管理进度基准变更</strong>的过程。</p>
<p><mark>本过程的主要作用</mark>是在整个项目期间<u><strong>保持对进度基准的维护</strong></u>，且需要在整个项目期间开展。</p>
<p>有效和有力的<u>控制项目进度计划的变更</u>，应重点注意：</p>
<p>​	①保证项目进度计划是<u><strong>现实的</strong></u>、<u><strong>可行的</strong></u>、<strong><u>可操作的</u></strong>。</p>
<p>​	②有纪律并加强领导来<u><strong>强调</strong></u>达到项目进度计划的<u><strong>重要性</strong></u>。</p>
<p>​	③<u><strong>及时督促和检查</strong></u>项目进度计划的<u><strong>执行与变更</strong></u>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230529142523464.png" alt="image-20230529142523464"></p>
<h4 id="进度计划变更控制的三个基础">进度计划变更控制的三个基础</h4>
<p>①<mark>关键的干系人</mark><u><strong>参与制定和一致认可</strong></u>项目进度计划，是<em><strong>计划可控</strong></em>的基础。</p>
<p>②<u><strong>建立现实的项目进度计划</strong></u>是<em><strong>计划可行</strong></em>的基础。</p>
<p>③<u><strong>项目经理清楚而诚实地汇报项目的状态</strong></u>是<em><strong>计划可用</strong></em>的基础。</p>
<blockquote>
<p>对这三项工作的<u><strong>检查与判断</strong></u>，是项目进度计划变更控制的<strong>基本保证</strong>。</p>
</blockquote>
<h4 id="项目经理-处理人问题">项目经理（处理人问题）</h4>
<p><mark>项目经理的主要工作</mark>是领导项目所涉及的人，以控制进度计划变更 。为此要利用领导技能来发挥大家的作用：</p>
<p>① <strong>授权</strong> — 授权项目团队成员对他们的活动负责。</p>
<p>② <strong>激励</strong> — 用激励手段来鼓励人们达到进度期望。</p>
<p>③ <strong>纪律</strong> — 必须使用纪律来控制项目进度 。</p>
<p>④ <strong>谈判</strong> — 学习、掌握和传授良好的谈判技巧。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230529143013602.png" alt="image-20230529143013602" style="zoom:50%;" />
<h4 id="使用软件进行时间管理">使用软件进行时间管理</h4>
<p>①<strong>理解</strong>项目管理的概念在软件中的<strong>体现方式</strong>。</p>
<p>②**<u>准确</u><strong>、</strong><u>及时</u><strong>、</strong><u>完整</u>**的输入<mark>基础数据与信息</mark>。</p>
<p>③ 将<u>实际工作</u>与<u>熟练的掌握</u><u><strong>软件功能和操作技巧紧密结合</strong></u>。</p>
<h4 id="进度控制概括来说"><mark>进度控制概括来说</mark></h4>
<blockquote>
<p>事前：对影响因素进行控制</p>
<p>事中：对具体过程进行控制</p>
<p>事后：改进或更新，采取补救措施</p>
</blockquote>
<h2 id="本章小结">本章小结</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230529143842947.png" alt="image-20230529143842947" style="zoom:50%;" />
<h2 id="课堂快速测试">课堂快速测试</h2>
<ol>
<li class="lvl-3">
<p>活动属性</p>
</li>
<li class="lvl-3">
<p>FS</p>
</li>
<li class="lvl-3">
<p>跟踪甘特图</p>
</li>
<li class="lvl-3">
</li>
</ol>
<h2 id="课堂讨论">课堂讨论</h2>
<h5 id="1-为什么定义活动是项目进度管理而不是项目范围管理的过程">1、 为什么定义活动是项目进度管理而不是项目范围管理的过程</h5>
<blockquote>
<p>从项目进度管理和项目范围管理的定义和作用以及定义活动的作用来分析</p>
</blockquote>
<h5 id="2-解释活动工期估计和人工量估计之间的差异">2、解释活动工期估计和人工量估计之间的差异</h5>
<blockquote>
<p>活动工期估计和人工量估计之间的主要差异在于它们关注的方面不同。活动工期估计关注的是时间，即每个活动完成所需的时间量。它强调的是项目的时间计划和进度安排。人工量估计则关注的是资源，即项目所需的人力资源数量。它强调的是项目的资源需求和资源管理。</p>
</blockquote>
<h2 id="课堂作业">课堂作业</h2>
<h3 id="网络图与甘特图的区别">网络图与甘特图的区别</h3>
<blockquote>
<p>网络图更侧重于活动之间的逻辑关系和复杂性，而甘特图更侧重于时间计划和可视化效果。</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章（项目成本管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/7-%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目成本管理</h1>
<h3 id="学习目标">学习目标</h3>
<blockquote>
<ol>
<li class="lvl-3">
<p>理解项目成本管理的重要性</p>
</li>
<li class="lvl-3">
<p>解释基本的项目成本管理的原理、概念和术语</p>
</li>
<li class="lvl-3">
<p>描述成本计划、==成本估算、成本预算和<strong>成本控制</strong>==过程⭐️</p>
</li>
<li class="lvl-3">
<p>解释<strong>成本估算</strong>的<u>不同类型</u></p>
</li>
<li class="lvl-3">
<p>理解软件项目的<strong>成本估算</strong>所包含的<u>内容</u></p>
</li>
<li class="lvl-3">
<p><mark>掌握挣值分析的计算方法</mark>⭐️</p>
</li>
<li class="lvl-3">
<p>理解<u>应用挣值分析</u>的好处</p>
</li>
<li class="lvl-3">
<p>描述软件如何辅助项目成本管理</p>
</li>
</ol>
</blockquote>
<h2 id="1-项目成本管理的重要性">1 项目成本管理的重要性</h2>
<h5 id="成本管理中的误区-计划阶段">成本管理中的误区—计划阶段</h5>
<p>导致：</p>
<ol>
<li class="lvl-3">
<p>项目技术经济分析失去客观依据，影响项目决策</p>
</li>
<li class="lvl-3">
<p>建设成本最小化，不等于项目盈利最大</p>
</li>
</ol>
<h3 id="it项目中成本管理存在的问题">IT项目中成本管理存在的问题</h3>
<p>①很多软件项目的原始成本估算不准确。</p>
<p>②由于没有经过实际验证，认为成本增长和失败将是预料中的事。</p>
<p>③项目经理与项目组对项目成本估算和控制不相关。</p>
<p>④项目组成员对项目成本的理解和把握不准确。</p>
<h4 id="失控原因">失控原因</h4>
<p>（1）对工程项目认识不足</p>
<p>（2）组织制度不健全</p>
<p>（3）方法问题</p>
<p>（4）技术的制约</p>
<p>（5）需求管理不当</p>
<h2 id="2-基本概念">2 基本概念</h2>
<h4 id="成本-项目成本-生命周期成本">成本、项目成本、生命周期成本</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601162250691.png" alt="image-20230601162250691" style="zoom:50%;" />
<h4 id="成本类型">成本类型</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601162438428.png" alt="image-20230601162438428" style="zoom:50%;" />
<h5 id="成本控制基线">⭐️成本控制基线</h5>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>应急储备（在成本控制基线内，<mark>受到项目经理的控制</mark>）——已知的未知</p>
</li>
<li class="lvl-2">
<p>管理储备（不在成本）——未知的未知</p>
</li>
</ul>
</blockquote>
<h4 id="利润-利润率-现金流分析">利润、利润率、现金流分析</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>利润：收益减去支出的值。</p>
</li>
<li class="lvl-2">
<p>利润率：利润与收益的比率。</p>
</li>
<li class="lvl-2">
<p>现金流分析：对现金及现金等价物的流入与流出量的分析。<strong>确定一个项目预计的年度成本、收益和每年发生的现金流。</strong></p>
</li>
</ul>
<h4 id="学习曲线理论-储备金">学习曲线理论、储备金</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601163743180.png" alt="image-20230601163743180" style="zoom:50%;" />
<h4 id="应急储备-管理储备-成本基准">应急储备、管理储备、成本基准</h4>
<p>应急储备：为一些可以部分预计的未来情况（已知的未知）做准备。在成本基准中，PM可控制</p>
<p>管理储备：考虑到未来不可预测的情况（未知的未知）。不在成本基准中 PM无权控制，需要向管理层申请 。</p>
<p><em><strong>成本基准</strong></em>：<u>是经批准的<mark>按时间安排</mark>的成本支出计划，并随时反映了经批准的项目变更（所增加或减少的资金项目），被用于度量和监督项目的实际执行成本。</u></p>
<h3 id="项目成本管理">⭐️项目成本管理</h3>
<p><mark>项目成本管理</mark>（包含用来确保项目团队在批准的预算内<span style="color: red;">完成一个项目</span>的必要过程）包括为使项目在批准的预算内完成而对成本进行规划、估算、预算和控制的各个过程，从而确保项目在批准的预算内完工。</p>
<p>目的：确保项目在批准的预算内完成，实现<u><strong>项目价值最大化</strong></u>。</p>
<h2 id="3-项目成本的构成">3 项目成本的构成</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601164105764.png" alt="image-20230601164105764" style="zoom:50%;" />
<h2 id="4-项目成本的影响因素">4 项目成本的影响因素</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601164131513.png" alt="image-20230601164131513" style="zoom:50%;" />
<h2 id="5-项目成本管理">5 项目成本管理</h2>
<p>①<mark>项目成本管理</mark>:主要<mark>目标是</mark>在批准的预算范围内，保质、保量、按时完成项目任务。</p>
<p>②确定预算:项目经理必须确信他们的项目有恰当的定义、精确的时间和成本估算、以及他们参与同意的和切合实际的预算。</p>
<p>③责任:努力减少和控制成本，满足项目干系人的期望，这是项目经理的责任。</p>
<h3 id="项目成本管理定义">项目成本管理定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601164246451.png" alt="image-20230601164246451" style="zoom:50%;" />
<h3 id="项目成本管理的构成">项目成本管理的构成</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601164311528.png" alt="image-20230601164311528" style="zoom:50%;" />
<h3 id="项目成本管理的过程">项目成本管理的过程</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601164459234.png" alt="image-20230601164459234" style="zoom:50%;" />
<h2 id="6-规划成本管理">6 规划成本管理</h2>
<p><mark>规划成本管理</mark>是项目管理计划的组成部分，描述将<u><strong>如何规划、安排和控制</strong></u>项目成本。</p>
<h6 id="主要包括如下信息：">主要包括如下信息：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>计量单位</p>
</li>
<li class="lvl-2">
<p>准确度</p>
</li>
<li class="lvl-2">
<p>控制临界值</p>
</li>
<li class="lvl-2">
<p>绩效测量规则：定义评估规则，例如跟踪实际成本的频率和详细程度。</p>
</li>
<li class="lvl-2">
<p>组织程序链接：将用于成本核算的WBS的组成部分作为控制账户，每个控制账户都有唯一的编码或账号， 直接与执行组织的会计制度相联系。</p>
</li>
<li class="lvl-2">
<p>报告格式：描述项目所需的成本报告的格式和频率。</p>
</li>
<li class="lvl-2">
<p>过程描述：描述如何执行所有的成本管理过程。</p>
</li>
</ul>
<h2 id="7-成本估计">7 成本估计</h2>
<p><mark>估算成本</mark>是对<u>完成项目工作所需资源成本</u>进行<strong>近似估算</strong>的过程。</p>
<p>本过程的<mark>主要作用</mark>是确定完成项目所需的成本数额。</p>
<p>本过程应根据需要在整个项目期间定期开展。</p>
<blockquote>
<p><u><em><strong><span style="color: red;">成本估算在WBS一级进行</span></strong></em></u></p>
</blockquote>
<h4 id="估算成本包括：">估算成本包括：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>直接成本：人、材料、设备等</p>
</li>
<li class="lvl-2">
<p>间接成本：不好直接分摊的成本，间接率</p>
</li>
<li class="lvl-2">
<p>不可预见费  10%</p>
</li>
<li class="lvl-2">
<p>储备金：价差预备费、应急储备金和管理储备金</p>
</li>
</ul>
<h3 id="估算的类型与主要输出">估算的类型与主要输出</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601170639704.png" alt="image-20230601170639704" style="zoom:50%;" />
<h3 id="构成">构成</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601170820779.png" alt="image-20230601170820779" style="zoom:50%;" />
<h3 id="成本估计方法">成本估计方法</h3>
<p><em><strong>类比估算法</strong></em>：也叫<mark>自上而下估算法</mark>，它是使用以前的、相似项目的实际成本作为目前项目成本估算的根据。</p>
<p><em><strong>自下而上估计法</strong></em>：首先对项目工作分解结构（WBS）中的具体工作包或者活动所需要的资源进行估算，然后逐级累加，并最终汇总成为项目的总成本。</p>
<p><em><strong>参数模型估算法</strong></em>：根据项目的特征参数建立一个数学模型，利用这个数学模型来计算（预测）项目的成本。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601171616894.png" alt="image-20230601171616894" style="zoom:50%;" />
<h2 id="8-成本预算">8 成本预算</h2>
<p><mark>成本预算</mark>：汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准的过程。目的是为了确定测量项目实际绩效的基准计划，而<mark>把整个成本估算</mark><u><strong>按照时间段</strong></u>分配到具体工作包或者活动上去。</p>
<h4 id="两个要点">两个要点</h4>
<p><strong>（1）把成本估算分配到项目生命期中的==每一个活动（或工作包）==中。</strong></p>
<p><strong>（2）建立<mark>成本控制基准线</mark>（ＢＣＷＳ或ＰＶ）－用来度量项目执行清况。</strong></p>
<p>成本基准：是一个阶段性的预算，<u>项目经理</u>使用它来<strong>衡量并监测成本的执行情况</strong>。</p>
<p>项目预算：由<u>成本基准</u>加上<u><mark>管理</mark>储备金</u>组成。</p>
<p>控制账户：是<u>工作包成本估算</u>加上<u><mark>应急</mark>储备金</u>。</p>
<p>工作包成本估算：是<u>活动成本估算</u>加上<u>活动应急储备金</u>。</p>
<h3 id="成本预算主要工作">成本预算主要工作</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>确定项目总的预算（估算加储备）</p>
</li>
<li class="lvl-2">
<p>确定项目各项活动的预算</p>
</li>
<li class="lvl-2">
<p>确定项目各项活动预算的投入时间</p>
</li>
<li class="lvl-2">
<p>给出项目成本预算的“S”曲线</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601172730955.png" alt="image-20230601172730955" style="zoom:50%;" />
<h3 id="成本预算的过程">成本预算的过程</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601173642987.png" alt="image-20230601173642987" style="zoom:50%;" />
<h3 id="理解成本预算与成本估算间的关系和区别？">理解成本预算与成本估算间的关系和区别？</h3>
<p>成本估算是基于已有的信息和经验进行的，通常包括对项目资源、劳动力、材料和其他相关费用的估计。</p>
<p>成本预算是根据已经确定的项目范围、成本估算和时间计划，编制出的一个具体的成本计划。</p>
<p>成本估算是对项目成本的初步估计，而成本预算是在项目实施阶段进行的具体成本计划。一前一后的关系</p>
<h2 id="9-成本控制-挣值管理">9 成本控制（挣值管理）⭐️</h2>
<h3 id="概念">概念</h3>
<p>是指在项目管理过程中，根据成本管理计划对项目成本进行管理，尽量保证项目成本控制在预算范围内，它对项目的资金支出进行核算和监控。成本控制是在成本预算的基础上开展的。</p>
<p>控制成本是监督项目状态，以更新项目成本和管理成本基准变更的过程。</p>
<p><mark>主要作用</mark>是，在整个项目期间保持对成本基准的维护。需要在整个项目期间开展。</p>
<p>成本控制将各项工作的<u>实际费用与计划费用（即预算）进行比较</u>，对成本费用进行评价，并对未完成项目进行预测，使成本控制在预算范围内。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>它涉及<u><strong>成本变化因素中的控制（</strong></u>事前）、<u><strong>实施过程中的控制</strong></u>（事中）、<u><strong>实际发生的变动的控制</strong></u>（事后）。</p>
</li>
</ul>
<p>①项目成本控制：是保证各项工作在它们各自的预算范围内进行。</p>
<p>②依据：成本预算是成本控制的基础。费用基线、项目实施报告、变更请求是成本控制的依据。</p>
<h3 id="成本控制主要包括">成本控制主要包括</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605142339256.png" alt="image-20230605142339256" style="zoom:50%;" />
<h3 id="项目成本控制内容-项目成本变更控制系统">项目成本控制内容/项目成本变更控制系统</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605142609069.png" alt="image-20230605142609069" style="zoom:50%;" />
<h3 id="成本控制过程">成本控制过程</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605142746829.png" alt="image-20230605142746829" style="zoom:50%;" />
<h3 id="成本控制-挣值分析">成本控制-挣值分析</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605142952158.png" alt="image-20230605142952158" style="zoom: 80%;" />
<h4 id="基本概念">基本概念</h4>
<p>⭐️挣值方法是<mark>对项目范围、进度和成本进行综合控制的一种有效方法</mark>。它对于计划完成的工作、实际挣得的利益、实际花费的成本进行比较，以确定成本和进度是否按计划进行。</p>
<p>项目挣值：指已完成作业量的计划成本的中间变量。</p>
<p>⭐️挣值方法**<u>核心要素</u>**：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>三个<span style="color: red;">关键变量</span>：<em><strong>PV、AC、EV（挣值）</strong></em></p>
</li>
<li class="lvl-2">
<p>两个<mark>偏差</mark>：<em><strong>CV、SV</strong></em></p>
</li>
<li class="lvl-2">
<p>两个<mark>绩效指标</mark>：<em><strong>CPI、SPI</strong></em></p>
</li>
</ul>
<h4 id="示例">示例</h4>
<p>假设现在有一个项目，为期4个月，总预算4000美元，每月任务为总量的1／4，预算也是总预算的1／4。现在一个月过去了，完成了本月任务的80％，花费了900美元。下表以这个情景说明挣值的术语和含义。</p>
<h5 id="基本术语">基本术语</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605143938441.png" alt="image-20230605143938441" style="zoom:67%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605144005430.png" alt="image-20230605144005430" style="zoom: 67%;" />
<blockquote>
<p>公式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>P</mi><mi>I</mi><mo>=</mo><mfrac><mrow><mi>E</mi><mi>V</mi></mrow><mrow><mi>A</mi><mi>C</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">CPI=\frac{EV}{AC}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>A</mi><mi>C</mi><mo>=</mo><mfrac><mrow><mi>B</mi><mi>A</mi><mi>C</mi></mrow><mrow><mi>C</mi><mi>P</mi><mi>I</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">EAC=\frac{BAC}{CPI}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</blockquote>
<h5 id="挣值法的四个评价指标：">挣值法的四个评价指标：</h5>
<p><mark>费用偏差CV（Cost Variance)</mark>。 CV是指检查期间BCWP与ACWP之间的差异。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>V</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mtext>–</mtext><mi>A</mi><mi>C</mi><mi>W</mi><mi>P</mi><mo>=</mo><mi>E</mi><mi>V</mi><mo>−</mo><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CV = BCWP – ACWP = EV - AC
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">–</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p><mark>进度偏差SV（Schedule Variance)</mark>。 SV是指检查期间BCWP与BCWS 之间的差异。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>V</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mtext>–</mtext><mi>B</mi><mi>C</mi><mi>W</mi><mi>S</mi><mo>=</mo><mi>E</mi><mi>V</mi><mo>−</mo><mi>P</mi><mi>V</mi></mrow><annotation encoding="application/x-tex"> SV = BCWP – BCWS = EV - PV
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">–</span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SV=对应预算的实际工作量—对应预算的预算工作量</p>
</li>
</ul>
<p><mark>费用执行指标CPI （Cost Performed Index)</mark>。 CPI是指预算费用与实际费用之比（或工时值之比）。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>P</mi><mi>I</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mi mathvariant="normal">/</mi><mi>A</mi><mi>C</mi><mi>W</mi><mi>P</mi><mo>=</mo><mi>E</mi><mi>V</mi><mi mathvariant="normal">/</mi><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex"> CPI = BCWP / ACWP = EV / AC
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">/</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p><mark>进度执行指标SPI （ Schedule Performed Index)</mark>。 SPI是指项目挣得值与计划值之比。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>P</mi><mi>I</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mi mathvariant="normal">/</mi><mi>B</mi><mi>C</mi><mi>W</mi><mi>S</mi><mo>=</mo><mi>E</mi><mi>V</mi><mi mathvariant="normal">/</mi><mi>P</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">SPI = BCWP / BCWS = EV / PV
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">SP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
<h4 id="挣值法参数分析与对应措施表">⭐️挣值法参数分析与对应措施表</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605150836031.png" alt="image-20230605150836031" style="zoom: 50%;" />
<h4 id="挣值分析绘图">⭐️挣值分析绘图</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>要会绘制图，并且必须在图中标记相应的参数</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605151223763.png" alt="image-20230605151223763" style="zoom:50%;" />
<h2 id="课堂快速测试">课堂快速测试</h2>
<ol>
<li class="lvl-3">
<p>成本</p>
</li>
<li class="lvl-3">
</li>
</ol>
<p><u><em><strong>案例分析第二个需要掌握</strong></em></u></p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章（项目质量管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/8-%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目质量管理</h1>
<h3 id="学习目标">学习目标</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608163453189.png" alt="image-20230608163453189" style="zoom:50%;" />
<h2 id="1-软件质量">1 软件质量</h2>
<h3 id="什么是质量">什么是质量</h3>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608164140930.png" alt="image-20230608164140930" style="zoom:50%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608164215327.png" alt="image-20230608164215327" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608164442662.png" alt="image-20230608164442662" style="zoom:50%;" />
<h2 id="2-软件项目质量管理">2 软件项目质量管理</h2>
<h4 id="成本-质量与工期的关系图">成本、质量与工期的关系图</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608164357661.png" alt="image-20230608164357661" style="zoom: 25%;" />
<h3 id="项目质量管理">项目质量管理</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608164526254.png" alt="image-20230608164526254" style="zoom: 50%;" />
<p><mark>项目质量管理</mark>是为了保障项目的产出物能够满足项目业主/客户以及项目各方面相关利益者的需要所开展的对于项目产出物的质量和项目工作质量的全面管理工作。</p>
<h3 id="软件质量特性">软件质量特性</h3>
<p>①功能性：适合性、准确性、互操作性、依从性、安全性；</p>
<p>②可靠性：成熟性、容错性、易恢复性；</p>
<p>③易用性：易理解性、易学性、易操作性；</p>
<p>④效 率：时间特性、资源特性；</p>
<p>⑤可维护性：易分析性、易改变性、稳定性、易测试性；</p>
<p>⑥可移植性：适应性、易安装性、遵循性、易替换性.</p>
<h2 id="3-软件项目质量管理过程">3 软件项目质量管理过程</h2>
<p>项目质量管理是指为满足项目质量目标要求所需要的管理过程；这些过程包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>质量计划</p>
</li>
<li class="lvl-2">
<p>质量保证</p>
</li>
<li class="lvl-2">
<p>质量控制</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608170152226.png" alt="image-20230608170152226" style="zoom:50%;" />
<p>质量管理发展的四个阶段</p>
<ol>
<li class="lvl-3">
<p>传统</p>
</li>
<li class="lvl-3">
<p>统计</p>
</li>
<li class="lvl-3">
<p>全面</p>
</li>
<li class="lvl-3">
<p>用户的满意度</p>
</li>
</ol>
<h2 id="4-现代质量管理">4 现代质量管理</h2>
<h3 id="戴明改进循环-pdca循环">戴明改进循环(PDCA循环)</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608172443224.png" alt="image-20230608172443224" style="zoom:50%;" />
<h5 id="pdca循环全过程分为四个依序衔接的阶段：">PDCA循环全过程分为四个依序衔接的阶段：</h5>
<ol>
<li class="lvl-3">
<p>计划阶段（Plan）</p>
</li>
<li class="lvl-3">
<p>执行阶段（Do）</p>
</li>
<li class="lvl-3">
<p>检查阶段（Check）</p>
</li>
<li class="lvl-3">
<p>处理阶段（Action）</p>
</li>
</ol>
<h5 id="四个明显特性：">四个明显特性：</h5>
<ol>
<li class="lvl-3">
<p>周而复始</p>
</li>
<li class="lvl-3">
<p>大环带小环</p>
</li>
<li class="lvl-3">
<p>阶梯式上升</p>
</li>
<li class="lvl-3">
<p>统计的工具</p>
</li>
</ol>
<h2 id="5-质量规划">5 质量规划</h2>
<p><mark>质量规划</mark>：识别项目及其可交付成果的质量要求和/或标准，并书面描述项目将如何证明符合质量要求或标准的过程。</p>
<p><mark>主要作用</mark>是，为在整个项目期间如何管理和核实质量提供指南和方向。</p>
<p><mark>项目质量计划</mark>是指为确定项目应该达到的质量标准（项目质量的规定指标）和如何达到这些项目质量标准而做的项目质量的计划与安排工作。</p>
<h4 id="质量方针">质量方针</h4>
<p>是项目组织中高级管理层规定的项目质量管理的大政方针，是一个组织对待项目质量管理的指导思想，是项目计划编制应遵循的原则和依据.</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608172614675.png" alt="image-20230608172614675" style="zoom:50%;" />
<h2 id="6-质量保证">6 质量保证</h2>
<h4 id="目标">目标</h4>
<p>① 确保项目质量计划的执行与实现。</p>
<p>② 不断地对质量进行改进。</p>
<blockquote>
<p>“质量保证” 是以<u>保证质量</u>为<mark>基础</mark>，<u>达到用户的“信任”</u> 为<mark>基本目的</mark>。</p>
</blockquote>
<h3 id="项目质量保证管理过程">项目质量保证管理过程</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608172745435.png" alt="image-20230608172745435" style="zoom:50%;" />
<h5 id="标杆法">⭐️标杆法</h5>
<h2 id="7-质量控制">7 质量控制</h2>
<h4 id="质量控制过程">质量控制过程</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608172841223.png" alt="image-20230608172841223" style="zoom:33%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608173029456.png" alt="image-20230608173029456" style="zoom:50%;" />
<h4 id="影响项目质量因素的控制-5m1e">影响项目质量因素的控制——5M1E</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608172925755.png" alt="image-20230608172925755" style="zoom: 50%;" />
<h2 id="8-质量控制的工具和技术">⭐️8 质量控制的工具和技术</h2>
<ol>
<li class="lvl-3">
<p>排列图</p>
</li>
<li class="lvl-3">
<p>Pareto 图</p>
</li>
<li class="lvl-3">
<p>控制图</p>
</li>
<li class="lvl-3">
<p>因果图（鱼刺图）</p>
</li>
<li class="lvl-3">
<p>关联图</p>
</li>
<li class="lvl-3">
<p>散点图</p>
</li>
</ol>
<h3 id="统计抽样和标准差">统计抽样和标准差</h3>
<h4 id="六西格玛-6σ">六西格玛 6σ</h4>
<p>6σ项目有着特殊的实施性和实施步骤，那就是6σ改进模式：DMAIC（定义、评估、分析、改进、控制）及DFSS（定义、评估、分析、设计、印证）</p>
<p><em><strong><u>6σ通过<mark>降低偏差</mark>来提高质量</u></strong></em></p>
<h2 id="9-提高软件项目质量">9 提高软件项目质量</h2>
<p><mark>提高软件质量关键在领导</mark></p>
<p><img src="C:%5CUsers%5Cwgj%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230608173844262.png" alt="image-20230608173844262"></p>
<h2 id="本章小结">本章小结</h2>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608173754055.png" alt="image-20230608173754055"></p>
<h2 id="课堂快速测试">课堂快速测试</h2>
<ol>
<li class="lvl-3">
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章（项目人力资源管理）</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/9-%E9%A1%B9%E7%9B%AE%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目人力资源管理</h1>
<h3 id="学习目标">学习目标</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230612141659010.png" alt="image-20230612141659010" style="zoom:50%;" />
<h3 id="人力资源含义">⭐️人力资源含义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230612141827962.png" alt="image-20230612141827962" style="zoom:50%;" />
<h4 id="人力资源具有的特征：">⭐️人力资源具有的特征：</h4>
<p>①***<mark>可再生</mark>的生物性资源***：它以人身为天然载体，是一种“活”的资源，并与人的自然生理特征相联系。</p>
<p>②<em><strong>居于<mark>主导地位</mark>的动能性资源</strong></em>：人类不同于自然界其他生物之处在于人具有目的性、主观能动性和社会意识。</p>
<p>③<em><strong>具有<mark>时效性</mark>的资源</strong></em>：人力资源的形成、开发、使用都具有时间方面的制约。</p>
<h3 id="各种权利的含义-了解每种权利准确的定义-选择-填空">⭐️各种权利的含义（了解每种权利准确的定义-选择、填空）</h3>
<ol>
<li class="lvl-3">
<p>强制权力</p>
</li>
<li class="lvl-3">
<p>合法权力</p>
</li>
<li class="lvl-3">
<p>专家权力</p>
</li>
<li class="lvl-3">
<p>奖励权力</p>
</li>
<li class="lvl-3">
<p>参照权力（感召权利）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件项目组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>软件项目组织管理期末总结1</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%931/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>软件项目组织管理期末总结1</h1>
<blockquote>
<p>选择：概念+小计算；</p>
<p>填空题：跟课堂测试差不多；</p>
<p>论述题（简答）：记忆（比如：什么与什么的区别之类的）</p>
<p>最后两道大题：挣值分析、网络图和关键路径分析法。</p>
</blockquote>
<h2 id="一-走进项目管理">一 走进项目管理</h2>
<h3 id="it-项目？失败的原因？软件项目管理？">IT 项目？失败的原因？软件项目管理？</h3>
<h4 id="it-项目？">IT 项目？</h4>
<p>（1） 信息的定义：是<strong>有一定含义的数据</strong>，是<strong>加工处理后的数据</strong>，是对<strong>决策或行为产生影响的数据</strong>。即，<mark><strong>有价值的数据集合</strong></mark>。</p>
<p>（2） IT 项目的定义：包括<mark>使用</mark><strong>硬件、软件或者网络</strong>来创造一件独特的<u>产品</u>、一项<u>服务</u>或者一种<u>结果</u>的<mark>一次性努力</mark>。</p>
<h4 id="失败的原因？">失败的原因？</h4>
<p><mark>软件项目失败的原因</mark>：一是<strong>软件项目的复杂性</strong>，二是<strong>缺乏合格的软件项目管理人才</strong>。缺乏**<u>有效的项目管理</u><strong>是导致软件项目<mark>失控</mark>的</strong>直接原因**。</p>
<blockquote>
<p>为了完成项目既定目标，需要通过软件项目管理过程来对软件任务进行组织、计划、实施、管理和评估，以明确和满足范围、时间、成本、质量等方面的约束限制。</p>
</blockquote>
<h4 id="软件项目管理？">软件项目管理？</h4>
<blockquote>
<p>软件项目管理<mark>属于IT管理范畴</mark>，它是IT项目管理的一个<strong>核心部分</strong>。</p>
<p>软件项目管理的<mark>对象</mark>——<strong>软件项目</strong>。</p>
<p>20世纪70年代中期美国提出的软件项目管理，引起人们的关注。</p>
</blockquote>
<p><mark>软件项目管理</mark>是<u>为了使</u>软件项目能够<mark>按照</mark><strong><u>预定的范围、成本、进度、质量</u></strong><mark>顺利完成</mark>，而对范围、费用、时间、质量、<u>人力资源、风险、采购</u>等<u><em><strong>进行分析和管理</strong></em></u>的活动。</p>
<h3 id="活动的3个基本特点？人类有组织的活动分为那两种类型-有什么区别？">活动的3个基本特点？人类有组织的活动分为那两种类型，有什么区别？</h3>
<p><strong>（1）</strong> 人类活动的特点：<strong>目的性</strong>、<strong>依存性</strong>、<strong>知识性</strong></p>
<p>（2） 人类<strong>有组织的活动</strong>分为 <strong>2</strong> 类，分别是<strong>作业</strong>和<strong>项目</strong>。<mark>作业是<strong>连续不断、周而复始</strong>的，而项目是<strong>临时的、一次性的</strong>。</mark></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619110300783.png" alt="image-20230619110300783"></p>
<h3 id="什么是项目-项目的特征？项目的组成要素-3个-？">什么是项目?项目的特征？项目的组成要素（3个）？</h3>
<p>（1） 项目的定义：<mark>项目是为</mark><strong>创造一件独特的产品</strong>、<strong>一项服务</strong>或者<strong>一种结果</strong>而进行的**<u>临时性努力</u>**。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>项目都有明确且具体的<strong>目标</strong>，是指完成<strong>特定目标</strong>需要完成的任务，具有<u>一次性</u>。</p>
</li>
<li class="lvl-2">
<p>项目都有明确界定的<strong>工作范围</strong>，是一项<u>有待完成的任务</u>，有着<u>特定的</u><strong>环境和要求</strong>。</p>
</li>
</ul>
<p><strong>（2）</strong> 项目的特点：<strong>目的性</strong>、<strong>一次性</strong>、<strong>整体性</strong>、<strong>临时性</strong>、<strong>不确定性</strong>、<strong>多变性</strong>（资源）、<strong>过程性</strong>、<strong>具有发起人</strong>、<strong>需要资源</strong></p>
<p>（3） 项目的<mark>组成要素</mark>：<u><em><strong><mark>范围、时间、成本</mark></strong></em></u></p>
<h3 id="什么是项目管理？">什么是项目管理？</h3>
<p>1.项目管理的基本概念：<u>管理指的是<strong>社会组织中</strong>，为了实现<strong>预期目标</strong>，以<strong>人</strong>为中心进行的<strong>协调</strong>活动</u>。有效的管理者=<strong>理论掌握</strong>+<strong>技巧运用</strong>+<strong>思想化</strong></p>
<p>（1） 项目管理的定义：分为两类，第一种指的是一种<strong>管理活动</strong>，即一种<strong>有意识</strong>地<mark>按照</mark>项目的<strong>特点和规律</strong>，对项目<u><strong>进行组织管理</strong></u>的活动；第二种指的是一种<strong>管理学科</strong>，即<mark>以</mark><u>项目管理活动</u><mark>为研究对象</mark>的一门学科，它是探求<strong>项目活动</strong><u>科学组织管理</u>的理论与方法。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>⭐️<mark>项目管理</mark>就是把<strong>各种<u>知识、技能、手段（工具）和技术</u></strong><mark>应用于</mark><u>项目活动</u>之中，以<mark>达到</mark><u>项目的要求</u>。</p>
</li>
</ul>
<p>（2） 项目管理的<mark>特点</mark>：</p>
<p>①项目管理的日常活动通常围绕<strong>项目计划</strong>、<strong>项目组织</strong>、<strong>质量管理</strong>、<strong>费用控制</strong>、<strong>进度控制</strong>等五项任务来展开。（<strong>计划</strong>、<strong>组织</strong>、<strong>指导</strong>、<strong>控制</strong>＆<strong>协调</strong>）——围绕五项任务</p>
<p>②项目管理与传统的部门管理相比最大的区别是<u><strong>注重于综合性管理</strong>，并且<strong>强调时间期限</strong></u>。</p>
<p>③项目管理必须通过<strong>不完全确定的过程</strong>，在**<u>确定的期限内</u><strong>生产出</strong>不完全确定的产品<strong>或完成</strong>不完全确定的任务**。——不完全过程、产品（任务）</p>
<p>（3） 项目管理的内容：</p>
<p>①对象：<strong>项目</strong></p>
<p>②目的：满足或超出干系人对项目的需求与期望</p>
<p>③全过程：<strong>贯穿着系统工程的思想</strong></p>
<p>④组织：<strong>临时性</strong>、<strong>柔性</strong>（组织）</p>
<p>⑤体制：一种基于团队管理的<strong>个人负责制</strong></p>
<p>⑥方式：<strong>目标管理</strong></p>
<p>⑦要点：创造和保持一种使<strong>项目能顺利进行的环境</strong></p>
<p>⑧方法和手段：<strong>计划</strong>、<strong>组织</strong>、<strong>指导</strong>、<strong>控制</strong>＆<strong>协调</strong></p>
<p>⑨实现过程：运用<strong>知识</strong>、<strong>技能</strong>、<strong>工具</strong>和<strong>技术</strong></p>
<p>（4） <mark>项目管理关注<strong>创新性</strong>，追求的是<strong>效果</strong>；作业管理关注<strong>惯例性</strong>，追求的是<strong>效率</strong>。</mark></p>
<h3 id="什么是利益相关者？">什么是利益相关者？</h3>
<p><mark>利益相关者</mark>：指的是<u>所有<strong>参与项目</strong>或者<strong>受到项目影响</strong>的<strong>个人或组织</strong></u>，也叫做<strong>项目干系人</strong>。主要有<strong>项目经理</strong>、<strong>客户</strong>、<strong>执行组织</strong>、<strong>开发团队成员</strong>、<strong>发起人</strong>和<strong>出资方</strong>。</p>
<h3 id="项目管理和作业管理的区别？">项目管理和作业管理的区别？</h3>
<p>项目管理——<u>创新性</u>、追求<mark>效果</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>充满了<u><strong>不确定因素</strong></u></p>
</li>
<li class="lvl-2">
<p><u><strong>跨越部门</strong></u>的界限</p>
</li>
<li class="lvl-2">
<p>有严格的<u><strong>时间期限要求</strong></u></p>
</li>
</ul>
<p>作业管理——<u>惯例性</u>、追求<mark>效率</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>注重对<u>效率和质量的考核</u></p>
</li>
<li class="lvl-2">
<p>注重<u>当前执行情况与前期进行比较</u></p>
</li>
</ul>
<h3 id="项目管理知识体系-10大知识领域">项目管理知识体系（10大知识领域）</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619110622803.png" alt="image-20230619110622803"></p>
<p><strong>项目管理知识体系</strong>（<strong>PMBOK</strong>）：一共有 <strong>10 个知识领域</strong>，<strong>42 个管理过程</strong>。10 个知识领域分为 <strong>4 个核心</strong>（范围，时间，成本，质量）+<strong>5</strong> <strong>个辅助</strong>（人力资源，沟通，风险，采购，干系人）+<strong>项目管理整合</strong></p>
<p><strong>（1）</strong> 过程的表示：<strong>输入→工具与技术→输出</strong></p>
<p><strong>（2）</strong> 项目管理的改革：传统项目管理看重<strong>项目实施的环节</strong>，现代的看重<strong>人的因素</strong></p>
<h3 id="项目管理九大知识领域">项目管理九大知识领域</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619110737796.png" alt="image-20230619110737796"></p>
<p><u><em><strong>时间、范围、成本、质量、人力资源、沟通、风险、采购、综合（集成）管理（项目管理整合）</strong></em></u></p>
<h3 id="项目管理工具和技术">项目管理工具和技术</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>能够帮助项目经理和其团队实施9大知识领域的所有工作</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619110930640.png" alt="image-20230619110930640"></p>
<h3 id="it项目管理知识体系">IT项目管理知识体系</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619110953333.png" alt="image-20230619110953333"></p>
<p>三维结构模型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向对象</p>
</li>
<li class="lvl-2">
<p>面向流程</p>
</li>
<li class="lvl-2">
<p>面向职能</p>
</li>
</ul>
<h3 id="什么是项目群？特征？">什么是项目群？特征？</h3>
<h4 id="项目群-program">⭐️项目群（program）</h4>
<p>项目群（program）：<strong>多个相互关联项目的集合</strong></p>
<p>基本特征：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>相互关联</p>
</li>
<li class="lvl-2">
<p>每个项目<u>相互间有一定的<strong>相似性</strong></u></p>
</li>
</ul>
<h3 id="什么是项目群管理？项目群管理强调什么？">什么是项目群管理？项目群管理强调什么？</h3>
<p>项目群管理（program Management）：一组相互关联的项目，<mark>使用</mark><strong><u>协同方法</u>进行管理来<mark>获得收益和进行控制</mark></strong>，而这种收益和控制在单独管理这些项目时是不易获得的。</p>
<p>项目群管理强调：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>集成</strong>（如IT项目的弱电集成项目）</p>
</li>
<li class="lvl-2">
<p><u>协同与资源优化</u></p>
</li>
</ul>
<h3 id="什么是项目组合管理？目的是什么？项目管理和项目组合管理的不同之处？">什么是项目组合管理？目的是什么？项目管理和项目组合管理的不同之处？</h3>
<h4 id="项目组合管理">⭐️项目组合管理</h4>
<p>项目组合管理——<strong>对由项目和项目群<mark>有机组合的整体</mark>所开展的管理。</strong></p>
<p>项目组合的目的——<strong>实现组织战略和愿景</strong>，也称战略项目组合。（实现战略目标）</p>
<p>项目组合管理<mark>强调</mark>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>战略目标</strong></u>（宏观）</p>
</li>
<li class="lvl-2">
<p>项目组合的<strong>投资回报</strong></p>
</li>
<li class="lvl-2">
<p><u>资源约束下</u>的<strong>项目选择</strong></p>
</li>
</ul>
<p>不同之处：项目管理实现<strong>战术目标</strong>，项目组合管理实现<strong>战略目标</strong>（战术目标<u><strong>更具体,时间短</strong></u>；战略目标重点<mark>强调</mark>一组织的<u>长期目标</u>）</p>
<h3 id="项目经理的作用？职责？应掌握的技能？">项目经理的作用？职责？应掌握的技能？</h3>
<h5 id="项目经理的作用">项目经理的作用</h5>
<p><u><em><strong>项目经理是为项目的成功策划和执行负总责的人</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>管理能力</p>
</li>
<li class="lvl-2">
<p>领导能力</p>
</li>
</ul>
<h6 id="主要职责">主要职责</h6>
<p>项目经理<mark>首要职责</mark>是在**<u>预算范围内</u><mark>按时优质地领导</mark>项目小组完成<u>全部项目工作内容</u>，<u>并使客户满意</u>**</p>
<h4 id="应掌握的技能">应掌握的技能</h4>
<blockquote>
<p>项目经理最重要的是：“<mark>沟通</mark>”。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>项目管理知识体系</mark></p>
</li>
<li class="lvl-2">
<p>应用领域相关知识、标准和规则</p>
</li>
<li class="lvl-2">
<p><mark>项目环境知识</mark></p>
</li>
<li class="lvl-2">
<p><mark>一般管理知识和技能</mark></p>
<ul class="lvl-2">
<li class="lvl-4">财务管理，融资，销售，营销，合同，物流后勤，人事管理，健康，安全实践等。</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>软技能/人际关系技能</mark></p>
<ul class="lvl-2">
<li class="lvl-4">有效沟通，影响组织完成任务、领导、激励、谈判、冲突管理、问题解决等。</li>
</ul>
</li>
</ul>
<h3 id="项目管理发展阶段？">项目管理发展阶段？</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230621021424103.png" alt="image-20230621021424103"></p>
<h2 id="二-把控环境-控制过程">二 把控环境 控制过程</h2>
<h3 id="项目管理工作需要采用系统的方法？包括哪三个方面？">项目管理工作需要采用系统的方法？包括哪三个方面？</h3>
<p>系统：是由若干个可以<u><strong>相互区别、相互联系而又相互作用</strong></u>的要素所组成, 在一定的层次结构形式中分布, 在给定的环境约束下, 为达到**<u>整体的目的</u>**而存在的<u><strong>有机集合体</strong></u>。</p>
<h4 id="系统方法">系统方法</h4>
<p>描述一种<u>在解决复杂问题时</u>所需的<u><strong>整体性和分析性</strong></u>的方法</p>
<p>包括三部分</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong><u>系统哲学</u></strong></em> - 将事情作为系统考虑的整体模型</p>
</li>
<li class="lvl-2">
<p><u><em><strong>系统分析</strong></em></u> - 解决问题的方法（需要定义系统的范围、将其分解为各个组成部分，然后<u>识别和估计</u>问题、机会、约束和需求）</p>
</li>
<li class="lvl-2">
<p><u><em><strong>系统管理</strong></em></u> - 解决与<mark>系统的创建</mark>、<mark>维持和变更</mark>相关的<u><mark>业务上</mark>（费用）、<mark>技术上</mark>和<mark>组织上</mark></u>的问题</p>
</li>
</ul>
<h3 id="什么是组织环境？">什么是组织环境？</h3>
<blockquote>
<p>1)环境:<u>组织外部</u>存在的<strong>一切客观因素和条件</strong>。⭐️</p>
<p>2)组织:按照一定<u><strong>目的、任务和形式</strong></u><mark>加以编制</mark>的群体。</p>
</blockquote>
<p>存在于组织外部，和组织密切联系，决定组织存在和发展的自然、经济、技术、政治、社会的各种因素和条件的总和。任何一个组织都离不开外部因素和条件而独立存在。</p>
<h3 id="组织的四个框架？">组织的四个框架？</h3>
<h5 id="四个框架">四个框架</h5>
<table>
<thead>
<tr>
<th>结构框架</th>
<th>人力资源框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>用来解决组织结构化的问题<strong>着眼于不同部门的角色、责任</strong>，以满足最高管理层设定的目标和政策， <br /><span style="color: red;"> 重点用于协调、控制  </span></td>
<td>重点在于<strong>促成组织需求和个人需求</strong>之间的<span style="color: red;">平衡与协调</span></td>
</tr>
<tr>
<td><strong>政治框架</strong></td>
<td><strong>标志框架</strong></td>
</tr>
<tr>
<td><strong>处理组织和人的政治问题</strong>  假定组织是由各种人和利益集团组成的联合体 <br /><span style="color: red;">冲突和权力是中心问题</span></td>
<td>主要指<strong>与事件相关的符号和含义</strong> <br /><span style="color: red;">文化很重要  </span></td>
</tr>
</tbody>
</table>
<h3 id="组织的结构？">组织的结构？</h3>
<h4 id="组织结构">⭐️组织结构</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><em><strong>职能型</strong></em></u> – 职能经理向CEO汇报</p>
</li>
<li class="lvl-2">
<p><u><em><strong>项目型</strong></em></u> – 项目经理对CEO负责</p>
</li>
<li class="lvl-2">
<p><u><em><strong>矩阵型</strong></em></u> --介于职能型组织和项目型组织之间. <u>需要向<strong>两个或多个上级</strong>汇报</u>, <u><strong>弱矩阵、平衡矩阵和强矩阵</strong></u></p>
</li>
</ul>
<h5 id="组织结构对项目的影响">组织结构对项目的影响</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230504173431442.png" alt="image-20230504173431442" style="zoom:50%;" />
<h3 id="项目生命周期？项目的4个阶段？各阶段主要任务？">项目生命周期？项目的4个阶段？各阶段主要任务？</h3>
<h4 id="项目生命周期">项目生命周期</h4>
<p>生命周期：项目都需要<mark>经历</mark>一个从**<u>开始到结束的时间过程</u>**，项目工作在这一过程中呈现出一定的<u><strong>阶段性</strong></u>的特征。</p>
<h4 id="项目阶段">项目阶段</h4>
<p>阶段：几个基本的阶段包括:</p>
<p>1）概念 Conceive     2) 开发 Develop</p>
<p>3）实施 Execute        4) 收尾 Finish</p>
<p>(简称C ．Ｄ．Ｅ．Ｆ阶段)</p>
<p>说明：前两个阶段(概念和开发)主要工作是<mark>做计划</mark>，称做<strong>项目可行性阶段</strong>。后两个阶段(实施和收尾)主要是<mark>开展实际工作</mark>，称做<strong>项目获取阶段</strong>。</p>
<h4 id="各阶段主要任务">各阶段主要任务</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508142544919.png" alt="项目生命周期基本框架"></p>
<h3 id="什么是管理评审？管理评审的重要性？">什么是管理评审？管理评审的重要性？</h3>
<p><mark>管理评审</mark>被称为<strong>阶段出口</strong>或<strong>终止点</strong>，发生在<u>每个项目阶段结束后</u>。</p>
<h4 id="管理评审的重要性">管理评审的重要性</h4>
<p><em><strong>评审</strong></em>：每个项目在继续<u>进入下一个阶段之前都必</u>须<mark>顺利通过</mark>前面的<strong>每一个项目阶段</strong></p>
<p><em><strong>标志</strong></em>：顺利通过前面的每一个项目阶段的标志是通过<strong>本阶段</strong>和<strong>前面的每一个项目阶段</strong>的管理评审</p>
<p><em><strong>目的</strong></em>：项目管理评审的目的是要<strong>判断项目是否应该继续、重新定位或终止</strong>，每个阶段的管理评审，对后阶段的工作起指导性的作用，务必严格执行</p>
<h3 id="虚拟团队">虚拟团队</h3>
<p>虚拟团队：是<strong>虚拟组织</strong>中的一种新型的<u>工作组织形式</u>，是一些人由于具有共同理想、目标或利益，结合在一起的团队，只需要通过<u><em>虚拟方式</em></u>讨论交换文档就可以分工完成一份事先拟定好的工作。</p>
<h3 id="什么是过程？项目管理过程组？各过程组所需时间和活动水平？-实施-最需要资源和时间-计划-监控-启动和收尾-要求资源和时间最少">什么是过程？项目管理过程组？各过程组所需时间和活动水平？ <mark>实施（最需要资源和时间）</mark>、计划、监控、<mark>启动和收尾（要求资源和时间最少）</mark></h3>
<p><strong>过程</strong>–是为<u>实现某个特定目标</u>而进行的**<u>一系列活动</u>**。</p>
<p>**项目管理过程组：**是从启动到计划、执行（实施）、监控和收尾的<u><strong>一系列活动</strong></u>。</p>
<h5 id="五大过程组：">五大过程组：</h5>
<ol>
<li class="lvl-3">
<p>启动过程：是**<u>识别、评价、确定、开始</u>**一个新的项目或者<u><strong>开始一个项目的一个新阶段</strong></u>的过程。</p>
</li>
<li class="lvl-3">
<p>计划过程：包括制订和维护一个可执行的计划，以保证项目满足组织的要求。</p>
</li>
<li class="lvl-3">
<p>实施（执行）过程：包括协调人力和其他资源来执行项目的计划，以产生项目或者项目阶段的产品、服务或者结果。</p>
</li>
<li class="lvl-3">
<p>监控过程：包括有规律地<u><strong>测量和监视项目进程</strong></u>以保证项目团队能够满足项目目标。（<u><em><strong>根据项目目标来衡量项目进度，并采取纠正措施</strong></em></u>）</p>
</li>
<li class="lvl-3">
<p>收尾/终止过程：包括<u><strong>对项目或者项目阶段的正式验收</strong></u>，并有效地终止，使项目或项目阶段任务有序、圆满的完成。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230508153258223.png" alt="image-20230508153258223" style="zoom: 80%;" />
<blockquote>
<p><mark>实施过程</mark>和<mark>监控过程</mark>贯穿整个过程⭐️</p>
</blockquote>
<h3 id="各过程组的成果？">各过程组的成果？</h3>
<p>（1） 项目开始阶段启动过程主要成果：形成一个<strong>项目章程</strong>和选择一位<strong>项目经理</strong>。项目一个新阶段启动过程主要成果：对阶段进入条件的<strong>评估与确认</strong></p>
<p>（2） 计划过程组的成果包括：<strong>工作分解结构</strong>，<strong>范围说明书</strong>，<strong>项目进度</strong>和<strong>项目成本估计</strong>（记忆：质量、范围、时间、成本）。研究表明实现最佳实践的公司至少花 20%的时间在<strong>启动</strong>和<strong>计划</strong>过程。</p>
<p>（3） 执行过程组的主要成果：按计划完成项目工作，即项目<strong>实际工作的交付</strong>（实际交付成果）</p>
<p><strong>（4）</strong> 监控过程的理想产出：<strong>通过交付满足时间</strong>、<strong>成本</strong>和<strong>质量约束的项目来成功地完成项目</strong></p>
<p>（5） 收尾过程组的关键结果：工作的<strong>正式验收</strong>和<strong>项目审计和项目经验总结报告</strong>等一些总结性文件。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>验收报告和项目经验总结报告等总结性文件</mark></p>
</li>
</ul>
<h3 id="项目管理过程组和9大知识领域的联系-计划过程组-九九归一">项目管理过程组和9大知识领域的联系。（计划过程组） 九九归一</h3>
<h4 id="过程组与知识领域之间的关系">过程组与知识领域之间的关系</h4>
<p>⭐️<u><mark>计划过程</mark>与<mark>监控过程</mark>贯穿全部知识领域</u>（详见：以下的关系表）</p>
<p>⭐️<mark>项目集成管理</mark>包含了全部5个过程组</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511160523275.png" alt="image-20230511160523275" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230511160625082.png" alt="image-20230511160625082" style="zoom: 50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619120818054.png" alt="image-20230619120818054" style="zoom:50%;" />
<h2 id="三-整合项目资源">三 整合项目资源</h2>
<h3 id="什么是项目集成管理？">什么是项目集成管理？</h3>
<p><mark>项目集成管理</mark>是指为<mark>确保项目各项工作</mark>能够<u>有机地</u><strong>协调和配合</strong>所开展的<strong>综合性和全局性</strong>的<mark>项目管理<strong>工作与过程</strong></mark>，是实现<strong>整体项目成功</strong>的关键。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>项目集成管理任务是在项目生命周期中<strong>协调</strong>所有<u>其他项目管理知识领域所涉及的过程</u>。</p>
</li>
<li class="lvl-2">
<p>项目集成管理围绕<strong>项目计划</strong>进行，主要过程有<u><strong>计划制定</strong>、<strong>计划执行</strong>和<strong>计划变更控制</strong>。</u></p>
</li>
</ul>
<h3 id="包括7个主要过程？-制定项目章程-创建初步的项目范围说明书-制定项目管理计划-指导和管理项目实施-监控项目工作-整体变更控制-项目收尾">包括7个主要过程？ 制定项目章程、创建初步的项目范围说明书、 制定项目管理计划、指导和管理项目实施、监控项目工作、 整体变更控制、 项目收尾</h3>
<p>(1) <u><strong>制定项目章程</strong></u>。它是指与<u>项目利益相关者一起合作</u>，制定<u>正式批准项目</u>的文件——章程。</p>
<p>(2) <u><strong>创建初步的项目范围说明书</strong></u>。它是指通过<u>与项目利益相关者的合作</u>，尤其是与项目产品、服务或其他产出的用户合作，开发出<u>总体的范围要求</u>。这个过程的目的便是建立初步的项目范围说明书。</p>
<p>(3) <u><strong>制定项目管理计划</strong></u>。这个阶段涉及协调所有<u>计划要付出的努力</u>，创建一份一致、连贯的文件——项目管理计划。</p>
<p>(4) <u><strong>指导和管理项目实施</strong></u>。这涉及通过实施项目管理计划中的活动，来<u>执行项目管理计划</u>。这个阶段主要完成交付物、变更请求、工作绩效信息、被实施的变更请求、纠正措施、预防措施和缺陷修复。</p>
<p>(5) <u><strong>监控项目工作</strong></u>。这涉及监督项目工作是否符合项目的绩效目标。这个阶段主要<u>完成惩治和预防措施建议</u>、<u>缺陷修复建议</u>以及<u>变更请求</u>。</p>
<p>(6) <u><strong>整体变更控制</strong></u>。它涉及对影响项目交付物和组织运营资产的所有变更做好协调工作。这个阶段的任务<u>包括被批准和被拒绝的变更请求</u>、被批准的纠正和预防措施、被批准和生效的缺陷修复、交付物、项目管理计划和项目范围说明书的更新。</p>
<p>(7) <u><strong>项目收尾</strong></u>。它涉及完成所有的项目活动，从而式<u>结束项目</u>。这个阶段包括最终产品、服务或者成果，行政上和合同上的终止于续，以及对组织运营资产的更新。</p>
<blockquote>
<p>助记：联系五大过程组</p>
<p>(1)、(2)为启动；</p>
<p>(3)为计划；</p>
<p>(4)为实施；</p>
<p>(5)、(6)为监控；</p>
<p>(7)为收尾</p>
</blockquote>
<h3 id="用于战略计划的swot-方法？">用于战略计划的SWOT 方法？</h3>
<p>&quot;SWOT&quot;是一种商业分析工具，其名称代表着Strengths（优势）、Weaknesses（劣势）、Opportunities（机会）和Threats（威胁）。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SWOT 即基于内外部竞争环境和竞争条件下的态势分析，就是将<mark>与研究对象密切相关的</mark>各种主要<u><strong>内部优势、劣势和外部的机会和威胁</strong></u>等，通过调查<mark>列举出来</mark>，并<mark>依照</mark><u><strong>矩阵形式排列</strong></u>，然后<mark>用</mark><u><strong>系统分析</strong></u>的思想，把<u>各种因素相互匹配起来</u><mark>加以分析</mark>，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p>
</li>
<li class="lvl-2">
<p>运用这种方法，可以对研究对象所处的情景进行<u><strong>全面、系统、准确</strong></u>的研究，从而根据研究结果制定相应的<u><strong>发展战略、计划以及对策</strong></u>等。</p>
</li>
</ul>
<h3 id="筛选信息技术项目过程？财务分析：净现值-投资回报率-投资回收期">筛选信息技术项目过程？财务分析：净现值、投资回报率、投资回收期</h3>
<h4 id="筛选信息技术项目过程-重点">⭐️筛选信息技术项目过程（重点⭐️）</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515141208580.png" alt="筛选信息技术项目过程" style="zoom:50%;" />
<p>⭐️<u>识别</u>潜在项目<u>之后</u>，还必须<mark>进行筛选</mark>，下面是4种筛选方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>注重<u><strong>整个组织的需求</strong></u>；——标准：“<mark>需求、资金和意愿</mark>”。</p>
</li>
<li class="lvl-2">
<p>将IT<u><strong>项目进行分类</strong></u>；——依据：优先级、时间、动机</p>
</li>
<li class="lvl-2">
<p>进行净现值等<u><strong>财务分析</strong></u>；</p>
</li>
<li class="lvl-2">
<p>运用<u><strong>加权评分模</strong></u>型。</p>
</li>
</ul>
<h4 id="对it项目进行分类">⭐️对IT项目进行分类</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于<mark>优先级</mark>的分类：将待选项目按高、中、低三个次序进行整体综合排序，首先进行最重要的项目。</p>
</li>
<li class="lvl-2">
<p>基于<mark>时间</mark>的分类：基于时间的考虑筛选项目，可能是完成项目所需的工期时间，也可能是项目必须满足的截止日期；</p>
</li>
<li class="lvl-2">
<p>基于<mark>动机</mark>的分类</p>
<ul class="lvl-2">
<li class="lvl-4"><mark>问题、机会、（上级）指令</mark></li>
<li class="lvl-4">机会：评价项目是否可以<u><strong>解决某个问题</strong></u>，或是<u><strong>抓住某种机会</strong></u>，或迎合某个<u><strong>指示要求</strong></u>；</li>
</ul>
</li>
</ul>
<h4 id="净现值分析">净现值分析⭐️</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>净现值分析( net present value analysis)是计算项目<u><strong><mark>预期</mark>净货币收益和损失</strong></u>的方法，将当前时间点之后的所有未来预期现金流入和流出都做折现计算。</p>
</li>
<li class="lvl-2">
<p>只考虑那些能产生<u><strong>正净现值的项目</strong></u>（项目回报超过了资金成本）</p>
<ul class="lvl-2">
<li class="lvl-4">优先选择净现值大的项目</li>
</ul>
</li>
</ul>
<p>折现因子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>r</mi><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{(1+r)^t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7253em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>第t年现金流：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">A_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span style="color: red;">净现值(NPV)：</span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1...</mn><mi>n</mi></mrow></munder><mfrac><msub><mi>A</mi><mi>t</mi></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>r</mi><msup><mo stretchy="false">)</mo><mi>t</mi></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sum_{t=1...n} \frac{A_t}{(1+r)^t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.6274em;vertical-align:-1.2671em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1...</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7196em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><mark>折现率</mark>( discount rate)是用来将未来现金流折现的利率，也称作资本化率或资本机会成本。</p>
<h4 id="投资回报率-投资回报">投资回报率/投资回报</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>选择项目时候另外一个重要的财务考虑因素便是投资回报。</p>
</li>
<li class="lvl-2">
<p>投资回报率/投资回报(retum on investment , ROI) 是项目的收益减去成本后，再除以成本的结果。</p>
</li>
</ul>
<p><span style="color: red;">投资回报率（ROI）：</span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mtext>总的折现收益</mtext><mo>−</mo><mtext>总的折现成本</mtext></mrow><mtext>总的折现成本</mtext></mfrac></mrow><annotation encoding="application/x-tex">\frac{总的折现收益-总的折现成本}{总的折现成本}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总的折现成本</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总的折现收益</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">总的折现成本</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span style="color: red;">投资回收期：</span></p>
<p>项目从投产年算起，用每年的净收益将初始全部投资收回的时间。（投资回收期是指项目从开始投资到回收全部投资成本所需要的时间）</p>
<p>计算方法：假设第x年时收入的金额&gt;=每年投入金额的总和，那么投资回收期就是：x-投产年+1</p>
<h5 id="例题：">例题：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619121911732.png" alt="image-20230619121911732"></p>
<h3 id="什么是项目章程？包括哪些信息？">⭐️什么是项目章程？包括哪些信息？</h3>
<p><strong>项目章程</strong>是一份<mark>正式认可项目</mark>的文件，并**<u>为项目目标和管理</u>**<mark>提供方向</mark></p>
<p>项目章程的<mark>主要内容</mark>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515143838763.png" alt="image-20230515143838763" style="zoom:50%;" />
<h3 id="一个项目管理计划包括：整体介绍-组织描述-管理程序-技术程序-任务范围-时间进度-经费预算等">一个<mark>项目管理计划</mark>包括：整体介绍、组织描述、管理程序、技术程序、任务范围、时间进度、经费预算等。</h3>
<p>（范围：任务范围、时间：时间进度、成本：经费预算）</p>
<h3 id="集成变更控制：在整个项目的生命周期中识别-估计和管理变更">集成变更控制：在整个项目的生命周期中<mark>识别、估计和管理变更</mark>。</h3>
<h3 id="集成变更控制的目的？">集成变更控制的目的？</h3>
<p>⭐️集成变更控制的<mark>主要目的是</mark>:</p>
<p>(1)<strong>控制</strong>可能造成变更的<strong>因素</strong>，以<strong>确保</strong>变更都是<strong>有益的</strong>。——识别</p>
<p>(2)<strong>确认</strong>变更已经<strong>发生</strong>。——估计</p>
<p>(3)<strong>管理</strong>发生的<strong>变更</strong>。——管理</p>
<h3 id="变更控制系统">变更控制系统</h3>
<p>变更控制系统：是一个<strong>正式的</strong>、<strong>文档化的</strong>过程，描述了正式的项目文件可能改变的时间和方式，主要有<mark>三个控制要素</mark>：<strong>建立变更控制组织</strong>、<strong>优化配置管理</strong>、<strong>及时进行沟通</strong>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230515151747652.png" alt="image-20230515151747652" style="zoom:50%;" />
<h2 id="四-控制项目范围">四 控制项目范围</h2>
<h3 id="软件企业与it项目应用企业信息化成功的基本保证是对项目范围的确切圈定-为此必须强调：三类人的获取和三要素的把握？">软件企业与IT项目应用企业信息化成功的基本保证是对<mark>项目范围</mark>的确切圈定，为此必须强调：三类人的获取和三要素的把握？</h3>
<h5 id="三类人的获取">三类人的获取</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong>需求专家</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>咨询专家</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>概要设计专家</strong></em></p>
</li>
</ul>
<h5 id="三要素的把握">三要素的把握</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong>企业需求</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>管理理论</strong></em></p>
</li>
<li class="lvl-2">
<p><em><strong>竞争压力</strong></em></p>
</li>
</ul>
<blockquote>
<h5 id="成功的三要素">成功的三要素</h5>
<p>对于<u><strong>企业需求</strong></u>、<u><strong>管理理论</strong></u>、<u><strong>竞争压力</strong></u>（<u><strong>核心竞争力</strong></u>）三要素的有效把握才是<mark>成功地定义软件需求和确定项目范围</mark>的基本保证！</p>
</blockquote>
<h3 id="什么是范围？什么项目范围管理？">什么是范围？什么项目范围管理？</h3>
<p><mark>范围</mark>是指开展<u><strong>项目产品</strong></u>所包括的<mark>所有工作</mark>及产生这些产品经过的<mark>所有过程</mark>。</p>
<p>项目范围管理<strong>是指对项目<mark>包括什么与不包括什么</mark>的定义与控制过程。</strong></p>
<h3 id="项目范围管理的作用？-两个实施方面-一个最终交付方面">项目范围管理的作用？ （两个实施方面，一个最终交付方面）</h3>
<h5 id="项目范围管理的作用">⭐️项目范围管理的作用</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>为项目实施<u>提供任务范围的<mark>框架</mark></u></p>
</li>
<li class="lvl-2">
<p>对项目的实施<u>提供有效的<mark>控制</mark></u></p>
</li>
<li class="lvl-2">
<p>为<u>项目最终交付</u>提供<mark>依据</mark></p>
</li>
</ul>
<blockquote>
<p><em><strong>用于确保项目组和项目干系人对作为项目结果的项目产品以及生产这些产品所用到的过程有一个共同的理解。</strong></em></p>
</blockquote>
<h3 id="项目范围管理的过程？-各过程？范围规划-范围定义-工作结构分解-范围验证-范围控制">项目范围管理的过程？ 各过程？范围规划 范围定义 工作结构分解 范围验证 范围控制</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518162905237.png" alt="image-20230518162905237" style="zoom:50%;" />
<ol>
<li class="lvl-3">
<p>范围规划：项目范围管理计划</p>
</li>
<li class="lvl-3">
<p>需求收集：明确需求</p>
</li>
<li class="lvl-3">
<p>范围定义：项目范围说明书</p>
</li>
<li class="lvl-3">
<p>工作分解结构：WBS词典、范围差异</p>
</li>
<li class="lvl-3">
<p>范围验证：要收可交付成果</p>
</li>
<li class="lvl-3">
<p>范围控制：<mark>监督</mark>项目和产品的范围状态、<mark>管理</mark><strong><u>范围基准</u></strong><mark>变更</mark></p>
</li>
</ol>
<h3 id="什么是工作分解结构？作用？特点？建立方法？">什么是工作分解结构？作用？特点？建立方法？</h3>
<p><mark>工作分解结构</mark>是一种<u><strong>以结果为导向</strong></u>的<u>分析方法</u>，<mark>用于分析</mark>项目所涉及到的工作，<strong>所有这些工作</strong>构成了项目的<strong>整个范围</strong>。它将主要的**<u>项目可交付成果</u>**分解成<mark>更小和更易管理</mark>的部分。</p>
<p><mark>WBS 的作用</mark>如下图所示，考试如果考到就把这个图表述一遍：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230518171731036.png" alt="image-20230518171731036" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>参与者快速定位</p>
</li>
<li class="lvl-2">
<p>防止范围遗漏</p>
</li>
<li class="lvl-2">
<p>对全局进行把控</p>
</li>
<li class="lvl-2">
<p>帮助成员<u>集中重点区域</u></p>
</li>
<li class="lvl-2">
<p>防止项目变更</p>
</li>
<li class="lvl-2">
<p>了解自己的工作对项目的影响</p>
</li>
<li class="lvl-2">
<p>促进团队和项目干系人的沟通与合作</p>
</li>
</ul>
<p><mark>WBS 的特点</mark>是通常以<strong>图表</strong>的形式表示，每一项元素通常被赋予<strong>唯一的标识</strong>，最低一层元素一般被称为<strong>工作包</strong>，<strong>WBS</strong> <strong>字典</strong>是描述 WBS <strong><u>每项条目详细信息</u><strong>的文件，一般包含</strong>工作包的描述</strong>。</p>
<blockquote>
<p>⭐️<u><em><strong>WBS有层次，没有层次的不是WBS</strong></em></u></p>
</blockquote>
<p><mark>WBS 的建立方法</mark>有<strong>类比法</strong>和<strong>分解法</strong>，前者考虑<u><strong>取类似项目参考</strong></u>，后者考虑<u><strong>自上而下或自下而上分解</strong></u>。</p>
<h3 id="范围基线？">范围基线？</h3>
<p>范围基线：<u><strong>项目范围说明书</strong></u>及<u><strong>相关的WBS</strong></u>、<u><strong>WBS词典</strong></u>构成，是<mark>实现</mark>**<u>项目范围目标的绩效</u>**的依据。</p>
<h2 id="五-保障项目进度">五 保障项目进度</h2>
<h3 id="什么是项目计划？什么是进度计划？">什么是项目计划？什么是进度计划？</h3>
<p>项目计划：是<mark>指导项目实施和控制</mark>的一系列纲领性文件，是经高层管理批准的项目正式文档。</p>
<p>进度计划：是表达项目中各项工作（活动）的<u><strong>开展顺序</strong></u>、<u><strong>开始及完成时间</strong></u>及<u><strong>相互衔接关系</strong></u>的计划。进度计划是进度控制和管理的依据；同时引导项目其他类型的计划工作。</p>
<h3 id="项目时间管理？主要过程：活动定义-活动排序-活动资源估算-活动历时估算-项目进度计划编制-以及进度跟踪与控制过程">项目时间管理？主要过程：活动定义、活动排序、活动资源估算、活动历时估算、项目进度计划编制、以及进度跟踪与控制过程。</h3>
<p>采用一定的方法，对项目范围所包括的==<strong>活动</strong>及其相互关系进行分析==，对各项活动<mark>所需的资源和时间进行估算</mark>，并在<strong>项目的时间期限内</strong><mark>合理地安排和控制</mark><strong>活动的开始和结束时间</strong></p>
<ol>
<li class="lvl-3">
<p>活动定义</p>
</li>
<li class="lvl-3">
<p>活动排序</p>
</li>
<li class="lvl-3">
<p>活动资源估算</p>
</li>
<li class="lvl-3">
<p>活动历时估算</p>
</li>
<li class="lvl-3">
<p><mark>项目进度计划</mark>编制</p>
</li>
<li class="lvl-3">
<p>进度跟踪与控制过程</p>
</li>
</ol>
<h3 id="什么是活动？活动清单-活动属性-里程碑-？？？">什么是活动？活动清单、活动属性、里程碑 ？？？</h3>
<p><u><strong>活动或任务</strong></u>：是项目进行期间需要完成的<u><strong>工作单元</strong></u>，它们有预期的<u><strong>历时、成本和资源要求</strong></u>。</p>
<p>①<strong>活动清单</strong>：项目将要进行的<mark>所有计划活动</mark>，可以看作是 <u>WBS 的进一步延伸</u>。</p>
<p>②<strong>活动属性</strong>：每项<u><strong>活动</strong></u>的<mark>具体描述</mark>，属性随时间会演进</p>
<p>③<strong>里程碑清单</strong>：项目中的<strong>重要时间点</strong>或者<strong>时间</strong>，每个里程碑是<strong>强制性的</strong>，里程碑事件的<mark>工期是 <strong>0</strong></mark>，因为是一个时间点。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230522153130633.png" alt="image-20230522153130633" style="zoom:50%;" />
<h3 id="分解用于活动定义时-最后结果是activities；分解用于范围定义时-最后结果为deliverables">分解用于活动定义时，最后结果是Activities；分解用于范围定义时，最后结果为Deliverables</h3>
<p>⭐️分解用于<u><strong>活动定义</strong></u>时，最后结果是Activities(活动)；分解用于<u><strong>范围定义</strong></u>时，最后结果为Deliverables(可交付成果)——联系WBS概念</p>
<h3 id="依赖关系">依赖关系</h3>
<h5 id="依赖关系-四种">依赖关系（四种）</h5>
<p><mark>依赖关系或关系</mark>反映了项目活动或任务的<mark>顺序</mark>。一个<u><strong>没有明确活动之间关系</strong></u>的项目是不可能成功的。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>强制依赖关系（硬逻辑关系）</strong></u>是项目工作<mark>固有的特性</mark>(行业逻辑）。</p>
</li>
<li class="lvl-2">
<p><u><strong>自由依赖关系（软逻辑关系）</strong></u>是由项目<mark>团队来定义的</mark>(是否签字）。</p>
</li>
<li class="lvl-2">
<p><u><strong>外部依赖关系</strong></u> 涉及<mark>项目活动与非项目活动之间</mark>的关系（操作系统供应商）。</p>
</li>
<li class="lvl-2">
<p><u><strong>内部依赖关系</strong></u> 涉及<mark>项目活动之间</mark>的关系（在项目团队控制之内）。</p>
</li>
</ul>
<h3 id="活动排序的工具：双代号网络图-前导图">活动排序的工具：双代号网络图、前导图</h3>
<h5 id="箭线图法-adm-双代号网络-aoa">⭐️箭线图法(ADM)-双代号网络(AOA)</h5>
<p>①项目网络图 ：项目网络图是<u><strong>项目活动之间的逻辑关系或排序</strong></u>的<em><strong>图形显示</strong></em>。</p>
<p>②表示方法：使用<u><strong>箭线图法(ADM)</strong></u>或<u><strong>双代号网络图法(AOA)</strong></u>编制的网络图如图所示。 AOA是用箭线表示活动，用节点的连接点反映活动顺序的网络制图技术。<mark>节点</mark>简单的<u><strong>表示活动的<mark>开始和结束</mark></strong></u>。</p>
<p><u><em><strong>双代号网络图法(AOA)示例</strong></em></u>：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162032690.png" alt="双代号网络图法(AOA)示例"></p>
<blockquote>
<p><mark>缺点：</mark></p>
<ul class="lvl-1">
<li class="lvl-2">只能表示FS一种活动依赖关系</li>
</ul>
</blockquote>
<h6 id="虚活动">⭐️虚活动</h6>
<p>作用：<em><strong>辅助排序使用</strong></em></p>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162511167.png" alt="image-20230525162511167" style="zoom: 33%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162559410.png" alt="image-20230525162559410" style="zoom:33%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p><u><em><strong>只有双代号网络图法（AOA）中采用“虚活动”。</strong></em></u></p>
</blockquote>
<h5 id="前导图法-pdm-单代号网络-aon">⭐️前导图法(PDM)-单代号网络(AON)</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525162941631.png" alt="image-20230525162941631" style="zoom:50%;" />
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525163017244.png" alt="image-20230525163017244"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525163026046.png" alt="image-20230525163026046"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p><mark>PDM法的优点：</mark></p>
<p>①大多数<strong>项目管理软件</strong>使用PDM法</p>
<p>②PDM法<u><strong>避免了使用虚活动</strong></u>(没有历时、不占用资源的活动)</p>
<p>③PDM法<u><strong>反映了任务之间的各种依赖关系</strong></u></p>
</blockquote>
<h5 id="pdm-与-adm-的区别：">PDM 与 ADM 的区别：</h5>
<p>①PDM 没有虚活动，ADM 涉及到虚活动</p>
<p>②PDM 活动在节点内，ADM 活动在箭线上</p>
<p>③PDM 涉及到 4 种依赖类型，ADM 只有 FS 一种类型</p>
<h3 id="活动间的4种关系">活动间的4种关系</h3>
<h5 id="四种依赖关系类型">四种依赖关系类型</h5>
<p>四种依赖关系类型：确定了活动之间存在某种依赖关系（强制的，自由的，或者外部的等）之后，接下来必须确定依赖关系的类型。活动之间存在<u><strong>四种依赖关系类型</strong></u>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>完成-开始（FS-Finished Start）：==从活动（紧前活动）==必须完成后，==到活动（紧后活动）==才能开始。</p>
</li>
<li class="lvl-2">
<p>开始-开始（SS）：从活动开始后，到活动才能开始。</p>
</li>
<li class="lvl-2">
<p>完成-完成（FF）：到活动完成前，从活动必须完成。</p>
</li>
<li class="lvl-2">
<p>开始-完成（SF）：从活动必须开始后，到活动才能完成。</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619150827131.png" alt="image-20230619150827131"></p>
<h3 id="进度安排的的工具？甘特图-跟踪甘特图-关键路径分析-关键链进度安排-计划评审技术分析">进度安排的的工具？甘特图（跟踪甘特图）、关键路径分析、关键链进度安排、计划评审技术分析</h3>
<h5 id="跟踪甘特图与网络图的区别">⭐️跟踪甘特图与网络图的区别</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>跟踪甘特图：<u>显示计划和实际的项目进度信息</u></p>
</li>
<li class="lvl-2">
<p>跟踪甘特图注重展示**<u>任务的时间轴和进度安排</u>**，而网络图则强调<u><strong>任务之间的依赖关系和流程</strong></u></p>
</li>
</ul>
<h3 id="浮动时间-最大机动时间">浮动时间（最大机动时间）</h3>
<p>一个活动在不影响项目完成时间的情况下，可以延迟的时间量。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230525170128574.png" alt="image-20230525170128574" style="zoom:50%;" />
<h3 id="关键路径分析的特点-应用">关键路径分析的特点、应用</h3>
<p><mark>关键路径法（CPM）</mark>：这种<mark>进度网络分析技术</mark><u><strong>在不考虑任何资源限制的情况下</strong></u>，<mark>根据</mark>制定的<u><strong>网络顺序逻辑关系</strong></u>和<u><strong>单一历时估算</strong></u>，<mark>沿</mark><u>进度网络路径</u>使用<u><strong>顺推与逆推法</strong></u>，计算出所有活动的<u>最早开始ES、最早结束EF、最晚开始LS和最晚完成LF日期</u>。<mark>用来</mark><u><em>预测整个项目的持续时间</em></u>。</p>
<blockquote>
<p><mark>其核心</mark>是<u><strong>计算浮动时间</strong></u>，确定哪些活动的进度安排灵活性最小。</p>
</blockquote>
<p><mark>关键路径</mark>：指<mark>决定</mark><u><strong>项目最早完成时间</strong></u>的一系列活动，是<u><strong>通过网络图的最长路径</strong></u>，其<u><strong>浮动时间最少</strong></u>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong>关键路径是可以变化的</strong></em>，如果对路径进行压缩可能会导致最终的项目完成时间减少，从而导致<u>最长时间路径</u>（关键路径）改变。</p>
</li>
<li class="lvl-2">
<p>是项目完成的最短完成时间</p>
</li>
</ul>
<p>⭐️<mark>计算关键路径</mark>：把通过网络图的每个路径上的所有<u>活动持续时间累加起来</u>，最长的路径就是关键路径。</p>
<h4 id="关键路径的特点">关键路径的特点</h4>
<p>①关键路径是<mark>最长的路径（图中时间累和最多的路径）</mark>。（见PDM图）</p>
<p>②关键路径反映了<mark>项目所花费的最短的时间</mark>。</p>
<p>③关键路径上的活动超时，总体进度就要拖延。</p>
<p>④关键路径只与项目的时间有关与关键活动无关。</p>
<p>⑤关键路径它与选择最短的路径无关。</p>
<p>⑥一个项目可能会<mark>有超过一条的关键路径</mark>。</p>
<p>⑦一个项目的<mark>关键路径可能会发生变化</mark>。</p>
<h4 id="关键路径法的应用">关键路径法的应用</h4>
<p>① <mark>利用</mark>关键路径<mark>分析平衡</mark><u><strong>进度计划</strong></u></p>
<p>② <u><strong>缩短</strong></u><mark>关键路径</mark>上的<u><strong>活动历时</strong></u> （重点在关键路径）</p>
<p>③ <mark>关注与及时更新</mark>关键路径数据</p>
<h3 id="缩短项目工期方法">缩短项目工期方法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以采用<mark>赶工</mark>（Crashing,<u><strong>通过增加资源</strong></u>）</p>
</li>
<li class="lvl-2">
<p>或<mark>快速跟进</mark>（Fast tracking,<u><strong>通过并行施工</strong></u>）等方法。</p>
</li>
</ul>
<blockquote>
<p><mark>赶工</mark>：通过增加资源，是<u>为了以最少的成本代价获得最大限度的进度压缩。</u>（关键路径上）</p>
<p><mark>快速跟进</mark>：并行执行那些通常以顺序方式执行的活动。</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>软件项目组织管理</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>测试作业1-组合分析方法</title>
    <url>/2023/05/11/University/junior/course/Software%20testing%20technology/%E4%BD%9C%E4%B8%9A1-%E7%BB%84%E5%90%88%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95-%E6%AD%A3%E4%BA%A4%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>测试作业1-组合分析方法</h1>
<h3 id="正交法代码实现">正交法代码实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> allpairspy <span class="keyword">import</span> AllPairs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid_combination</span>(<span class="params">row</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(row)</span><br><span class="line">    <span class="comment"># 设置过滤条件</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># ⼀年级 不能匹配 10-13岁</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;未登录&quot;</span> == row[<span class="number">0</span>] <span class="keyword">and</span> <span class="string">&quot;⾮会员&quot;</span> != row[<span class="number">1</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;第⼀次登录&quot;</span> == row[<span class="number">0</span>] <span class="keyword">and</span> <span class="string">&quot;VIP会员&quot;</span> == row[<span class="number">1</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;会员&quot;</span> == row[<span class="number">1</span>] <span class="keyword">and</span> <span class="string">&quot;会员9折&quot;</span> != row[<span class="number">2</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;VIP会员&quot;</span> == row[<span class="number">1</span>] <span class="keyword">and</span> <span class="string">&quot;VIP会员8折&quot;</span> != row[<span class="number">2</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">parameters = [</span><br><span class="line">    [<span class="string">&quot;未登录&quot;</span>, <span class="string">&quot;第⼀次登录&quot;</span>, <span class="string">&quot;正常登录&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;⾮会员&quot;</span>, <span class="string">&quot;会员&quot;</span>, <span class="string">&quot;VIP会员&quot;</span>, <span class="string">&quot;雇员&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;没有&quot;</span>, <span class="string">&quot;假⽇95折&quot;</span>, <span class="string">&quot;会员9折&quot;</span>,<span class="string">&quot;VIP会员8折&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;标准&quot;</span>, <span class="string">&quot;快递&quot;</span>, <span class="string">&quot;加急&quot;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PAIRWISE:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, pairs <span class="keyword">in</span> <span class="built_in">enumerate</span>(AllPairs(parameters,filter_func=is_valid_combination)):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;⽤例编号&#123;:2d&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, pairs))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> allpairspy <span class="keyword">import</span> AllPairs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因子水平</span></span><br><span class="line">parameters = [</span><br><span class="line">    [<span class="string">&quot;未登录&quot;</span>, <span class="string">&quot;第⼀次登录&quot;</span>, <span class="string">&quot;正常登录&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;⾮会员&quot;</span>, <span class="string">&quot;会员&quot;</span>, <span class="string">&quot;VIP会员&quot;</span>, <span class="string">&quot;雇员&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;没有&quot;</span>, <span class="string">&quot;假⽇95折&quot;</span>, <span class="string">&quot;会员9折&quot;</span>,<span class="string">&quot;VIP会员8折&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;标准&quot;</span>, <span class="string">&quot;快递&quot;</span>, <span class="string">&quot;加急&quot;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现约束的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constraint_func</span>(<span class="params">row</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(row)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;未登录&quot;</span> == row[<span class="number">0</span>] <span class="keyword">and</span> <span class="string">&quot;⾮会员&quot;</span> != row[<span class="number">1</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;第⼀次登录&quot;</span> == row[<span class="number">0</span>] <span class="keyword">and</span> <span class="string">&quot;VIP会员&quot;</span> == row[<span class="number">1</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;会员&quot;</span> == row[<span class="number">1</span>] <span class="keyword">and</span> <span class="string">&quot;会员9折&quot;</span> != row[<span class="number">2</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;VIP会员&quot;</span> == row[<span class="number">1</span>] <span class="keyword">and</span> <span class="string">&quot;VIP会员8折&quot;</span> != row[<span class="number">2</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;PAIRWISE:&quot;)</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> i, pairs <span class="keyword">in</span> <span class="built_in">enumerate</span>(AllPairs(parameters,filter_func=constraint_func)):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;⽤例编号&#123;:2d&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, pairs))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件测试技术</category>
        <category>作业</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件项目组织管理期末总结2</title>
    <url>/2023/07/09/University/junior/course/Software%20Project%20Organization%20Management/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%932/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>软件项目组织管理期末总结2</h1>
<h2 id="六-驾驭项目成本">六 驾驭项目成本</h2>
<h3 id="什么是成本？项目成本？学习曲线理论？储备金-应急-管理-？一些相关的概念">什么是成本？项目成本？学习曲线理论？储备金（应急、管理）？一些相关的概念。</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619161207877.png" alt="image-20230619161207877" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601163743180.png" alt="image-20230601163743180" style="zoom: 33%;" />
<p>储备金：包含于项目估算中，为<mark>减轻</mark><u><strong>未来难以预测的成本风险</strong></u>而准备的资金。</p>
<p>应急储备：为一些可以部分预计的未来情况（已知的未知）做准备。在成本基准中，PM（项目经理）可控制</p>
<p>管理储备：考虑到未来不可预测的情况（未知的未知）。不在成本基准中 PM无权控制，需要向管理层申请 。</p>
<p><em><strong>成本基准</strong></em>：<u>是经批准的<mark>按时间安排</mark>的<strong>成本支出计划</strong>，并<mark>随时反映</mark>了<strong>经批准的项目变更</strong>（所增加或减少的资金项目），被用于<mark>度量和监督</mark>项目的<strong>实际执行成本</strong>。</u></p>
<h3 id="什么是项目成本管理？目的？">什么是项目成本管理？目的？</h3>
<p><mark>项目成本管理</mark>（包含用来确保项目团队在批准的预算内<span style="color: red;">完成一个项目</span>的必要过程）包括<mark>为使项目</mark><strong>在批准的预算内完成</strong>而<mark>对成本</mark>进行<u><strong>规划、估算、预算和控制</strong></u>的各个过程，从而<u>确保项目在批准的预算内完工</u>。</p>
<p>目的：确保项目在批准的预算内完成，实现<u><strong>项目价值最大化</strong></u>。</p>
<h3 id="项目成本管理的过程？">项目成本管理的过程？</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601164459234.png" alt="image-20230601164459234" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>规划成本管理——成本管理计划</p>
</li>
<li class="lvl-2">
<p>成本估算——成本估算、估算依据</p>
</li>
<li class="lvl-2">
<p>成本预算——成本基准计划</p>
</li>
<li class="lvl-2">
<p>成本控制——修正估算、更新预算</p>
</li>
</ul>
<h3 id="什么是成本估算？成本估算工具和技术？成本估算的类型？">什么是成本估算？成本估算工具和技术？成本估算的类型？</h3>
<p><mark>成本估算</mark>是对<u>完成项目工作<strong>所需资源成本</strong></u>进行<strong>近似估算</strong>的过程。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601170820779.png" alt="image-20230601170820779" style="zoom:50%;" />
<blockquote>
<p><em><strong>类比估算法</strong></em>：也叫<mark>自上而下估算法</mark>，它是使用以前的、<u>相似项目</u>的实际成本作为目前项目成本估算的<u>根据</u>。</p>
<p><em><strong>自下而上估计法</strong></em>：首先对项目工作分解结构（WBS）中的<u>具体工作包或者活动所需要的资源进行估算</u>，然后逐级累加，并最终汇总成为项目的总成本。</p>
<p><em><strong>参数模型估算法</strong></em>：根据项目的<u>特征参数建立一个数学模型</u>，利用这个数学模型来<u>计算（预测）项目的成本</u>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601171616894.png" alt="image-20230601171616894" style="zoom:50%;" />
</blockquote>
<h5 id="估算的类型">估算的类型</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601170639704.png" alt="image-20230601170639704" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>粗略的量级估算</p>
</li>
<li class="lvl-2">
<p>预算估算</p>
</li>
<li class="lvl-2">
<p>确定性估算</p>
</li>
</ul>
<h3 id="什么是成本预算？概念的关键点是？主要工作是？">什么是成本预算？概念的关键点是？主要工作是？</h3>
<p><mark>成本预算</mark>：<mark>汇总所有</mark>单个<strong>活动或工作包的估算成本</strong>，<mark>建立</mark>一个<strong>经批准的成本基准</strong>的过程。<mark>目的是</mark>为了<u>确定测量项目实际绩效</u>的<strong>基准计划</strong>，而<mark>把整个成本估算</mark><u><strong>按照时间段</strong></u>分配到具体工作包或者活动上去。</p>
<h4 id="两个要点">两个要点</h4>
<p><strong>（1）把成本估算分配到项目生命期中的==每一个活动（或工作包）==中。</strong></p>
<p><strong>（2）建立<mark>成本控制基准线</mark>（ＢＣＷＳ或ＰＶ）－用来度量项目实际执行清况。</strong></p>
<h4 id="成本预算主要工作">成本预算主要工作</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>确定项目<mark>总的预算</mark>（<em><strong>估算+储备</strong></em>）</p>
</li>
<li class="lvl-2">
<p>确定项目<mark>各项活动的预算</mark></p>
</li>
<li class="lvl-2">
<p>确定项目各项活动预算的<mark>投入时间</mark></p>
</li>
<li class="lvl-2">
<p>给出<strong>项目成本预算</strong>的==“S”曲线==</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230601172730955.png" alt="image-20230601172730955" style="zoom:50%;" />
<h3 id="成本估算和成本预算的联系和区别？">成本估算和成本预算的联系和区别？</h3>
<p>（1） 关系：</p>
<p>①估算是预算的<strong>依据</strong></p>
<p>②估算和预算都属于<strong>成本管理的过程</strong></p>
<p>③用的<strong>工具和技术一致</strong></p>
<p>④预算是估算的<strong>进一步细分</strong></p>
<p>⑤都是成本控制的依据</p>
<p>（2） 区别：</p>
<p>①内容不同：预算是<mark>直接人工费用、辅助服务费用</mark>、采购物品费用；估算是<mark>直接成本、间接成本</mark>、不可预见费、储备金</p>
<p>②目标不同：预算是<mark>制定</mark>一个**<u>成本基准计划</u><strong>；估算是获得<mark>完成</mark>项目<u>所需费用</u>的</strong><u>近似值估算</u>**</p>
<p>③输入不同：预算是项目管理计划、项目文件、商业文件、协议、事业环境因素、组织过程资产；估算是项目管理计划、项目文件、事业环境因素、组织过程资产</p>
<p>④输出不同：预算是**<u>成本基准、资金要求</u><strong>、文件更新；估算是</strong><u>成本估算、估算依据</u>**、文件更新</p>
<h3 id="成本控制的工具-挣值分析">成本控制的工具——挣值分析</h3>
<h4 id="基本概念">基本概念</h4>
<p>⭐️挣值方法是<mark>对项目范围、进度和成本进行综合控制的一种有效方法</mark>。它对于计划完成的工作、实际挣得的利益、实际花费的成本进行比较，以确定成本和进度是否按计划进行。</p>
<p>项目挣值：指已完成作业量的计划成本的中间变量。</p>
<p>⭐️挣值方法**<u>核心要素</u>**：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>三个<span style="color: red;">关键变量</span>：<em><strong>PV、AC、EV（挣值）</strong></em></p>
</li>
<li class="lvl-2">
<p>两个<mark>偏差</mark>：<em><strong>CV、SV</strong></em></p>
</li>
<li class="lvl-2">
<p>两个<mark>绩效指标</mark>：<em><strong>CPI、SPI</strong></em></p>
</li>
</ul>
<h4 id="示例">示例</h4>
<p>假设现在有一个项目，为期4个月，总预算4000美元，每月任务为总量的1／4，预算也是总预算的1／4。现在一个月过去了，完成了本月任务的80％，花费了900美元。下表以这个情景说明挣值的术语和含义。</p>
<h5 id="基本术语">基本术语</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605143938441.png" alt="image-20230605143938441" style="zoom:67%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605144005430.png" alt="image-20230605144005430" style="zoom: 67%;" />
<blockquote>
<p>公式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>P</mi><mi>I</mi><mo>=</mo><mfrac><mrow><mi>E</mi><mi>V</mi></mrow><mrow><mi>A</mi><mi>C</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">CPI=\frac{EV}{AC}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>A</mi><mi>C</mi><mo>=</mo><mfrac><mrow><mi>B</mi><mi>A</mi><mi>C</mi></mrow><mrow><mi>C</mi><mi>P</mi><mi>I</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">EAC=\frac{BAC}{CPI}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</blockquote>
<h5 id="挣值法的四个评价指标：">挣值法的四个评价指标：</h5>
<p><mark>费用偏差CV（Cost Variance)</mark>。 CV是指检查期间BCWP与ACWP之间的差异。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>V</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mtext>–</mtext><mi>A</mi><mi>C</mi><mi>W</mi><mi>P</mi><mo>=</mo><mi>E</mi><mi>V</mi><mo>−</mo><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CV = BCWP – ACWP = EV - AC
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">–</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p><mark>进度偏差SV（Schedule Variance)</mark>。 SV是指检查期间BCWP与BCWS 之间的差异。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>V</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mtext>–</mtext><mi>B</mi><mi>C</mi><mi>W</mi><mi>S</mi><mo>=</mo><mi>E</mi><mi>V</mi><mo>−</mo><mi>P</mi><mi>V</mi></mrow><annotation encoding="application/x-tex"> SV = BCWP – BCWS = EV - PV
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">–</span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SV=对应预算的实际工作量—对应预算的预算工作量</p>
</li>
</ul>
<p><mark>费用执行指标CPI （Cost Performed Index)</mark>。 CPI是指预算费用与实际费用之比（或工时值之比）。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>P</mi><mi>I</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mi mathvariant="normal">/</mi><mi>A</mi><mi>C</mi><mi>W</mi><mi>P</mi><mo>=</mo><mi>E</mi><mi>V</mi><mi mathvariant="normal">/</mi><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex"> CPI = BCWP / ACWP = EV / AC
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">/</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p><mark>进度执行指标SPI （ Schedule Performed Index)</mark>。 SPI是指项目挣得值与计划值之比。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>P</mi><mi>I</mi><mo>=</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mi mathvariant="normal">/</mi><mi>B</mi><mi>C</mi><mi>W</mi><mi>S</mi><mo>=</mo><mi>E</mi><mi>V</mi><mi mathvariant="normal">/</mi><mi>P</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">SPI = BCWP / BCWS = EV / PV
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">SP</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
<h4 id="挣值法参数分析与对应措施表">⭐️挣值法参数分析与对应措施表</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605150836031.png" alt="image-20230605150836031" style="zoom: 50%;" />
<blockquote>
<p>EV大于PV：效率高，进度快；否则，效率低，进度慢</p>
<p>AC大于EV：投入超前（CV &lt; 0）；否则，投入延后</p>
</blockquote>
<h4 id="挣值分析绘图">⭐️挣值分析绘图</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>要会绘制图，并且必须在图中标记相应的参数</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230605151223763.png" alt="image-20230605151223763" style="zoom:50%;" />
<h4 id="例题">例题</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230621023700881.png" alt="image-20230621023700881"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230621023810177.png" alt="image-20230621023810177"></p>
<h2 id="七-保证项目质量">七 保证项目质量</h2>
<h3 id="软件质量的重要性？">软件质量的重要性？</h3>
<p>①人们对软件的<strong>依赖性越来越大</strong>；</p>
<p>②软件质量问题带来的<strong>危害也越来越严重</strong>；</p>
<p>③软件产品质量正在<strong>牵动着社会的命脉</strong>；</p>
<p><strong>忽视软件质量必将让我们付出更大的代价，受到更为严厉的惩罚。</strong></p>
<h3 id="质量的传统和新认识-质量和等级的区别">质量的传统和新认识，质量和等级的区别</h3>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608164140930.png" alt="image-20230608164140930" style="zoom:50%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608164215327.png" alt="image-20230608164215327" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="质量和等级的区别">质量和等级的区别</h4>
<p>产品的质量影响成本，产品的特征影响销售。而<mark>等级</mark>指的是，<strong>相同功能用途</strong>但是<strong>技术参数不同</strong>的实体<mark>进行分类或排序</mark>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>质量是反映<strong>实体</strong>满足<strong>明确</strong>和<strong>隐含</strong>需要的能力的<strong>特性</strong>总和</p>
</li>
<li class="lvl-2">
<p>项目管理要解决的问题<strong>不是等级</strong>，<strong>而是质量</strong>。</p>
</li>
</ul>
<h3 id="ios对质量的定义-质量管理的定义">IOS对质量的定义、质量管理的定义</h3>
<p>（1） 质量：是反映<strong>实体</strong>满足<strong>明确</strong>和<strong>隐含</strong>需要的能力的<strong>特性</strong>总和。实体包括<strong>产品、过程和活动</strong>，不同的实体质量的实质内容<strong>不一样</strong>。</p>
<p>（2）质量管理：在质量方面<mark>指挥和控制</mark><strong>组织</strong>的协调活动。</p>
<h3 id="什么是软件质量？">什么是软件质量？</h3>
<p><mark>软件质量</mark>是将客户的<strong>隐性需求</strong>转换为<strong>明确需求</strong>,并且满足所有<strong>明确需求</strong>。同时还与如何最小化隐性需求、最小化未实现的需求相关。此外还与是否以一致的、可重复的满足相关需求有关。</p>
<blockquote>
<p>从用户角度评价，即如何使用软件、使用效果如何、软件性能如何；开发团队角度评价，要用最少的资源与最快的进度生产出质量最优的产品；维护者角度，对软件维护方面的特性；管理者角度，注重总体效益和长远利益。</p>
</blockquote>
<h3 id="项目质量管理是指为满足项目质量目标要求所需要的管理过程；包括：质量计划-质量保证-质量控制">项目质量管理是指为满足<mark>项目质量目标要求</mark>所需要的管理过程；包括：质量计划 质量保证 质量控制</h3>
<h3 id="质量管理发展的四个阶段">质量管理发展的四个阶段</h3>
<ol>
<li class="lvl-3">
<p><em><strong>传统阶段</strong></em>：这是质量管理的<mark>起始阶段</mark>，也被称为<mark>检查阶段</mark>。在这个阶段，质量管理主要依赖于检查和筛选产品或服务的最终结果，以确定是否符合规定的标准。这包括使用人工方法进行检查、纠正和调整以确保产品的合格性。</p>
</li>
<li class="lvl-3">
<p><em><strong>统计阶段</strong></em>：在这个阶段，质量管理<strong>开始</strong><mark>引入统计方法和概念</mark>。这个阶段的关键概念是质量控制。通过对生产过程进行统计分析，识别和纠正潜在的质量问题，以提高产品和服务的质量水平。统计过程控制（SPC）和质量函数展开（QFD）是在这个阶段被广泛应用的方法。</p>
</li>
<li class="lvl-3">
<p><em><strong>全面阶段</strong></em>：<u><strong><mark>全面质量管理</mark>（TQM）是这一阶段的核心理念</strong></u>。TQM强调组织的全员参与，并将质量管理的责任扩展到整个组织。在这个阶段，质量管理不仅关注产品或服务的质量，还注重组织内部的流程、文化和员工的参与。TQM的目标是通过持续改进和顾客导向的方法来提高整体质量。</p>
</li>
<li class="lvl-3">
<p><em><strong>用户满意度阶段</strong></em>：这个阶段<mark>强调了顾客满意度的重要性</mark>。质量管理的目标是实现超越顾客期望的产品和服务，并确保顾客的满意度和忠诚度。这个阶段强调建立和维护良好的顾客关系、持续改进和顾客导向的方法。质量管理被视为一种战略工具，用于实现顾客满意度并提高组织的竞争力。</p>
</li>
</ol>
<h3 id="戴明改进循环-pdca-特性">戴明改进循环 PDCA、特性</h3>
<h4 id="戴明改进循环-pdca循环">戴明改进循环(PDCA循环)</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608172443224.png" alt="image-20230608172443224" style="zoom:50%;" />
<p>PDCA 循环是<strong>计划</strong>、<strong>执行</strong>、<strong>检查</strong>、<strong>处理</strong>。</p>
<h5 id="四个明显特性：">四个明显特性：</h5>
<ol>
<li class="lvl-3">
<p>周而复始</p>
</li>
<li class="lvl-3">
<p>大环带小环</p>
</li>
<li class="lvl-3">
<p><mark>阶梯式</mark>上升</p>
</li>
<li class="lvl-3">
<p><u>统计的工具</u></p>
</li>
</ol>
<h3 id="项目质量计划编制方法：成本收益分析法-质量标杆法-质量图表法-实验设计法">项目质量计划编制方法：成本收益分析法、<mark>质量标杆法</mark>、质量图表法、<mark>实验设计法</mark></h3>
<p>① 成本收益分析：质量成本的概念是将产品质量保持在规定的质量水平上所需的费用，一般分为一致性成本、不一致性成本两种。</p>
<p><mark>② 质量标杆法</mark>：用其他项目质量结果或计划作为新项目的**<u>质量参照体系</u><strong>和</strong><u>比照目标</u>**。</p>
<p>③ 质量图表法：使用各种图表制定项目质量计划的方法。</p>
<p><mark>④ 实验设计法</mark>：用实验的方法去<mark>识别</mark><strong>项目质量及其影响因素</strong>，然后编制项目质量计划。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>开放性、创新性项目</u>要<strong>通过实验</strong><mark>规划</mark>项目质量</p>
</li>
</ul>
<h3 id="影响项目质量的因素-5m1e">影响项目质量的因素 5M1E</h3>
<p>影响项目质量因素的控制一共六项，分别是<strong>人、方法、环境、测量、机械设备、材料与构配件</strong>，记作 <strong>5M1E</strong>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230608172925755.png" alt="image-20230608172925755" style="zoom: 50%;" />
<h3 id="质量控制的工具和方法：排列图-散布图-控制图-因果图-关联图-6西格玛-测试">质量控制的工具和方法：<mark>排列图、散布图、控制图</mark>、因果图、关联图、<mark>6西格玛</mark>、测试</h3>
<p>①  <strong>排列图</strong>（<strong>帕累托图</strong>）：以 <strong>80/20</strong> 原则为基本思想，用于<strong>找出影响质量的关键因素</strong>。用频数与累计来显示，比如“沙含泥量过大”是 16，画折线时用（45+16）/80 来做，而不是 16/80。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/%E6%8E%92%E5%88%97%E5%9B%BE.jpg" alt="排列图"></p>
<p>② <strong>控制图</strong>：用于确认<strong>项目过程和结果是否处于受控状态</strong>。七点定律指的是：产出物多次检查特征值连续 7 个点在控制中线的<strong>同一侧</strong>或者连续七个递增或递减点，认为项目质量出现失控。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230620204800195.png" alt="image-20230620204800195" style="zoom: 33%;" />
<p><strong>③</strong> <strong>因果图</strong>（鱼刺图）：用来揭示<strong>问题的原因或其潜在原因</strong>。</p>
<p><strong>④</strong> <strong>关联图</strong>（头脑风暴法）：用于分析<strong>复杂因素交织在一起的问题</strong>。</p>
<p><strong>⑤</strong> <strong>散点图（散布图）</strong>：由 X 和 Y 构成，用于显示<strong>两个变量之间的<mark>相关性</mark></strong>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230620204850983.png" alt="image-20230620204850983" style="zoom:50%;" />
<p>⑥ <strong>统计抽样</strong>：样本大小=0.25*（可信度因子/可接受误差）²。</p>
<p>⑦ <strong>6σ管理法</strong>：通过降低偏差来提高质量</p>
<p>⑧ <strong>测试</strong></p>
<h3 id="提高软件项目质量的方法">提高软件项目质量的方法</h3>
<p>提高软件质量：<mark>关键在<strong>领导</strong></mark>，同时需要<mark>控制<strong>质量成本</strong></mark>，<mark>考虑</mark><strong>组织影响</strong>、<strong>工作环境因素</strong>和<strong>质量</strong>，注意<mark>改善工作环境</mark>以提高生产效率和质量。利用一些<mark>成熟度模型来进行管理</mark>。</p>
<h2 id="八-协调项目人力资源">八 协调项目人力资源</h2>
<h3 id="什么是人力资源？具有哪些特征？">什么是人力资源？具有哪些特征？</h3>
<h4 id="人力资源含义">⭐️人力资源含义</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230612141827962.png" alt="image-20230612141827962" style="zoom:50%;" />
<h4 id="人力资源具有的特征：">⭐️人力资源具有的特征：</h4>
<p>①***<mark>可再生</mark>的生物性资源***：它以人身为天然载体，是一种“活”的资源，并与人的自然生理特征相联系。</p>
<p>②<em><strong>居于<mark>主导地位</mark>的动能性资源</strong></em>：人类不同于自然界其他生物之处在于人具有目的性、主观能动性和社会意识。</p>
<p>③<em><strong>具有<mark>时效性</mark>的资源</strong></em>：人力资源的形成、开发、使用都具有时间方面的制约。</p>
<h3 id="什么是项目人力资源管理？">什么是项目人力资源管理？</h3>
<p><strong>项目人力资源管理</strong>可以定义为**<u>根据项目目标</u>**，<mark>采用科学的方法</mark>，<u>对项目组织成员</u>进行合理的选拔、培训、考核、激励，<u>使其融合到组织之中</u>，并充分发挥其潜能，从而<u><strong>保证高效实现项目目标</strong></u>的过程。</p>
<h3 id="管理员工的关键所在：激励理论-权力理论-习惯">管理员工的关键所在：激励理论、权力理论、习惯</h3>
<p>（1）激励理论：激励人分为<strong>内在动机</strong>和<strong>外在动机</strong>两种动力，前者是<strong>满足自身乐趣</strong>，后者是<u>获利避免惩罚</u>。</p>
<p>（2）权力理论：权力是一种<mark>影响行为</mark>的<strong>潜在能力</strong>。</p>
<p>（3）习惯：</p>
<p>​			①<strong>积极主动</strong></p>
<p>​			②<strong>以终为始，一开始就牢记结果</strong></p>
<p>​			③<strong>把最重要的事放在最重要的位置上</strong></p>
<p>​			④<strong>考虑双赢</strong></p>
<p>​			⑤<strong>首先去理解别人然后再被别人理解</strong></p>
<p>​			⑥<strong>协同工作</strong></p>
<p>​			⑦<strong>不断更新</strong></p>
<h3 id="马斯洛的需求层次理论">马斯洛的需求层次理论</h3>
<p>在马斯洛需求理论中，将人的<mark>需求划分为五层</mark>，自下而上分别是<strong>生理需求</strong>、<strong>安全需求</strong>、社会需求、尊重需求和自我实现需求。</p>
<h3 id="赫茨伯格的双因素理论">赫茨伯格的双因素理论</h3>
<p>赫茨伯格认为，人工作的<strong>主要激励因素</strong>来自<strong>个人成绩</strong>与<strong>由此获得的认可度</strong></p>
<h3 id="权力的5种主要类型：强制权力-合法权力-专家权力-奖励权力-参照权力">权力的5种主要类型：强制权力、<mark>合法权力、专家权力</mark>、奖励权力、<mark>参照权力</mark>。</h3>
<ol>
<li class="lvl-3">
<p>强制权力：对不服从领导者指示或要求的人进行控制和惩罚的权力。一般强制权力在项目团队的建设中不是一个很好的方法。</p>
</li>
<li class="lvl-3">
<p><mark>合法权力</mark>：通过法律或制度规定的权力。是指在高级管理层对项目经理正式授权的基础上，项目经理让员工进行工作的权力。</p>
</li>
<li class="lvl-3">
<p><mark>专家权力</mark>：用个人知识和技能让员工改变他们的行为。</p>
</li>
<li class="lvl-3">
<p>奖励权力：就是使用一些激励措施来引导员工去工作。</p>
</li>
<li class="lvl-3">
<p><mark>参照权力</mark>（感召权力）：**<u>个人特质</u><strong>产生的一种</strong><u>使别人认同</u>**的权力,与人格特性及其他个人特质有关。 参照权力形成的原因是<u>他人的崇拜</u>,因此拥有者必定具有某种能使别人敬仰并奉为楷模的魅力。</p>
</li>
</ol>
<h3 id="项目人力资源管理的过程-4个">项目人力资源管理的过程 4个</h3>
<p>项目人力资源管理过程：分为四个步骤，<strong>人力资源规划</strong>、<strong>团队组建</strong>、<strong>团队建设</strong>和<strong>团队管理</strong>。</p>
<h3 id="人力资源规划-责任分配矩阵">人力资源规划 责任分配矩阵</h3>
<p>（1） 人力资源规划：包括<strong>识别与记录</strong>项目角色、责任和汇报关系，产生项目的<strong>组织结构图</strong>和<strong>人员配置管理计划</strong>。工作<strong>解释与分配</strong>也很重要，分为 4 个阶段：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/工作的解释和分配4个阶段.jpg" alt="工作的解释和分配4个阶段" style="zoom:50%;" />
<p>（2）<strong>责任分配矩阵</strong>（RAM）是用<u>矩阵表格的形式</u><mark>表示</mark><u><strong>工作分解结构中的细目</strong></u>，以及工作绩效<mark>对应的个人责任</mark>。除了可以分配细分的工作活动外，还可以用于<u>定义项目的通用角色和责任</u>， 可以做<strong>项目干系人角色分配</strong>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/%E8%B4%A3%E4%BB%BB%E5%88%86%E9%85%8D%E7%9F%A9%E9%98%B5.jpg" alt="责任分配矩阵"></p>
<p>人员配置计划描述了人员在<strong>什么时候、什么方式进入和离开项目团队</strong>，一般用<strong>资源柱状****图</strong>（直方图）表示。</p>
<h3 id="组建项目团队-主要途径-资源负荷-资源平衡">组建项目团队 主要途径 <mark>资源负荷 资源平衡</mark></h3>
<p><mark>团队组建</mark>：<u>通过<mark>招聘或者其他方式</mark>，<mark>获得</mark>项目所需人员</u>，并根据状况安排或分配到指定岗位上，<mark>主要途径</mark>有<u><strong>人员预先指派</strong></u>、<u><strong>谈判</strong></u>、<u><strong>虚拟团队</strong></u>等。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>其中虚拟团队的优点有：技术发达、地理限制小、人才丰富、资源节约。</p>
</li>
</ul>
<p>团队是<strong>项目成员的一个整合过程</strong>。项目经理通过<strong>资源负荷</strong>和<strong>资源平衡</strong>两种方法来<mark>最有效使用</mark><u>项目人员</u>，前者用于<u><strong>指定资源</strong></u>，后者用于**<u>合理化分配</u>**。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>资源负荷容易引发<strong>过度分配</strong>，造成工作人员手头的任务过多。</p>
</li>
</ul>
<h3 id="开发项目团队-团队发展的5个阶段-工具和方法"><mark>开发</mark>项目团队 团队发展的5个阶段、工具和方法</h3>
<h4 id="开发项目团队">开发项目团队</h4>
<p>通过<mark>培训个人与团队的技能</mark>来**<u>改善</u>**项目绩效。</p>
<p>输出是：<u>评估团队绩效</u>。</p>
<h4 id="5个阶段">5个阶段</h4>
<p><strong>①</strong> <strong>形成</strong>：辨识人际边界和任务边界，建立成员的<strong>相互关系</strong>，项目经理起到<strong>指导性作用</strong>。</p>
<p><strong>②</strong> <strong>震荡</strong>：获取信心，但是存在<strong>人际冲突</strong>与分化，项目经理起到<strong>影响性作用</strong>。</p>
<p><strong>③</strong> <strong>规范</strong>：规则、价值等都已建立，<strong>团队效能提高</strong>，项目经理为<strong>参与式领导</strong></p>
<p><strong>④</strong> <strong>项目成熟</strong>：团队角色更灵活，运作如一个整体，项目经理为<strong>委任式领导</strong>。</p>
<p><strong>⑤</strong> <strong>项目解散</strong>：任务完成，团队解散</p>
<h4 id="工具和方法">工具和方法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>团队建设活动</mark></p>
</li>
<li class="lvl-2">
<p><mark>一般管理技术</mark></p>
</li>
<li class="lvl-2">
<p><mark>绩效考评与奖励系统</mark></p>
</li>
<li class="lvl-2">
<p><mark>人员配置</mark></p>
</li>
<li class="lvl-2">
<p><mark>培训</mark></p>
</li>
</ul>
<h3 id="管理项目团队-工作和方法-冲突管理-解决方法：回避和撤出-竞争和逼迫-缓和和调停-妥协-正视">管理项目团队 工作和方法 （冲突管理 解决方法：回避和撤出、竞争和逼迫、缓和和调停、妥协、正视）</h3>
<p>管理项目团队：除了开发团队外，项目经理必须领导团队完成各种项目活动。</p>
<h4 id="工作和方法">工作和方法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>观察和交谈</p>
</li>
<li class="lvl-2">
<p>项目绩效评价</p>
</li>
<li class="lvl-2">
<p>冲突管理</p>
</li>
<li class="lvl-2">
<p>问题日志</p>
</li>
</ul>
<p>冲突管理的解决方法：<u><strong>回避和撤出、竞争和逼迫、缓和和调停、妥协、正视</strong></u></p>
<h2 id="九-改善项目的沟通">九 改善项目的沟通</h2>
<h3 id="软件项目成功的三个主要因素">软件项目成功的三个主要因素</h3>
<ol>
<li class="lvl-3">
<p>用户参与</p>
</li>
<li class="lvl-3">
<p>主管层的支持</p>
</li>
<li class="lvl-3">
<p>需求的<mark>清晰表述</mark></p>
</li>
</ol>
<h3 id="项目沟通管理的目标？">项目沟通管理的目标？</h3>
<p>项目沟通管理的目标是：<mark>及时</mark>而适当地<u><strong>创建</strong>、<strong>收集</strong>、<strong>发送</strong>、<strong>储存</strong>和<strong>处理</strong></u>项目的信息。</p>
<h3 id="项目沟通管理的过程？"><mark>项目沟通管理的过程？</mark>⭐️</h3>
<p>（1） <strong>规划沟通管理</strong>：主要作用是为及时向<strong>相关方提供相关信息</strong>。输入包括项目章程、项目管理计划、项目文件、事业环境因素和组织过程资产。项目管理计划包括<strong>资源管理计划</strong>和<strong>相关方参与计划</strong>，都属于人力资源管理的内容。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>输出：<mark>沟通管理计划</mark></p>
</li>
</ul>
<p>（2） <strong>管理沟通</strong>：<strong>确保</strong>项目信息及时且恰当地收集、生成、发布、存储、检索、管理、监督和最终处置的过程。主要作用是**<u>促成项目团队和相关方之间有效的信息流动</u>**。本过程需要在整个项目期间开展。</p>
<p>（3） <strong>监督沟通</strong>：是<mark>确保满足</mark>项目及其相关方的<strong>信息需求</strong>的过程。主要作用是<strong>按沟通管理计划和相关方参与计划</strong>的要求<strong>优化</strong>信息传递流程。主要目标是在整个项目生命周期中确保信息的<strong>最佳流动</strong>。</p>
<h3 id="沟通管理计划包括哪些内容？">沟通管理计划包括哪些内容？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>描述什么信息送给谁、何时送、如何送。</p>
</li>
<li class="lvl-2">
<p>传送重要项目信息的格式。</p>
</li>
<li class="lvl-2">
<p>获得信息的方法。</p>
</li>
</ul>
<p>主要包括以下内容：</p>
<p>① 描述信息收集和文件归档的结构。</p>
<p>② <mark>描述什么信息送给谁、何时送、如何送。</mark></p>
<p>③ <mark>传送重要项目信息的格式。</mark></p>
<p>④ 用于创建信息的日程表。</p>
<p>⑤ <mark>获得信息的方法。</mark></p>
<p>⑥ 更新沟通管理计划的方法。</p>
<p>⑦ 项目干系人沟通分析。</p>
<h3 id="沟通复杂性的确定：沟通渠道数目的计算公式"><mark>沟通复杂性的确定</mark>：沟通渠道数目的计算公式⭐️</h3>
<p>沟通复杂性的确定依赖于<strong>人数</strong>，当团队中有 n 个人的时候，沟通渠道 S 的计算公式为：S=n(n-1)/2。</p>
<p>沟通方法大致分为<strong>互动沟通</strong>、<strong>推式沟通</strong>和<strong>拉式沟通</strong>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/%E6%B2%9F%E9%80%9A%E6%B8%A0%E9%81%93%E8%AE%A1%E7%AE%97.jpg" alt="沟通渠道计算"></p>
<blockquote>
<p>互动沟通是一种双向的、交互式的沟通方式；</p>
<p>推式沟通是一种单向的、发送方主导的沟通方式；</p>
<p>拉式沟通是一种接收者主导的沟通方式。</p>
</blockquote>
<h3 id="绩效报告的作用和内容？状态报告-进度报告-项目预测和变更请求">绩效报告的作用和内容？状态报告、进度报告、项目预测和变更请求</h3>
<p>工作绩效报告的<mark>作用</mark>是使<strong>项目干系人</strong><mark>知晓</mark>为了<u>达到项目的目标，</u>是<u>如何使用资源</u>的，这些资源的状况和对项目的贡献。主要包括以下四类<mark>内容</mark>：</p>
<p>① <strong>状态报告</strong>：项目在某一特定<strong>时间点</strong>所处的位置</p>
<p>② <strong>进度报告</strong>：项目组在某一特定<strong>期间</strong>所完成的工作</p>
<p><strong>③</strong> <strong>项目预测</strong>：预测项目<strong>未来的</strong>状态与进度</p>
<p>④ <strong>变更请求</strong>：项目变更的<mark>原因</mark>、对目标和资源的<mark>影响</mark>以及采取的<mark>措施</mark></p>
<h3 id="管理收尾的主要输出是项目档案-正式接受和取得的教训">管理收尾的主要输出是<mark>项目档案、正式接受和取得的教训</mark>。</h3>
<h3 id="改善沟通的建议">改善沟通的建议</h3>
<p>改善沟通的建议可以<u><strong><mark>利用沟通技能</mark></strong></u>、<u><strong><mark>召开有效的会议</mark></strong></u>、<u><strong><mark>使用项目沟通模板</mark></strong></u>、<u><strong>建立沟通基础结构</strong></u>、<u><strong><mark>利用软件辅助沟通</mark></strong></u>。</p>
<p>发现冲突后需要根据<strong>关系和任务的重要程度</strong>判断选择哪种方式解决：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/出现冲突后选择的解决方式.png" alt="出现冲突后选择的解决方式" style="zoom:50%;" />
<h2 id="十-应对项目风险">十 应对项目风险</h2>
<h3 id="什么是风险？项目风险管理？">什么是风险？项目风险管理？</h3>
<p>风险：是可能给<mark>项目的成功</mark>带来**<u>威胁或损害</u><strong>的</strong>可能性**。</p>
<p>项目风险管理：是指<mark>通过</mark><strong>风险识别</strong>、<strong>风险分析</strong>和<strong>风险评估</strong>去<mark>认识</mark>项目的风险，并<strong>以此为基础</strong><mark>合理的使用</mark>各种<strong>风险应对</strong>措施、管理方法、技术和手段，对项目风险<mark>实行</mark><u><strong>有效的应对和监控</strong></u>，妥善处理风险事件所造成的不利后果，以<strong>最低的成本</strong><mark>实现</mark><u><strong>项目总体目标</strong></u>的实践活动的总称。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><em><strong>项目风险管理是对项目风险进行<mark>识别、评估和应对</mark>的过程。</strong></em></u></p>
</li>
</ul>
<h3 id="项目风险管理的特点？目标？">项目风险管理的特点？目标？</h3>
<h5 id="特点：">特点：</h5>
<p>①活动:项目风险管理是为减轻潜在的不利事件对项目的影响而采取的一项活动。</p>
<p>②成本：<mark>风险管理是一种投资，需要成本</mark>。</p>
<p>③成本和收益：在任何情况下，<mark>项目风险管理的成本不应超过项目潜在的收益</mark>。</p>
<p>④平衡：需要努力<mark>在项目的各个方面寻找<strong>风险和机会之间</strong>的<strong>平衡</strong></mark>。</p>
<h5 id="目标：">目标：</h5>
<p>把<mark>对于项目目标而言</mark><strong>正面事件</strong>的<u>概率和影响</u>结果<mark>最大化</mark>和把<strong>负面事件</strong>的<u>概率和影响</u>最小化。</p>
<h3 id="风险承受度？">风险承受度？</h3>
<p>①风险承受度：是从<mark>潜在回报中</mark>得到满足或快乐的程度。</p>
<p>②表现形式：一些组织或个人对风险有一种中性的承受度，一些对风险很厌恶，而另一些则追求风险。</p>
<h5 id="风险规避-风险中立-风险偏好"><strong>风险规避 风险中立 风险偏好</strong></h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230619174055551.png" alt="image-20230619174055551" style="zoom:50%;" />
<blockquote>
<p>比如：一个人在面临更大的风险时获得更大的满足感，并愿意付出代价承担风险，那么这个人是（风险偏好型）。</p>
</blockquote>
<h3 id="项目风险管理涉及的主要过程：风险规划管理-风险识别-定性风险分析-定量风险分析-风险应对计划和风险监控">项目风险管理涉及的主要过程：<mark>风险规划管理、风险识别、定性风险分析、定量风险分析、风险应对计划和风险监控</mark>。</h3>
<h3 id="四个应对风险的基本措施是：规避-接受-减轻-转移">四个应对风险的基本措施是：<mark>规避、接受、减轻、转移</mark>。</h3>
<h2 id="不考-十一-关注项目的采购和外包">（不考）十一 关注项目的采购和外包</h2>
<h3 id="什么是项目采购？什么是项目采购管理？">什么是项目采购？什么是项目采购管理？</h3>
<h3 id="项目采购的特点-目标？">项目采购的特点，目标？</h3>
<h3 id="项目采购管理的主要过程？">项目采购管理的主要过程？</h3>
<h3 id="编制采购计划的工具和技术有哪些？">编制采购计划的工具和技术有哪些？</h3>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件项目组织管理</category>
      </categories>
      <tags>
        <tag>软件项目组织管理</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>测试作业2-代码静态分析</title>
    <url>/2023/05/11/University/junior/course/Software%20testing%20technology/%E4%BD%9C%E4%B8%9A2-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>测试作业2-代码静态分析</h1>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/u011943534/article/details/83037496">(77条消息) Intellij IDEA 使用checkstyle、pmd、findbugs检查静态代码质量_码农-文若书生的博客-CSDN博客_idea pmd</a></p>
<p>FindBugs参考：[(77条消息) IDEA插件系列（3）：FindBugs插件检查项目bug_二木成林的博客-CSDN博客](<a href="https://blog.csdn.net/cnds123321/article/details/102852177#:~:text=%E6%8F%90%E4%BE%9B%E9%9D%99%E6%80%81%E5%AD%97%E8%8A%82%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8C%E4%BB%A5%E4%BB%8EIntelliJ,IDEA%E4%B8%AD%E6%9F%A5%E6%89%BEJava%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E3%80%82">https://blog.csdn.net/cnds123321/article/details/102852177#:~:text=提供静态字节代码分析，以从IntelliJ,IDEA中查找Java代码中的错误。</a> FindBugs是Java的缺陷检测工具，它使用静态分析来查找200多种错误模式，例如空指针取消引用，无限递归循环，对Java库)</p>
<p>check使用参考：[(77条消息) IDEA下安装与使用CheckStyle_杨林伟的博客-CSDN博客_checkstyle idea](<a href="https://blog.csdn.net/qq_20042935/article/details/112602107#:~:text=IDEA%E4%B8%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8CheckStyle">https://blog.csdn.net/qq_20042935/article/details/112602107#:~:text=IDEA下安装与使用CheckStyle</a> 1 1. 前言 CheckStyle 是 SourceForge 下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。,3. 配置CheckStyle 3.1 新建CheckStyle代码规范文件 首先在本地新建 checkstyle.xml 文件，里面的内容如下： )</p>
</blockquote>
<p>分析源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Example</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        a=m;</span><br><span class="line">        b=n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Function_A</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">6</span> &amp;y&gt;<span class="number">0</span>)  &#123;</span><br><span class="line">        ans=x+a;</span><br><span class="line">        &#125;    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans=x-a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Function_B</span><span class="params">(intx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">6</span>)</span><br><span class="line">        ans=x*a;</span><br><span class="line">        <span class="keyword">else</span>   ans=x/b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pmd静态分析">PMD静态分析</h3>
<p>PMD工具下载：</p>
<p>1、首先在IDEA的setting中找到plugin</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128181742853.png" alt="image-20221128181742853" style="zoom:50%;" />
<p>2、之后搜索PMD插件并下载：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128181840287.png" alt="image-20221128181840287" style="zoom:50%;" />
<p>3、之后指定待分析的代码并鼠标右键选择run PMD：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128181440031.png" alt="image-20221128181440031" style="zoom:50%;" />
<p>4、最后得到分析结果：</p>
<ol>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128182440601.png" alt="image-20221128182440601"></p>
<p>代码第1行的publicclass出现拼写错误。</p>
</li>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128182610904.png" alt="image-20221128182610904"></p>
<p>代码第19行出现变量定义错误：intx。</p>
</li>
<li class="lvl-3">
<p>将以上两个结果修改正确之后，再次run PMD并将结果保存为网页：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128211726932.png" alt="image-20221128211726932"></p>
</li>
</ol>
<h3 id="checkstyle静态分析">Checkstyle静态分析</h3>
<p>Checkstyle工具下载：</p>
<p>1、同样下载Checkstyle工具插件：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128182117062.png" alt="image-20221128182117062" style="zoom:50%;" />
<p>2、添加自定义规则：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128220103772.png" alt="image-20221128220103772"></p>
<p>3、检测代码得到如下结果：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128215320720.png" alt="image-20221128215320720"></p>
<p>此外，在使用Checkstyle静态分析时，出现了<code>The source file could not be parsed by Checkstyle</code>的问题，经过网上查阅资料和试错，发现将Checkstyle的version改为8.1版本之下即可。</p>
<h3 id="总结">总结</h3>
<p>综上结果，对比两种工具：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>目的</th>
<th>检查项</th>
</tr>
</thead>
<tbody>
<tr>
<td>PMD</td>
<td>检查java源文件中的潜在问题</td>
<td>空try/catch/finally/switch语句块、未使用的局部变量、参数和private方法、空if/while语句、过于复杂的表达式、复杂类</td>
</tr>
<tr>
<td>Checkstyle</td>
<td>检查java源文件是否与代码规范相符</td>
<td>java注释、命名规范、多余的imports、size度量、缺少必要的空格、重复代码</td>
</tr>
</tbody>
</table>
<h3 id="附录">附录</h3>
<p>checkstyle.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">module</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Puppy Crawl//DTD Check Configuration 1.3//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.puppycrawl.com/dtds/configuration_1_3.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Checker&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 官方主页：https://checkstyle.sourceforge.io --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 检查文件是否以一个空行结束 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;NewlineAtEndOfFile&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文件长度不超过1500行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;FileLength&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1500&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每行不超过120个字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;LineLength&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;150&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;TreeWalker&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 想严格对文件头进行检查，请把文件头定义在一个外部文件中，如：java_header_file.txt 然后使 用&quot;headerFile&quot;属性：</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;Header&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;headerFile&quot; value=&quot;java_header_file.txt&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;ignoreLines&quot; value=&quot;1, 5&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/module&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 忽略掉文件头的几行声明  不指定外部文件时出错，暂不使用</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;Header&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;ignoreLines&quot; value=&quot;1, 5&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/module&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ********************************javadoc的检查********************--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查Javadoc --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;JavadocStyle&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 忽略句号结尾检查 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&#x27;checkFirstSentence&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;false&#x27;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&#x27;checkEmptyJavadoc&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;true&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查所有的interface和class的doc --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;JavadocType&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 注释里允许所有注解 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&#x27;allowUnknownTags&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;true&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查所有方法的javadoc 注意方法上的@param XXX后必须跟参数说明检查才能通过 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&#x27;MissingJavadocMethod&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;allowMissingPropertyJavadoc&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;allowedAnnotations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Override,Deprecated,ApiOperation&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ignoreMethodNamesRegex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;main&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;JavadocMethod&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 变量的javadoc --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;JavadocVariable&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 忽略检查的变量名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&#x27;ignoreNamePattern&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;.*Business|.*Service|.*Handler|.*Mapper|.*Template|.*Client|.*Util.*|LOG|LOGGER&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ********************************import方面的检查*********** --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- import中避免星号&quot;*&quot; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;AvoidStarImport&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查是否从非法的包中导入了类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;IllegalImport&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查是否导入了多余的包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;RedundantImport&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--没用的import检查，比如：1.没有被用到 2.重复的 3.import java.lang的 4.import与该类在同一个package的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;UnusedImports&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ********************************命名规则检查****************** --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 包名检查 ^[a-z]+(\.[a-z][a-z0-9]*)*$ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;PackageName&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;^[a-z]+(\.[a-z][a-z0-9]*)*$&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> <span class="attr">key</span>=<span class="string">&quot;name.invalidPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;包名 &#x27;&#x27;&#123;0&#125;&#x27;&#x27; 要符合 &#x27;&#x27;&#123;1&#125;&#x27;&#x27;格式.&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 类型(Class或Interface)名  ^[A-Z][a-zA-Z0-9]*$--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;TypeName&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;severity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;warning&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> <span class="attr">key</span>=<span class="string">&quot;name.invalidPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;名称 &#x27;&#x27;&#123;0&#125;&#x27;&#x27; 要符合 &#x27;&#x27;&#123;1&#125;&#x27;&#x27;格式.&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方法名  ^[a-z][a-zA-Z0-9]*$--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;MethodName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方法的参数命名 ^[a-z][a-zA-Z0-9]*$--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ParameterName &quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 非static型变量  ^[a-z][a-zA-Z0-9]*$--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;MemberName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 常量(static , final 字段)  ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ConstantName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 局部的final变量，包括catch中的参数  ^[a-z][a-zA-Z0-9]*$ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;LocalFinalVariableName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 局部的非final型的变量，包括catch中的参数  ^[a-z][a-zA-Z0-9]*$ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;LocalVariableName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 仅仅是static型的变量（不包括staticfinal型）  ^[a-z][a-zA-Z0-9]*$ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;StaticVariableName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- **************方法的参数个数不超过5个。 并且不对构造方法和重写方法进行检查*******--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ParameterNumber&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tokens&quot;</span> <span class="attr">value</span>=<span class="string">&quot;METHOD_DEF&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ignoreOverriddenMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ************************代码行数及行代码长度限制****************** --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件长度不超过1500行，放在TreeWalker前面 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方法不超过300行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;MethodLength&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tokens&quot;</span> <span class="attr">value</span>=<span class="string">&quot;METHOD_DEF&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每行不超过120个字</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;LineLength&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;max&quot; value=&quot;150&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/module&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ****************************空格限定***************************** --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查约定方法名与左边圆括号之间不许出现空格</span></span><br><span class="line"><span class="comment">            public void wrongStyleMethod ()&#123;</span></span><br><span class="line"><span class="comment">            public void wrongStyleMethod</span></span><br><span class="line"><span class="comment">                                        (String para1, String para2)&#123;</span></span><br><span class="line"><span class="comment">            都是不能通过的，只允许方法名后紧跟左边圆括号&quot;(&quot;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;MethodParamPad&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 不允许左圆括号右边有空格，也不允许与右圆括号左边有空格</span></span><br><span class="line"><span class="comment">            public void wrongStyleMethod( String para1, String para2 )&#123;</span></span><br><span class="line"><span class="comment">            public void correctStyleMethod(String para1, String para2)&#123;</span></span><br><span class="line"><span class="comment">            都不能通过--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ParenPad&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 在类型转换时，不允许左圆括号右边有空格，也不允许与右圆括号左边有空格</span></span><br><span class="line"><span class="comment">            Object myObject = ( Object )other;</span></span><br><span class="line"><span class="comment">            不能通过--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;TypecastParenPad&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--  代码中不允许使用&quot;tab&quot;键。(&#x27;\t&#x27;) 因为在不同的编辑器下有的tab占8个空格（如windows记事</span></span><br><span class="line"><span class="comment">                  本），有的占4个（如当前大多数IDE）。</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;TabCharacter&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查在某个特定关键字之后应保留空格 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;NoWhitespaceAfter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查在某个特定关键字之前应保留空格 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;NoWhitespaceBefore&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 操作符换行策略检查 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;OperatorWrap&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查分隔符是否在空白之后 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;WhitespaceAfter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查分隔符周围是否有空白 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;WhitespaceAround&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- **********************关键字********************************** --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每个关键字都有正确的出现顺序。比如 public static final XXX 是对一个常量的声明。如果使用</span></span><br><span class="line"><span class="comment">            static public final 就是错误的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ModifierOrder&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 过滤多于的关键字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;RedundantModifier&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ***********************空白域************************************* --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不能出现空白区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;EmptyBlock&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 所有区域都要使用大括号 if(true)System.out.println(&quot;if 嵌套浓度限定&quot;);不能通过--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;NeedBraces&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 多余的括号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;AvoidNestedBlocks&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;allowInSwitchCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查左大括号位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;LeftCurly&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查右大括号位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;RightCurly&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ******************************编码方面的检查 **********************--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查空的代码段</span></span><br><span class="line"><span class="comment">            不许出现空语句</span></span><br><span class="line"><span class="comment">            int a = 0; //正常</span></span><br><span class="line"><span class="comment">            ; // 这里就是一个空的语句</span></span><br><span class="line"><span class="comment">            int b = 0; //正常</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;EmptyStatement&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果某个变量一直都没变，那么它就应该是final型的</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;FinalLocalVariable&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查在重写了equals方法后是否重写了hashCode方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;EqualsHashCode&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不允许使用switch语句</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;IllegalToken&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_SWITCH&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/module&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查switch语句是否有default --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;MissingSwitchDefault&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查局部变量或参数是否隐藏了类中的变量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;HiddenField&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tokens&quot;</span> <span class="attr">value</span>=<span class="string">&quot;VARIABLE_DEF&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内部赋值语句 ：String s = Integer.toString(i = 2); --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;InnerAssignment&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绝对不能容忍魔法数 ，即数据标识常量化</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;MagicNumber&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 循环控制变量不能被修改</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 1; i++) &#123;</span></span><br><span class="line"><span class="comment">            i++; // 这里是极可能是程序员大意写出来的。</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ModifiedControlVariable&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 多余的throw</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;RedundantThrows&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 未被简化的条件表达式 检查过度复杂的条件表达式，</span></span><br><span class="line"><span class="comment">            比如： (b == true), b || true, !false, 难读且容易出错 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;SimplifyBooleanExpression&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 未被简化的布尔返回值</span></span><br><span class="line"><span class="comment">            if (valid())&#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            就可以写成：</span></span><br><span class="line"><span class="comment">            return !valid();</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;SimplifyBooleanReturn&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- String的比较不能用!= 和 == --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;StringLiteralEquality&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 限制for循环最多嵌套2层 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;NestedForDepth&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- if最多嵌套3层 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;NestedIfDepth&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- try最多被嵌套2层 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;NestedTryDepth&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--重载方法是否在同个地方--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;OverloadMethodsDeclarationOrder&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查并确认一个类的clone()方法调用了父类的clone() --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;SuperClone&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查并确认一个类的finalize()调用了父类的finalize() --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;SuperFinalize&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不能catch java.lang.Exception,异常分类处理</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;IllegalCatch&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;illegalClassNames&quot; value=&quot;java.lang.Exception&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/module&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 确保一个类有package声明 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;PackageDeclaration&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一个方法中最多有10个return --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ReturnCount&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxForVoid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 确保某个class 在被使用时都已经被初始化成默认值(对象是null ,</span></span><br><span class="line"><span class="comment">            数字和字符是0 , boolean 变量是false.)了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ExplicitInitialization&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不许有同样内容的String</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;MultipleStringLiterals&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 同一行不能有多个声明 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;MultipleVariableDeclarations&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不必要的圆括号 检查不必要的圆括号”(,)”。比如， if(((((true))))) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;UnnecessaryParentheses&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 限制一个布尔表达式中的 &amp;&amp;, || 和^的个数。可以让代码看起来更清晰，容易排错和维护  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;BooleanExpressionComplexity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一个类中如果使用太多其他的类，是肯定会增加系统复杂度的。使用其他的类越少，耦合度就越少 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ClassDataAbstractionCoupling&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 确保函数的分支复杂度没有超出限制</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;CyclomaticComplexity&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;max&quot; value=&quot;20&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/module&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- NPATH 量度计算了一个函数的可执行的分支个数</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;NPathComplexity&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;property name=&quot;max&quot; value=&quot;20&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/module&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 类设计检查 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查只有private构造函数的类是否声明为final --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;FinalClass&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查接口是否仅定义类型</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;InterfaceIsType&quot;/&gt;</span></span><br><span class="line"><span class="comment">    	--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查类成员的可见度 检查类成员的可见性。只有static final 成员是public的除非在本检查的protectedAllowed和packagedAllowed属性中进行了设置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;VisibilityModifier&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packageAllowed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;protectedAllowed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 禁止使用System.out.println --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Regexp&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.printStackTrace&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;illegalPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Regexp&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;System.out.println&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;illegalPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ************************其他*********************************** --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查并确保所有的常量中的L都是大写的。因为小写的字母l跟数字1太象了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;UpperEll&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查数组类型的定义是String[] args，而不是String args[] --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;ArrayTypeStyle&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不许使用与代码同行的注释</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;TrailingComment&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不许存在TO DO</span></span><br><span class="line"><span class="comment">        &lt;module name=&quot;TodoComment&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 除了正常的程序入口之外，所有的main方法都应该被删掉或注释掉 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;UncommentedMain&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;excludedClasses&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.*[Application,Test]$&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 检查并确保所有的常量中的L都是大写的。也就是在常量中没有使用”l”而是用的”L”，比如long型常</span></span><br><span class="line"><span class="comment">            量，都要以”L”结尾。这与Sun编码规范 3.10.1 相一致。小写的字母l 跟数字1 太象了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;UpperEll&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件测试技术</category>
        <category>作业</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>15级样卷总结</title>
    <url>/2023/05/11/University/junior/course/Software%20testing%20technology/%E6%B5%8B%E8%AF%9515%E7%BA%A7%E6%A0%B7%E5%8D%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>2022年期末测试15级样卷总结</h1>
<h2 id="选择题">选择题</h2>
<p>1、关于软件测试原则的叙述：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>测试覆盖率和测试用例擞量成正比❌</p>
</li>
<li class="lvl-2">
<p><mark>不能</mark>实现穷举测试</p>
</li>
<li class="lvl-2">
<p>程序员不能测试自己的程序</p>
</li>
</ul>
<p>2、关于软件测试与软件开发的认识：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>软件生命周期各个阶段都可能产生错误</p>
</li>
<li class="lvl-2">
<p>软件开发的需求分析和设计阶段就应开始测试工作</p>
</li>
<li class="lvl-2">
<p>测试越早进行，越有助于提高被测软件的质量</p>
</li>
</ul>
<p>16、确认测试</p>
<p>==定义：==确认测试又称<u>有效性测试</u>。有效性测试是在模拟的环境下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。任务是验证软件的功能和性能及其他特性是否与用户的要求一致。对软件的功能和性能要求在软件需求规格说明书中已经明确规定，它包含的信息就是软件确认测试的基础。</p>
<p>确认测试的目的是向未来的用户表明系统能够像预定要求那样工作。经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是确认测试的任务，即软件的功能和性能如同用户所合理期待的那样。</p>
<p>19、什么是MCDC（修正条件逻辑判定）？</p>
<p>答：修正判定条件覆盖-----程序中的每个输入和输出都至少被调用一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次，并且每一个判定中的每一个条件必须能够独立影响一个判定的输出，即<mark>在其他条件不变的前提下仅改变这个条件的值，而使判定结果改变。</mark></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/digiproto2020/article/details/115693579">(97条消息) MCDC — 修正判定条件覆盖_每天造轮子的博客-CSDN博客_mcdc覆盖</a></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222172229891.png" alt="image-20230222172229891"></p>
<p><u><em><strong>每个条件都曾独立地对结果产生影响</strong></em></u>，相当于是每一个测试用例的布尔值相对于上一个用例来说只改变了一个：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222172446742.png" alt="image-20230222172446742"></p>
</blockquote>
<p>20、等价类划分法中有效与无效等价类个数的确认</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>输入条件规定了<mark>取值范围或值的个数</mark>的情况下，则可以确立<u><strong>一个</strong>有效等价类(在范围内)和<strong>两个</strong>无效等价类(不在范围内)</u>。</p>
<ul class="lvl-2">
<li class="lvl-4">范围：范围内（1个），范围外（2个）——<em><strong>只针对区间为[a,b]的形式</strong></em>或<u><em><strong>非负整数的形式</strong></em></u></li>
<li class="lvl-4">值的个数：等于个数（1个），小于个数、大于个数</li>
</ul>
</li>
<li class="lvl-2">
<p>在输入条件规定了输入值的集合或者<mark>规定了“必须如何”的条件</mark>的情况下，可以确立<u><strong>一个</strong>有效等价类和<strong>一个</strong>无效等价类</u>。</p>
</li>
<li class="lvl-2">
<p>在输入条件是一个<mark>布尔量</mark>的情况下，可确定<u><strong>一个</strong>有效等价类和<strong>一个</strong>无效等价类</u>。</p>
<ul class="lvl-2">
<li class="lvl-4">比如：条件：a&gt;0</li>
</ul>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>多输入的或关系</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{多输入的或关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">多输入的或关系</span></span></span></span>：在规定了<mark>输入数据的一组值</mark>(假定n个)，并且程序要对每一个输入值分别处理的情况下，可确立<u><strong>n个</strong>有效等价类和<strong>一个</strong>无效等价类。</u></p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>多输入的且关系</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{多输入的且关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">多输入的且关系</span></span></span></span>：在规定了输入数据必须遵守的规则的情况下，可确立<u><strong>一个</strong>有效等价类(符合规则)和<strong>若干个</strong>无效等价类(从不同角度违反规则)。</u></p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>细分等价类</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{细分等价类}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">细分等价类</span></span></span></span>：在确知已划分的等价类中，各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步地划分为更小的等价类。</p>
</li>
</ul>
<h2 id="填空题">填空题</h2>
<p>2、在自低向上测试中，要编写称为<u><em><strong>测试驱动模块</strong></em></u>的模块来测验正在测试的模块</p>
<blockquote>
<p>自顶向下测试中需要<mark>插桩</mark></p>
</blockquote>
<p>3、测试计划主要包括：<u><em><strong>确定测试范围、制定测试策略、安排测试资源、制定进度、评估风险和应对策略</strong></em></u></p>
<p>4、不需要修复软件缺陷的原因包括：<u><em><strong>没有时间、不能算真正的软件缺陷、风险太大、不值得修复</strong></em></u></p>
<p>6、<u><em><strong>动态白盒测试</strong></em></u>又称为结构化测试</p>
<p>8、当使用渐增方式把模块结合到程序中去时，有<u><em><strong>自顶向下</strong></em></u>和<u><em><strong>自底向上</strong></em></u>两种集成策略</p>
<p>9、<u><em><strong>性能测试</strong></em></u>就是为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在<u><em><strong>真实环境、特定负载</strong></em></u>条件下，通过<u><em><strong>工具模拟</strong></em></u>实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况</p>
<h2 id="简答题">简答题</h2>
<p>1、简述软件测试的基本原则。</p>
<blockquote>
<p>（1）不可能执行穷尽测试；（2）Zero bug 与Good Enough；（3）测试应该<mark>尽早启动</mark>，尽早介入；（4）软件测试应该<mark>追溯需求</mark>；（5）缺陷存在群集现象；（6）杀虫剂悖论（<mark>缺陷具有免疫性</mark>）；（7）<u>测试无法显示潜伏的软件缺陷</u>。</p>
</blockquote>
<p>2、 简述软件开发-软件测试的对应关系。</p>
<blockquote>
<p>软件开发过程是一个自顶向下逐步<mark>细化</mark>的过程（1分）。软件测试是一个自底向上的<mark>集成</mark>过程（1分）。对<mark>需求验证</mark>对应的<mark>验收测试</mark>，<u><strong>客户需求的确认测试</strong></u>（1分）；<mark>系统架构设计的验证</mark>对应系统的<mark>非功能性测试</mark>（1分）；产品<mark>详细设计的验证</mark>对应<mark>功能测试</mark>（1分）；<mark>代码的验证</mark>对应<mark>单元测试</mark>和<mark>集成测试</mark>（1分）。</p>
</blockquote>
<p>3、简述α测试和β测试。</p>
<blockquote>
<p>α测试由<mark>用户、测试人员、开发人员</mark>等共同参与的<mark>内部测试</mark>（3分）。β测试是<mark>内测后的公测</mark>. 即完全交给<mark>最终用户测试</mark>（3分）。</p>
</blockquote>
<p>4、介绍缺陷生命周期涉及的缺陷状态，考虑相关处理给出合理的缺陷<mark>生命周期图示</mark>。</p>
<blockquote>
<p>缺陷状态：包括新打开、已修复、已关闭等（2分）。</p>
<p>相关处理：可以考虑缺陷重新打开、是否是缺陷？是否推迟缺陷处理等方面（4分）。</p>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222111917898.png" alt="image-20230222111917898" style="zoom: 80%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026102830336.png" alt="image-20221026102830336" style="zoom: 80%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
</blockquote>
<p>5、简述<mark>性能测试</mark>的基本过程，文字描述或图示均可。</p>
<blockquote>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222113152264.png" alt="image-20230222113152264" style="zoom: 50%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218195023212.png" alt="image-20230218195023212"></th>
</tr>
</thead>
<tbody></tbody>
</table>
</blockquote>
<h2 id="设计题">设计题</h2>
<p>1、</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222160118222.png" alt="image-20230222160118222"></p>
<p>从题目中的<strong>1&lt;=c&lt;=100</strong>可知，本等价类划分应该采取的原则：输入条件规定了<mark>取值范围或值的个数</mark>的情况下，则可以确立<u><strong>一个</strong>有效等价类(在范围内)和<strong>两个</strong>无效等价类(不在范围内)</u>。而在有效等价类<strong>1&lt;=c&lt;=100</strong>中<mark>还存在细分等价类</mark>。</p>
<blockquote>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222164707548.png" alt="image-20230222164707548"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222164718768.png" alt="image-20230222164718768"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>问题3：<strong>错误推测法、判定表法、因果图法、场景设计法</strong></p>
</blockquote>
<p>2、</p>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222160139908.png" alt="image-20230222160139908"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222160146514.png" alt="image-20230222160146514"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>问题1：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222171026003.png" alt="image-20230222171026003"></p>
<p>问题2：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222171400217.png" alt="image-20230222171400217"></p>
<p>V(G)=7</p>
<p>问题3：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222171037956.png" alt="image-20230222171037956"></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件测试技术</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>09级试卷总结</title>
    <url>/2023/05/11/University/junior/course/Software%20testing%20technology/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9509%E8%AF%95%E5%8D%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>2022年期末复习09卷总结</h1>
<h2 id="选择题">选择题</h2>
<p>1、开发文档不包括<mark>维护修改建议</mark>✔️</p>
<blockquote>
<p>软件文件可分为<u><em><strong>开发文档、管理文档和用户文档</strong></em></u></p>
</blockquote>
<p>2、为降低维护的难度，可采取措施：<u>在开发过程中就采取有利于维护的措施，并加强维护管理</u></p>
<p>3、测试用例应包括：① 测试目标和被测功能 ② 测试环境和其他条件 ③ 测试数据和测试步骤</p>
<p>4、属于编码规范评测内容：</p>
<ol>
<li class="lvl-3">
<p>源程序文档化检查，包括符号名的命名、程序的注释等规范性检查</p>
</li>
<li class="lvl-3">
<p>数据说明检查，包括数据说明次序、语句中变量顺序检查</p>
</li>
<li class="lvl-3">
<p>程序结构检查，程序应采用基本的控制结构、避免不必要的转移控制等</p>
</li>
</ol>
<blockquote>
<p>软件编码规范评测围绕以下4个方面展开：<mark>源程序文档化、数据说明的方法、语句结构和输入/输出方法。</mark></p>
</blockquote>
<p>5、概要设计说明书的评测内容：</p>
<p>① 分析该软件的系统结构、子系统结构，确认该软件设计是否覆盖了所有已确定的软件需求，软件每一成分是否可追溯到某一项需求</p>
<p>③ 从软件维护的角度出发，确认该软件设计是否考虑了方便未来的维护</p>
<p>④ 是否所有界面与更高级别文档中的需求一致</p>
<blockquote>
<p><mark>概要设计说明书的评测内容如下：</mark></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>**可追溯性：**分析该软件的系统结构、子系统结构，确认该软件设计是否覆盖了所有已确定的软件需求，软件每一成分是否可追溯到某一项需求。</p>
</li>
<li class="lvl-2">
<p><strong>接口</strong>：分析软件各部分之间的联系，确认该软件的内部接口与外部接口是否已经明确定义，模块是否满足高内聚和低耦合的要求，模块作用范围是否在其控制范围之内。</p>
</li>
<li class="lvl-2">
<p>**风险：**确认该软件设计在现有技术条件下和预算范围内是否能按时实现。</p>
</li>
<li class="lvl-2">
<p>**实用性：**确认该软件设计对于需求的解决方案是否实用。</p>
</li>
<li class="lvl-2">
<p>**技术清晰度：**确认该软件设计是否以一种易于翻译成代码的形式表达。</p>
</li>
<li class="lvl-2">
<p><strong>可维护性</strong>：从软件维护的角度出发，确认该软件设计是否考虑了方便未来的维护。</p>
</li>
<li class="lvl-2">
<p>**质量：**确认该软件设计是否表现出良好的质量特征。</p>
</li>
<li class="lvl-2">
<p><strong>各种选择方案</strong>：看是否考虑过其他方案，比较各种选择方案的标准是什么。</p>
</li>
<li class="lvl-2">
<p>**限制：**评估对该软件的限制是否现实，是否与需求一致。</p>
</li>
<li class="lvl-2">
<p>**其他具体问题：**对于文档、可测试性、设计过程等进行评估。</p>
</li>
</ul>
</blockquote>
<p>6、</p>
<blockquote>
<p><mark>单元测试又称模块测试</mark>，是针对软件设计的最小单位–程序模块，进行正确性检验的测试工作。其目的在于发现各模块内部可能存在的各种差错。单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</p>
</blockquote>
<p>7、关于测试的正确描述：</p>
<p>① 测试用例应由测试设计人员来制定<br>
③ 测试工作展开于项目立项后，而不是代码开发完成之后</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>测试用例应由<mark>测试设计人员</mark>来制定。</p>
</li>
<li class="lvl-3">
<p>测试点应由<mark>测试设计人员</mark>确立。（<u><em><strong>而不是测试人员</strong></em></u>）</p>
</li>
<li class="lvl-3">
<p>测试工作展开于项目立项后，而不是代码开发完成之后。</p>
</li>
<li class="lvl-3">
<p>软件包括<mark>程序、数据和文档</mark>，所以软件测试并<mark>不仅仅是程序测试</mark>。</p>
</li>
</ol>
</blockquote>
<p>8、通常测试用例很难100 ％覆盖测试需求，因为：</p>
<p>① 输入量太大<br>
② 输出结果太多<br>
③ 软件实现途径多<br>
④测试依据没有统一标准</p>
<p>9、边界值分析法确认边界值：</p>
<p>如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。</p>
<blockquote>
<h6 id="确定边界值的原则">确定边界值的原则</h6>
<ol>
<li class="lvl-3">如果<mark>输入条件规定了值的范围</mark>，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。
<ul class="lvl-3">
<li class="lvl-5">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005112608245.png" alt="image-20221005112608245" style="zoom:50%;" />
</li>
</ul>
</li>
<li class="lvl-3">如果<mark>输入条件规定了值的个数</mark>，则用最大个数、最小个数、比最小个数少、比最大个数多 1的数作为测试数据。
<ul class="lvl-3">
<li class="lvl-5">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005112618012.png" alt="image-20221005112618012" style="zoom:50%;" />
</li>
</ul>
</li>
<li class="lvl-3">很多如果程序的规格说明给出的输入域或输出域是<mark>有序集合</mark>，则应选取集合的第一个元素和最后一个元素作为测试用例。</li>
<li class="lvl-3">如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。</li>
</ol>
</blockquote>
<p>10、语句覆盖：<mark>使程序中的每个可执行语句至少被执行一次</mark></p>
<p>11、计算圈（环路）复杂度：</p>
<blockquote>
<p>计算方法包括3种：</p>
<ul class="lvl-1">
<li class="lvl-2">V（G）＝区域数</li>
<li class="lvl-2">V（G）＝判断结点数＋1</li>
<li class="lvl-2">V（G）＝边－节点＋2</li>
</ul>
</blockquote>
<p>12、<strong>判定覆盖</strong>：使得程序中每个判断的<mark>取真分支和取假分支</mark>至少经历一次</p>
<p>13、反映web应用客户端交易处理性能的评估指标有：① 并发用户数② 交易响应时间③ 交易通过率④ 吞吐量⑤ 点击率</p>
<p>14、<u><mark>需求规格说明书</mark></u>导致软件缺陷的最大原因（因为如果需求不是客户需要的，那么这将会是最大的软件缺陷——没能满足用户的需求）</p>
<p>15、测试记录包括：</p>
<p>① 测试计划或包含测试用例的测试规格说明</p>
<p>③ 与测试用例相关的所有结果，包括在测试期间出现的所有失败</p>
<p>④ 测试中涉及的人员身份</p>
<blockquote>
<p>测试期间出现问题的<u><em>评估与分析</em></u><mark>不应该在测试记录中</mark></p>
</blockquote>
<h2 id="设计题">设计题</h2>
<p>线性独立路径：<mark>保证每行代码语句至少被执行一次</mark>（也就是说要包含程序流图中的所有的线段）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116103841143.png" alt="image-20221116103841143" style="zoom:50%;" />
<p>程序流程图：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230214171158968.png" alt="image-20230214171158968"></p>
<blockquote>
<p>线性独立路径：</p>
<p>path1:1-2-3-4-5-6-9-10-13-14</p>
<p>path2:1-2-3-4-7-8-9-11-12-13-14</p>
<p>path3:1-2-3-4-7-8-9-11-13-14</p>
</blockquote>
<h2 id="简答题">简答题</h2>
<p>1、请简述什么是压力测试和负载测试，主要区别是什么？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>负载测试是模拟实际软件系统所承受的负载条件的系统负荷</mark>，通过不断加载（如逐渐增加模拟用户的数量）或其它加载方式来观察不同负载下系统的<mark>响应时间和数据吞吐量、系统占用的资源</mark>（如CPU、内存）等，以检验系统的<mark>行为和特性</mark>，以发现系统<mark>可能存在</mark>的<mark>性能瓶颈、内存泄漏、不能实时同步</mark>等问题。负载测试更多地体现了一种方法或一种技术。</p>
</li>
<li class="lvl-2">
<p><mark>压力测试是在强负载（大数据量、大量并发用户等）下的测试</mark>，查看应用系统在<mark>峰值使用情况下</mark>的操作行为，从而有效地发现系统的<mark>某项功能隐患</mark>、系统是否具有良好的<mark>容错能力</mark>和<mark>可恢复能力</mark>。压力测试分为高负载下的长时间（如24小时以上）的<mark>稳定性压力测试</mark>和极限负载情况下导致系统崩溃的<mark>破坏性压力测试</mark>。</p>
</li>
<li class="lvl-2">
<p><mark>压力测试可以被看作是负载测试的一种</mark>，即高负载下的负载测试，或者说压力测试采用负载测试技术。通过压力测试，可以<u>更快地发现内存泄漏问题</u>，还可以<u>更快地发现影响系统稳定性的问题</u>。</p>
</li>
</ul>
<p>2、结合整个软件项目开发周期，描述软件测试在各个阶段的行为？</p>
<blockquote>
<p>利用螺旋模型，V模型、W模型、H模型、X模型和前置模型答题均可。或者利用单元测试，集成测试，确认测试和系统测试回答也给分。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>需求分析阶段：测试需求规格说明书，是否与用户要求一致</p>
</li>
<li class="lvl-2">
<p>概要设计阶段：测试概要设计说明中是否<mark>覆盖了所有已确定的需求，<mark>是否考虑了</mark>后期维护</mark></p>
</li>
<li class="lvl-2">
<p>详细设计阶段：数据结构，算法是否正确，编码规范</p>
</li>
<li class="lvl-2">
<p>编码阶段：  单元测试，集成测试</p>
</li>
<li class="lvl-2">
<p>系统验收阶段：测试系统是否完成了需求规格说明书中的所有内容</p>
</li>
</ul>
<p>3、简述LOADRUNNER作用, 描述其在实践中的基本操作步骤？</p>
<blockquote>
<p>1<br>
虚拟用户生成器用来录制操作者的操作，建立虚拟用户脚本。操作录制到自动虚拟用户脚本中，以便作为负载测试的基础。<br>
VuGen<br>
2<br>
压力控制器执行虚拟使用者脚本以产生虚拟用户，对被测系统发出请求和接收响应，模拟实际的负载。<br>
3<br>
结果分析器通过测试结果的数据，用来分析压力测试结果提供包含深入的性能分析信息的图和报告。</p>
</blockquote>
<p>a．选择协议：LOADRUNNER在录制的过程中就可以通过脚本语言将通信过程录制下来。所以只要明确了被测软件的通信过程和所使用的协议，LOADRUNNER才能正确的录制脚本。</p>
<p>b. 录制测试脚本:根据需求设定好脚本录制参数后，在VIRTUAL USER GENERATOR主窗口单击START RECORD按钮，系统就开始自动录制脚本。</p>
<p>c. 强化测试脚本: 插入事务, 插入集合点, 脚本参数化, 插入检查点等…</p>
<p>d. 设定运行场景: 设定运行策略，包括虚拟人数，虚拟组，运行时间等</p>
<p>e. 运行场景，得到报告，分析系统瓶颈，生成修改建议</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件测试技术</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>12级试卷总结</title>
    <url>/2023/05/11/University/junior/course/Software%20testing%20technology/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9512%E8%AF%95%E5%8D%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>2022年期末测试习题12级总结</h1>
<h2 id="选择题">选择题</h2>
<ol>
<li class="lvl-3">
<p>用户最关心的软件质量是<u><strong>使用质量</strong></u></p>
</li>
<li class="lvl-3">
<p>正确的软件测试阶段的排序是 <u><strong>单元测试、集成测试、系统测试、验收测试</strong></u></p>
</li>
<li class="lvl-3">
<p>白盒测试主要用于<u><strong>单元测试、集成测试</strong></u></p>
</li>
<li class="lvl-3">
<p>系统测试的工作环境是<u><strong>仿真环境</strong></u></p>
</li>
<li class="lvl-3">
<p>软件测试计划评审会需要哪些人员参加？<u><strong>项目经理 、QA 负责人 、配置负责人 、测试组</strong></u></p>
</li>
<li class="lvl-3">
<p>单元测试时必须进行的测试包括 <u><strong>接口测试、边界测试、  重要执行路径测试、局部数据结构测试、语句覆盖和分支覆盖测试、错误处理能力测试。</strong></u></p>
</li>
</ol>
<h2 id="简答题">简答题</h2>
<p>1． 软件测试的<strong>原则</strong>是什么？（10分）</p>
<ol>
<li class="lvl-3">
<p>Good Enough原则：投入与产出平衡</p>
</li>
<li class="lvl-3">
<p>Pareto（帕累托法则）原则：二八原则</p>
</li>
<li class="lvl-3">
<p>尽可能早的开展测试</p>
</li>
<li class="lvl-3">
<p>错误多的地方多投入</p>
</li>
<li class="lvl-3">
<p>同化问题：交叉测试，利用不同人的观点</p>
</li>
</ol>
<p>2． 简述一下如何进行一次<strong>性能测试</strong>，有哪些步骤，并对步骤进行简要说明？（10分）</p>
<ol>
<li class="lvl-3">
<p>制定性能测试目标、</p>
</li>
<li class="lvl-3">
<p>选择性能测试工具、</p>
</li>
<li class="lvl-3">
<p>设计性能测试、</p>
</li>
<li class="lvl-3">
<p>监控分析系统、</p>
</li>
<li class="lvl-3">
<p>性能调优。</p>
</li>
</ol>
<p>3．（等价类划分以及对应的测试用例、边界值分析以及对应的测试用例；<mark>注意作答的格式</mark>）</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222004849000.png" alt="image-20230222004849000"></p>
<p>4．绘制软件缺陷（Bug）的处理流程图</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/clip_image002.jpg" alt="img"></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218203247268.png" alt="image-20230218203247268" style="zoom:50%;" />
<blockquote>
<p>以上两图均正确</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件测试技术</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试技术笔记1</title>
    <url>/2023/05/11/University/junior/course/Software%20testing%20technology/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>软件测试技术笔记之一</h1>
<blockquote>
<ol>
<li class="lvl-3">选择</li>
<li class="lvl-3">填空</li>
<li class="lvl-3">解答</li>
<li class="lvl-3">案例分析</li>
</ol>
</blockquote>
<h2 id="绪论">绪论</h2>
<h3 id="软件测试技术-测试任务">软件测试技术——测试任务</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220919161141887.png" alt="image-20220919161141887"></p>
<h4 id="白盒测试和黑盒测试的区别包括以下几点：">白盒测试和黑盒测试的区别包括以下几点：</h4>
<h6 id="定义不同">定义不同</h6>
<p>黑盒测试：顾名思义就是把测试对象看作一个不能打开的黑盒子。测试时，测试人员完全不用考虑盒子里面的逻辑结构和具体运作，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明，检验输出结果对不对。</p>
<p>白盒测试：与黑盒恰恰相反，这种方法是把测试对象看作一个打开的透明盒子。测试时，测试人员会利用程序内部的逻辑结构及有关信息，通过在不同点检查程序状态，检验程序中的每条通路是否都能按预定要求进行正确工作。</p>
<h6 id="测试对象不同">测试对象不同</h6>
<p>黑盒测试：主要针对的是程序所展现给用户的功能。</p>
<p>白盒测试：主要针对的是程序代码逻辑，简单的说，就是前者测试最终展示功能，后者测试后台程序。</p>
<h6 id="测试方式不同">测试方式不同</h6>
<p>黑盒测试：功能测试，是通过测试来检测每个功能是否都能正常使用。</p>
<p>白盒测试：称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。</p>
<h6 id="测试目的不同">测试目的不同</h6>
<p>黑盒测试：把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。</p>
<p>白盒测试：通过检查软件内部的逻辑结构，对软件中的逻辑路径进行覆盖测试。在程序不同地方设立检查点，检查程序的状态，以确定实际运行状态与预期状态是否一致。</p>
<h6 id="测试原则不同">测试原则不同</h6>
<p>黑盒测试：以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p>
<p>白盒测试：一个模块中的所有独立路径至少被测试一次。所有逻辑值均需测试 true 和 false 两种情况。</p>
<blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220919161108477.png" alt="image-20220919161108477" style="zoom: 33%;" />
</blockquote>
<h4 id="静态测试与动态测试">静态测试与动态测试</h4>
<p>静态测试是指测试不运行的部分：只是检查和审阅,如规范测试、软件模型测试、文档测试等。动态测试是通常意义上的测试，也就是运行和使用软件。</p>
<blockquote>
<p>静态测试包括：</p>
<ol>
<li class="lvl-3">代码测试</li>
<li class="lvl-3">界面测试</li>
<li class="lvl-3">文档测试</li>
</ol>
</blockquote>
<h4 id="单元测试-集成测试以及系统测试">单元测试、集成测试以及系统测试</h4>
<h6 id="方式不同">方式不同</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>单元测试一般由开发小组采用白盒方式来测试。</p>
</li>
<li class="lvl-2">
<p>集成测试一般由开发小组采用<mark>白盒加黑盒</mark>的方式来测试。</p>
</li>
<li class="lvl-2">
<p>系统测试一般由独立测试小组采用黑盒方式来测试。</p>
</li>
</ul>
<h6 id="粒度不同">粒度不同</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>单元测试的粒度最小。</p>
</li>
<li class="lvl-2">
<p>系统测试的粒度最大。</p>
</li>
<li class="lvl-2">
<p>集成测试界于单元测试和系统测试之间，起到“桥梁作用”。</p>
</li>
</ul>
<h6 id="内容不同">内容不同</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>单元测试主要测试单元是否符合“设计”。</p>
</li>
<li class="lvl-2">
<p>集成测试既验证“设计”，又验证“需求”。</p>
</li>
<li class="lvl-2">
<p>系统测试主要测试系统是否符合“需求规格说明书”</p>
</li>
</ul>
<h4 id="alpha测试与-beta测试"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>测试与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>测试</h4>
<h6 id="测试时间不同：">测试时间不同：</h6>
<p>Beta测试是<mark>软件产品完成了功能测试和系统测试之后</mark>，在产品发布之前所进行的软件测试活动，它是<u><strong>技术测试的最后一个阶段。</strong></u></p>
<p>alpha测试简称“α测试”，可以<mark>从软件产品编码结束之时开始，或在模块(子系统)测试完成之后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度之后再开始</mark>。</p>
<h6 id="测试的目的不同：">测试的目的不同：</h6>
<p>α测试的目的是评价软件产品的FLURPS（即功能、局域化、可用性、可靠性、性能和支持）。尤其注重产品的界面和特色。α测试即为非正式验收测试。</p>
<p>Beta测试是一种验收测试，通过了验收测试，产品就会进入发布阶段。</p>
<h6 id="测试人员及场所不同：">测试人员及场所不同：</h6>
<p>α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，α测试不能由程序员或测试员完成。α测试发现的错误，可以在测试现场立刻反馈给开发人员，由开发人员及时分析和处理。</p>
<p>Beta测试由软件的最终用户们在一个或多个客户场所进行。开发者通常不在Beta测试的现场，因Beta测试是软件在开发者不能控制的环境中的“真实”应用。</p>
<h4 id="回归测试-冒烟测试和随机测试">回归测试、冒烟测试和随机测试</h4>
<p>回归测试：</p>
<p>对软件的新版本测试时，重复执行上一个版本测试时的用例。回归测试可以在任何测试阶段进行，既有黑盒测试的回归，也有白盒测试的回归。</p>
<p>冒烟测试：</p>
<p>对新版本<mark>进行系统大规模的测试之前</mark>，先验证一下软件的基本功能是否实现，是否具备可测性</p>
<p>随机测试：</p>
<p>随机测试是指所有的输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性错误。</p>
<h3 id="软件测试过程模型">软件测试过程模型</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>V模型</p>
</li>
<li class="lvl-2">
<p>W模型</p>
</li>
<li class="lvl-2">
<p>X模型</p>
</li>
<li class="lvl-2">
<p>H模型</p>
</li>
</ul>
<h4 id="软件的生命周期">软件的生命周期</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921110105722.png" alt="image-20220921110105722" style="zoom: 80%;" />
<h5 id="v模型">V模型</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921105920976.png" alt="image-20220921105920976" style="zoom:50%;" />
<blockquote>
<p><mark>先开发，后测试</mark></p>
<p><u><em><strong>软件开发与软件测试的关系？（用V模型回答即可）</strong></em></u></p>
</blockquote>
<h5 id="w模型">W模型</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921110532865.png" alt="image-20220921110532865" style="zoom: 50%;" />
<blockquote>
<p>边开发，边测试<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>测试与开发同步进行</p>
<p>W模型：两个V字型模型</p>
<p><u><em><strong>软件开发与软件测试的关系？（用W模型回答即可）</strong></em></u></p>
</blockquote>
<h5 id="x模型">X模型</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921111549903.png" alt="image-20220921111549903" style="zoom:50%;" />
<h5 id="h模型">H模型</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921111523013.png" alt="image-20220921111523013" style="zoom:50%;" />
<h4 id="作业："><mark>作业：</mark></h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921114127385.png" alt="image-20220921114127385"></p>
<blockquote>
<p>对矿泉水瓶这个产品进行相应的测试？从哪些方面考虑。</p>
<ol>
<li class="lvl-3">外观方面：水瓶的高度、底座，水瓶上的字体颜色大小是否合适等等；</li>
<li class="lvl-3">功能方面：水瓶是否能够装水不漏、能不能够让人喝到水、瓶盖拧紧不漏的时候能不能让人拧开；</li>
<li class="lvl-3">性能方面：抗压、抗摔、抗高温、抗低温；</li>
<li class="lvl-3">安全方面：物理方面：瓶子是否有凸起刺手的地方，瓶口是否光滑；化学方面就是会不会产生有毒物质；</li>
<li class="lvl-3">易用性方面：水瓶的信息是否全面（保质期、生产日期、厂商等等），方不方便携带（手拿、放包里）；</li>
<li class="lvl-3">兼容性方面：装其他液体会不会产生有毒物质、能不能装固体。</li>
</ol>
<p>参考：<a href="https://blog.csdn.net/qq_41907993/article/details/108116028">(77条消息) 软件测试笔记——如何测试一个矿泉水瓶？_努力小c的博客-CSDN博客_如何测试一个水瓶</a></p>
</blockquote>
<p>测试的四个阶段：</p>
<ol>
<li class="lvl-3">
<p>单元测试</p>
</li>
<li class="lvl-3">
<p>集成测试</p>
</li>
<li class="lvl-3">
<p>系统测试</p>
</li>
<li class="lvl-3">
<p>验收测试</p>
</li>
</ol>
<p>测试考虑的方面：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>界面友好性测试<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>矿泉水瓶是否有好看的样式</p>
</li>
<li class="lvl-2">
<p>功能测试<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>矿泉水瓶是否能够分装矿泉水不漏、矿泉水瓶是否耐用（一般指水瓶塑料质量）、矿泉水瓶瓶盖和瓶身是否匹配</p>
</li>
<li class="lvl-2">
<p>易用性测试<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>水瓶是否设计合理，符合人体工学方便手拿</p>
</li>
<li class="lvl-2">
<p>常规性测试</p>
</li>
<li class="lvl-2">
<p>兼容性测试<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>高温下能不能保持、装其它液体并较好地保存</p>
</li>
</ul>
<h3 id="测试需求分析">测试需求分析</h3>
<ol>
<li class="lvl-3">
<p>测试需求是什么？</p>
<ol>
<li class="lvl-6">
<p>测试需求主要解决“测什么”的问题</p>
</li>
<li class="lvl-6">
<p>测试需求应全部覆盖已定义的业务流程</p>
</li>
<li class="lvl-6">
<blockquote>
<p>测试目标不等于质量目标，质量水平测试目标体现测试价值该项目的测试边界哪些东西要测试</p>
</blockquote>
</li>
</ol>
</li>
<li class="lvl-3">
<p>为什么需要软件测试需求？</p>
<ol>
<li class="lvl-6">软件测试需求是设计测试用例的依据</li>
<li class="lvl-6">有助于保证测试的质量和进度</li>
<li class="lvl-6">软件测试需求是衡量测试覆盖率的重要指标</li>
</ol>
</li>
<li class="lvl-3">
<p>如何进行软件测试需求？</p>
<p>测试需求分析的主要目的：依据需求文档提取测试点，根据测试点来编写测试用例</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>测试点分析</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{测试点分析}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">测试点分析</span></span></span></span>：</p>
<ol>
<li class="lvl-8">通过分析需求描述中的输入、输出、处理、限制、约束等，给出对应的验证内容（功能测试）</li>
<li class="lvl-8">通过分析各个功能模块之间的业务顺序，和各个功能模块之间传递的信息和数据，对存在功能交互的功能项，给出对应的验证内容；（功能交互测试）</li>
<li class="lvl-8">考虑到需求的完整性，要充分覆盖软件需求的各种特征，包含隐形需求的验证，比如界面的验证，注册账号的唯一性验证（界面、易用性、安全性、性能压力）</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="测试需求分析过程">测试需求分析过程</h4>
<ol>
<li class="lvl-3">
<p>了解项目的背景、产品价值，解决什么业务问题→分析业务需求，确定测试目标</p>
</li>
<li class="lvl-3">
<p>了解用户是谁，用户所关心的问题→分析用户需求</p>
</li>
<li class="lvl-3">
<p>确定待测软件的功能特性，可以从整体到局部，从上到下，逐层分解，形成待测试的功能列表</p>
</li>
<li class="lvl-3">
<p>确定待测软件的非功能特性，基于本系统的特点而需特别关注的质量属性</p>
</li>
<li class="lvl-3">
<p>确定测试项的优先级</p>
</li>
</ol>
<p><mark>作业</mark>：软件测试计划书在第一次实验之前完成（小组）</p>
<h3 id="软件测试计划">软件测试计划</h3>
<h4 id="测试用例">测试用例</h4>
<p>定义：测试用例=<mark>输入</mark>（<strong>测试步骤和操作步骤</strong>）+<mark>输出</mark>（<strong>期望结果</strong>）+ <mark>测试环境</mark>（<strong>系统环境设置</strong>）</p>
<h3 id="黑盒测试">黑盒测试</h3>
<p>基本概念：黑盒测试是从用户观点出发的测试，其目的是<mark>尽可能发现软件的外部行为错误</mark>。⭐️</p>
<h5 id="黑盒测试用例设计方法">黑盒测试用例设计方法</h5>
<ol>
<li class="lvl-3">
<p>等价类划分法</p>
</li>
<li class="lvl-3">
<p>边界值分析法</p>
</li>
<li class="lvl-3">
<p>因果图法</p>
</li>
<li class="lvl-3">
<p>判定表法</p>
</li>
<li class="lvl-3">
<p>正交分解法</p>
</li>
<li class="lvl-3">
<p>基本路径分析法</p>
</li>
<li class="lvl-3">
<p>场景设计法</p>
</li>
<li class="lvl-3">
<p>错误推测法</p>
</li>
</ol>
<h6 id="等价类划分法">等价类划分法</h6>
<p>把所有可能的输入数据，即程序输入域划分为若干个 互不相交的子集，称为等价类，然后从每个等价类中 选取少数具有代表性的数据作为测试用例，进行测试。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在分析需求规格说明的基础上划分等价类，列出等价类表。</p>
</li>
<li class="lvl-2">
<p>等价类是某个输入域的子集，在该子集中每个输入数据的作用是等效的。</p>
</li>
<li class="lvl-2">
<p>分为<strong>有效等价类</strong>和<strong>无效等价类</strong>。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005102215984.png" alt="image-20221005102215984" style="zoom:50%;" />
<h6 id="确定等价类的原则">确定等价类的原则</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>输入条件规定了<mark>取值范围或值的个数</mark>的情况下，则可以确立<u><strong>一个</strong>有效等价类(在范围内)和<strong>两个</strong>无效等价类(不在范围内)</u>。</p>
</li>
<li class="lvl-2">
<p>在输入条件规定了输入值的集合或者<mark>规定了“必须如何”的条件</mark>的情况下，可以确立<u><strong>一个</strong>有效等价类和<strong>一个</strong>无效等价类</u>。</p>
</li>
<li class="lvl-2">
<p>在输入条件是一个<mark>布尔量</mark>的情况下，可确定<u><strong>一个</strong>有效等价类和<strong>一个</strong>无效等价类</u>。</p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>多输入的或关系</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{多输入的或关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">多输入的或关系</span></span></span></span>：在规定了<mark>输入数据的一组值</mark>(假定n个)，并且程序要对每一个输入值分别处理的情况下，可确立<u><strong>n个</strong>有效等价类和<strong>一个</strong>无效等价类。</u></p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>多输入的且关系</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{多输入的且关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">多输入的且关系</span></span></span></span>：在规定了输入数据必须遵守的规则的情况下，可确立<u><strong>一个</strong>有效等价类(符合规则)和<strong>若干个</strong>无效等价类(从不同角度违反规则)。</u></p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>细分等价类</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{细分等价类}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">细分等价类</span></span></span></span>：在确知已划分的等价类中，各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步地划分为更小的等价类。</p>
</li>
</ul>
<h6 id="确定测试用例">确定测试用例</h6>
<p>(a) 建立等价类表，列出所有划分出的等价类：</p>
<p>(b) 为每个等价类规定一个唯一的编号；</p>
<p>© <u>设计一个新的测试用例，使其<mark>尽可能多地覆盖尚未覆盖的有效等价类</mark></u>；⭐️</p>
<p>(d) 重复©，最后使得所有有效等价类均被测试用例所覆盖；</p>
<p>(e) <u>设计一个新的测试用例，使其<mark>只覆盖一个无效等价类</mark></u>；⭐️</p>
<p>(f) 重复e)使所有无效等价类均被覆盖。</p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005105851336.png" alt="image-20221005105851336"></p>
<p>例如：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005105822624.png" alt="image-20221005105822624" style="zoom:50%;" />
<p>是否是等腰三角形的无效等价类？怎么写？</p>
<p>首先写满足三角形的基本条件，然后是三条边都不相等。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span>b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span>c</p>
<p>等边三角形的无效等价类？</p>
<p>同样是必须先满足三角形的基本条件，然后是三条边两两互不相等，总共可以写出三条无效等价类。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span>b或b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span>c或a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span>c</p>
</blockquote>
<h6 id="边界值分析法">边界值分析法</h6>
<p>在等价类划分基础上进行边界值分析测试的基本思想是， 选取正好等于、刚刚大于或刚刚小于等价类边界的值作 为测试数据，而不是选取等价类中的典型值或任意值做 为测试数据。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>边界值分析法是一种很实用的黑盒测试用例方法，它具有很强的发现故障的能力。</p>
</li>
<li class="lvl-2">
<p>很多错误发生在输入或输出范围的边界上，因此针对各种边界情况设置测试用例， 可以更有效地发现缺陷。</p>
</li>
<li class="lvl-2">
<p>边界条件就是软件计划的操作界限所在的边缘条件。</p>
</li>
</ul>
<h6 id="实例：">-<mark>实例：</mark></h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222163409694.png" alt="image-20230222163409694"></p>
<blockquote>
<p><mark>答题规范：</mark></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222192045017.png" alt="image-20230222192045017"></p>
</blockquote>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>边界</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{边界}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">边界</span></span></span></span>是指相当于输入等价类和输出等价类而言，稍高于边界值及稍低于其边界值的一些特定情况。<br>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222163533267.png" alt="image-20230222163533267"></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005111521366.png" alt="image-20221005111521366" style="zoom: 50%;" />
<p><mark>对于一个n变量的程序，边界值分析测试会产生4n+1个测试用例。</mark>（<mark>不考虑区域外</mark>的无效等价类）</p>
<h6 id="健壮性边界测试">健壮性边界测试</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>健壮性测试是边界值分析的一种扩展</p>
</li>
<li class="lvl-2">
<p>变量除了取min，min＋，nom， max－，max五个边界值外， 还要考虑采用一个略超过最大值（max+）以及一个略小于最 小值 (min-) 的取值</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005111821818.png" alt="image-20221005111821818" style="zoom:50%;" />
<p><mark>对于一个n变量的程序，健壮性边界值测试将产生6n+1个测试用例</mark>（<mark>考虑区域外</mark>的无效等价类）</p>
<p>健壮性测试最有意义的部分不是输入，而是预期的输出，观察例外情况如何处理。</p>
<h6 id="确定边界值的原则">确定边界值的原则</h6>
<ol>
<li class="lvl-3">
<p>如果<mark>输入条件规定了值的范围</mark>，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。</p>
<ul class="lvl-2">
<li class="lvl-5">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005112608245.png" alt="image-20221005112608245" style="zoom:50%;" />
</li>
</ul>
</li>
<li class="lvl-3">
<p>如果<mark>输入条件规定了值的个数</mark>，则用最大个数、最小个数、比最小个数少、比最大个数多 1的数作为测试数据。</p>
<ul class="lvl-2">
<li class="lvl-5">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005112618012.png" alt="image-20221005112618012" style="zoom:50%;" />
</li>
</ul>
</li>
<li class="lvl-3">
<p>很多如果程序的规格说明给出的输入域或输出域是<mark>有序集合</mark>，则应选取集合的第一个元素和最后一个元素作为测试用例。</p>
</li>
<li class="lvl-3">
<p>如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。</p>
</li>
</ol>
<h5 id="textcolor-red-题目-：等价类划分"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>题目</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{题目}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">题目</span></span></span></span>：等价类划分</h5>
<p>条件规定了<mark>取值范围或值的个数</mark>的情况下（1个有效，2个无效）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005113228451.png" alt="image-20221005113228451" style="zoom:50%;" />
<blockquote>
<p><mark><strong>等价类划分题目的正确回答形式：</strong></mark></p>
<ol>
<li class="lvl-3">
<p>等价类划分——格式：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218195522914.png" alt="image-20230218195522914"></p>
</li>
<li class="lvl-3">
<p>测试用例设计——格式：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218200237385.png" alt="image-20230218200237385"></p>
</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>有效等价类</td>
<td>1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span>p<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span>20</td>
<td></td>
</tr>
<tr>
<td></td>
<td>第一个有效等价类细分</td>
<td>p=20</td>
<td></td>
</tr>
<tr>
<td></td>
<td>……</td>
<td>15&lt;p&lt;20</td>
<td></td>
</tr>
<tr>
<td></td>
<td>……</td>
<td>p=15</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>10&lt;p&lt;15</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>p=10</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>5&lt;p&lt;10</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>p=5</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1&lt;p&lt;5</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>无效等价类</td>
<td>p&lt;1</td>
<td>N/A</td>
</tr>
<tr>
<td>3</td>
<td>无效等价类</td>
<td>p&gt;20</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<blockquote>
<p>16组边界测试</p>
</blockquote>
<h5 id="基于组合技术和组合优化的方法">基于组合技术和组合优化的方法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>判定表/决策表方法</p>
</li>
<li class="lvl-2">
<p>因果图</p>
</li>
<li class="lvl-2">
<p>两两组合方法</p>
</li>
<li class="lvl-2">
<p>正交实验法</p>
</li>
</ul>
<h6 id="判定表">判定表</h6>
<blockquote>
<p><u>在所有的黑盒测试方法中，基于判定表的测试是<mark>最严格</mark>，<mark>最具有逻辑性</mark>的测试方法。</u></p>
</blockquote>
<p>定义：判定表是把作为条件的所有输入的各种组合值以及对应输出值都罗列出来而形成的表格。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012101501775.png" alt="image-20221012101501775" style="zoom:50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p>条件桩</p>
</li>
<li class="lvl-3">
<p>条件项</p>
</li>
<li class="lvl-3">
<p>动作桩</p>
</li>
<li class="lvl-3">
<p>动作项</p>
</li>
</ol>
</blockquote>
<p>判定表的特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>条件的顺序无关</p>
</li>
<li class="lvl-2">
<p>操作/活动的顺序无关</p>
</li>
<li class="lvl-2">
<p>规则间的无关联</p>
</li>
</ul>
<h6 id="判定表方法步骤">判定表方法步骤</h6>
<ol>
<li class="lvl-3">
<p>列出条件桩</p>
</li>
<li class="lvl-3">
<p>列出动作桩</p>
</li>
<li class="lvl-3">
<p>填入条件项及其组合</p>
</li>
<li class="lvl-3">
<p>填入动作项，制定初始判定表</p>
</li>
<li class="lvl-3">
<p>简化、合并相似规则或者相同动作</p>
</li>
</ol>
<h6 id="判定表实例">判定表实例</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221102101230013.png" alt="image-20221102101230013" style="zoom: 33%;" />
<h6 id="因果图">因果图</h6>
<p>多种输入条件的组合，输入之间有关系，例如，约束关系、组合关系，需要进行因果分析，不可直接采用判定表方法。</p>
<h6 id="因果图基本符号"><mark>因果图基本符号</mark><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012103438292.png" alt="image-20221012103438292"></h6>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>互斥 E：a、b、c <mark>只能有一个成立</mark>，但是可以都不成立。</p>
</li>
<li class="lvl-2">
<p>包含 I：a、b、c 中<mark>至少有一个成立</mark>。可以多选但不能不选。</p>
</li>
<li class="lvl-2">
<p>唯一 O：a、b、c 有且仅有一个为 1。也就是说多个原因中有且只有一个成立。</p>
</li>
<li class="lvl-2">
<p>要求 R：如果 a 成立，则要求 b 必须也成立，其他的不做约束。一个出现，另一个也一定出现</p>
</li>
<li class="lvl-2">
<p>强制屏蔽 M：对于结果的约束。当 a = 1 时，要求 b 必须为0，其他的不约束。a 不成立时，b 的值不一定。唯一和互斥的区别是：唯一必须选一个；互斥可以不选，如果选只能选一个，几个原因中有且只有一个成立。</p>
</li>
</ul>
</blockquote>
<h6 id="因果图的基本流程：">因果图的基本流程：</h6>
<blockquote>
<p>1.<mark>分析</mark>软件规格说明文档描述的<mark>哪些是原因（输入条件），哪些是结果（输出条件）</mark>。原因常是输入条件或输入条件的等价类，结果是输出条件；<br>
2.分析程序规格说明的描述中的语义内容，将其表示成<mark>连接各个原因与各个结果的“因果图”</mark>；<br>
3.<mark>标明约束条件</mark>。在因果图上标上哪些不可能发生的因果关系，表明约束或限制条件；<br>
5.把<mark>判定表的每一列作为依据设计测试用例</mark>。（因果图导出判定表）</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>题目之一</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{题目之一}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">题目之一</span></span></span></span>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012103512102.png" alt="image-20221012103512102" style="zoom:50%;" />
<blockquote>
<p>因果图：<mark>帮助生成决策表</mark></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012103650938.png" alt="image-20221012103650938" style="zoom: 33%;" />
<p>决策表</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012103733794.png" alt="image-20221012103733794"></p>
<p><u><em><strong>中间结点：一般用于抽离多个输入的共性</strong></em></u></p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>题目之二</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{题目之二}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">题目之二</span></span></span></span>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012103948725.png" alt="image-20221012103948725" style="zoom:50%;" />
<blockquote>
<p>首先找出输入条件（原因）和输出条件（结果）：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012104553998.png" alt="image-20221012104553998" style="zoom:50%;" />
<p>得到因果图：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012105836977.png" alt="image-20221012105836977"></p>
<table>
<thead>
<tr>
<th>原因：1</th>
<th>1</th>
<th>1</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>11：不属于1~4</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>21：不移动</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
</tbody>
</table>
<p>（11）=（1）（2）（3）（~4）</p>
<p>（21）=（~ 1）+（~ 2）+（~ 3）+（4）</p>
<p>最后得到决策表：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012111030509.png" alt="image-20221012111030509"></p>
</blockquote>
<h5 id="因果图回溯">因果图回溯</h5>
<h6 id="建立有限项的判定表"><mark>建立有限项的判定表</mark></h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>选择一个结果作为当前状态</p>
</li>
<li class="lvl-2">
<p>对因果图进行回溯，查找导致<code>该果为1</code>的所有因的组合</p>
</li>
<li class="lvl-2">
<p>在判定表中为每个因的组合生成一列</p>
</li>
<li class="lvl-2">
<p>对于每种“因”的组合，判断所有其他“果”的状态，并放置在每一列中。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017145707560.png" alt="image-20221017145707560" style="zoom:50%;" />
<h6 id="回溯一个or-结点-x-a-b-c-并关系">回溯一个or 结点（x=a + b + c，并关系）</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017145937514.png" alt="image-20221017145937514"></p>
<blockquote>
<p>个人理解：</p>
<p><code>x=a+b</code>：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>x=1时，不考虑a=b=1的情况，其它情况都考虑(10,01)；</p>
</li>
<li class="lvl-2">
<p>x=0时，考虑导致结果为0的<u>所有组合</u>：</p>
<ul class="lvl-3">
<li class="lvl-4">考虑a=b=0的所有情况；</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="回溯一个and-结点-x-a-b-c-交关系">回溯一个and 结点，（x=a * b * c, 交关系）</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017165536197.png" alt="image-20221017165536197"></p>
<blockquote>
<p>个人理解：</p>
<p><code>x=a*b*c</code>：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>x=1时，考虑a=b=c=1的所有情况；</p>
</li>
<li class="lvl-2">
<p>x=0时，考虑导致结果为0的<u>所有组合</u>：</p>
<ul class="lvl-3">
<li class="lvl-4">对a=b=c=0只考虑1种；</li>
<li class="lvl-4">abc(001,010,011…)取值中存在至少一个1时：
<ul class="lvl-5">
<li class="lvl-6">为1的只考虑1种</li>
<li class="lvl-6">取0的考虑所有组合：
<ul class="lvl-7">
<li class="lvl-8">根据交或并运算循环套用规则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="因果突发示例：">因果突发示例：</h5>
<p>1️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012113110208.png" alt="image-20221012113110208" style="zoom:50%;" />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">回溯：</span><br><span class="line">(<span class="number">1</span>+<span class="number">2</span>)*(<span class="number">3</span>*<span class="number">4</span>)=x=<span class="number">0</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">-7</span>=<span class="number">1</span>时，除了<span class="number">1</span>、<span class="number">2</span>外全为<span class="number">1</span>，且<span class="number">12</span>可取<span class="number">11</span>、<span class="number">10</span>、<span class="number">01</span></span><br><span class="line">因此输出为x=<span class="number">1</span>的情况就只有三种，因此最后x=<span class="number">0</span>的结果就只有<span class="number">13</span>组</span><br><span class="line"><span class="number">13</span>组</span><br><span class="line">(x)=(<span class="number">5</span>)*(<span class="number">6</span>)=<span class="number">0</span></span><br><span class="line">set x=<span class="number">0</span>,</span><br><span class="line">so <span class="number">5</span>=<span class="number">0</span>,<span class="number">6</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="number">5</span>=<span class="number">1</span>,<span class="number">6</span>=<span class="number">0</span> <span class="keyword">or</span> <span class="number">5</span>=<span class="number">0</span>,<span class="number">6</span>=<span class="number">0</span></span><br><span class="line"><span class="number">5</span>=<span class="number">0</span>,<span class="number">6</span>=<span class="number">1</span>:(<span class="number">5</span>=<span class="number">0</span>考虑所有情况,<span class="number">6</span>=<span class="number">1</span>只考虑一种)</span><br><span class="line">	<span class="number">1</span>=<span class="number">0</span>,<span class="number">2</span>=<span class="number">0</span>;</span><br><span class="line">	<span class="number">3</span>=<span class="number">1</span>,<span class="number">4</span>=<span class="number">1</span></span><br><span class="line">    <span class="number">1</span>种</span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>,<span class="number">6</span>=<span class="number">0</span>:(<span class="number">5</span>=<span class="number">1</span>只考虑一种,<span class="number">6</span>=<span class="number">0</span>考虑所有情况)</span><br><span class="line">	<span class="number">3</span>=<span class="number">4</span>=<span class="number">0</span> <span class="keyword">or</span> <span class="number">3</span>=<span class="number">0</span>,<span class="number">4</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="number">3</span>=<span class="number">1</span>,<span class="number">4</span>=<span class="number">0</span></span><br><span class="line">    <span class="number">3</span>种</span><br><span class="line"><span class="number">5</span>=<span class="number">0</span>,<span class="number">6</span>=<span class="number">0</span>:(<span class="number">5</span>=<span class="number">6</span>=<span class="number">0</span>只考虑一种)</span><br><span class="line">    <span class="number">1</span>=<span class="number">0</span>,<span class="number">2</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="number">3</span>=<span class="number">4</span>=<span class="number">0</span></span><br><span class="line">    <span class="number">1</span>种</span><br><span class="line">最后保留<span class="number">5</span>种</span><br></pre></td></tr></table></figure>
<p>2️⃣找出(91) = 1的输入？</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017141743361.png" alt="image-20221017141743361" style="zoom:50%;" />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">91</span>)=~(<span class="number">36</span>)</span><br><span class="line">    =~(<span class="number">32</span>*<span class="number">35</span>)</span><br><span class="line">    =~((~<span class="number">1</span>+<span class="number">31</span>)*(<span class="number">5</span>+<span class="number">8</span>+<span class="number">33</span>+<span class="number">34</span>))</span><br><span class="line">    =~((~<span class="number">1</span>+<span class="number">2</span>*<span class="number">3</span>)*(<span class="number">5</span>+<span class="number">8</span>+(<span class="number">6</span>*<span class="number">9</span>*<span class="number">10</span>)+(<span class="number">7</span>*<span class="number">13</span>*<span class="number">14</span>)))</span><br><span class="line">    =<span class="number">1</span></span><br><span class="line"><span class="number">36</span>=<span class="number">0</span> set <span class="number">32</span>=<span class="number">0</span> <span class="keyword">or</span> <span class="number">35</span>=<span class="number">0</span></span><br><span class="line">    <span class="number">32</span>=<span class="number">0</span>,<span class="number">35</span>=<span class="number">0</span>时：</span><br><span class="line">    <span class="number">1</span>=<span class="number">1</span>,<span class="number">31</span>=<span class="number">0</span>;<span class="number">5</span>=<span class="number">8</span>=<span class="number">33</span>=<span class="number">34</span>=<span class="number">0</span></span><br><span class="line">    <span class="number">1</span>种</span><br><span class="line">    <span class="number">32</span>=<span class="number">0</span>,<span class="number">35</span>=<span class="number">1</span>时：</span><br><span class="line">    <span class="number">1</span>=<span class="number">1</span>,<span class="number">31</span>=<span class="number">0</span>;<span class="number">5</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="number">8</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="number">33</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="number">34</span>=<span class="number">1</span></span><br><span class="line">    。。。直接算很难求，需要结合下面的约束关系图进行问题的简化</span><br><span class="line">        </span><br><span class="line">    存在约束：</span><br><span class="line">    （aRb:a=<span class="number">1</span>,则b=<span class="number">1</span>；a=<span class="number">0</span>，则b不定）(<span class="built_in">E</span>(<span class="number">6</span>,<span class="number">7</span>)表示<span class="number">6</span>和<span class="number">7</span>至多出现一个<span class="number">1</span>)</span><br><span class="line">    <span class="number">9</span>R6</span><br><span class="line">    <span class="number">10</span>R6</span><br><span class="line">    <span class="number">13</span>R7</span><br><span class="line">    <span class="number">14</span>R7</span><br><span class="line">    <span class="built_in">E</span>(<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    由以上条件可以知道</span><br><span class="line">    must <span class="number">36</span>=<span class="number">0</span>(consider all):</span><br><span class="line">		<span class="number">32</span>=<span class="number">0</span>,<span class="number">35</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="number">32</span>=<span class="number">1</span>,<span class="number">35</span>=<span class="number">0</span> <span class="keyword">or</span> <span class="number">32</span>=<span class="number">0</span>,<span class="number">35</span>=<span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="number">32</span>=<span class="number">0</span>(all),<span class="number">35</span>=<span class="number">1</span>(only one):</span><br><span class="line">			<span class="comment">//32=0(all)</span></span><br><span class="line">			<span class="number">1</span>=<span class="number">1</span>(one),<span class="number">31</span>=<span class="number">0</span>(all):</span><br><span class="line">				<span class="number">2</span>,<span class="number">3</span>出现一个<span class="number">0</span>既满足:<span class="number">3</span> kinds      </span><br><span class="line">            </span><br><span class="line">        <span class="number">32</span>=<span class="number">1</span>(one),<span class="number">35</span>=<span class="number">0</span>(all):</span><br><span class="line">			<span class="comment">//35=0(all)</span></span><br><span class="line">            <span class="number">5</span>=<span class="number">0</span>,<span class="number">8</span>=<span class="number">0</span>,<span class="number">33</span>=<span class="number">0</span>(all),<span class="number">34</span>=<span class="number">0</span>(all):(根据并规则，考虑满足的所有情况)</span><br><span class="line">				<span class="comment">//33=0(all)-注意约束条件</span></span><br><span class="line">        		<span class="number">6</span>=<span class="number">1</span>,<span class="number">9</span>=<span class="number">1</span>,<span class="number">10</span>=<span class="number">0</span>;</span><br><span class="line">                <span class="number">6</span>=<span class="number">1</span>,<span class="number">9</span>=<span class="number">0</span>,<span class="number">10</span>=<span class="number">1</span>;</span><br><span class="line">				<span class="number">6</span>=<span class="number">1</span>,<span class="number">9</span>=<span class="number">0</span>,<span class="number">10</span>=<span class="number">0</span>;</span><br><span class="line">				<span class="number">6</span>=<span class="number">0</span>,<span class="number">9</span>=<span class="number">0</span>,<span class="number">10</span>=<span class="number">0</span>;</span><br><span class="line">        		<span class="comment">//34=0(all)-注意约束条件</span></span><br><span class="line">				<span class="number">7</span>=<span class="number">1</span>,<span class="number">13</span>=<span class="number">1</span>,<span class="number">14</span>=<span class="number">0</span>;</span><br><span class="line">                <span class="number">7</span>=<span class="number">1</span>,<span class="number">13</span>=<span class="number">0</span>,<span class="number">14</span>=<span class="number">1</span>;</span><br><span class="line">				<span class="number">7</span>=<span class="number">1</span>,<span class="number">13</span>=<span class="number">0</span>,<span class="number">14</span>=<span class="number">0</span>;</span><br><span class="line">				<span class="number">7</span>=<span class="number">0</span>,<span class="number">13</span>=<span class="number">0</span>,<span class="number">14</span>=<span class="number">0</span>;</span><br><span class="line">				<span class="comment">//注意E(5,6,7,8)：5,6,7,8至多有一个1</span></span><br><span class="line">				so:<span class="number">7</span> kinds</span><br><span class="line">                    <span class="number">6</span>=<span class="number">1</span>,<span class="number">7</span>=<span class="number">0</span> <span class="number">3</span> kinds</span><br><span class="line">                    <span class="number">7</span>=<span class="number">1</span>,<span class="number">6</span>=<span class="number">0</span> <span class="number">3</span> kinds</span><br><span class="line">                    <span class="number">6</span>=<span class="number">0</span>,<span class="number">7</span>=<span class="number">0</span> <span class="number">1</span> kinds</span><br><span class="line">        <span class="number">32</span>=<span class="number">0</span>,<span class="number">35</span>=<span class="number">0</span>:(只考虑一种)</span><br><span class="line">			so:<span class="number">1</span> kinds</span><br></pre></td></tr></table></figure>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017143058355.png" alt="image-20221017143058355" style="zoom:50%;" />
<h5 id="为什么需要组合覆盖和正交试验法？">为什么需要组合覆盖和正交试验法？</h5>
<h6 id="新需求">新需求</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>多因素组合</p>
</li>
<li class="lvl-2">
<p>传统测试方法的大工作量</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017150328405.png" alt="image-20221017150328405" style="zoom:50%;" />
<blockquote>
<p>决策表存在不足</p>
</blockquote>
<h4 id="两两组合测试">两两组合测试</h4>
<blockquote>
<p>所有测试数据两两配对，<mark>每一对数据至少出现一次</mark>，两两组合测试也称结对测试(Pairwise Testing)。大部分缺陷是在进行两个变量取值冲突的测试时被发现的，不仅仅是在所有的组合情况下才会被发现，所以不用测试所有的组合，在一定的时间、一定的人力条件下测试所有的两两组合即可。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017150734564.png" alt="image-20221017150734564" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>大部分缺陷是在两个变量取值冲突的测试时被发现的</p>
</li>
<li class="lvl-2">
<p>构造测试用例需要涵盖每个因素的所有状态，并且涵盖每2个因素之间的所有交互。</p>
</li>
<li class="lvl-2">
<p>不仅仅是在所有的组合情况下才会发现所有的测试缺陷</p>
</li>
<li class="lvl-2">
<p>没有必要构造覆盖所有因素的所有组合的测试用例集合，只需要构造覆盖每个因素的所有状态，覆盖任意2个因素所有状态的测试用例集合。</p>
</li>
</ul>
<h4 id="组合覆盖法">组合覆盖法</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017151202031.png" alt="image-20221017151202031" style="zoom:50%;" />
<blockquote>
<p>成对覆盖：</p>
<ul class="lvl-1">
<li class="lvl-2">要求任意两个因素的所有水平组合要被覆盖一次</li>
</ul>
</blockquote>
<h5 id="作业："><mark>作业：</mark></h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017150943556.png" alt="image-20221017150943556" style="zoom:50%;" />
<h4 id="正交试验法-orthogonal-test-design-method-otdm">正交试验法（Orthogonal Test Design Method, OTDM）</h4>
<p>正交测试源于正交试验设计方法。从大量的（实验）数据（测试例）中挑选适量的、有代表性的点（条件组合），从而合理地安排实验（测试）的一种科学实验设计方法。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>正交测试法使用已经构造好了的正交表格来安排试验并进行数据分析。</p>
</li>
<li class="lvl-2">
<p>简单易行并且计算表格化，应用性较好。</p>
</li>
<li class="lvl-2">
<p>是一种有效减少测试用例个数的设计方法。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017151530280.png" alt="image-20221017151530280" style="zoom:67%;" />
<h6 id="正交试验法示例：">正交试验法示例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017152332203.png" alt="image-20221017152332203" style="zoom:50%;" />
<p>简单对比法：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017152244303.png" alt="image-20221017152244303" style="zoom:50%;" />
<blockquote>
<p>由以上简单对比法可以得到：</p>
<p>m=3，n=3（A、B、C）</p>
<p>第一次：实验n次</p>
<p>第二次：实验(m-1)次</p>
<p>第三次：实验(m-1)次</p>
<p>最后总共实验了：n+2*(m-1)次</p>
</blockquote>
<h5 id="正交表法-orthogonalarraytesting-strategy-oats">正交表法（OrthogonalArrayTesting Strategy,OATS ）</h5>
<p>正交表的两大优越性，即“<mark>均匀分散，整齐可比</mark>”。特性中有任意一条不满足，就不是正交表。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017152530191.png" alt="image-20221017152530191"></p>
<p>正交表</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017152850670.png" alt="image-20221017152850670" style="zoom:50%;" />
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>每一列中各数字出现的次数都一样多；</p>
</li>
<li class="lvl-2">
<p>任何两列所构成的有序数对出现次数一样多。</p>
</li>
</ul>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017153203105.png" alt="image-20221017153203105" style="zoom:50%;" />
<h6 id="正交表法练习：">正交表法练习：</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017153710513.png" alt="image-20221017153710513"></p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219182700209.png" alt="image-20230219182700209"></p>
<p>补充：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219183826453.png" alt="image-20230219183826453"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219184145479.png" alt="image-20230219184145479"></p>
</blockquote>
<h4 id="textcolor-red-10月17日作业："><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mn>10</mn><mtext>月</mtext><mn>17</mn><mtext>日作业：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{10月17日作业：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord" style="color:red;">10</span><span class="mord cjk_fallback" style="color:red;">月</span><span class="mord" style="color:red;">17</span><span class="mord cjk_fallback" style="color:red;">日作业：</span></span></span></span></h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221017162532169.png" alt="image-20221017162532169"></p>
<h4 id="功能图法">功能图法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个程序的功能通常由<u>静态说明</u>和<u>动态说明</u>组成</p>
</li>
<li class="lvl-2">
<p>静态说明描述了<u>输入条件和输出条件之间的对应关系</u></p>
</li>
<li class="lvl-2">
<p>动态说明描述了<u>输入数据的次序或者转移的次序</u></p>
</li>
<li class="lvl-2">
<p>功能图法就是<mark>为了解决动态说明问题</mark>的一种测试用例的设计方法</p>
</li>
</ul>
<h6 id="构成：">构成：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>状态迁移图（statetransitiondiagram，STD）：适用于动态说明，输入数据和当前状态决定输出数据和后续状态</p>
</li>
<li class="lvl-2">
<p>逻辑功能模型（logicfunctionmodel，LFM）：适合于描述静态说明，输出数据仅由输入数据决定</p>
</li>
</ul>
<h6 id="逻辑功能表：">逻辑功能表：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019102601847.png" alt="image-20221019102601847" style="zoom: 67%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>从逻辑功能表中，可以根据所有的输入输出以及状态来生成所需要的节点和路径，形成实现功能图的基本路径组合——&gt;基本路径覆盖法设计测试用例</p>
</li>
<li class="lvl-2">
<p>功能图法实际是一种黑盒、白盒混合用例设计方法</p>
</li>
</ul>
<h5 id="测试用例生成规则：">测试用例生成规则：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>节点代替状态，弧线代替迁移。</p>
</li>
<li class="lvl-2">
<p><mark>状态迁移图转化为一个程序的控制流程图形式</mark>，问题也转换为程序的路径测试问题。</p>
</li>
<li class="lvl-2">
<p>从功能图生成实用的测试用例。一个结构化的状态迁移中，定义3种形式的循环：</p>
<ul class="lvl-2">
<li class="lvl-4">顺序</li>
<li class="lvl-4">选择</li>
<li class="lvl-4">重复</li>
</ul>
</li>
</ul>
<h5 id="功能图生成测试用例的过程：">功能图生成测试用例的过程：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>生成局部测试用例：在每个状态中，从因果图生成局部测试用例。局部测试库由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成</p>
</li>
<li class="lvl-2">
<p>测试路径生成：利用上面的规则生成从初始状态到最后状态的测试路径；</p>
</li>
<li class="lvl-2">
<p>测试用例合成：合成测试路径与功能图中每个状态的局部测试用例。结果是初状态到最后一个状态的一个状态序列，以及每个状态中输入数据与对应输出数据组合。</p>
</li>
</ul>
<h4 id="场景设计法">场景设计法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>黑盒测试中重要的测试用例设计方法</p>
</li>
<li class="lvl-2">
<p><u>事件触发时的情景</u>便形成了<mark>场景</mark>，场景的<u>不同触发顺序</u>构成了<mark>用例</mark></p>
</li>
<li class="lvl-2">
<p>基本流（基本流程）</p>
</li>
<li class="lvl-2">
<p>备选流（分支流程）</p>
</li>
</ul>
<p>用例场景：描述流经用例的路径，从用例开始到结束遍历这条路径上所有基本流和备选流</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019103245664.png" alt="image-20221019103245664" style="zoom: 50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>同一事件的不同触发顺序和处理结果就形成<mark>事件流</mark></p>
</li>
</ul>
<blockquote>
<p>V：表示有效（valid）</p>
<p>I：表示无效</p>
<p>n/a：表示不适用</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019103433299.png" alt="image-20221019103433299" style="zoom:50%;" />
<blockquote>
<p>直黑线表示基本流、备选流用不同的彩色表示</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>场景1：基本流</p>
</li>
<li class="lvl-2">
<p>场景2：基本流、备选流1；</p>
</li>
<li class="lvl-2">
<p>场景3：基本流、备选流3；</p>
</li>
<li class="lvl-2">
<p>场景4：基本流、备选流3、备选流1；</p>
</li>
<li class="lvl-2">
<p>场景5：基本流、备选流1、备选流2；</p>
</li>
<li class="lvl-2">
<p>场景6：基本流、备选流4</p>
</li>
<li class="lvl-2">
<p>场景7：基本流、备选流3、备选流4</p>
</li>
<li class="lvl-2">
<p>场景8：基本流、备选流3、备选流1、备选流2</p>
</li>
</ul>
<h4 id="错误推测法">错误推测法</h4>
<h6 id="流程：">流程：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019112312887.png" alt="image-20221019112312887" style="zoom:50%;" />
<h3 id="黑盒测试方法的比较与选择">黑盒测试方法的比较与选择</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019112649434.png" alt="image-20221019112649434" style="zoom:50%;" />
<h6 id="选择：">选择：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果变量引用的是物理量，可采用等价类测试和边界值测试。</p>
</li>
<li class="lvl-2">
<p>如果变量引用的是逻辑量，可采用等价类测试用例和决策表测试。</p>
</li>
<li class="lvl-2">
<p>如果变量是独立的，可采用边界值分析测试和等价类测试。</p>
</li>
<li class="lvl-2">
<p>如果变量不是独立的，可采用决策表测试。</p>
</li>
<li class="lvl-2">
<p>如果可保证是单缺陷假设，可采用边界值分析。</p>
</li>
<li class="lvl-2">
<p>如果可保证是多缺陷假设，可采用边界值分析测试和决策表测试。</p>
</li>
<li class="lvl-2">
<p>如果程序包含大量例外处理，可采用健壮性测试和决策表测试。</p>
</li>
</ul>
<h5 id="小结：">小结：</h5>
<ol>
<li class="lvl-3">
<p>进行等价类划分，包括输入条件和输出条件的等价类划分，将无限测试变成有限测试，这是减少工作量和提高测试效率最有效的方法；</p>
</li>
<li class="lvl-3">
<p>在任何情况下都必须使用<mark>边界值分析方法</mark>，经验表明，用这种方法设计出的测试用例<mark>发现错误的能力最强</mark>；</p>
</li>
<li class="lvl-3">
<p>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法和判定表法；</p>
</li>
<li class="lvl-3">
<p>对于配置参数类软件，用<mark>正交试验法</mark>选择较好的组合方式达到最佳效果；</p>
</li>
<li class="lvl-3">
<p>功能图法也是很好的测试用例设计方法，可以通过不同时期条件的有效性设计不同的测试数据；</p>
</li>
<li class="lvl-3">
<p>对于业务清晰的系统，可以利用场景法贯穿整个测试案例过程在案例中综合使用各种测试方法；</p>
</li>
<li class="lvl-3">
<p>可以用错误推测法追加一些测试用例，这需要依靠测试工程师的智慧和经验。</p>
</li>
</ol>
<h5 id="场景法实例：">场景法实例：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019112927024.png" alt="image-20221019112927024"></p>
<blockquote>
<p>A</p>
<p>AB</p>
<p>AC</p>
<p>AD</p>
<p>AE</p>
<p><strong><u><em>答题格式：</em></u></strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222234931858.png" alt="image-20230222234931858"></p>
</blockquote>
<h2 id="软件缺陷的生命周期">软件缺陷的生命周期</h2>
<h5 id="定义：">定义：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>软件缺陷生命周期指的是一个软件缺陷被发现、报告到这个缺陷被修复、验证直至最后关闭的完整过程</p>
</li>
<li class="lvl-2">
<p>缺陷生命周期是各类开发人员一起参与、协同测试的过程</p>
</li>
<li class="lvl-2">
<p>软件缺陷<mark>一旦发现</mark>便进入<mark>严密监控之中</mark>，<u>直至软件缺陷生命周期终结</u>，这样即可保证在较短的时间内高效率地关闭所有的缺陷，缩短软件测试的进程，提高软件质量，同时减少开发、测试和维护成本。</p>
</li>
</ul>
<h6 id="基本的缺陷生命周期">基本的缺陷生命周期</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026102400945.png" alt="image-20221026102400945" style="zoom:33%;" />
<ol>
<li class="lvl-3">
<p>发现-打开：<mark>测试人员</mark>找到<mark>软件缺陷</mark>并将软件缺陷<mark>提交给开发人员</mark>。</p>
<ul class="lvl-2">
<li class="lvl-5">测试人员<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>开发人员</li>
</ul>
</li>
<li class="lvl-3">
<p>打开-修复：开发人员<mark>再现、修复缺陷</mark>，然后提交给<mark>测试人员去验证</mark>。</p>
<ul class="lvl-2">
<li class="lvl-5">开发人员<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>测试人员</li>
</ul>
</li>
<li class="lvl-3">
<p>修复-关闭：<mark>测试人员验证</mark>修复过的软件，<mark>关闭</mark>已不存在的<mark>缺陷</mark></p>
<ul class="lvl-2">
<li class="lvl-5">测试人员</li>
</ul>
</li>
</ol>
<h4 id="软件缺陷-bug-处理流程-v">⭐️软件缺陷==（Bug）处理流程==(V)</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026102830336.png" alt="image-20221026102830336" style="zoom:33%;" />
<h5 id="实际的缺陷生命周期">实际的缺陷生命周期</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026103804673.png" alt="image-20221026103804673" style="zoom: 33%;" />
<h5 id="缺陷处理详细">缺陷处理详细</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>确保每个被发现的缺陷都能够被解决（被解决<u>不一定是将bug完全修复</u>，<u>而是指对该缺陷有一个解决方案</u>，如：延期等）</p>
</li>
<li class="lvl-2">
<p>验证：缺陷的修复需要得到测试人员的验证，同时还要进行回归测试，检查这个缺陷的修复是否会引入新的问题；</p>
</li>
<li class="lvl-2">
<p>重新打开：重新打开一个缺陷，需要加注释说明、电话沟通等，否则会引起“打开-修复”多个来回，造成测试人员和开发人员不必要的矛盾（背锅侠）</p>
</li>
<li class="lvl-2">
<p>关闭：<mark>只有测试人员有关闭缺陷的权限</mark>，开发人员没有这个权限。</p>
</li>
<li class="lvl-2">
<p>暂缓：如果每个人都同意将确实存在的缺陷移到以后处理，应该指定下一个版本号或修改的日期。一旦新的版本开始时，这些暂缓的缺陷应该重新被打开。</p>
</li>
<li class="lvl-2">
<p>审阅：可以由<mark>测试管理员、项目管理员或其他人</mark>来进行，审阅缺陷报告的质量水平；</p>
</li>
<li class="lvl-2">
<p>拒绝：如果审阅者决定需要对一份缺陷报告进行重大修改，应该和测试人员一起讨论，由<mark>测试人员纠正缺陷报告</mark>，然后再次提交；</p>
</li>
<li class="lvl-2">
<p>完善：完整地描述了问题的特征并将其分离，那么审查者就会肯定这个报告；</p>
</li>
<li class="lvl-2">
<p>分配：分配给适当的开发人员，如果不知道具体开发人员，应分配给项目开发组长，由开发组长再分配给对应的开发人员；</p>
</li>
</ul>
<h6 id="软件缺陷描述-状态">软件缺陷描述|状态</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026110456852.png" alt="image-20221026110456852" style="zoom: 50%;" />
<h6 id="软件缺陷描述-严重性">软件缺陷描述|严重性</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222101531553.png" alt="image-20230222101531553"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>致命的（fatal）、严重的（critical）、一般的（major）、微小的（minor）</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026110534433.png" alt="image-20221026110534433" style="zoom: 50%;" />
<h6 id="软件缺陷描述-优先级">软件缺陷描述|优先级</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222101600191.png" alt="image-20230222101600191"></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026110616496.png" alt="image-20221026110616496" style="zoom:33%;" />
<h6 id="软件缺陷描述-严重性和优先级">软件缺陷描述|严重性和优先级</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>一般地，严重程度高的软件缺陷具有较高的优先级。</p>
</li>
<li class="lvl-2">
<p>严重程度高优先级不一定高，某些严重的软件缺陷只在非常极端的条件下产生</p>
</li>
<li class="lvl-2">
<p>严重程度低的优先级不一定低</p>
</li>
</ul>
<h6 id="缺陷报告-缺陷报告的详细信息">缺陷报告|缺陷报告的详细信息</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026111427547.png" alt="image-20221026111427547" style="zoom:33%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026111521088.png" alt="image-20221026111521088" style="zoom: 33%;" />
<h6 id="软件缺陷报告-缺陷描述的基本要求">软件缺陷报告|缺陷描述的基本要求</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>单一准确</p>
</li>
<li class="lvl-2">
<p>可以再现</p>
</li>
<li class="lvl-2">
<p>完整统一</p>
</li>
<li class="lvl-2">
<p>短小简练</p>
</li>
<li class="lvl-2">
<p>特定条件</p>
</li>
<li class="lvl-2">
<p>补充完善</p>
</li>
<li class="lvl-2">
<p><u><mark>不做评价</mark></u></p>
</li>
</ul>
<h5 id="bug的优先排列：">Bug的优先排列：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>可重复性(Repeatability)</p>
</li>
<li class="lvl-2">
<p>可发生性(Visibility)</p>
</li>
<li class="lvl-2">
<p>严重性(Severity)</p>
</li>
<li class="lvl-2">
<p><u>优先级=（可重复性+可发生性）X 严重性</u></p>
</li>
</ul>
<h5 id="软件测试管理-质量成本">软件测试管理|质量成本</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026113056168.png" alt="image-20221026113056168" style="zoom: 80%;" />
<h6 id="软件测试管理-质量成本实例">软件测试管理|质量成本实例</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026113852858.png" alt="image-20221026113852858" style="zoom: 50%;" />
<blockquote>
<p>2、3种情况</p>
</blockquote>
<h2 id="实验要求">实验要求</h2>
<h4 id="测试用例撰写要求：">测试用例撰写要求：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>用例名：简明扼要</p>
</li>
<li class="lvl-2">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026100643992.png" alt="image-20221026100643992" style="zoom:50%;" />
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件测试技术</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试技术笔记2</title>
    <url>/2023/05/11/University/junior/course/Software%20testing%20technology/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>软件测试技术笔记之二</h1>
<h2 id="开发人员测试">开发人员测试</h2>
<h3 id="白盒测试">白盒测试</h3>
<p>目录：</p>
<ol>
<li class="lvl-3">
<p>白盒测试方法</p>
</li>
<li class="lvl-3">
<p>逻辑覆盖测试法</p>
</li>
<li class="lvl-3">
<p>基本路径测试法</p>
</li>
<li class="lvl-3">
<p>循环测试</p>
</li>
<li class="lvl-3">
<p>测试用例数估算</p>
</li>
</ol>
<h5 id="黑盒测试与白盒测试的比较">黑盒测试与白盒测试的比较</h5>
<h6 id="黑盒测试：">黑盒测试：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>功能测试</p>
</li>
<li class="lvl-2">
<p>数据驱动测试</p>
</li>
</ul>
<h6 id="白盒测试：">白盒测试：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>结构测试</p>
</li>
<li class="lvl-2">
<p>逻辑驱动测试</p>
</li>
</ul>
<h5 id="静态白盒测试">静态白盒测试</h5>
<p>在不执行软件的条件下<mark>进行程序设计的审查</mark></p>
<h5 id="动态白盒测试-结构化测试">动态白盒测试（结构化测试）</h5>
<p><mark>检查代码</mark>并<mark>观察运行状况</mark></p>
<h6 id="白盒测试主要方法：">白盒测试主要方法：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>逻辑覆盖测试法</p>
</li>
<li class="lvl-2">
<p>基本路径测试法</p>
</li>
<li class="lvl-2">
<p>循环路径覆盖法</p>
</li>
</ul>
<h5 id="程序控制流图">程序控制流图</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114150337990.png" alt="image-20221114150337990" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114150405720.png" alt="image-20221114150405720" style="zoom:50%;" />
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205171154097.png" alt="image-20221205171154097"></p>
<h6 id="基本路径测试：">基本路径测试：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114150538456.png" alt="image-20221114150538456" style="zoom: 33%;" />
<h5 id="静态符号执行">静态符号执行</h5>
<h5 id="动态符号执行">动态符号执行</h5>
<p>以具体的数值作为输入，执行程序代码，在程序实际执行路径的基础上，用符号执行技术对路径进行分析，提取路径的约束表达式。</p>
<h3 id="textcolor-red-11月4日作业：静态分析"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mn>11</mn><mtext>月</mtext><mn>4</mn><mtext>日作业：静态分析</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{11月4日作业：静态分析}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord" style="color:red;">11</span><span class="mord cjk_fallback" style="color:red;">月</span><span class="mord" style="color:red;">4</span><span class="mord cjk_fallback" style="color:red;">日作业：静态分析</span></span></span></span></h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114150729609.png" alt="image-20221114150729609" style="zoom:50%;" />
<h4 id="基于逻辑覆盖的测试方法"><mark>基于逻辑覆盖的测试方法</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>语句覆盖（SC）</p>
</li>
<li class="lvl-2">
<p>判定覆盖（DC）</p>
</li>
<li class="lvl-2">
<p>条件覆盖（CC）</p>
</li>
<li class="lvl-2">
<p>判定-条件覆盖（CDC）</p>
</li>
<li class="lvl-2">
<p>条件组合覆盖（MCC）</p>
</li>
</ul>
<h5 id="语句覆盖-sc">语句覆盖（SC）</h5>
<ol>
<li class="lvl-3">
<p>语句覆盖法的基本思想是设计若干测试用例，运行被测程序，<mark>使程序中的每个可执行语句至少被执行一次</mark></p>
</li>
<li class="lvl-3">
<p>如果是顺序结构，就是让测试从头执行到尾</p>
</li>
<li class="lvl-3">
<p>如果有分支、条件和循环，需要利用判定覆盖、条件覆盖等方法，执行足够的测试覆盖全部语句</p>
</li>
</ol>
<blockquote>
<p>语句覆盖能发现一般语句的错误，但不能发现其中的逻辑错误。</p>
</blockquote>
<h5 id="判定-分支-覆盖-dc">判定(分支)覆盖（DC）</h5>
<ol>
<li class="lvl-3">
<p>判定覆盖法的基本思想是设计若干用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次，即判断真假值均曾被满足。</p>
</li>
<li class="lvl-3">
<p>一个判定代表着程序的一个分支，所以判定覆盖也被称为分支覆盖。</p>
</li>
<li class="lvl-3">
<p>满足判定覆盖➔满足语句覆盖</p>
</li>
</ol>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218154524603.png" alt="image-20230218154524603"></p>
</blockquote>
<h5 id="条件覆盖-cc">条件覆盖（CC）</h5>
<ol>
<li class="lvl-3">
<p>条件覆盖的基本思想是设计若干测试用例，执行被测程序以后，要使<u><mark>每个判断中每个条件</mark>的可能取值至少满足一次</u></p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218154621783.png" alt="image-20230218154621783"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218154715833.png" alt="image-20230218154715833"></p>
<h5 id="判定-条件覆盖-cdc">判定-条件覆盖（CDC）</h5>
<ol>
<li class="lvl-3">
<p>判定-条件覆盖是<mark>判定和条件覆盖</mark>设计方法的<mark>交集</mark>，即设计足够的测试用例，使得判断条件中的<mark>所有条件可能取值</mark>至少<mark>执行一次</mark>，同时，<mark>所有判断的可能结果</mark>至少<mark>执行一次</mark></p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114153711184.png" alt="image-20221114153711184"></p>
<h5 id="条件组合覆盖-mcc">条件组合覆盖（MCC）</h5>
<ol>
<li class="lvl-3">
<p>条件组合覆盖的基本思想是设计足够的测试用例，使得判断中<mark>每个条件的所有可能组合</mark>至少<mark>出现一次</mark>，并且<mark>每个判断本身的判定结果</mark>也至少<mark>出现一次</mark>。</p>
</li>
<li class="lvl-3">
<p>它与条件覆盖的差别是它不是简单地要求每个条件都出现“真”与“假”两种结果，而是要求让这些结果的所有可能组合都至少出现一次。</p>
</li>
<li class="lvl-3">
<p><u><em>满足条件组合覆盖，一定满足判定覆盖、条件覆盖、条件判定组合覆盖</em></u></p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114154109637.png" alt="image-20221114154109637"></p>
<h4 id="基本路径测试法-基本路径覆盖-bpc">基本路径测试法|基本路径覆盖（BPC）</h4>
<h5 id="基本路径覆盖的设计过程">基本路径覆盖的设计过程</h5>
<ol>
<li class="lvl-3">
<p>依据代码绘制流程图（控制流图）</p>
</li>
<li class="lvl-3">
<p>确定控制流图的<mark>圈复杂度</mark>（cyclomaticcomplexity ）</p>
</li>
<li class="lvl-3">
<p>确定<mark>线性独立路径</mark>的基本集合( basis set )</p>
</li>
<li class="lvl-3">
<p>设计测试用例覆盖每条基本路径</p>
</li>
</ol>
<blockquote>
<p>圈复杂度就确定了基本集合中线性独立路径的数量。</p>
<p>同时注意<mark>基本集合不一定唯一</mark></p>
<p>V(G)是一个上界</p>
</blockquote>
<h5 id="代码绘制流程图">⭐️代码绘制流程图</h5>
<h6 id="1-复合条件简化：">1️⃣复合条件简化：</h6>
<blockquote>
<p>如果判断中的条件表达式是复合条件，即条件表达式是由一个或多个逻辑运算符（or, and, nor）连接的<u>逻辑表达式</u>，则需要改变复合条件的判断为一系列<mark>只有单个条件的嵌套的判断</mark>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原始代码</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">and</span> b:</span><br><span class="line">    then x;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    then y;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#复合条件拆分</span></span><br><span class="line"><span class="keyword">if</span> a then:</span><br><span class="line">    <span class="keyword">if</span> b then:</span><br><span class="line">    	then x;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    then y;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="🌊圈复杂度的计算">🌊圈复杂度的计算</h5>
<blockquote>
<p>圈复杂度（Cyclomaticcomplexity）: 代码逻辑复杂度的度量，提供了被测代码的路径数量。复杂度越高，出错的概率越大</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116102954687.png" alt="image-20221116102954687" style="zoom:50%;" />
<p><mark>对于结点数量：包括起点和终点；所有终点只计算一次，多个return和throw算作一个节点</mark></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116103628905.png" alt="image-20221116103628905" style="zoom:50%;" />
<p>实例：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116112006475.png" alt="image-20221116112006475" style="zoom: 33%;" />
<p>​																										<strong>（控制流图）</strong></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218220149174.png" alt="image-20230218220149174" style="zoom:50%;" />
<p><u><em><strong>控制流图的几种结构：</strong></em></u></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/e6894c529e158296c77ae8b0c371a736.png" alt="img"></p>
<h5 id="u-关于流程图中的循环语句代码-u-span-style-color-red-？？？-span"><u><em><strong>关于流程图中的循环语句代码</strong></em></u><span style="color: red;">？？？</span></h5>
<ol>
<li class="lvl-3">
<p>首先在绘制程序流程图的时候要将循环语句设计为判断结点</p>
</li>
<li class="lvl-3">
<p>在计算圈复杂度时，由循环语句呈现的判断结点不算入下面公式的<code>判断结点数目</code>中</p>
</li>
</ol>
</blockquote>
<h5 id="☁-线性独立路径的基本集合">☁️线性独立路径的基本集合</h5>
<blockquote>
<p>由基本集导出的测试用例，<u>保证每行代码语句至少被执行一次</u><mark>基本集合不一定唯一</mark></p>
<ol>
<li class="lvl-3">独立路径：至少引入一系列新的处理语句或条件的任何路径</li>
<li class="lvl-3">基本集：由独立路径构成的集合</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116103841143.png" alt="image-20221116103841143" style="zoom:50%;" />
<p>习题：</p>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116110336074.png" alt="image-20221116110336074"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116110300651.png" alt="image-20221116110300651"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>以上流程图圈复杂度：9</p>
<p>⭐️分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于switch</span></span><br><span class="line"><span class="keyword">switch</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    	operation1;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        operation2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        operation3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以转换为if-else的形式</span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;operation1;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">    &#123;operation2;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;operation3;&#125;</span><br><span class="line"><span class="comment">//进一步地可以拓展为以下</span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;operation1;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;operation3;&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">    &#123;operation1;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;operation3;&#125;</span><br><span class="line"><span class="comment">/*由此可以看出存在两组if-esle结果，因此记判断节点数（或简单可预测节点数）为2*/</span></span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>总结：基本路径测试并不是测试所有路径的组合，仅仅保证每条基本路径被执行一次</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{总结：基本路径测试并不是测试所有路径的组合，仅仅保证每条基本路径被执行一次}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">总结：基本路径测试并不是测试所有路径的组合，仅仅保证每条基本路径被执行一次</span></span></span></span></p>
</blockquote>
<h6 id="测试用例覆盖每条基本路径">测试用例覆盖每条基本路径</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205173056291.png" alt="image-20221205173056291"></p>
<h6 id="小结：各覆盖之间的包含关系">小结：<mark>各覆盖之间的包含关系</mark></h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116111415418.png" alt="image-20221116111415418" style="zoom:50%;" />
<blockquote>
<p>以上表示的是各种覆盖方法之间子集关系</p>
</blockquote>
<h6 id="白盒测试逻辑覆盖习题">白盒测试逻辑覆盖习题</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116100341934.png" alt="image-20221116100341934"></p>
<h4 id="循环测试">循环测试</h4>
<blockquote>
<p>目标:在循环内部及边界上执行测试</p>
</blockquote>
<h6 id="简单循环-迭代次数n">简单循环(迭代次数n)</h6>
<ol>
<li class="lvl-3">
<p>完全跳过循环</p>
</li>
<li class="lvl-3">
<p>只经过循环一次</p>
</li>
<li class="lvl-3">
<p>经过循环两次</p>
</li>
<li class="lvl-3">
<p>经过循环m（m &lt; n ）次</p>
</li>
<li class="lvl-3">
<p>分别经过循环n-1, n, n+1 次</p>
</li>
</ol>
<h6 id="嵌套-nested-循环">嵌套（Nested）循环</h6>
<ol>
<li class="lvl-3">
<p>在最里面的循环完成前面所述的简单循环测试，同时设定外部循环的最小迭代次数</p>
</li>
<li class="lvl-3">
<p>逐步向外循环进行</p>
</li>
<li class="lvl-3">
<p>直到所有循环被测试</p>
</li>
</ol>
<h6 id="串行连接的循环">串行连接的循环</h6>
<ol>
<li class="lvl-3">
<p>独立循环➔可以分别看成简单循环测试</p>
</li>
<li class="lvl-3">
<p>依赖性循环➔可以看成是嵌套循环</p>
</li>
</ol>
<h5 id="循环化简">循环化简</h5>
<blockquote>
<p>比较简单的小程序实现路径覆盖是可能做到的；如果程序中出现多个判断和多个循环，可能的路径数据急剧增长，以至于实现完全路径覆盖不可能做到。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><u>对循环机制进行简化，舍掉一些次要因素</u>，极大地减少路径数量，使得覆盖有限的路径成为可能。</p>
</li>
<li class="lvl-3">
<p><u>循环化简，即限制循环的次数。</u>无论循环的形式和实际执行循环体的次数多少，只考虑循环1次和0次两种情况，即进入循环和跳过循环两种情况。</p>
</li>
</ol>
<h5 id="最少测试用例数估算">最少测试用例数估算</h5>
<ol>
<li class="lvl-3">
<p>顺序型——构成串行操作</p>
</li>
<li class="lvl-3">
<p>选择型——构成分支操作</p>
</li>
<li class="lvl-3">
<p>重复型——构成循环操作</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116125307022.png" alt="image-20221116125307022" style="zoom:50%;" />
<blockquote>
<p>为简化问题，避免出现测试用例极多的组合爆炸，把构成循环操作的重复型结构用选择结构代替。即不指望测试循环体所有的重复执行，而是只对循环体检验一次。</p>
</blockquote>
<h5 id="串行分支路径计算方式：">串行分支路径计算方式：</h5>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116112145953.png" alt="image-20221116112145953" style="zoom:50%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116112226435.png" alt="image-20221116112226435" style="zoom: 50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h6 id="复杂实例：">复杂实例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116112324286.png" alt="image-20221116112324286" style="zoom:50%;" />
<blockquote>
<p>上下层之间用乘法：</p>
<ol>
<li class="lvl-3">下层（8、9）判断有3条路径</li>
<li class="lvl-3">上层（6、7）判断的总共3条路径*（2、3、4、5）判断总共5条路径=15条路径，再+（1）判断下Y情况的1条路径=&gt;16条路径</li>
<li class="lvl-3">最后上下相乘：3*16=48条路径</li>
</ol>
</blockquote>
<h3 id="textcolor-red-考试类型题：画流程图-覆盖"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试类型题：画流程图、覆盖</mtext><mo>…</mo><mo>…</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试类型题：画流程图、覆盖……}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试类型题：画流程图、覆盖</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner" style="color:red;">……</span></span></span></span></h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116113018608.png" alt="image-20221116113018608"></p>
<blockquote>
<p>问题1：（<mark>判断覆盖必须保证每个判定语句都分别取一次T和一次F</mark>）</p>
<p>对于语句的100%判定覆盖</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222190533112.png" alt="image-20230222190533112"></p>
<p><mark>以上表格中注意到的是year%100 == 0成立则year%4 == 0一定成立，因此year%4 == 0可以省略</mark></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123105856921.png" alt="image-20221123105856921" style="zoom:50%;" />
<p>问题2：</p>
<p>V(G)=11</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123110003672.png" alt="image-20221123110003672" style="zoom:50%;" />
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123110303231.png" alt="image-20221123110303231"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123110324263.png" alt="image-20221123110324263"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230222191357937.png" alt="image-20230222191357937"></td>
<td></td>
</tr>
</tbody>
</table>
<p>问题3：</p>
<p>11</p>
<p>线性无关路径与线性独立路径?</p>
<p><mark>（每行代码至少被执行一次）</mark></p>
</blockquote>
<h4 id="程序插桩">程序插桩</h4>
<blockquote>
<p>工具：JaCoCo</p>
<ul class="lvl-1">
<li class="lvl-2">java程序覆盖信息收集工具</li>
</ul>
</blockquote>
<h5 id="程序插桩类型">程序插桩类型</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123111429595.png" alt="image-20221123111429595"></p>
<h4 id="变异测试">变异测试</h4>
<blockquote>
<ol>
<li class="lvl-3">
<p>变异测试评价测试用例集S</p>
</li>
<li class="lvl-3">
<p>评价之后生成缺陷检测能力更强的测试用例集合S<sup>+</sup></p>
</li>
</ol>
<p>相关参考：<a href="https://www.cnblogs.com/TongWee/p/4505289.html">Mutation Testing(变异测试) - Weston233 - 博客园 (cnblogs.com)</a></p>
<p>CSU参考：<a href="https://blog.csdn.net/weixin_44997802/article/details/127149008">(77条消息) 变异测试(mutation testing)：一种评估测试用例集错误检测能力的方法_CSU迦叶的博客-CSDN博客_mutation test</a></p>
</blockquote>
<h6 id="变异体杀死">变异体杀死</h6>
<ol>
<li class="lvl-3">
<p>当原程序和变异程序存在差异时，测试用例检测到变异程序的缺陷，则变异程序被杀死；</p>
</li>
<li class="lvl-3">
<p>当原程序和变异程序不存在差异时，测试用例检测不到变异程序的缺陷，则变异程序存活；</p>
</li>
</ol>
<h6 id="变异算子">变异算子</h6>
<ol>
<li class="lvl-3">
<p>运算符变异</p>
</li>
<li class="lvl-3">
<p>数值变异</p>
</li>
<li class="lvl-3">
<p>返回变异</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>==定义 4（可杀除变异体）==若存在测试用例 <em>t</em>，在变异体 <em>p</em>′ 和原有程序 <em>p</em> 上的执行结果不一致， 则称该变异体 <em>p</em>′ 相对于测试用例集 <em>T</em> 是可杀除变异体。</p>
</li>
<li class="lvl-2">
<p><mark>定义 5（可存活变异体）</mark> 若不存在任何测试用例t， 在变异体 <em>p</em>′ 和原有程序 <em>p</em> 上的执行结果不一致， 则称该变异体 <em>p</em>′ 相对于测试用例集 <em>T</em> 是可存活变异体。一部分可存活变异体通过设计新的测试用例可以转化成可杀除变异体， 剩余的可存活变异体则可能是等价变异体。本文对等价变异体定义如下。</p>
</li>
<li class="lvl-2">
<p>==定义 6 （等价变异体）==若变异体 <em>p</em>′ 与原有程序 <em>p</em> 在语法上存在差异， 但在语义上与 <em>p</em> 保持一致， 则称<em>p</em>′ 是 <em>p</em> 的等价变异体。</p>
</li>
</ul>
<h6 id="变异得分">变异得分</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123113534268.png" alt="image-20221123113534268" style="zoom:50%;" />
<blockquote>
<p>变异得分公式：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/4e5e91983e704f138a2e51c4ec79a69a.png" alt="img"></p>
</blockquote>
<h5 id="变异测试习题">变异测试习题</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123113908351.png" alt="image-20221123113908351" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123113957994.png" alt="image-20221123113957994" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123173112188.png" alt="image-20221123173112188" style="zoom:50%;" />
<h3 id="单元测试">单元测试</h3>
<h5 id="定义">定义</h5>
<p>单元测试是对软件基本的组成单元进行独立的测试</p>
<blockquote>
<p><mark>单元测试可以由程序员自己完成也可以由专业人员完成</mark></p>
</blockquote>
<h5 id="单元测试的目标">单元测试的目标</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>目标:<mark>单元模块被正确编码</mark></u></p>
</li>
<li class="lvl-2">
<p>信息能否正确地流入和流出单元</p>
</li>
<li class="lvl-2">
<p>在单元工作过程中，其内部数据能否保持其完整性</p>
<ul class="lvl-2">
<li class="lvl-4">包括内部数据的形式</li>
<li class="lvl-4">内容及相互关系不发生错误</li>
<li class="lvl-4">全局变量在单元中的处理和影响</li>
</ul>
</li>
<li class="lvl-2">
<p>为限制数据加工而设置的边界处，能否正确工作</p>
</li>
<li class="lvl-2">
<p>单元的运行能否做到满足特定的逻辑覆盖</p>
</li>
</ul>
<h5 id="单元测试任务-5个任务"><mark>单元测试任务（5个任务）</mark></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>模块独立执行路径</mark>测试</p>
<ul class="lvl-2">
<li class="lvl-4">检查每一条独立执行路径的测试，并保证每条语句被至少执行一次。</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>局部数据结构</mark>测试</p>
<ul class="lvl-2">
<li class="lvl-4">检查局部数据结构完整性。
<ul class="lvl-4">
<li class="lvl-6"><u>不正确或不一致的数据类型说明；使用尚未赋值或尚未初始化的变量；错误的初始值或错误的缺省值；变量名拼写错或书写错；不一致的数据类型。</u></li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>模块接口</mark>测试</p>
<ul class="lvl-2">
<li class="lvl-4">检查模块接口的正确性。</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>单元边界</mark>条件测试</p>
<ul class="lvl-2">
<li class="lvl-4">检查临界数据处理的正确性。</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>单元容错</mark>测试</p>
<ul class="lvl-2">
<li class="lvl-4">预设的各种出错处理是否正确有效。</li>
</ul>
</li>
</ul>
<h5 id="单元测试最重要的手段-u-静态测试-u-的运用">单元测试最重要的手段——*<u><strong><mark>静态测试</mark></strong></u>*的运用</h5>
<h6 id="单元测试三部曲">单元测试三部曲⭐️</h6>
<ol>
<li class="lvl-3">
<p>互审</p>
</li>
<li class="lvl-3">
<p>走审</p>
</li>
<li class="lvl-3">
<p>评审</p>
</li>
</ol>
<p>运行单元程序有时需要<mark>基于</mark>被测单元的<mark>接口</mark>，开发相应的<mark>驱动模块和桩模块</mark>。</p>
<h6 id="驱动模块-drive"><mark>驱动模块（drive）</mark></h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><em>对底层或子层模块进行测试所编写的调用这些模块的程序</em></u></p>
</li>
<li class="lvl-2">
<p>调用要测试的模块</p>
</li>
</ul>
<h6 id="桩模块-stub"><mark>桩模块（stub）</mark></h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><em>对顶层或上层模块进行测试时所编写的替代下层模块的程序</em></u></p>
</li>
<li class="lvl-2">
<p>由被测试模块调用</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128144227009.png" alt="image-20221128144227009"></p>
<p>实例：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128144413388.png" alt="image-20221128144413388" style="zoom:50%;" />
<h3 id="集成测试"><mark>集成测试</mark></h3>
<blockquote>
<p><u><mark><em><strong>对概要设计书进行验证</strong></em></mark></u></p>
</blockquote>
<h5 id="集成测试模式">集成测试模式</h5>
<ol>
<li class="lvl-3">
<p>渐增式测试模式</p>
<ul class="lvl-2">
<li class="lvl-5">把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试</li>
<li class="lvl-5">测试更彻底</li>
<li class="lvl-5">需要较多的机器时间</li>
</ul>
</li>
<li class="lvl-3">
<p>非渐增式测试模式</p>
<ul class="lvl-2">
<li class="lvl-5">先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</li>
<li class="lvl-5"><span style="color: red;">可以并行测试</span></li>
</ul>
</li>
</ol>
<p><u>大棒集成方法</u>：先是对每一个子模块进行测试（单元测试阶段），然后将所有模块一次性的全部集成起来进行集成测试。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>适合在规模较小的应用系统中使用</p>
</li>
</ul>
<p><span style="color: green;">两种模式比较：</span></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128152034802.png" alt="image-20221128152034802"></p>
<h6 id="集成测试分析">集成测试分析</h6>
<p>组件之间存在显示/隐形相依性</p>
<p>相依性关系：关联、聚集、消息、调用、全局变量与公共数据。</p>
<p>获取相依性关系：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>结构分析</p>
</li>
<li class="lvl-2">
<p>接口分析</p>
</li>
<li class="lvl-2">
<p>模块分析</p>
</li>
</ul>
<h6 id="自顶向下法-top-down-integration">自顶向下法(Top-down Integration)</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128160501703.png" alt="image-20221128160501703"></p>
<blockquote>
<p><u><em>自顶向下法需要许多插桩操作</em></u></p>
</blockquote>
<h6 id="自底向上法-bottom-up-integration">自底向上法(Bottom-up Integration)</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128160757817.png" alt="image-20221128160757817"></p>
<blockquote>
<p>需要驱动模块</p>
</blockquote>
<h6 id="混合策略-modified-top-down-integration">混合策略(Modified Top-down Integration)</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>混合法：对软件结构中<mark>较上层</mark>，使用的是“<mark>自顶向下</mark>”法；对软件结构中<mark>较下层</mark>，使用的是“<mark>自底向上</mark>”<br>
法，<u><strong>两者相结合</strong></u></p>
</li>
<li class="lvl-2">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128160856119.png" alt="image-20221128160856119"></p>
</li>
</ul>
<h6 id="三明治集成方法-sandwich-integration">三明治集成方法(Sandwich Integration)</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128161404502.png" alt="image-20221128161404502"></p>
<blockquote>
<p>它<mark>将自顶向下和自底向上的集成方法有机地结合起来</mark>，<u>不需要写桩程序</u>。因为在测试初自底向上集成已经验证了底层模块的正确性。</p>
</blockquote>
<p>改善的三明治集成方法</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128161458069.png" alt="image-20221128161458069"></p>
<blockquote>
<p>改进的三明治集成方法，不仅自两头向中间集成，而且<mark>保证每个模块得到单独的测试</mark>，<u>使测试进行得比较彻底</u></p>
</blockquote>
<h5 id="持续集成">持续集成</h5>
<blockquote>
<p>通常系统集成都会采用持续集成的策略，软件开发中各个模块不是同时完成，根据进度将完成的模块尽可能早的进行集成，有助于尽早发现Bug，避免集成中大量Bug涌现。</p>
</blockquote>
<h3 id="面向对象的单元测试">面向对象的单元测试</h3>
<h4 id="面向对象的测试">面向对象的测试</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向对象<mark>分析</mark>的测试</p>
</li>
<li class="lvl-2">
<p>面向对象<mark>设计</mark>的测试</p>
</li>
<li class="lvl-2">
<p>面向对象<mark>编程</mark>的测试</p>
</li>
</ul>
<h5 id="传统单元测试">传统单元测试</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>针对程序的函数、过程或完成某一特定功能的程序块</p>
</li>
</ul>
<h5 id="面向对象软件的单元测试">面向对象软件的单元测试</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>测试类成员函数</mark></p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207102510192.png" alt="image-20221207102510192"></p>
<h3 id="系统测试">系统测试</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>功能测试</p>
</li>
<li class="lvl-2">
<p>回归测试</p>
</li>
<li class="lvl-2">
<p>性能测试</p>
<ul class="lvl-2">
<li class="lvl-4">负载压力测试</li>
<li class="lvl-4">性能测试工具LoadRunner的初级使用</li>
</ul>
</li>
<li class="lvl-2">
<p>其他非功能性测试</p>
</li>
</ul>
<h4 id="功能测试">功能测试</h4>
<h5 id="单元功能测试">单元功能测试</h5>
<p>•保证所测试的每个独立的模块的功能正确，从输入条件和输出结果来判断是否满足程序的设计要求</p>
<h5 id="系统功能测试">系统功能测试</h5>
<p>•考虑模块间的相互作用，考虑系统的应用环境</p>
<p>•衡量标准是实现产品规格说明书上所要求的功能</p>
<p>•特别地，模拟用户从头到尾（End-to-End,端到端）的业务测试，确保系统可以完成实现设计的功能，<mark>满足用户实际业务需求</mark></p>
<h5 id="功能测试要点">功能测试要点</h5>
<p>•每项功能符合实际要求</p>
<p>•<mark>功能逻辑</mark>清楚，符合使用者习惯</p>
<p>•系统的各种状态按照业务流程而变化，并保持稳定</p>
<p>•<mark>系统的界面</mark>清晰、美观</p>
<p>•菜单、按钮操作正常、灵活，能处理一些异常<mark>操作</mark></p>
<p>•能接受正确的<mark>数据输入</mark>，对异常输入的容错处理</p>
<p>•<mark>数据的输出</mark>结果准确，格式清晰，可以保存和读取</p>
<p>•程序安装、启动正常，有相应的提示框、错误提示等</p>
<p>•……</p>
<h4 id="回归测试">回归测试</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>一旦程序某些区域被修改了，就可能影响其它区域，导致受影响的区域<mark>出现新的缺陷</mark>（回归缺陷）。</p>
</li>
<li class="lvl-2">
<p>回归测试是为了发现回归缺陷而进行的测试。</p>
</li>
</ul>
<h5 id="回归测试定义">回归测试定义</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>定义</mark>：对软件的新版本测试时，<mark>重复执行上一个版本</mark>测试时<mark>的用例</mark>。</p>
</li>
<li class="lvl-2">
<p>回归测试可以在任何测试阶段进行。既有黑盒测试的回归，也有白盒测试的回归。</p>
</li>
</ul>
<h5 id="回归测试策略">回归测试策略</h5>
<ol>
<li class="lvl-3">
<p>再测试全部用例</p>
</li>
<li class="lvl-3">
<p>基于风险选择测试</p>
</li>
<li class="lvl-3">
<p>基于操作剖面选择测试</p>
</li>
<li class="lvl-3">
<p>再测试修改的部分</p>
</li>
<li class="lvl-3">
<p>更智能的选择方法</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207105052116.png" alt="image-20221207105052116"></p>
<h4 id="性能测试">性能测试</h4>
<h6 id="性能测试的基本流程-10步骤-："><mark>性能测试的基本流程（10步骤）：</mark></h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230218195023212.png" alt="image-20230218195023212"></p>
<blockquote>
<p>性能测试用来<mark>保证</mark>产品发布后<mark>系统的性能</mark>能够<mark>满足用户需求</mark></p>
</blockquote>
<ol>
<li class="lvl-3">
<p>执行效率</p>
</li>
<li class="lvl-3">
<p>资源占用</p>
</li>
<li class="lvl-3">
<p>稳定性</p>
</li>
<li class="lvl-3">
<p>安全性</p>
</li>
<li class="lvl-3">
<p>兼容性</p>
</li>
<li class="lvl-3">
<p>可扩展性</p>
</li>
<li class="lvl-3">
<p>可靠性…</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207105358428.png" alt="image-20221207105358428"></p>
<p><mark>性能测试</mark>（performance test）就是为了<u><em>发现系统性能问题或获取系统性能相关指标而进行的测试</em></u>。一般在<mark>真实环境</mark>、<mark>特定负载（正常或峰值）<mark>条件下，通过</mark>工具模拟</mark>实际软件系统的运行及其操作，同时监控<u><strong>性能各项指标</strong></u>，最后<u>对测试结果进行分析</u>来确定系统的性能状况。</p>
<h6 id="性能测试目标">性能测试目标</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>获取系统性能某些指标数据</p>
</li>
<li class="lvl-2">
<p>为了验证系统是否达到用户提出的性能指标</p>
</li>
<li class="lvl-2">
<p>发现系统中存在的性能瓶颈，优化系统的性能</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>评价系统当前性能</p>
</li>
<li class="lvl-4">
<p>预测系统未来性能</p>
</li>
<li class="lvl-4">
<p>寻找瓶颈，优化性能</p>
</li>
<li class="lvl-4">
<p>寻找错误</p>
</li>
</ul>
</li>
</ul>
<h5 id="性能测试类型">性能测试类型</h5>
<p><u><em><strong>性能规划测试</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在多种特定的环境下，获得不同配置的系统的性能指标，从而决定在系统部署时采用什么样的软、硬件配置——预测系统未来性能</p>
</li>
</ul>
<p><u><em><strong>性能基准测试</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基准线</p>
</li>
</ul>
<p><u><em><strong>容量测试</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以看作性能的测试一种，因为系统的容量可以看作是系统性能指标之一</p>
</li>
</ul>
<p><u><em><strong>性能验证测试</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>验证系统是否达到事先已定义的系统性能指标、能否满足系统的性能需求</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207111214200.png" alt="image-20221207111214200" style="zoom:67%;" />
<h6 id="全生命周期性能评估">全生命周期性能评估</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207111456089.png" alt="image-20221207111456089"></p>
<h6 id="产品生命周期中负载压力测试计划">产品生命周期中负载压力测试计划</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>需求分析中充分关注负载压力性能</p>
</li>
<li class="lvl-2">
<p>在设计中得到负载压力性能指标</p>
</li>
<li class="lvl-2">
<p>开发阶段创建负载压力性能测试环境</p>
</li>
<li class="lvl-2">
<p>验收阶段在多等级范围内测试并调优</p>
</li>
<li class="lvl-2">
<p>运行阶段持续监控系统负载压力性能</p>
</li>
</ul>
<h5 id="性能测试需求和指标">性能测试需求和指标</h5>
<blockquote>
<p>用户对各项指标提出的明确需求；如果用户没有提出性能指标，则根据用户需求、测试设计人员的经验来设计各项测试指标。（需求+经验）</p>
</blockquote>
<p><u><em>只有具备了清楚而量化的性能指标，性能测试才能开始实施。</em></u></p>
<p><strong>主要的性能指标：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>服务器的各项指标（CPU、内存占用率等）</p>
</li>
<li class="lvl-2">
<p>后台数据库的各项指标</p>
</li>
<li class="lvl-2">
<p>网络流量</p>
</li>
<li class="lvl-2">
<p>响应时间</p>
</li>
</ul>
<p><strong>不同角度的关注点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>最终用户的体验，如2-5-10原则</p>
</li>
<li class="lvl-2">
<p>商业需求，如“比竞争对手的产品好”</p>
</li>
<li class="lvl-2">
<p>技术需求，如CPU使用率不超过70％</p>
</li>
<li class="lvl-2">
<p>标准要求</p>
</li>
</ul>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>响应时间是用户的关注点；</p>
</li>
<li class="lvl-2">
<p>容量和数据吞吐量是（产品市场团队）业务处理方面的关注点；</p>
</li>
<li class="lvl-2">
<p>而系统资源占用率是开发团队的技术关注点。</p>
</li>
</ul>
</blockquote>
<h6 id="性能的具体指标">性能的具体指标</h6>
<ol>
<li class="lvl-3">
<p>数据传输的吞吐量（Transactions）</p>
</li>
<li class="lvl-3">
<p>数据处理效率（Transactionspersecond）</p>
</li>
<li class="lvl-3">
<p>数据请求的响应时间（Responsetime）</p>
</li>
<li class="lvl-3">
<p>内存和CPU使用率</p>
</li>
<li class="lvl-3">
<p>连接时间（ConnectTime）、发送时间（SentTime）</p>
</li>
<li class="lvl-3">
<p>处理时间（ProcessTime）、页面下载时间</p>
</li>
<li class="lvl-3">
<p>第一次缓冲时间</p>
</li>
<li class="lvl-3">
<p>每秒（SSL）连接数</p>
</li>
<li class="lvl-3">
<p>每秒事务总数、每秒下载页面数</p>
</li>
<li class="lvl-4">
<p>每秒点击次数、每秒HTTP响应数</p>
</li>
<li class="lvl-4">
<p>每秒重试次数</p>
</li>
</ol>
<h6 id="实例参考">实例参考</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207112712113.png" alt="image-20221207112712113"></p>
<h5 id="负载压力测试-span-style-color-red-性能测试的重要组成部分-span">负载压力测试|<span style="color: red;">性能测试的重要组成部分</span></h5>
<p>负载压力测试，在<mark>一定约束条件下</mark>测试系统所能承受的<u>并发用户量</u>、<u>运行时间</u>、<u>数据量</u>，以确定系统能承受的最大负载压力。</p>
<blockquote>
<p>在一种需要反常（如长时间的峰值）数量、频率或资源的方式下，<mark>执行可重复的负载测试</mark>，以<mark>检查程序对异常情况的抵抗能力</mark>，找出性能瓶颈或其它不稳定性问题。</p>
</blockquote>
<h6 id="负载压力测试类型">负载压力测试类型</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>并发性能测试（重点）</p>
</li>
<li class="lvl-2">
<p>疲劳强度测试</p>
</li>
<li class="lvl-2">
<p>大数据量测试</p>
</li>
</ul>
<h4 id="非功能性测试">非功能性测试</h4>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件测试技术</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>1-简单工厂模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>简单工厂模式</h1>
<h3 id="创建型模式">创建型模式</h3>
<ol>
<li class="lvl-3">
<p>关注<mark>对象的创建过程</mark></p>
</li>
<li class="lvl-3">
<p>对类的实例化过程进行了抽象，将软件模块中对象的创建和对象的使用分离</p>
</li>
<li class="lvl-3">
<p>描述如何<mark>将对象的创建和使用分离</mark></p>
</li>
</ol>
<blockquote>
<p><mark>java创建对象方法：</mark></p>
<ol>
<li class="lvl-3">new关键字直接创建</li>
<li class="lvl-3">工厂创建对象——工厂模式</li>
<li class="lvl-3">克隆创建对象——原型模式</li>
<li class="lvl-3">通过反射创建对象</li>
</ol>
</blockquote>
<h6 id="创建型模式一览表">创建型模式一览表</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116191204763.png" alt="image-20221116191204763" style="zoom:50%;" />
<blockquote>
<p><mark>单例模式是唯一一个自己创建自己的模式</mark></p>
<p>简单工厂模式（<mark>参数化工厂模式</mark>）只有一个工厂</p>
<ol>
<li class="lvl-3">
<p>存在问题：单个工厂负责所有产品的生产，可能会任务过重——<mark>违反单一职责原则</mark></p>
</li>
<li class="lvl-3">
<p>增加新产品时需要修改源代码——<mark>违反开闭原则</mark></p>
</li>
</ol>
</blockquote>
<h3 id="简单工厂模式-基本实现流程：">简单工厂模式-基本实现流程：</h3>
<ol>
<li class="lvl-3">
<p>具体产品类：将需要创建的各种不同产品对象的相关代码封装到具体产品类中</p>
</li>
<li class="lvl-3">
<p>抽象产品类：将具体产品类公共的代码进行抽象和提取后封装在一个抽象产品类中</p>
</li>
<li class="lvl-3">
<p>工厂类：提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入参数的不同创建不同的具体产品对象</p>
</li>
<li class="lvl-3">
<p>客户端：只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象</p>
</li>
</ol>
<h4 id="简单工厂模式定义">简单工厂模式定义</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116192710871.png" alt="image-20221116192710871" style="zoom:50%;" />
<blockquote>
<p>在具体的FactoryPatternDemo 类中将类对象作为局部变量，因此是依赖关系而不是关联关系</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>在简单工厂模式中用于创建实例的方法通常是<mark>静态(static)方法</mark>，又被称为静态工厂方法(Static Factory Method)模式</p>
</li>
<li class="lvl-3">
<p>要点：如果需要什么，只需要传入一个正确的参数，就可以获取所需要的对象，而<u>无须知道其创建细节</u></p>
</li>
<li class="lvl-3">
<p>简单工厂模式也称为<u>Parameterized Factory Methods</u>（参数化工厂模式）</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116195324477.png" alt="image-20221116195324477" style="zoom: 67%;" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">a=<span class="keyword">new</span> <span class="title class_">A1</span>();</span><br><span class="line">a.</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*问：此时通过a.能够看到哪些方法？</span></span><br><span class="line"><span class="comment">*答：只能看到父类A的m1()和m2()方法，因为a首先是单独被类A声明的，而不是在声明a的时候就同时用A1()实例化，因*此只能看到类A的两个方法，而无法看到类A1的m3()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><u>在java中static会导致丧失多态性</u></p>
<p><mark>子类不能够覆盖父类的静态（static）方法</mark></p>
</blockquote>
<h5 id="简单工厂模式结构">简单工厂模式结构</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116194350957.png" alt="image-20221116194350957" style="zoom:50%;" />
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>工厂类（</mtext><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>y</mi><mtext>）中创建产品的方法是</mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>c</mi><mtext>方法</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{工厂类（Factory）中创建产品的方法是static方法}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">工厂类（</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">F</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">c</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">ory</span><span class="mord cjk_fallback" style="color:red;">）中创建产品的方法是</span><span class="mord mathnormal" style="color:red;">s</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="color:red;">c</span><span class="mord cjk_fallback" style="color:red;">方法</span></span></span></span></p>
</blockquote>
<h5 id="简单工厂模式包含以下3个角色">简单工厂模式包含以下3个角色</h5>
<ol>
<li class="lvl-3">
<p>Factory（工厂角色）</p>
</li>
<li class="lvl-3">
<p>Product（抽象产品角色）</p>
<ul class="lvl-2">
<li class="lvl-5">如果抽象父类不需要实现具体的方法，则使用接口实现</li>
<li class="lvl-5">如果抽象父类需要实现一些具体的方法，则使用类实现</li>
</ul>
</li>
<li class="lvl-3">
<p>ConcreteProduct（具体产品角色）</p>
</li>
</ol>
<h5 id="典型的抽象产品类代码">典型的抽象产品类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体产品类代码">典型的具体产品类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的工厂类代码">典型的工厂类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的客户端代码">典型的客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Product product; </span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>); <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图1：">实例类图1：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116200747782.png" alt="image-20221116200747782" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ShapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	在以上代码中如果要更改生成的产品就必须要修改源代码，违反了开闭原则，所以将改变的部分放到XML配置文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>加载/解析配置文件：</p>
<ol>
<li class="lvl-3">DOM加载配置文件
<ul class="lvl-3">
<li class="lvl-5">一次性读取全部内容到内存</li>
<li class="lvl-5">相对于SAX来说内存占用多，但是速度快</li>
</ul>
</li>
<li class="lvl-3">SAX加载配置文件
<ul class="lvl-3">
<li class="lvl-5">逐行扫描文档，一边扫描一边解析</li>
<li class="lvl-5">内存占用少</li>
</ul>
</li>
</ol>
<p><mark>java涉及到文件读取和外部操作时一般都要用try-catch作异常处理</mark></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xml文件</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;chartType&gt;histogram&lt;/chartType&gt;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	chartType可以有多个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载xml文件</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取图表类型，并返回类型名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getChartType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象——调用DOM固有方法</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;							</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src//designpatterns//simplefactory//config.xml&quot;</span>)); </span><br><span class="line">		</span><br><span class="line">            <span class="comment">//获取包含图表类型的文本结点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;chartType&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">chartType</span> <span class="operator">=</span> classNode.getNodeValue().trim();</span><br><span class="line">            <span class="keyword">return</span> chartType;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>引入配置文件：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116202058610.png" alt="image-20221116202058610" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">Chart chart;</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> XMLUtil.getChartType(); <span class="comment">//读取配置文件中的参数</span></span><br><span class="line">chart = ChartFactory.getChart(type); <span class="comment">//创建产品对象</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="实例类图2：">实例类图2：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116203043356.png" alt="image-20221116203043356" style="zoom:50%;" />
<h6 id="工厂类多创建方法：">工厂类多创建方法：</h6>
<p>针对构造函数的参数重载在工厂中定义不同的create方法（Rectangle是抽象产品类）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116203724278.png" alt="image-20221116203724278" style="zoom:50%;" />
<h5 id="简单工厂模式的优点：">简单工厂模式的优点：</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116203111937.png" alt="image-20221116203111937" style="zoom:50%;" />
<ol>
<li class="lvl-3">
<p>对象创建和使用的分离</p>
</li>
<li class="lvl-3">
<p>客户端无须知道所创建的具体产品类的类名</p>
</li>
<li class="lvl-3">
<p>通过<mark>引入配置文件</mark>，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</p>
</li>
</ol>
<blockquote>
<p><u><mark>所有模式都实现了对象创建和使用的分离</mark></u></p>
</blockquote>
<h5 id="模式的缺点：">模式的缺点：</h5>
<ol>
<li class="lvl-3">
<p>工厂类集中了所有产品的创建逻辑，<mark>职责过重</mark></p>
</li>
<li class="lvl-3">
<p>增加了系统中类的个数</p>
</li>
<li class="lvl-3">
<p>系统扩展困难，一旦<mark>添加新产品不得不修改工厂逻辑</mark>（即，修改源代码）</p>
</li>
<li class="lvl-3">
<p>由于使用了静态工厂方法，造成<mark>工厂角色无法形成基于继承的等级结构</mark></p>
<ul class="lvl-2">
<li class="lvl-5"><u>子类不能覆盖父类的静态方法</u></li>
</ul>
</li>
</ol>
<h4 id="模式适用环境">模式适用环境⭐️</h4>
<ol>
<li class="lvl-3">
<p>工厂类负责创建的对象比较少，对象的类型比较稳定</p>
</li>
<li class="lvl-3">
<p>客户端只知道传入工厂类的参数，对于如何创建对象并不关心扩展</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>10-装饰模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/10-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%87%AA%E5%AD%A6%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>装饰模式</h1>
<h4 id="分析">分析</h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>可以<mark>在不改变一个对象本身功能的基础上给对象增加额外的新行为</mark>（照片+相框 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span> 防潮、美观）</p>
</li>
<li class="lvl-2">
<p>是一种用于替代继承的技术，它通过一种无须定义子类的方式给对象动态增加职责，使用对象之间的<mark>关联关系取代类之间的继承关系</mark></p>
</li>
<li class="lvl-2">
<p><mark>引入了装饰类</mark>，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能</p>
</li>
</ul>
</blockquote>
<h3 id="装饰模式的定义">装饰模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211141426050.png" alt="image-20230211141426050"></p>
<blockquote>
<p><mark>对象结构型模式</mark></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>以对客户透明的方式动态地给一个对象<mark>附加上更多的责任</mark></p>
</li>
<li class="lvl-2">
<p>可以在<u>不需要创建更多子类的情况下，让对象的功能得以扩展</u></p>
</li>
</ul>
<h4 id="装饰模式结构">装饰模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211141537950.png" alt="image-20230211141537950" style="zoom:50%;" />
<h5 id="装饰模式包含以下4个角色：">装饰模式包含以下4个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Component（抽象构件）</p>
</li>
<li class="lvl-2">
<p>ConcreteComponent（具体构件）</p>
</li>
<li class="lvl-2">
<p>Decorator（抽象装饰类）</p>
</li>
<li class="lvl-2">
<p>ConcreteDecorator（具体装饰类）</p>
</li>
</ul>
<h5 id="抽象构件类典型代码">抽象构件类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体构件类典型代码">具体构件类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span>  <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实现基本功能    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象装饰类典型代码">抽象装饰类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component; <span class="comment">//维持一个对抽象构件对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入一个抽象构件类型的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component=component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();  <span class="comment">//调用原有业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体装饰类典型代码">具体装饰类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation(); <span class="comment">//调用原有业务方法</span></span><br><span class="line">        addedBehavior(); <span class="comment">//调用新增业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedBehavior</span><span class="params">()</span> &#123;	</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211142115337.png" alt="image-20230211142115337"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211142132245.png" alt="image-20230211142132245"></p>
<blockquote>
<p>(1) Component：抽象界面构件类，充当抽象构件类</p>
<p>(2) Window：窗体类，充当具体构件类</p>
<p>(3) TextBox：文本框类，充当具体构件类</p>
<p>(4) ListBox：列表框类，充当具体构件类</p>
<p>(5) ComponentDecorator：构件装饰类，充当抽象装饰类</p>
<p>(6) ScrollBarDecorator：滚动条装饰类，充当具体装饰类</p>
<p>(7) BlackBorderDecorator：黑色边框装饰类，充当具体装饰类</p>
<p>(8) Client：客户端测试类</p>
</blockquote>
<h5 id="结果及分析">结果及分析</h5>
<h6 id="1-实现多次装饰-代码">1、实现多次装饰（代码）</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Component component, componentSB, componentBB; </span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">Window</span>(); </span><br><span class="line">        componentSB = <span class="keyword">new</span> <span class="title class_">ScrollBarDecorator</span>(component); </span><br><span class="line">        componentBB = <span class="keyword">new</span> <span class="title class_">BlackBorderDecorator</span>(componentSB);</span><br><span class="line">        componentBB.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">为构件增加黑色边框！</span><br><span class="line">为构件增加滚动条！</span><br><span class="line">显示窗体！</span><br></pre></td></tr></table></figure>
<h4 id="透明装饰模式">透明装饰模式</h4>
<ol>
<li class="lvl-3">
<p>透明(Transparent)装饰模式：要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而<mark>应该全部声明为抽象构件类型</mark></p>
</li>
<li class="lvl-3">
<p>对于客户端而言，具体构件对象和具体装饰对象没有任何区别</p>
</li>
<li class="lvl-3">
<p>可以让客户端<mark>透明地使用装饰之前的对象和装饰之后的对象</mark>，无须关心它们的区别</p>
</li>
<li class="lvl-3">
<p>可以对一个已装饰过的对象<mark>进行多次装饰</mark>，得到更为复杂、功能更为强大的对象</p>
</li>
<li class="lvl-3">
<p><u>无法在客户端单独调用新增方法addedBehavior()</u></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">Component component_o,component_d1,component_d2; <span class="comment">//全部使用抽象构件定义</span></span><br><span class="line">component_o = <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">component_d1 = <span class="keyword">new</span> <span class="title class_">ConcreteDecorator1</span>(component_o);</span><br><span class="line">component_d2 = <span class="keyword">new</span> <span class="title class_">ConcreteDecorator2</span>(component_d1);</span><br><span class="line">component_d2.operation();</span><br><span class="line"><span class="comment">//无法单独调用component_d2的addedBehavior()方法</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h4 id="半透明装饰模式">半透明装饰模式</h4>
<ol>
<li class="lvl-3">
<p>半透明(Semi-transparent)装饰模式：用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义</p>
</li>
<li class="lvl-3">
<p>对于客户端而言，<mark>具体构件类型无须关心，是透明的</mark>；但是<mark>具体装饰类型必须指定，这是不透明的</mark></p>
</li>
<li class="lvl-3">
<p>可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便</p>
</li>
<li class="lvl-3">
<p>客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addedBehavior()方法</p>
</li>
<li class="lvl-3">
<p>最大的缺点在于<mark>不能实现对同一个对象的多次装饰</mark>，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">Component component_o; <span class="comment">//使用抽象构件类型定义</span></span><br><span class="line">component_o = <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">component_o.operation();</span><br><span class="line">ConcreteDecorator component_d; <span class="comment">//使用具体装饰类型定义</span></span><br><span class="line">component_d = <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(component_o);</span><br><span class="line">component_d.operation();</span><br><span class="line">component_d.addedBehavior(); <span class="comment">//单独调用新增业务方法</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于<mark>扩展一个对象的功能</mark>，<mark>装饰模式比继承更加灵活</mark>，不会导致类的个数急剧增加</p>
</li>
<li class="lvl-2">
<p>可以通过一种动态的方式来扩展一个对象的功能，<mark>通过配置文件可以在运行时选择不同的具体装饰类</mark>，从而实现不同的行为</p>
</li>
<li class="lvl-2">
<p>可以<mark>对一个对象进行多次装饰</mark></p>
</li>
<li class="lvl-2">
<p>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，且原有类库代码无须改变，<mark>符合开闭原则</mark></p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用装饰模式进行系统设计时<mark>将产生很多小对象</mark>，大量小对象的产生势必会占用更多的系统资源，在一定程度上<mark>影响程序的性能</mark></p>
</li>
<li class="lvl-2">
<p>比继承更加易于出错，排错也更困难，对于多次装饰的对象，<mark>调试时寻找错误</mark>可能需要逐级排查，<mark>较为烦琐</mark></p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在不影响其他对象的情况下，<mark>以动态、透明的方式给单个对象添加职责</mark></p>
</li>
<li class="lvl-2">
<p>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以<mark>使用装饰模式</mark></p>
</li>
</ul>
<h4 id="课后思考">课后思考</h4>
<p>半透明装饰模式能否实现对同一个对象的多次装饰？为什么？</p>
<blockquote>
<p>不能。<mark>原因见前面</mark></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>11-外观模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/11-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>外观模式</h1>
<h5 id="例子：两种喝茶方式示意图">例子：两种喝茶方式示意图</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205201930589.png" alt="image-20221205201930589"></p>
<blockquote>
<p>外观模式：增加外观类降低客户类与业务类（子系统类）之间的耦合度（<mark>迪米特法则</mark>）</p>
</blockquote>
<blockquote>
<p><u>为复杂子系统提供一个<mark>简单的访问入口</mark></u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205202214064.png" alt="image-20221205202214064" style="zoom:50%;" />
<ul class="lvl-1">
<li class="lvl-2">
<p>一个客户类需要和<mark>多个业务类</mark>交互，而这些需要交互的业务类<mark>经常会作为一个整体出现</mark></p>
</li>
<li class="lvl-2">
<p>引入一个新的==外观类(Facade)<mark>来负责和</mark>多个业务类【子系统(Subsystem)】==进行交互，而客户类只需与外观类交互</p>
</li>
<li class="lvl-2">
<p>为多个业务类的调用<mark>提供了一个统一的入口，简化了类与类之间的交互</mark></p>
</li>
</ul>
</blockquote>
<h5 id="分析示意图">分析示意图</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205202851500.png" alt="image-20221205202851500"></p>
<p><u><em><strong>外观类将客户类与子系统的内部复杂性分隔开</strong></em></u></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>没有外观类</strong>：每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度很大</p>
</li>
<li class="lvl-2">
<p><strong>引入外观类</strong>：客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而<mark>降低了系统的耦合度</mark></p>
</li>
</ul>
</blockquote>
<h3 id="外观模式的定义">外观模式的定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205203043036.png" alt="image-20221205203043036" style="zoom:50%;" />
<p>（广义）接口：一组方法的集合。</p>
<blockquote>
<p><mark>对象结构型模式</mark></p>
<ul class="lvl-1">
<li class="lvl-2">又称为<mark>门面模式</mark></li>
<li class="lvl-2">是<mark>迪米特法则</mark>的一种具体实现</li>
<li class="lvl-2">通过<mark>引入一个新的外观角色</mark>来<mark>降低原有系统的复杂度</mark>，同时<mark>降低</mark>客户类与子系统之间的<mark>耦合度</mark></li>
<li class="lvl-2">所指的<mark>子系统</mark>是一个广义的概念，它可以是<u><em><strong>一个类、一个功能模块、系统的一个组成部分或者一个完整的系统</strong></em></u></li>
</ul>
</blockquote>
<h4 id="外观模式结构">外观模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205203328047.png" alt="image-20221205203328047" style="zoom:50%;" />
<blockquote>
<p>增加子系统时都会<mark>违反开闭原则</mark>：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205203945188.png" alt="image-20221205203945188"></p>
</blockquote>
<h5 id="外观模式包含以下2个角色：">外观模式包含以下2个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Facade（外观角色）</p>
</li>
<li class="lvl-2">
<p>SubSystem（子系统角色）</p>
</li>
</ul>
<h5 id="子系统类典型代码">子系统类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="外观类典型代码">外观类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemA</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemB</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemC</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        obj1.methodA();</span><br><span class="line">        obj2.methodB();</span><br><span class="line">        obj3.methodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户类典型代码">客户类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205204124269.png" alt="image-20221205204124269" style="zoom: 80%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205204138223.png" alt="image-20221205204138223" style="zoom:67%;" />
<blockquote>
<p>(1) FileReader：文件读取类，充当子系统类</p>
<p>(2) CipherMachine：数据加密类，充当子系统类</p>
<p>(3) FileWriter：文件保存类，充当子系统类</p>
<p>(4) EncryptFacade：加密外观类，充当外观类</p>
<p>(5) Client：客户端测试类</p>
<p><u>扩展：凯撒加密</u></p>
</blockquote>
<h3 id="抽象外观类">抽象外观类⭐️</h3>
<h5 id="动机">动机</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>在标准的外观模式结构图中，如果需要<mark>增加、删除或更换</mark>与外观类交互的<mark>子系统类</mark>，必须修改外观类或客户端的源代码，这将<mark>违背开闭原则</mark></p>
</li>
<li class="lvl-2">
<p>可以通过<mark>引入抽象外观类对系统进行改进</mark>，在一定程度上解决该问题</p>
</li>
</ul>
<h5 id="模式结构">模式结构</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212191638186.png" alt="image-20221212191638186"></p>
<h5 id="抽象外观类代码实现">抽象外观类代码实现</h5>
<h6 id="抽象外观类代码">抽象外观类代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEncryptFacade</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fileEncrypt</span><span class="params">(String fileNameSrc, String fileNameDes)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="配置文件">配置文件</h6>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.facade.NewEncryptFacade<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="实体外观类代码">实体外观类代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewEncryptFacade</span> <span class="keyword">extends</span> <span class="title class_">AbstractEncryptFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileReader reader;</span><br><span class="line">    <span class="keyword">private</span> NewCipherMachine cipher;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NewEncryptFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">        cipher = <span class="keyword">new</span> <span class="title class_">NewCipherMachine</span>();</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileEncrypt</span><span class="params">(String fileNameSrc, String fileNameDes)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">plainStr</span> <span class="operator">=</span> reader.read(fileNameSrc);</span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptStr</span> <span class="operator">=</span> cipher.encrypt(plainStr);</span><br><span class="line">        writer.write(encryptStr,fileNameDes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h6 id="客户端代码">客户端代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        AbstractEncryptFacade ef;</span><br><span class="line">        ef = (AbstractEncryptFacade)XMLUtil.getBean();</span><br><span class="line">        ef.fileEncrypt(<span class="string">&quot;src//designpatterns//facade//src.txt&quot;</span>,<span class="string">&quot;src//designpatterns //facade//des.txt&quot;</span>);    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外观模式与单例模式联用">外观模式与单例模式联用</h4>
<h6 id="将外观类转变成单例类">将外观类转变成单例类</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212192413219.png" alt="image-20221212192413219" style="zoom:50%;" />
<h3 id="模式优点">模式优点</h3>
<ol>
<li class="lvl-3">
<p>对客户端<mark>屏蔽了子系统组件</mark>，<mark>减少</mark>了客户端所需<mark>处理的对象数目</mark>，并使得子系统使用起来更加容易</p>
</li>
<li class="lvl-3">
<p>实现了<mark>子系统与客户端之间的松耦合关系</mark>，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</p>
</li>
<li class="lvl-3">
<p><mark>子系统的内部变化不会影响到外观对象</mark>，一个子系统的修改对其他子系统也没有任何影响</p>
</li>
</ol>
<h3 id="模式缺点">模式缺点</h3>
<ol>
<li class="lvl-3">
<p><mark>不能很好地限制客户端直接使用子系统类</mark>，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</p>
<ul class="lvl-2">
<li class="lvl-5"><u><em>外观类提供统一地使用子系统的接口，但是并不限制客户类使用单个子系统</em></u></li>
</ul>
</li>
<li class="lvl-3">
<p>如果设计不当，<mark>增加新的子系统可能需要修改外观类的源代码</mark>，违背了开闭原则</p>
</li>
</ol>
<h3 id="模式适用环境">模式适用环境</h3>
<ol>
<li class="lvl-3">
<p>要为访问一系列复杂的子系统<mark>提供一个简单入口</mark></p>
</li>
<li class="lvl-3">
<p><u>客户端程序</u>与<u>多个子系统之间</u><mark>存在很大的<u>依赖性</u></mark></p>
</li>
<li class="lvl-3">
<p>在层次化结构中，可以使用外观模式来定义系统中每一层的入口，<mark>层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度</mark></p>
<ul class="lvl-2">
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212194557415.png" alt="image-20221212194557415"></li>
<li class="lvl-5">在两层之间增加一个处理器，让view层与controller层之间不再直接访问，而是通过处理器进行联系，同时可以通过xml配置文件更换处理器。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>12-代理模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/12-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>代理模式</h1>
<h4 id="分析">分析</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>**代购商品：**顾客 → 代购网站 → 商品</p>
</li>
<li class="lvl-2">
<p>**软件开发：**客户端 →  代理对象 →  真实对象</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212194832801.png" alt="image-20221212194832801"></p>
<blockquote>
<h5 id="类型">类型</h5>
<ul class="lvl-1">
<li class="lvl-2">远程代理</li>
<li class="lvl-2">保护代理</li>
<li class="lvl-2">虚拟代理</li>
<li class="lvl-2">缓冲代理</li>
<li class="lvl-2">智能引用代理</li>
<li class="lvl-2">……</li>
</ul>
<p><strong>实例：代理服务器</strong></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212194939412.png" alt="image-20221212194939412" style="zoom:50%;" />
</blockquote>
<h3 id="代理模式的定义">代理模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212195025595.png" alt="image-20221212195025595"></p>
<blockquote>
<p><mark>对象结构型模式</mark></p>
<ul class="lvl-1">
<li class="lvl-2">引入一个新的<mark>代理对象</mark></li>
<li class="lvl-2">代理对象在<u>客户端对象</u>和<u>目标对象</u>之间<mark>起到中介的作用</mark></li>
<li class="lvl-2"><mark>去掉客户不能看到的内容和服务</mark>或者<mark>增添客户需要的额外的新服务</mark>
<ul class="lvl-3">
<li class="lvl-4">在代理类中增加新服务</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="代理模式结构">代理模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212195740022.png" alt="image-20221212195740022" style="zoom:50%;" />
<blockquote>
<p><mark>符合开闭原则</mark></p>
<ul class="lvl-1">
<li class="lvl-2">增加服务<mark>只需要增加新的代理类</mark>即可，不修改源代码</li>
<li class="lvl-2">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212201721885.png" alt="image-20221212201721885" style="zoom:50%;" />
</li>
</ul>
</blockquote>
<h5 id="代理模式包含以下3个角色：">代理模式包含以下3个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Subject（抽象主题角色）</p>
<ul class="lvl-2">
<li class="lvl-4">接口和抽象类均可</li>
</ul>
</li>
<li class="lvl-2">
<p>Proxy（代理主题角色）</p>
</li>
<li class="lvl-2">
<p>RealSubject（真实主题角色）</p>
</li>
</ul>
<h5 id="抽象主题类典型代码">抽象主题类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="真实主题类典型代码">真实主题类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//业务方法具体实现代码</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代理类典型代码">代理类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();  <span class="comment">//维持一个对真实主题对象的引用 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        …...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.request();  <span class="comment">//调用真实主题对象的方法</span></span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="几种常见的代理模式">几种常见的代理模式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>远程代理(Remote Proxy)</strong>：为一个位于<u>不同的地址空间的对象</u>提供一个<strong>本地的代理对象</strong>，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为<mark>大使(Ambassador)</mark></p>
<ul class="lvl-2">
<li class="lvl-4">工作在本地，代理的是远程的对象</li>
<li class="lvl-4"><u>最难实现的代理方式</u></li>
<li class="lvl-4"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212202138593.png" alt="image-20221212202138593">
<ul class="lvl-4">
<li class="lvl-6">Java中通过RMI来实现</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>虚拟代理(Virtual Proxy)</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建</p>
<ul class="lvl-2">
<li class="lvl-4">桌面快捷方式，通过小文件代理大的exe文件</li>
<li class="lvl-4">QQ空间、朋友圈中使用小图片代理大图片</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>保护代理(Protect Proxy)</strong>：控制对一个对象的访问，可以给不同的用户<mark>提供不同级别的使用权限</mark></p>
</li>
<li class="lvl-2">
<p><strong>缓冲代理(Cache Proxy)</strong>：为某一个目标操作的结果<mark>提供临时的存储空间</mark>，以便多个客户端可以共享这些结果</p>
<ul class="lvl-2">
<li class="lvl-4"><u>内存中的数据代理硬盘中的数据</u>（需要有保证内存和硬盘数据一致的机制）</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>智能引用代理(Smart Reference Proxy)</strong>：当一个对象被引用时，<mark>提供一些额外的操作</mark>，例如将对象被调用的次数记录下来等</p>
</li>
</ul>
<h6 id="实例类图">实例类图</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212200831919.png" alt="image-20221212200831919" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212200848807.png" alt="image-20221212200848807" style="zoom:50%;" />
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212200859017.png" alt="image-20221212200859017"></p>
<p>以上类图用到了以下代理：</p>
<ol>
<li class="lvl-3">
<p>保护代理</p>
</li>
<li class="lvl-3">
<p>智能引用代理</p>
</li>
</ol>
<blockquote>
<p>(1) AccessValidator：身份验证类，业务类</p>
<p>(2) Logger：日志记录类，业务类</p>
<p>(3) Searcher：抽象查询类，充当抽象主题角色</p>
<p>(4) RealSearcher：具体查询类，充当真实主题角色</p>
<p>(5) ProxySearcher：代理查询类，充当代理主题角色</p>
<p>(6) Client：客户端测试类</p>
<p><strong>结果及分析</strong></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>保护代理和智能引用代理</p>
</li>
<li class="lvl-2">
<p>在代理类ProxySearcher中实现对真实主题类的<mark>权限控制和引用计数</mark></p>
</li>
</ul>
</blockquote>
<h4 id="远程代理">远程代理</h4>
<h6 id="动机">动机</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>客户端程序可以访问在远程主机上的对象</mark>，远程主机可能具有更好的计算性能与处理速度，可以快速地响应并处理客户端的请求</p>
</li>
<li class="lvl-2">
<p>可以<mark>将网络的细节隐藏起来</mark>，使得客户端不必考虑网络的存在</p>
</li>
<li class="lvl-2">
<p>客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而<mark>远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用</mark></p>
</li>
</ul>
<h6 id="结构">结构</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221212204422569.png" alt="image-20221212204422569"></p>
<blockquote>
<p>Java通过RMI实现远程代理</p>
</blockquote>
<h4 id="虚拟代理">虚拟代理</h4>
<h6 id="动机">动机</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于一些<mark>占用系统资源较多或者加载时间较长的对象</mark>，可以给这些对象提供一个虚拟代理</p>
</li>
<li class="lvl-2">
<p>在真实对象创建成功之前<mark>虚拟代理扮演真实对象的替身</mark>，而当真实对象创建之后，<mark>虚拟代理将用户的请求转发给真实对象</mark></p>
</li>
<li class="lvl-2">
<p>使用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能</p>
</li>
</ul>
<h6 id="应用">应用</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象（结合多线程技术）</p>
</li>
<li class="lvl-2">
<p>一个对象的加载十分耗费系统资源，让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象</p>
</li>
</ul>
<h4 id="java动态代理">Java动态代理</h4>
<h6 id="概述">概述</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>动态代理(Dynamic Proxy)可以让系统在运行时根据实际需要来动态创建代理类，<mark>让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法</mark></p>
</li>
<li class="lvl-2">
<p>Java语言提供了对动态代理的支持，Java语言实现动态代理时需要用到位于java.lang.reflect包中的一些类</p>
</li>
</ul>
<h3 id="模式优点：共有优点">模式优点：共有优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>能够<mark>协调调用者和被调用者</mark>，在一定程度上==<u>降低</u>了系统的<u>耦合度</u>==</p>
</li>
<li class="lvl-2">
<p>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，<mark>符合开闭原则</mark>，<u>系统具有较好的灵活性和可扩展性</u></p>
</li>
</ul>
<h3 id="模式优点：不同类型">模式优点：不同类型</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark><u>远程代理</u></mark>：可以将一些消耗资源较多的对象和操作<mark>移至性能更好的计算机上</mark>，<mark>提高了系统的整体运行效率</mark></p>
</li>
<li class="lvl-2">
<p><mark><u>虚拟代理</u></mark>：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在<mark>一定程度上节省系统的运行开销</mark></p>
</li>
<li class="lvl-2">
<p><mark><u>缓冲代理</u></mark>：为某一个操作的结果<mark>提供临时的缓存存储空间</mark>，以便在后续使用中能够<u><strong>共享这些结果</strong></u>，<mark>优化系统性能，缩短执行时间</mark></p>
</li>
<li class="lvl-2">
<p><mark><u>保护代理</u></mark>：可以控制对一个对象的<u><strong>访问权限</strong></u>，为不同用户<mark>提供不同级别的使用权限</mark></p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于在客户端和真实主题之间增加了代理对象，因此<mark>有些类型的代理模式可能会造成请求的处理速度变慢</mark>（例如保护代理）</p>
</li>
<li class="lvl-2">
<p>实现代理模式需要额外的工作，而且<mark>有些代理模式的实现过程较为复杂</mark>（例如远程代理）</p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>当客户端对象<mark>需要访问远程主机中的对象</mark>时可以使用<u><strong>远程代理</strong></u></p>
</li>
<li class="lvl-2">
<p>当需要用一个<mark>消耗资源较少的对象来代表一个消耗资源较多的对象</mark>，从而降低系统开销、缩短运行时间时可以使用<u><strong>虚拟代理</strong></u></p>
</li>
<li class="lvl-2">
<p>当需要<mark>为某一个被频繁访问的操作结果提供一个临时存储空间</mark>，以供多个客户端共享访问这些结果时可以使用<u><strong>缓冲代理</strong></u></p>
</li>
<li class="lvl-2">
<p>当需要<mark>控制对一个对象的访问</mark>，为不同用户提供不同级别的访问权限时可以使用<u><strong>保护代理</strong></u></p>
</li>
<li class="lvl-2">
<p>当需要<mark>为一个对象的访问（引用）提供一些额外的操作</mark>时可以使用<u><strong>智能引用代理</strong></u></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>14-命令模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/14-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>命令模式</h1>
<h4 id="分析">分析</h4>
<blockquote>
<p><strong>开关与电灯、排气扇示意图</strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213203820194.png" alt="image-20221213203820194"></p>
<h5 id="分析">分析</h5>
<p><strong>现实生活</strong></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>相同的开关可以通过不同的电线来控制不同的电器</p>
</li>
<li class="lvl-2">
<p>开关 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟷</mo></mrow><annotation encoding="application/x-tex">\longleftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟷</span></span></span></span> 请求发送者</p>
</li>
<li class="lvl-2">
<p>电灯 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟷</mo></mrow><annotation encoding="application/x-tex">\longleftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟷</span></span></span></span>请求的最终接收者和处理者</p>
</li>
<li class="lvl-2">
<p>开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213204319815.png" alt="image-20221213204319815"></p>
<p><u><span style="color: red;">发送者与接受者彻底地解耦</span></u></p>
<h5 id="动机">动机</h5>
<ul class="lvl-1">
<li class="lvl-2">
<p>将请求发送者和接收者<mark>完全解耦</mark></p>
</li>
<li class="lvl-2">
<p>发送者与接收者之间<mark>没有直接引用关系</mark></p>
</li>
<li class="lvl-2">
<p>发送请求的对象<mark>只需要知道如何发送请求</mark>，而<mark>不必知道如何完成请求</mark></p>
</li>
</ul>
</blockquote>
<h3 id="命令模式的定义">命令模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219190624768.png" alt="image-20221219190624768"></p>
<blockquote>
<p><mark>对象行为型模式</mark></p>
<p><u>命令对象</u></p>
<p>也可以处理一系列请求操作</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>别名为<mark>动作(Action)模式</mark>或<mark>事务(Transaction)模式</mark></p>
</li>
<li class="lvl-2">
<p>“用不同的请求对客户进行参数化”</p>
</li>
<li class="lvl-2">
<p>“对请求排队”</p>
<ul class="lvl-2">
<li class="lvl-4">多个命令存入队列中</li>
</ul>
</li>
<li class="lvl-2">
<p>“记录请求日志”</p>
</li>
<li class="lvl-2">
<p>“支持可撤销操作”</p>
</li>
</ul>
<h4 id="命令模式结构">命令模式结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219191436230.png" alt="image-20221219191436230"></p>
<h5 id="命令模式包含以下4个角色：">命令模式包含以下4个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Command（抽象命令类）</p>
</li>
<li class="lvl-2">
<p>ConcreteCommand（具体命令类）</p>
</li>
<li class="lvl-2">
<p>Invoker（调用者/发送者）</p>
</li>
<li class="lvl-2">
<p>Receiver（接收者）</p>
</li>
</ul>
<h5 id="命令模式实现">命令模式实现</h5>
<ol>
<li class="lvl-3">
<p>命令模式的本质是对<mark>请求进行封装</mark></p>
</li>
<li class="lvl-3">
<p><mark>一个请求对应于一个命令</mark>，将发出命令的责任和执行命令的责任<mark>分开</mark></p>
</li>
<li class="lvl-3">
<p>命令模式允许请求的一方和接收的一方<mark>独立开来</mark>，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的</p>
</li>
</ol>
<h5 id="典型的抽象命令类代码">典型的抽象命令类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的调用者-请求发送者-类代码">典型的调用者（请求发送者）类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="comment">//构造注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设值注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//业务方法，用于调用命令类的execute()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体命令类代码">典型的具体命令类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver; <span class="comment">//维持一个对请求接收者对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action(); <span class="comment">//调用请求接收者的业务处理方法action()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><u><em><strong>具体命令类可以与接受者类之间是聚合关系或是组合关系</strong></em></u></p>
</blockquote>
<h5 id="典型的请求接收者类代码">典型的请求接收者类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图：">实例类图：</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219192943937.png" alt="image-20221219192943937"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219192955525.png" alt="image-20221219192955525"></p>
<blockquote>
<p>(1) FunctionButton：功能键类，充当请求调用者（请求发送者）</p>
<p>(2) Command：抽象命令类</p>
<p>(3) ExitCommand：退出命令类，充当具体命令类</p>
<p>(4) HelpCommand：帮助命令类，充当具体命令类</p>
<p>(5) SystemExitClass：退出系统模拟实现类，充当请求接收者</p>
<p>(6) DisplayHelpClass：显示帮助文档模拟实现类，充当请求接收者</p>
<p>(7) Client：客户端测试类</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>如果需要更换具体命令类，无须修改源代码，<mark>只需修改配置文件</mark>，<span style="color: red;">完全符合开闭原则</span></p>
</li>
<li class="lvl-2">
<p>每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使相同的发送者对应不同的接收者，从而实现“<u><strong>将一个请求封装为一个对象，用不同的请求对客户进行参数化</strong></u>”，<u>客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者</u></p>
</li>
</ul>
</blockquote>
<h5 id="配置文件">配置文件</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.command.ExitCommand<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实现命令队列">实现命令队列</h3>
<h6 id="动机">动机</h6>
<ol>
<li class="lvl-3">
<p>当一个请求发送者发送一个请求时，<mark>有不止一个请求接收者产生响应</mark>，<u>这些请求接收者将逐个执行业务方法，完成对请求的处理</u></p>
</li>
<li class="lvl-3">
<p>增加一个<mark>CommandQueue类</mark>，由该类负责<mark>存储多个命令对象</mark>，而不同的命令对象可以对应不同的请求接收者</p>
</li>
<li class="lvl-3">
<p><mark>批处理</mark></p>
</li>
</ol>
<h5 id="commandqueue类实现代码">CommandQueue类实现代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandQueue</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个ArrayList来存储命令队列</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Command&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        commands.remove(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环调用每一个命令对象的execute()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object command : commands) &#123;</span><br><span class="line">            ((Command)command).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="相应的发送者代码">相应的发送者代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个CommandQueue对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> CommandQueue commandQueue; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造注入	</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(CommandQueue commandQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>. commandQueue = commandQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设值注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommandQueue</span> <span class="params">(CommandQueue commandQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.commandQueue = commandQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用CommandQueue类的execute()方法	</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        commandQueue.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><u>可以用顺序图来展现对象调用的顺序</u></p>
</blockquote>
<h3 id="记录请求日志">记录请求日志</h3>
<h6 id="动机">动机</h6>
<ol>
<li class="lvl-3">
<p><mark>将请求的历史记录保存下来</mark>，通常<mark>以日志文件</mark>(Log File)的形式<mark>永久存储在计算机中</mark></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>为系统提供一种<mark>恢复机制</mark></p>
</li>
<li class="lvl-5">
<p>可以用于<mark>实现批处理</mark></p>
</li>
<li class="lvl-5">
<p><mark>防止因为断电或者系统重启等原因造成请求丢失</mark>，而且可以<mark>避免重新发送全部请求时造成某些命令的重复执行</mark></p>
</li>
</ul>
</li>
</ol>
<h5 id="实现">实现</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>将发送<u>请求的命令对象</u><mark>通过序列化写到</mark><u>日志文件中</u></p>
</li>
<li class="lvl-2">
<p>命令类必须<mark>实现接口Serializable</mark></p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219194349557.png" alt="image-20221219194349557"></p>
<h3 id="实现撤销操作">实现撤销操作</h3>
<h6 id="实例类图">实例类图</h6>
<ol>
<li class="lvl-3">
<p>可以通过对命令类进行修改使得系统支持==撤销(Undo)<mark>操作和</mark>恢复(Redo)==操作</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219194520157.png" alt="image-20221219194520157"></p>
<p>类图结构：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219194544170.png" alt="image-20221219194544170"></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>加法类：Adder（请求接收者）</p>
</li>
<li class="lvl-2">
<p>抽象命令类：AbstractCommand</p>
</li>
<li class="lvl-2">
<p>加法命令类：AddCommand（具体命令类）</p>
</li>
<li class="lvl-2">
<p>计算器界面类：CalculatorForm（请求发送者）</p>
</li>
<li class="lvl-2">
<p>客户端测试类：Client</p>
</li>
</ul>
<p>不同的场景所实现Undo或Redo的方式不同</p>
</blockquote>
<h3 id="宏命令">宏命令</h3>
<h6 id="动机">动机</h6>
<ol>
<li class="lvl-3">
<p><mark>宏命令(Macro Command)<mark>又称为</mark>组合命令(Composite Command)</mark>，它是<u><em><strong>组合模式和命令模式联用的产物</strong></em></u></p>
</li>
<li class="lvl-3">
<p>宏命令是一个具体命令类，它<mark>拥有一个集合</mark>，在该集合中包含了对其他命令对象的引用</p>
</li>
<li class="lvl-3">
<p>当调用宏命令的execute()方法时，将<mark>递归调用它所包含的每个成员命令的execute()方法</mark>。<u>一个宏命令的成员可以是简单命令，还可以继续是宏命令</u></p>
</li>
<li class="lvl-3">
<p>执行一个宏命令将触发多个具体命令的执行，从而<mark>实现对命令的批处理</mark></p>
</li>
</ol>
<h4 id="类图结构">类图结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219195123146.png" alt="image-20221219195123146"></p>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>降低系统的耦合度</mark></p>
</li>
<li class="lvl-2">
<p>新的命令可以很容易地加入到系统中，<mark>符合开闭原则</mark></p>
</li>
<li class="lvl-2">
<p>可以比较容易地设计一个<mark>命令队列或宏命令（组合命令）</mark></p>
</li>
<li class="lvl-2">
<p>为请求的<mark>撤销(Undo)和恢复(Redo)操作</mark>提供了一种设计和实现方案</p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用命令模式<mark>可能会导致某些系统有过多的具体命令类</mark>（<u>针对每一个对请求接收者的调用操作都需要设计一个具体命令类</u>）</p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统需要<mark>将请求调用者和请求接收者解耦</mark>，使得调用者和接收者不直接交互</p>
</li>
<li class="lvl-2">
<p>系统需要在<mark>不同的时间指定请求、将请求排队和执行请求</mark></p>
</li>
<li class="lvl-2">
<p>系统需要支持<mark>命令的撤销(Undo)操作和恢复(Redo)操作</mark></p>
</li>
<li class="lvl-2">
<p>系统需要将一组操作组合在一起形成<mark>宏命令</mark></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>13-职责链模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/13-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>职责链模式</h1>
<h4 id="行为型模式">行为型模式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>行为型模式(Behavioral Pattern)关注系统中<u><em><strong>对象之间的交互</strong></em></u>，研究系统在运行时<mark>对象之间的相互通信与协作</mark>，<mark>进一步明确对象的职责</mark></p>
</li>
<li class="lvl-2">
<p>行为型模式：不仅仅关注类和对象本身，<u>还重点关注它们之间的<mark>相互作用</mark>和<mark>职责划分</mark></u></p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213193005339.png" alt="image-20221213193005339" style="zoom:50%;" />
<blockquote>
<p>红绿灯（事件源）……？</p>
</blockquote>
<h4 id="行为型模式分类">行为型模式分类</h4>
<h5 id="类行为型模式">类行为型模式</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用<mark>继承关系</mark>在几个类之间分配行为，主要<mark>通过多态</mark>等方式来<u>分配父类与子类的职责</u></p>
</li>
</ul>
<h5 id="对象行为型模式">对象行为型模式</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用对象的<mark>关联关系</mark>来分配行为，主要<mark>通过对象关联</mark>等方式来<u>分配两个或多个类的职责</u></p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213192943236.png" alt="image-20221213192943236"></p>
<blockquote>
<p>按钮（观察目标）</p>
</blockquote>
<h4 id="行为型模式一览表">行为型模式一览表<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213193254191.png" alt="image-20221213193254191"></h4>
<blockquote>
<p><u><strong>中介者模式</strong></u>——QQ好友与群组之间错综复杂的关系</p>
<p><u><strong>状态模式——自学</strong></u></p>
</blockquote>
<h3 id="职责链模式">职责链模式</h3>
<h6 id="实例分析">实例分析</h6>
<blockquote>
<p><strong>奖学金审批示意图</strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213193735975.png" alt="image-20221213193735975"></p>
<p><strong>分析</strong></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>辅导员、系主任、院长、校长都可以处理奖学金申请表，他们构成一个处理申请表的链式结构，申请表沿着这条链进行传递，这条链就称为职责链</p>
</li>
<li class="lvl-2">
<p>职责链可以是<mark>一条直线、一个环或者一个树形结构</mark>，<u>最常见的职责链是直线型</u>，即沿着一条单向的链来传递请求</p>
</li>
</ul>
<p>纯职责链：在一个链式结构上<mark>只有一个对象能够执行处理</mark>，<strong>处理之后不再往下传递</strong></p>
<p>非纯职责链：在一个链式结构上可能存在一个对象处理之后发送到下一个对象进行处理……</p>
</blockquote>
<h3 id="职责链模式的定义">职责链模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213194341042.png" alt="image-20221213194341042"></p>
<blockquote>
<p><mark>对象行为型模式</mark></p>
<p><span style="color: red;">标准职责链模式是纯职责链模式</span></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>将<mark>请求的处理者组织成一条</mark>链，并<mark>让请求沿着链传递</mark>，由链上的处理者对请求进行相应的处理</p>
</li>
<li class="lvl-2">
<p><mark>客户端无须关心请求的处理细节以及请求的传递</mark>，只需将请求发送到链上，<u><em><strong>将请求的发送者和请求的处理者解耦</strong></em></u></p>
</li>
</ul>
</blockquote>
<h4 id="职责链模式结构">职责链模式结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213194640323.png" alt="image-20221213194640323"></p>
<blockquote>
<p>处理流程：当前实体ConcreteHandler先判断是否能够处理，如果不能处理则转发给下一个ConcreteHandler</p>
</blockquote>
<h5 id="职责链模式包含以下2个角色：">职责链模式包含以下2个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Handler（抽象处理者）</p>
</li>
<li class="lvl-2">
<p>ConcreteHandler（具体处理者）</p>
</li>
</ul>
<h5 id="典型的抽象处理者代码">典型的抽象处理者代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">//维持对下家的引用</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体处理者代码">典型的具体处理者代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (请求满足条件) &#123;</span><br><span class="line">            <span class="comment">//处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.successor.handleRequest(request); <span class="comment">//转发请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的客户端代码">典型的客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">Handler handler1, handler2, handler3;</span><br><span class="line">handler1 = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerA</span>();</span><br><span class="line">handler2 = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerB</span>();</span><br><span class="line">handler3 = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerC</span>();</span><br><span class="line"><span class="comment">//创建职责链</span></span><br><span class="line">handler1.setSuccessor(handler2);</span><br><span class="line">handler2.setSuccessor(handler3);</span><br><span class="line"><span class="comment">//发送请求，请求对象通常为自定义类型</span></span><br><span class="line">handler1.handleRequest(<span class="string">&quot;请求对象&quot;</span>);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213200557529.png" alt="image-20221213200557529"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213200610437.png" alt="image-20221213200610437"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213200617709.png" alt="image-20221213200617709"></p>
<blockquote>
<p>(1) PurchaseRequest：采购单类，充当请求类</p>
<p>(2) Approver：审批者类，充当抽象处理者</p>
<p>(3) Director：主任类，充当具体处理者</p>
<p>(4) VicePresident：副董事长类，充当具体处理者</p>
<p>(5) President：董事长类，充当具体处理者</p>
<p>(6) Congress：董事会类，充当具体处理者</p>
<p>(7) Client：客户端测试类</p>
</blockquote>
<h5 id="结果及分析">结果及分析</h5>
<h6 id="增加一个经理-manager-角色">增加一个经理(Manager)角色</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经理类：具体处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//具体请求处理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getAmount() &lt; <span class="number">80000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;经理&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;审批采购单：&quot;</span> + request.getNumber() + <span class="string">&quot;，金额：&quot;</span> + request.getAmount() + <span class="string">&quot;元，采购目的：&quot;</span> + request.getPurpose() + <span class="string">&quot;。&quot;</span>);  <span class="comment">//处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.successor.processRequest(request);  <span class="comment">//转发请求</span></span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="修改客户端代码">修改客户端代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Approver rhuang;</span><br><span class="line">rhuang = <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line"><span class="comment">//创建职责链</span></span><br><span class="line">wjzhang.setSuccessor(rhuang);   <span class="comment">//将“黄蓉”作为“张无忌”的下家</span></span><br><span class="line">rhuang.setSuccessor(gyang);     <span class="comment">//将“杨过”作为“黄蓉”的下家</span></span><br><span class="line">gyang.setSuccessor(jguo);</span><br><span class="line">jguo.setSuccessor(meeting);</span><br></pre></td></tr></table></figure>
<h4 id="纯的职责链模式">纯的职责链模式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个具体处理者对象只能在两个行为中选择一个：<mark>要么承担全部责任，要么将责任推给下家</mark></p>
</li>
<li class="lvl-2">
<p><mark>不允许</mark>出现某一个具体处理者对象在<mark>承担了一部分或全部责任后又将责任向下传递的情况</mark></p>
</li>
<li class="lvl-2">
<p><mark>一个请求必须被某一个处理者对象所接收</mark>，<u><strong>不能出现某个请求未被任何一个处理者对象处理的情况</strong></u></p>
</li>
</ul>
<h4 id="不纯的职责链模式">不纯的职责链模式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>允许某个请求被一个具体处理者部分处理后向下传递</mark>，<u>或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</u></p>
</li>
<li class="lvl-2">
<p>一个请求<mark>可以最终不被任何处理者对象所接收并处理</mark></p>
</li>
<li class="lvl-2">
<p>JavaScript的<mark>事件浮升(Event Bubbling)处理机制</mark></p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221213202619514.png" alt="image-20221213202619514" style="zoom:50%;" />
<blockquote>
<p>不纯的职责链模式：onclick触发机制</p>
</blockquote>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>使得一个对象无须知道是其他哪一个对象处理其请求，<mark>降低了系统的耦合度</mark></p>
</li>
<li class="lvl-2">
<p><mark>可简化对象之间的相互连接</mark></p>
</li>
<li class="lvl-2">
<p>给对象<mark>职责的分配带来更多的灵活性</mark></p>
</li>
<li class="lvl-2">
<p>增加一个新的具体请求处理者时<mark>无须修改原有系统的代码</mark>，<u>只需要在客户端重新建链即可</u></p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>不能保证请求一定会被处理</mark></p>
</li>
<li class="lvl-2">
<p>对于比较长的职责链，<mark>系统性能将受到一定影响</mark>，在进行代码调试时不太方便</p>
</li>
<li class="lvl-2">
<p>如果建链不当，可能会造成循环调用，将<mark>导致系统陷入死循环</mark></p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>有多个对象可以处理同一个请求，<mark>具体哪个对象处理该请求待运行时刻再确定</mark></p>
</li>
<li class="lvl-2">
<p>在不明确指定接收者的情况下，<mark>向多个对象中的一个提交一个请求</mark></p>
</li>
<li class="lvl-2">
<p><mark>可动态指定一组对象处理请求</mark></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>17-策略模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/17-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>策略模式</h1>
<h4 id="分析">分析</h4>
<blockquote>
<h6 id="旅游出行方式示意图">旅游出行方式示意图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221195733839.png" alt="image-20221221195733839"></p>
<p>分析：</p>
<ol>
<li class="lvl-3">
<p>实现某个目标的途径不止一条，可根据实际情况选择一条合适的途径</p>
</li>
<li class="lvl-3">
<p>软件开发：</p>
<ul class="lvl-3">
<li class="lvl-5">
<p>多种算法，例如排序、查找、打折等</p>
</li>
<li class="lvl-5">
<p>使用硬编码(Hard Coding)实现将导致系统违背开闭原则，扩展性差，且维护困难</p>
</li>
<li class="lvl-5">
<p>可以定义一些独立的类来封装不同的算法，<u>每一个类封装一种具体的算法</u><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span><mark>策略类</mark></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="策略模式的定义">策略模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221200001069.png" alt="image-20221221200001069"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221201048957.png" alt="image-20221221201048957"></p>
<blockquote>
<p><mark>对象行为型模式</mark></p>
<ul class="lvl-1">
<li class="lvl-2">又称为<mark>政策(Policy)模式</mark></li>
<li class="lvl-2">每一个封装算法的类称之为<mark>策略(Strategy)类</mark></li>
<li class="lvl-2">策略模式提供了一种<mark>可插入式(Pluggable)算法的实现方案</mark>
<ul class="lvl-3">
<li class="lvl-4"><u><em>往算法中灵活地增加算法</em></u></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="策略模式结构">策略模式结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221200111909.png" alt="image-20221221200111909"></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><mark><u>完全符合开闭原则</u></mark></p>
</li>
</ul>
</blockquote>
<h5 id="策略模式包含以下3个角色：">策略模式包含以下3个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Context==（环境类）==</p>
</li>
<li class="lvl-2">
<p>Strategy（抽象策略类）</p>
</li>
<li class="lvl-2">
<p>ConcreteStrategy（具体策略类）</p>
</li>
</ul>
<h5 id="典型的抽象策略类代码">典型的抽象策略类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span>;  <span class="comment">//声明抽象算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体策略类代码">典型的具体策略类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//算法的具体实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//算法A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的环境类代码">典型的环境类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy; <span class="comment">//维持一个对抽象策略类的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入策略对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy= strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用策略类中的算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.algorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的客户端代码片段">典型的客户端代码片段</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">Strategy strategy;</span><br><span class="line">strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>(); <span class="comment">//可在运行时指定类型，通过配置文件和反射机制实现</span></span><br><span class="line">context.setStrategy(strategy);</span><br><span class="line">context.algorithm();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221200450612.png" alt="image-20221221200450612"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221200500413.png" alt="image-20221221200500413"></p>
<blockquote>
<p>(1) MovieTicket：电影票类，充当环境类</p>
<p>(2) Discount：折扣类，充当抽象策略类</p>
<p>(3) StudentDiscount：学生票折扣类，充当具体策略类</p>
<p>(4) ChildrenDiscount：儿童票折扣类，充当具体策略类</p>
<p>(5) VIPDiscount：VIP会员票折扣类，充当具体策略类</p>
<p>(6) Client：客户端测试类</p>
</blockquote>
<h6 id="结果及分析">结果及分析</h6>
<ol>
<li class="lvl-3">
<p>如果需要更换<mark>具体策略类</mark>，无须修改源代码，只需修改配置文件即可，完全<mark>符合开闭原则</mark></p>
</li>
</ol>
<h5 id="配置文件代码">配置文件代码</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.strategy.StudentDiscount<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="java-se中的布局管理">Java SE中的布局管理</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221200643103.png" alt="image-20221221200643103"></p>
<blockquote>
<p>容器中布局方法的切换：</p>
<ul class="lvl-1">
<li class="lvl-2">FlowLayout：流布局</li>
<li class="lvl-2">GridLayout：网格布局</li>
<li class="lvl-2">中间接口LayoutManager2：进行二次分类</li>
</ul>
</blockquote>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>提供了<mark>对开闭原则的完美支持</mark>，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为</p>
</li>
<li class="lvl-2">
<p>提供了<mark>管理相关的<u>算法族</u>的办法</mark></p>
</li>
<li class="lvl-2">
<p>提供了一种<mark>可以替换继承关系的办法</mark></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>也可以用继承实现：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221203733157.png" alt="image-20221221203733157"></p>
</li>
<li class="lvl-4">
<p>以上继承关系实现存在的缺陷：破坏封装性——子类的客户端代码可能会看到不需要的其它方法</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>可以<mark>避免多重条件选择语句</mark></p>
<ul class="lvl-2">
<li class="lvl-4">比如：if-else</li>
</ul>
</li>
<li class="lvl-2">
<p>提供了一种算法的<mark>复用机制</mark>，不同的环境类可以方便地复用策略类</p>
<ul class="lvl-2">
<li class="lvl-4"><u><em><strong>提高算法的保密性、安全性以及复用性</strong></em></u></li>
</ul>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端<mark>必须知道所有的策略类</mark>，并自行决定使用哪一个策略类</p>
</li>
<li class="lvl-2">
<p>将造成系统<mark>产生很多具体策略类</mark></p>
</li>
<li class="lvl-2">
<p><u><mark>无法同时在客户端使用多个策略类</mark></u></p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个系统<mark>需要动态地在几种算法中选择一种</mark></p>
</li>
<li class="lvl-2">
<p><u>避免使用难以维护的<mark>多重条件选择语句</mark></u></p>
</li>
<li class="lvl-2">
<p>不希望客户端知道复杂的、与<u>算法相关的数据结构</u>，<mark>提高算法的保密性与安全性</mark></p>
</li>
</ul>
<h4 id="课后思考">课后思考</h4>
<p>在策略模式中，一个环境类Context能否对应多个不同的策略等级结构？如何设计？</p>
<p>比如实际情景：飞机的多种起飞方式和多种飞行方式</p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221204729623.png" alt="image-20221221204729623"></p>
<p><u><em><strong>注意：区别于桥接模式</strong></em></u></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>15-观察者模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/15-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>观察者模式</h1>
<h4 id="分析">分析</h4>
<blockquote>
<h6 id="交通信号灯与汽车示意图">交通信号灯与汽车示意图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219202301412.png" alt="image-20221219202301412"></p>
<p>联动：两类对象之间的变化的联动</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>一对一的联动</p>
</li>
<li class="lvl-2">
<p>一对多的联动</p>
</li>
</ul>
<h6 id="分析">分析</h6>
<ul class="lvl-1">
<li class="lvl-2">
<p>交通信号灯<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">↔</span></span></span></span>观察目标</p>
</li>
<li class="lvl-2">
<p>汽车（汽车驾驶员）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">↔</span></span></span></span>观察者</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219202439035.png" alt="image-20221219202439035"></p>
<p><mark>一对多关系</mark></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>一个观察目标</p>
</li>
<li class="lvl-2">
<p>多个观察者</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p><strong>软件系统：</strong><mark>一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变</mark>，它们之间将<mark>产生联动</mark></p>
</li>
<li class="lvl-3">
<p><strong>观察者模式：</strong></p>
<ul class="lvl-3">
<li class="lvl-5">
<p>定义了对象之间一种<mark>一对多</mark>的依赖关系，让一个对象的改变能够影响其他对象</p>
</li>
<li class="lvl-5">
<p>发生改变的对象称为<mark>观察目标</mark>，被通知的对象称为<mark>观察者</mark></p>
</li>
<li class="lvl-5">
<p><u><em>一个观察目标可以对应多个观察者</em></u></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="观察者模式的定义">观察者模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219202955876.png" alt="image-20221219202955876"></p>
<blockquote>
<p><mark>对象行为型模式</mark></p>
<h6 id="别名"><mark>别名</mark></h6>
<ul class="lvl-1">
<li class="lvl-2">
<p>发布-订阅(Publish/Subscribe)模式</p>
<ul class="lvl-3">
<li class="lvl-4">比如：用户关注同一个公众号</li>
</ul>
</li>
<li class="lvl-2">
<p>模型-视图(Model/View)模式</p>
<ul class="lvl-3">
<li class="lvl-4">Model（观察目标）中的数据改变会导致View也发生变化（观察者）</li>
</ul>
</li>
<li class="lvl-2">
<p>源-监听器(Source/Listener)模式</p>
<ul class="lvl-3">
<li class="lvl-4">事件源（观察目标）</li>
<li class="lvl-4">监听器（观察者）</li>
</ul>
</li>
<li class="lvl-2">
<p>从属者(Dependents)模式</p>
</li>
</ul>
</blockquote>
<h4 id="观察者模式结构">观察者模式结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219203409264.png" alt="image-20221219203409264"></p>
<p>以上类图中两个部分不必要：</p>
<ol>
<li class="lvl-3">
<p>具体观察目标（ConcreteSubject）不必要</p>
</li>
<li class="lvl-3">
<p>具体观察者反向调用ConcreteSubject的关联关系不必要</p>
</li>
</ol>
<blockquote>
<p><u><em><strong>对于不同的观察者子类的update方法实现不同</strong></em></u></p>
<p><mark>最简单的观察者模式不需要ConcreteSubject类，即可实现一对多的关系！</mark></p>
<p>观察者在某些时候需要反向调用具体观察目标（ConcreteSubject）的状态数据等：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221219204003009.png" alt="image-20221219204003009"></p>
</blockquote>
<h5 id="观察者模式包含以下4个角色：">观察者模式包含以下4个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Subject（目标）</p>
</li>
<li class="lvl-2">
<p>ConcreteSubject（具体目标）</p>
</li>
<li class="lvl-2">
<p>Observer（观察者）</p>
</li>
<li class="lvl-2">
<p>ConcreteObserver（具体观察者）</p>
</li>
</ul>
<h5 id="典型的抽象目标类代码">典型的抽象目标类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个观察者集合用于存储所有观察者对象</span></span><br><span class="line">    <span class="keyword">protected</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册方法，用于向观察者集合中增加一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注销方法，用于在观察者集合中删除一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明抽象通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体目标类代码">典型的具体目标类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//实现通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历观察者集合，调用每一个观察者的响应方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers) &#123;</span><br><span class="line">            ((Observer)obs).update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的抽象观察者代码">典型的抽象观察者代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//声明响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体观察者代码">典型的具体观察者代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//实现响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体响应代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="说明：">说明：</h6>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>有时候在具体观察者类ConcreteObserver中需要使用到具体目标类ConcreteSubject中的状态（属性），会存在关联或依赖关系</p>
</li>
<li class="lvl-2">
<p>如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，<mark>在一定程度上违背了开闭原则</mark>，<u>但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响</u></p>
</li>
</ul>
</blockquote>
<h5 id="典型的客户端代码片段">典型的客户端代码片段</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line"><span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();</span><br><span class="line">subject.attach(observer); <span class="comment">//注册观察者</span></span><br><span class="line">subject.notify();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221191510214.png" alt="image-20221221191510214"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221191543280.png" alt="image-20221221191543280"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221191551207.png" alt="image-20221221191551207"></p>
<p><u>广播通信：一对多</u></p>
<p><u><em><strong>以上实例实现了一次<mark>一对一</mark>的联动，一次<mark>一对多</mark>的联动</strong></em></u></p>
<blockquote>
<p>(1) AllyControlCenter：指挥部（战队控制中心）类，充当抽象目标类</p>
<p>(2) ConcreteAllyControlCenter：具体指挥部类，充当具体目标类</p>
<p>(3) Observer：抽象观察者类</p>
<p>(4) Player：战队成员类，充当具体观察者类</p>
<p>(5) Client：客户端测试类</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221191936537.png" alt="image-20221221191936537"></p>
</blockquote>
<h4 id="jdk对观察者模式的支持">JDK对观察者模式的支持</h4>
<p>java.util.Observer以及java.util.Observable</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221192633066.png" alt="image-20221221192633066"></p>
<blockquote>
<p><u><em>Observable的Vector类型属性便于实现一对多的操作。</em></u></p>
</blockquote>
<h4 id="观察者模式与java事件处理">观察者模式与Java事件处理</h4>
<ol>
<li class="lvl-3">
<p><mark>事件源</mark>对象充当观察目标角色，<mark>事件监听器</mark>充当抽象观察者角色，<mark>事件处理对象</mark>充当具体观察者角色</p>
</li>
<li class="lvl-3">
<p>如果事件源对象的某个事件触发，则调用事件处理对象中的事件处理程序来对事件进行处理</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221192901167.png" alt="image-20221221192901167"></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>事件源(Event Source) ：<strong>Subject</strong></p>
<ul class="lvl-3">
<li class="lvl-4">例如：JButton，addActionListener()：注册方法；fireXXX()： 通知方法</li>
</ul>
</li>
<li class="lvl-2">
<p>事件监听器(Event Listener)：<strong>Observer</strong></p>
<ul class="lvl-3">
<li class="lvl-4">例如：ActionListener，actionPerformed()：响应方法</li>
</ul>
</li>
<li class="lvl-2">
<p>事件处理类(Event Handling Class)：<strong>ConcreteObserver</strong></p>
<ul class="lvl-3">
<li class="lvl-4">例如：LoginHandling：实现ActionListener接口</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221193014582.png" alt="image-20221221193014582"></p>
<h4 id="观察者模式与mvc">观察者模式与MVC</h4>
<h5 id="mvc-model-view-controller-架构">MVC(Model-View-Controller）架构</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>模型(Model)，视图(View)和控制器(Controller)</p>
</li>
<li class="lvl-2">
<p>模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者</p>
</li>
<li class="lvl-2">
<p>当模型层的数据发生改变时，视图层将自动改变其显示内容</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221193704264.png" alt="image-20221221193704264"></p>
<blockquote>
<p>模型层的数据就是观察目标，View就是观察者。当数据改变时，View中的图标也会跟随变化。</p>
</blockquote>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以实现<mark>表示层和数据逻辑层的分离</mark></p>
</li>
<li class="lvl-2">
<p>在观察目标和观察者之间<mark>建立一个抽象的耦合</mark></p>
<ul class="lvl-2">
<li class="lvl-4"><u>观察目标不一定需要抽象层，但观察者必须有抽象层</u></li>
</ul>
</li>
<li class="lvl-2">
<p>支持<mark>广播通信</mark>，<u>简化了一对多系统设计</u>的难度</p>
</li>
<li class="lvl-2">
<p><mark>符合开闭原则</mark>，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间<mark>不存在关联关系的情况下</mark>，<u>增加新的观察目标也很方便</u></p>
<ul class="lvl-2">
<li class="lvl-4">建立在具体层的关联关系可能会破坏开闭原则</li>
<li class="lvl-4"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221194310474.png" alt="image-20221221194310474"></li>
</ul>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>将所有的观察者都通知到会<mark>花费很多时间</mark></p>
</li>
<li class="lvl-2">
<p>如果存在<u><strong>循环依赖时可能导致系统崩溃</strong></u></p>
</li>
<li class="lvl-2">
<p><mark>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化</mark>的，而只是知道观察目标发生了变化</p>
<ul class="lvl-2">
<li class="lvl-4">形象来说：老鼠知道猫在叫，所以老鼠要跑，但是老鼠不知道猫为什么叫</li>
</ul>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>一个抽象模型有两个方面</strong></u>，其中<mark>一个方面依赖于另一个方面</mark>，将这两个方面封装在独立的对象中使它们<mark>可以各自独立地改变和复用</mark></p>
</li>
<li class="lvl-2">
<p><mark>一个对象的改变将导致一个或多个其他对象发生改变</mark>，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁</p>
<ul class="lvl-2">
<li class="lvl-4">一对一多的广播机制（一对多的联动）</li>
</ul>
</li>
<li class="lvl-2">
<p>需要在系统中<mark>创建一个触发链</mark></p>
<ul class="lvl-2">
<li class="lvl-4"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221221194810325.png" alt="image-20221221194810325"></li>
<li class="lvl-4"><strong><u><em>中间的对象将会即是观察者又是观察目标</em></u></strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>16-状态模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/16-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%87%AA%E5%AD%A6%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>状态模式</h1>
<h4 id="分析">分析</h4>
<blockquote>
<p>H<sub>2</sub>O的三种状态（未考虑临界点）</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211143306040.png" alt="image-20230211143306040"></p>
<p>1、在软件系统中：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>有些对象具有多种状态</p>
</li>
<li class="lvl-2">
<p>这些状态在某些情况下能够相互转换</p>
</li>
<li class="lvl-2">
<p>对象在不同的状态下将具有不同的行为</p>
</li>
</ul>
<p>2、复杂的条件判断语句来进行状态的判断和转换操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span> 导致代码的可维护性和灵活性下降 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span> 出现新的状态时，代码的扩展性很差，客户端代码也需要进行相应的修改，<mark>违背了开闭原则</mark></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestXYZ</span> &#123;</span><br><span class="line">    <span class="type">int</span> behaviour;</span><br><span class="line">    <span class="comment">//省略Getter和Setter方法</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (behaviour == <span class="number">0</span>)  &#123; </span><br><span class="line">            <span class="comment">//do something  &#125;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (behaviour == <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="comment">//do something  &#125;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (behaviour == <span class="number">2</span>) &#123; </span><br><span class="line">            <span class="comment">//do something  &#125;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (behaviour == <span class="number">3</span>) &#123; </span><br><span class="line">            <span class="comment">//do something &#125;</span></span><br><span class="line">        ... some more <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="状态模式的定义">状态模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211143719363.png" alt="image-20230211143719363"></p>
<blockquote>
<p><mark>对象行为型模式</mark></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>又名<mark>状态对象</mark>(Objects for States)</p>
</li>
<li class="lvl-2">
<p>用于<u>解决系统中复杂对象的状态转换以及不同状态下行为的封装问题</u></p>
</li>
<li class="lvl-2">
<p>将一个<mark>对象的状态从该对象中分离出来</mark>，<mark>封装到专门的状态类中</mark>，使得对象状态可以灵活变化</p>
</li>
<li class="lvl-2">
<p>对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，<mark>客户端都可以一致处理</mark></p>
</li>
</ul>
<h4 id="状态模式结构">状态模式结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211143932735.png" alt="image-20230211143932735"></p>
<h5 id="状态模式包含以下3个角色：">状态模式包含以下3个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Context（环境类）</p>
</li>
<li class="lvl-2">
<p>State（抽象状态类）</p>
</li>
<li class="lvl-2">
<p>ConcreteState（具体状态类）</p>
</li>
</ul>
<h5 id="典型的抽象状态类代码">典型的抽象状态类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">//声明抽象业务方法，不同的具体状态类可以有不同的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体状态类代码">典型的具体状态类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法具体实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的环境类代码">典型的环境类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state; <span class="comment">//维持一个对抽象状态对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;  <span class="comment">//其他属性值，该属性值的变化可能会导致对象的状态发生变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">        state.handle(); <span class="comment">//调用状态对象的业务方法</span></span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="状态模式实现">状态模式实现</h5>
<p>(1) 统一由环境类来负责状态之间的转换，<mark>环境类充当了状态管理器</mark>(State Manager)角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断属性值，根据属性值进行状态转换</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">	  <span class="built_in">this</span>.setState(<span class="keyword">new</span> <span class="title class_">ConcreteStateA</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">	  <span class="built_in">this</span>.setState(<span class="keyword">new</span> <span class="title class_">ConcreteStateB</span>());</span><br><span class="line">        &#125;</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>(2) 由<mark>具体状态类来负责状态之间的转换</mark>，可以在具体状态类的业务方法中判断环境类的某些属性值，再根据情况为环境类设置新的状态对象，实现状态转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeState</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="comment">//根据环境对象中的属性值进行状态转换</span></span><br><span class="line">        <span class="keyword">if</span> (ctx.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">            ctx.setState(<span class="keyword">new</span> <span class="title class_">ConcreteStateB</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctx.getValue() == <span class="number">2</span>) &#123;</span><br><span class="line">            ctx.setState(<span class="keyword">new</span> <span class="title class_">ConcreteStateC</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211144351815.png" alt="image-20230211144351815"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211144424371.png" alt="image-20230211144424371"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211144430035.png" alt="image-20230211144430035"></p>
<blockquote>
<p>(1) Account：银行账户，充当环境类</p>
<p>(2) AccountState：账户状态类，充当抽象状态类</p>
<p>(3) NormalState：正常状态类，充当具体状态类</p>
<p>(4) OverdraftState：透支状态类，充当具体状态类</p>
<p>(5) RestrictedState：受限状态类，充当具体状态类</p>
<p>(6) Client：客户端测试类</p>
</blockquote>
<h5 id="结果及分析">结果及分析</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">段誉开户，初始金额为<span class="number">0.0</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">段誉存款<span class="number">1000.0</span></span><br><span class="line">现在余额为<span class="number">1000.0</span></span><br><span class="line">现在帐户状态为designpatterns.state.NormalState</span><br><span class="line">---------------------------------------------</span><br><span class="line">段誉取款<span class="number">2000.0</span></span><br><span class="line">现在余额为-<span class="number">1000.0</span></span><br><span class="line">现在帐户状态为designpatterns.state.OverdraftState</span><br><span class="line">---------------------------------------------</span><br><span class="line">段誉存款<span class="number">3000.0</span></span><br><span class="line">现在余额为<span class="number">2000.0</span></span><br><span class="line">现在帐户状态为designpatterns.state.NormalState</span><br><span class="line">---------------------------------------------</span><br><span class="line">段誉取款<span class="number">4000.0</span></span><br><span class="line">现在余额为-<span class="number">2000.0</span></span><br><span class="line">现在帐户状态为designpatterns.state.RestrictedState</span><br><span class="line">---------------------------------------------</span><br><span class="line">段誉取款<span class="number">1000.0</span></span><br><span class="line">帐号受限，取款失败</span><br><span class="line">现在余额为-<span class="number">2000.0</span></span><br><span class="line">现在帐户状态为designpatterns.state.RestrictedState</span><br><span class="line">---------------------------------------------</span><br><span class="line">计算利息！</span><br></pre></td></tr></table></figure>
<h4 id="共享状态">共享状态</h4>
<h5 id="动机">动机</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>在有些情况下，<mark>多个环境对象可能需要共享同一个状态</mark></p>
</li>
<li class="lvl-2">
<p>如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象<mark>定义为环境类的静态成员对象</mark></p>
</li>
</ul>
<h6 id="开关的状态设计结构图">开关的状态设计结构图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211144705592.png" alt="image-20230211144705592"></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>开关类：Switch（环境类）</p>
</li>
<li class="lvl-2">
<p>开关状态类：SwitchState （抽象状态类）</p>
</li>
<li class="lvl-2">
<p>打开状态类：OnState（具体状态类）</p>
</li>
<li class="lvl-2">
<p>关闭状态类：OffState （具体状态类）</p>
</li>
<li class="lvl-2">
<p>客户端测试类：Client</p>
</li>
</ul>
</blockquote>
<h4 id="使用环境类实现状态转换">使用环境类实现状态转换</h4>
<h5 id="动机">动机</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于客户端而言，<mark>无须关心状态类</mark>，可以<mark>为环境类设置默认的状态类</mark>，将状态的转换工作交给环境类（或具体状态类）来完成，具体的转换细节对于客户端而言是透明的</p>
</li>
<li class="lvl-2">
<p>可以通过环境类来实现状态转换，<mark>环境类作为一个状态管理器</mark>，统一实现各种状态之间的转换操作</p>
</li>
</ul>
<h6 id="实例类图">实例类图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211145010503.png" alt="image-20230211145010503"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211145016630.png" alt="image-20230211145016630"></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>屏幕类：Screen （环境类）</p>
</li>
<li class="lvl-2">
<p>抽象状态类：State</p>
</li>
<li class="lvl-2">
<p>正常状态类：NormalState （具体状态类）</p>
</li>
<li class="lvl-2">
<p>二倍状态类：LargerState （具体状态类）</p>
</li>
<li class="lvl-2">
<p>四倍状态类：LargestState （具体状态类）</p>
</li>
<li class="lvl-2">
<p>客户端测试类：Client</p>
</li>
</ul>
</blockquote>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>封装了状态的转换规则</mark>，可以<mark>对状态转换代码进行集中管理</mark>，而不是分散在一个个业务方法中</p>
</li>
<li class="lvl-2">
<p>将所有与某个状态有关的行为放到一个类中，<u>只需要注入一个不同的状态对象即可使环境对象拥有不同的行为</u></p>
</li>
<li class="lvl-2">
<p>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起</p>
</li>
<li class="lvl-2">
<p><mark>可以让多个环境对象共享一个状态对象</mark>，从而减少系统中对象的个数</p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>会增加系统中类和对象的个数，<mark>导致系统运行开销增大</mark></p>
</li>
<li class="lvl-2">
<p><mark>结构与实现都较为复杂</mark>，如果使用不当将导致程序结构和代码混乱，增加系统设计的难度</p>
</li>
<li class="lvl-2">
<p><mark>对开闭原则的支持并不太好</mark>，<u>增加新的状态类需要修改负责状态转换的源代码</u>，否则无法转换到新增状态；而且<u>修改某个状态类的行为也需要修改对应类的源代码</u></p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>对象的行为依赖于它的状态</mark>（例如某些属性值），<mark>状态的改变将导致行为的变化</mark></p>
</li>
<li class="lvl-2">
<p><mark>在代码中包含大量与对象状态有关的条件语句</mark>，<u>这些条件语句的出现会导致代码的可维护性和灵活性变差</u>，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2-工厂方法模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>工厂方法模式</h1>
<blockquote>
<p>参考：</p>
</blockquote>
<h3 id="工厂方法模式的定义">工厂方法模式的定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121190626440.png" alt="image-20221121190626440" style="zoom:50%;" />
<blockquote>
<p>通常而言的<mark>使用了工厂</mark>指的就是<mark>工厂方法模式</mark></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>简称为<mark>工厂模式(Factory Pattern)</mark></p>
</li>
<li class="lvl-2">
<p>又可称作<mark>虚拟构造器模式</mark>(Virtual Constructor Pattern)或<mark>多态工厂模式</mark>(Polymorphic Factory Pattern)</p>
</li>
<li class="lvl-2">
<p><u>工厂父类负责定义创建产品对象的公共接口</u>，而<u>工厂子类则负责生成具体的产品对象</u></p>
</li>
<li class="lvl-2">
<p>目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类</p>
</li>
</ul>
<h4 id="工厂方法模式结构">工厂方法模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121191000614.png" alt="image-20221121191000614" style="zoom:50%;" />
<h5 id="工厂方法模式包含以下角色">工厂方法模式包含以下角色</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Product（抽象产品）</p>
</li>
<li class="lvl-2">
<p>ConcreteProduct（具体产品）</p>
</li>
<li class="lvl-2">
<p>Factory（抽象工厂）</p>
</li>
<li class="lvl-2">
<p>ConcreteFactory（具体工厂）</p>
</li>
</ul>
<h6 id="典型的抽象工厂类代码">典型的抽象工厂类代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="典型的具体工厂类代码">典型的具体工厂类代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="典型的客户端代码片段">典型的客户端代码片段</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">Factory factory;</span><br><span class="line">factory = <span class="keyword">new</span> <span class="title class_">ConcreteFactory</span>(); <span class="comment">//可通过配置文件和反射机制实现</span></span><br><span class="line">Product product;</span><br><span class="line">product = factory.factoryMethod();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="实例类图1：">实例类图1：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121191924490.png" alt="image-20221121191924490" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121192203153.png" alt="image-20221121192203153" style="zoom:50%;" />
<blockquote>
<p>具体关键代码见书P46</p>
<p>(1) Logger：日志记录器接口，充当抽象产品角色</p>
<p>(2) DatabaseLogger：数据库日志记录器，充当具体产品角色</p>
<p>(3) FileLogger：文件日志记录器，充当具体产品角色</p>
<p>(4) LoggerFactory：日志记录器工厂接口，充当抽象工厂角色</p>
<p>(5) DatabaseLoggerFactory：数据库日志记录器工厂类，充当具体工厂角色</p>
<p>(6) FileLoggerFactory：文件日志记录器工厂类，充当具体工厂角色</p>
<p>(7) Client：客户端测试类</p>
</blockquote>
<h3 id="java反射机制-java-reflection">Java反射机制(Java Reflection)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Java反射(Java Reflection)是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等</p>
</li>
<li class="lvl-2">
<p>Class类的实例表示正在运行的Java应用程序中的类和接口，其<code>forName(String className)</code>方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过Class对象的<code>newInstance()</code>方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">Class c=Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">Object obj=c.newInstance();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>java父类转换成子类需要使用<code>(Type)obj</code>进行强制转换。</p>
<p>java类型强制转换只有<mark>自己转成自己的类型</mark>和<mark>转换成父类的类型</mark>是安全的。<u><strong>只有这两种转换方式不会报错。</strong></u></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>原本是==Object类型（最大父类型）==的实例可以转换成任何类型。</p>
</li>
</ul>
</blockquote>
<h3 id="配置文件">配置文件</h3>
<h5 id="配置文件">配置文件</h5>
<p>//存储类名：<mark>包名.类名</mark></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!— config.xml --&gt;</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.factorymethod.FileLoggerFactory<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="xmlutil-java文件">XMLUtil.java文件</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XMLUtil.java</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建DOM文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;							</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src//designpatterns//factorymethod//config.xml&quot;</span>)); </span><br><span class="line">		</span><br><span class="line">            <span class="comment">//获取包含类名的文本结点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String cName=classNode.getNodeValue();</span><br><span class="line">          </span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class c=Class.forName(cName);</span><br><span class="line">            Object obj=c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="客户端代码">客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    LoggerFactory factory;	<span class="comment">//将LoggerFactory作为参数类型（只有作类属性的时候才是关联），所以是依赖关系</span></span><br><span class="line">    Logger logger;	<span class="comment">//将Logger作为参数类型，所以是依赖关系</span></span><br><span class="line">    factory = (LoggerFactory)XMLUtil.getBean(); <span class="comment">//getBean()的返回类型为Object，需要进行强制类型转换</span></span><br><span class="line">    logger = factory.createLogger();</span><br><span class="line">    logger.writeLog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<u>简单的反射</u>创建工厂，再由工厂创建复杂的对象（产品）</p>
<p><u><strong>配置文件是纯文本文件，不需要编译。</strong></u></p>
</blockquote>
<h4 id="增加新产品的步骤">增加新产品的步骤</h4>
<p>(1) 增加一个新的具体产品类作为抽象产品类的子类</p>
<p>(2) 增加一个新的具体工厂类作为抽象工厂类的子类，该工厂用于创建新增的具体产品对象</p>
<p>(3) 修改配置文件，用新的具体工厂类的类名字符串替换原有工厂类类名字符串</p>
<p>(4) 编译新增具体产品类和具体工厂类，运行客户端代码，即可完成新产品的增加和使用</p>
<p><mark>以上完全符合开闭原则</mark></p>
<h3 id="工厂方法的重载">工厂方法的重载</h3>
<h5 id="结构图">结构图</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121195730772.png" alt="image-20221121195730772" style="zoom:50%;" />
<h5 id="抽象工厂类loggerfactory示意代码">抽象工厂类LoggerFactory示意代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体工厂类databaseloggerfactory示意代码">具体工厂类DatabaseLoggerFactory示意代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">//使用默认方式连接数据库，代码省略</span></span><br><span class="line">	    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line">	    <span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line">	    <span class="keyword">return</span> logger;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span> &#123;</span><br><span class="line">	    <span class="comment">//使用参数args作为连接字符串来连接数据库，代码省略</span></span><br><span class="line">	    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line">	    <span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line">	    <span class="keyword">return</span> logger;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	    <span class="comment">//使用封装在参数obj中的连接字符串来连接数据库，代码省略</span></span><br><span class="line">	    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line">	    <span class="comment">//使用封装在参数obj中的数据来初始化数据库日志记录器，代码省略</span></span><br><span class="line">	    <span class="keyword">return</span> logger;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他具体工厂类代码省略</span></span><br></pre></td></tr></table></figure>
<h3 id="工厂方法的隐藏">工厂方法的隐藏</h3>
<blockquote>
<p>违反了<mark>单一职责原则</mark></p>
<ol>
<li class="lvl-3">目的：为了进一步简化客户端的使用</li>
<li class="lvl-3">实现：在工厂类中直接调用产品类的业务方法，客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法</li>
</ol>
</blockquote>
<h5 id="结构图">结构图</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121200102222.png" alt="image-20221121200102222" style="zoom:50%;" />
<h5 id="抽象工厂类loggerfactory示意代码">抽象工厂类LoggerFactory示意代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将接口改为抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="comment">//在工厂类中直接调用日志记录器类的业务方法writeLog()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="built_in">this</span>.createLogger();</span><br><span class="line">        logger.writeLog();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端代码">客户端代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        LoggerFactory factory;</span><br><span class="line">        factory = (LoggerFactory)XMLUtil.getBean();</span><br><span class="line">        factory.writeLog(); <span class="comment">//直接使用工厂对象来调用产品对象的业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>工厂方法用来创建客户所需要的产品，同时还向客户<u>隐藏了哪种具体产品类将被实例化这一细节</u></p>
</li>
<li class="lvl-2">
<p>能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部</p>
<ul class="lvl-2">
<li class="lvl-4">符合<mark>单一职责原则</mark></li>
<li class="lvl-4"><u><strong>每个工厂只负责一个产品的创建</strong></u></li>
</ul>
</li>
<li class="lvl-2">
<p>在系统中加入新产品时，<mark>完全符合开闭原则</mark></p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统中<strong>类的个数将成对增加</strong>，在一定程度上<strong>增加了系统的复杂度</strong>，会给系统<strong>带来一些额外的开销</strong></p>
</li>
<li class="lvl-2">
<p><strong>增加了系统的抽象性和理解难度</strong></p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端不知道它所需要的对象的类（客户端<mark>不需要知道具体产品类的类名</mark>，<u>只需要知道所对应的工厂即可</u>，具体产品对象由具体工厂类创建）</p>
<ul class="lvl-2">
<li class="lvl-4">每个工厂只负责一个产品的创建，<mark>换了工厂就换了产品</mark></li>
</ul>
</li>
<li class="lvl-2">
<p>抽象工厂类<mark>通过其子类来指定创建哪个对象</mark></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>3-抽象工厂模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>抽象工厂模式</h1>
<blockquote>
<p>详细参考：<a href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html">抽象工厂模式 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h4 id="工厂模式对比">工厂模式对比</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>工厂方法模式</p>
<ul class="lvl-2">
<li class="lvl-4">每个具体工厂只有一个或者一组重载的工厂方法，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销</li>
</ul>
</li>
<li class="lvl-2">
<p>抽象工厂模式</p>
<ul class="lvl-2">
<li class="lvl-4"><u>一个工厂可以生产一系列产品（一族产品）</u>，极大减少了工厂类的数量</li>
</ul>
</li>
</ul>
<h4 id="产品等级结构与产品族">产品等级结构与产品族</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>产品等级结构</mark>：产品等级结构即产品的<mark>继承结构</mark>（通俗来说就是<mark>产品的种类数量</mark>）</p>
</li>
<li class="lvl-2">
<p><mark>产品族</mark>：产品族是指<u>由同一个工厂生产的</u>，<u>位于不同产品等级结构中的一组产品</u></p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121201310034.png" alt="image-20221121201310034"></p>
<h5 id="模式动机">模式动机</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是<mark>多个位于不同产品等级结构、属于不同类型的具体产品时</mark>就可以使用抽象工厂模式</p>
</li>
<li class="lvl-2">
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121201555609.png" alt="image-20221121201555609"></p>
<h3 id="抽象工厂模式的定义">抽象工厂模式的定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121201635800.png" alt="image-20221121201635800" style="zoom:50%;" />
<blockquote>
<p>属于<u>对象<mark>创建型模式</mark></u>；</p>
<p>抽象工厂模式的应用例子：</p>
<ol>
<li class="lvl-3">
<p>软件的皮肤</p>
<ul class="lvl-3">
<li class="lvl-5">每一套皮肤会拥有不同的按钮，窗口，提示窗等</li>
</ul>
</li>
</ol>
</blockquote>
<ol>
<li class="lvl-3">
<p>又称为<mark>工具(Kit)模式</mark></p>
</li>
<li class="lvl-3">
<p>抽象工厂模式中的具体工厂不只是创建一种产品，它<mark>负责创建一族产品</mark></p>
</li>
<li class="lvl-3">
<p>当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率</p>
</li>
</ol>
<h4 id="抽象工厂模式结构">抽象工厂模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121202058939.png" alt="image-20221121202058939" style="zoom:50%;" />
<blockquote>
<p>产品等级结构：A、B</p>
<p>产品族：两个（两个具体工厂）</p>
<p>抽象工厂模式：</p>
<ol>
<li class="lvl-3">
<p>如果只增加新的<mark>产品族</mark>（即增加一个新的具体工厂或同时在原有产品等级结构上进行扩展）则<mark>符合开闭原则</mark>，不用修改源代码。</p>
</li>
<li class="lvl-3">
<p>如果需要<mark>增加新的产品等级结构</mark>C则需要修改源代码（Factory接口需要增加相关代码），因此<mark>不符合开闭原则</mark>。</p>
</li>
</ol>
<p>综上而言：对于抽象工厂模式来说，增加新的产品族是方便的。</p>
</blockquote>
<h5 id="抽象工厂模式包含以下角色：">抽象工厂模式包含以下角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>AbstractFactory（抽象工厂）</p>
</li>
<li class="lvl-2">
<p>ConcreteFactory（具体工厂）</p>
</li>
<li class="lvl-2">
<p>AbstractProduct（抽象产品）</p>
</li>
<li class="lvl-2">
<p>ConcreteProduct（具体产品）</p>
</li>
</ul>
<h5 id="典型的抽象工厂类代码">典型的抽象工厂类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>; <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>; <span class="comment">//工厂方法二</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体工厂类代码">典型的具体工厂类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工厂方法二</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图1：">实例类图1：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121203218866.png" alt="image-20221121203218866" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221121203227879.png" alt="image-20221121203227879" style="zoom:50%;" />
<blockquote>
<p>(1) Button：按钮接口，充当抽象产品</p>
<p>(2) SpringButton：Spring按钮类，充当具体产品</p>
<p>(3) SummerButton：Summer按钮类，充当具体产品</p>
<p>(4) TextField：文本框接口，充当抽象产品</p>
<p>(5) SpringTextField：Spring文本框类，充当具体产品</p>
<p>(6) SummerTextField：Summer文本框类，充当具体产品</p>
<p>(7) ComboBox：组合框接口，充当抽象产品</p>
<p>(8) SpringComboBox：Spring组合框类，充当具体产品</p>
<p>(9) SummerComboBox：Summer组合框类，充当具体产品</p>
<p>(10) SkinFactory：界面皮肤工厂接口，充当抽象工厂</p>
<p>(11) SpringSkinFactory：Spring皮肤工厂，充当具体工厂</p>
<p>(12) SummerSkinFactory：Summer皮肤工厂，充当具体工厂</p>
<p>(13) Client：客户端测试类</p>
</blockquote>
<h3 id="配置文件">配置文件</h3>
<p>修改类名即可切换产品族</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span></span><br><span class="line">        designpatterns.abstractfactory.SpringSkinFactory</span><br><span class="line">    <span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><mark>其它和工厂方法模式相似</mark></p>
<blockquote>
<p>进一步地可以将xml文件的修改做成可视化界面</p>
</blockquote>
<h4 id="开闭原则的倾斜性">开闭原则的倾斜性</h4>
<ol>
<li class="lvl-3">
<p>增加<mark>产品族</mark>符合开闭原则；</p>
</li>
<li class="lvl-3">
<p>增加<mark>产品等级结构</mark>不符合开闭原则。</p>
</li>
</ol>
<h3 id="模式优点">模式优点</h3>
<ol>
<li class="lvl-3">
<p><mark>隔离了具体类的生成</mark>，使得客户端并不需要知道什么被创建</p>
</li>
<li class="lvl-3">
<p>当一个<strong>产品族中的多个对象被设计成一起工作时</strong>，它能够<mark>保证客户端始终只使用同一个产品族中的对象</mark></p>
</li>
<li class="lvl-3">
<p><mark>增加新的产品族很方便</mark>，无须修改已有系统，<mark>符合开闭原则</mark></p>
</li>
</ol>
<h3 id="模式缺点">模式缺点</h3>
<ol>
<li class="lvl-3">
<p><u>增加新的产品等级结构麻烦</u>，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，<u><mark>违背了开闭原则</mark></u></p>
</li>
</ol>
<h3 id="模式适用环境">模式适用环境</h3>
<ol>
<li class="lvl-3">
<p>一个系统<mark>不应当依赖于产品类实例如何被创建、组合和表达的细节</mark>（不用知道创建的具体细节）</p>
</li>
<li class="lvl-3">
<p>系统中有多于一个的产品族，但<mark>每次只使用其中某一产品族</mark></p>
</li>
<li class="lvl-3">
<p>属于<mark>同一个产品族的产品将在一起使用</mark>，这一约束必须在系统的设计中体现出来（严格按照一个具体工厂提供一个产品族）</p>
</li>
<li class="lvl-3">
<p><mark>产品等级结构稳定</mark>，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构（<u>不经常增加产品等级结构</u>）</p>
</li>
</ol>
<h3 id="三种工厂模式对比的三个角度">三种工厂模式对比的三个角度</h3>
<h5 id="从结构-类图-：">从结构（类图）：</h5>
<ol>
<li class="lvl-3">
<p>简单工厂模式：一个继承结构（一种抽象产品）</p>
</li>
<li class="lvl-3">
<p>工厂方法模式：两个继承结构（一个抽象工厂、一种抽象产品）</p>
</li>
<li class="lvl-3">
<p>抽象工厂模式：继承结构大于等于3个（一个抽象工厂、两个或多个抽象产品）</p>
</li>
</ol>
<h5 id="演化关系：">演化关系：</h5>
<p>抽象工厂模式（一个产品等级结构，即只有一个抽象产品类时）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo><mover><mo><mo>⟶</mo></mo><mtext>退化</mtext></mover></mo></mrow><annotation encoding="application/x-tex">\stackrel{退化}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3003em;vertical-align:-0.011em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">退化</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></span>工厂方法模式（只有一个工厂时）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo><mover><mo><mo>⟶</mo></mo><mtext>退化</mtext></mover></mo></mrow><annotation encoding="application/x-tex">\stackrel{退化}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3003em;vertical-align:-0.011em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">退化</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></span>简单工厂模式</p>
<h5 id="开闭原则：">开闭原则：</h5>
<ol>
<li class="lvl-3">
<p>简单工厂模式：违背开闭原则</p>
</li>
<li class="lvl-3">
<p>工厂方法模式：符合开闭原则</p>
</li>
<li class="lvl-3">
<p>抽象工厂模式：对增加产品族符合，对增加产品等级结构不符合（<mark>开闭原则的倾斜性</mark>）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>18-模板方法模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/18-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>模板方法模式</h1>
<h6 id="span-style-color-red-2022年12月28日周三晚上测试-25道选择题-15分钟-span"><mark><span style="color: red;">2022年12月28日周三晚上测试（25道选择题——15分钟）</span></mark></h6>
<h4 id="分析引入">分析引入</h4>
<blockquote>
<h5 id="请客吃饭示意图">请客吃饭示意图</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226185441760.png" alt="image-20221226185441760" style="zoom: 50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226185528491.png" alt="image-20221226185528491" style="zoom: 33%;" />
</blockquote>
<h3 id="模板方法模式的定义">模板方法模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226185613187.png" alt="image-20221226185613187"></p>
<blockquote>
<p><mark>类行为型模式</mark></p>
<ul class="lvl-1">
<li class="lvl-2">是一种<mark>基于继承的代码复用技术</mark></li>
<li class="lvl-2">将一些复杂流程的<mark>实现步骤</mark>封装在一系列<mark>基本方法</mark>中</li>
<li class="lvl-2">在抽象父类中提供一个称之为<mark>模板方法</mark>的方法来定义这些<mark>基本方法的执行次序</mark>，而通过其<mark>子类</mark>来<mark>覆盖某些步骤</mark>，从而<mark>使得相同的算法框架可以有不同的执行结果</mark></li>
</ul>
</blockquote>
<h4 id="模板方法模式结构">模板方法模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226185719954.png" alt="image-20221226185719954" style="zoom:50%;" />
<h5 id="模板方法模式包含以下2个角色：">模板方法模式包含以下2个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>AbstractClass（抽象类）</p>
<ul class="lvl-2">
<li class="lvl-4"><u><em><strong>包含模版方法：定义函数方法调用的次序</strong></em></u></li>
</ul>
</li>
<li class="lvl-2">
<p>ConcreteClass（具体子类）</p>
</li>
</ul>
<h4 id="模板方法模式实现">模板方法模式实现</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>模板方法 (Template Method)</p>
<ul class="lvl-2">
<li class="lvl-4"><u><em><strong>实现框架</strong></em></u></li>
</ul>
</li>
<li class="lvl-2">
<p>基本方法 (Primitive Method)</p>
<ul class="lvl-2">
<li class="lvl-4">抽象方法(Abstract Method)</li>
<li class="lvl-4">具体方法(Concrete Method)</li>
<li class="lvl-4">钩子方法(Hook Method)</li>
</ul>
</li>
</ul>
<h5 id="钩子方法">钩子方法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>“挂钩”方法： isXXX()或hasXXX()，返回类型为boolean类型</p>
<ul class="lvl-2">
<li class="lvl-4"><u>通过钩子方法来确定某一步骤是否执行</u></li>
<li class="lvl-4">提供了一种子类对父类的<u><em><strong>反向控制机制</strong></em></u></li>
</ul>
</li>
<li class="lvl-2">
<p><mark>空方法</mark></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="comment">//模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">template</span><span class="params">()</span> &#123;</span><br><span class="line">    open();</span><br><span class="line">    display();</span><br><span class="line">    <span class="comment">//通过钩子方法来确定某一步骤是否执行</span></span><br><span class="line">    <span class="keyword">if</span>(isPrint()) &#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//钩子方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h5 id="抽象类典型代码">抽象类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        primitiveOperation1();</span><br><span class="line">        primitiveOperation2();</span><br><span class="line">        primitiveOperation3();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//基本方法—具体方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本方法—抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本方法—钩子方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span>   </span><br><span class="line">    &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体子类典型代码">具体子类典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226190022242.png" alt="image-20221226190022242" style="zoom:50%;" />
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226190526575.png" alt="image-20221226190526575" style="zoom:50%;" /><u><strong>这里的模版方法是handle()。</strong></u></p>
<blockquote>
<p>(1) Account：账户类，充当抽象类</p>
<p>(2) CurrentAccount：活期账户类，充当具体子类</p>
<p>(3) SavingAccount：定期账户类，充当具体子类</p>
<p>(4) Client：客户端测试类</p>
</blockquote>
<h4 id="引入配置文件">引入配置文件</h4>
<p>如果需要更换或增加具体子类，无须修改源代码，只需修改配置文件即可，符合开闭原则</p>
<h5 id="配置文件代码">配置文件代码</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.templatemethod.CurrentAccount<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="实例类图2">实例类图2</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226190727782.png" alt="image-20221226190727782" style="zoom: 50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221226190737714.png" alt="image-20221226190737714" style="zoom:50%;" />
<h5 id="抽象类代码">抽象类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//designpatterns.templatemethod.hookmethod.DataViewer.java</span></span><br><span class="line"><span class="keyword">package</span> designpatterns.templatemethod.hookmethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DataViewer</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法：获取数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//具体方法：转换数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将数据转换为XML格式。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//抽象方法：显示数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">displayData</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//钩子方法：判断是否为XML格式的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNotXMLData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        getData();</span><br><span class="line">        <span class="comment">//如果不是XML格式的数据则进行数据转换</span></span><br><span class="line">        <span class="keyword">if</span> (isNotXMLData()) &#123;</span><br><span class="line">            convertData();	</span><br><span class="line">        &#125;</span><br><span class="line">        displayData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实际类代码">实际类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//designpatterns.templatemethod.hookmethod.XMLDataViewer.java</span></span><br><span class="line"><span class="keyword">package</span> designpatterns.templatemethod.hookmethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLDataViewer</span> <span class="keyword">extends</span> <span class="title class_">DataViewer</span> &#123;</span><br><span class="line">    <span class="comment">//实现父类方法：获取数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从XML文件中获取数据。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//实现父类方法：显示数据，默认以柱状图方式显示，可结合桥接模式来改进</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;以柱状图显示数据。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//覆盖父类的钩子方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNotXMLData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，<mark>在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</mark></p>
</li>
<li class="lvl-2">
<p>提取了类库中的公共行为，将公共行为放在父类中，而<mark>通过其子类来实现不同的行为</mark></p>
</li>
<li class="lvl-2">
<p>可实现一种<mark>反向控制结构</mark>，<u>通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行</u></p>
</li>
<li class="lvl-2">
<p>更换和增加新的子类很方便，<mark><u>符合单一职责原则和开闭原则</u></mark></p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>需要为每一个基本方法的不同实现提供一个子类，<mark>如果父类中可变的基本方法太多，将会导致类的个数增加</mark>，系统会更加庞大，设计也更加抽象（<span style="color: red;">可结合桥接模式</span>）</p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>一次性实现一个算法的不变部分，并<mark>将可变的行为留给子类来实现</mark></p>
</li>
<li class="lvl-2">
<p>各子类中<mark>公共的行为应被提取出来</mark>，并<mark>集中到一个公共父类中</mark>，以避免代码重复</p>
</li>
<li class="lvl-2">
<p>需要<mark>通过子类来决定父类算法中某个步骤是否执行</mark>，实现子类对父类的<mark>反向控制</mark></p>
</li>
</ul>
<h4 id="课后思考">课后思考</h4>
<p>在模板方法模式中，钩子方法如何实现子类控制父类的行为？</p>
<blockquote>
<p>钩子方法返回Boolean类型，结合条件语句判断是否执行父类某一步骤。</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>6-单例模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/6-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>单例模式</h1>
<blockquote>
<p>典型实例：电脑的任务管理器</p>
<p>详细参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>关键：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{关键：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">关键：</span></span></span></span><mark>构造函数私有化</mark></p>
</blockquote>
<h6 id="span-style-color-red-提示：12月7日下周周三上实验课-span"><span style="color: red;">提示：12月7日下周周三上实验课</span></h6>
<h5 id="适合使用单例模式的2种类">适合使用单例模式的2种类</h5>
<ol>
<li class="lvl-3">
<p>占用资源特别多的类(<u><strong>特别占内存</strong></u>)</p>
</li>
<li class="lvl-3">
<p>起管理作用的类</p>
</li>
</ol>
<h3 id="单例模式的定义">单例模式的定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128190958385.png" alt="image-20221128190958385" style="zoom:50%;" />
<blockquote>
<p><mark>对象创建型模式</mark></p>
<ul class="lvl-1">
<li class="lvl-2">某个类只能有一个实例</li>
<li class="lvl-2">必须自行创建这个实例</li>
<li class="lvl-2">必须自行向整个系统提供这个实例</li>
</ul>
</blockquote>
<p><u><em>如果单例类有重载构造函数，需要将所有的构造函数都设为私有的(private)。</em></u></p>
<h4 id="单例模式结构">单例模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128191339642.png" alt="image-20221128191339642" style="zoom:50%;" />
<ol>
<li class="lvl-3">
<p><mark>构造函数私有化</mark></p>
</li>
<li class="lvl-3">
<p><u>私有静态成员变量存储实例</u></p>
</li>
<li class="lvl-3">
<p>有<mark>静态public方法</mark>返回私有实例</p>
</li>
</ol>
<h5 id="要点：">要点：</h5>
<ol>
<li class="lvl-3">
<p>私有构造函数</p>
</li>
<li class="lvl-3">
<p>静态私有成员变量（自身类型）</p>
</li>
<li class="lvl-3">
<p>静态公有的工厂方法</p>
</li>
</ol>
<h5 id="核心代码">核心代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;  <span class="comment">//静态私有成员变量</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//静态公有工厂方法，返回唯一实例</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">		    instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();	</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color: blue;">单例模式只能有一个单例角色：</span></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128191817487.png" alt="image-20221128191817487" style="zoom: 50%;" />
<blockquote>
<p>Load Balancer:负载均衡器，判断服务器是否空闲并分配请求。</p>
<p>负载均衡软件：确保一个计算机只能启动一个负载均衡软件，避免发生冲突。</p>
</blockquote>
<h6 id="实例类图：">实例类图：</h6>
<img src="C:\Users\wgj\AppData\Roaming\Typora\typora-user-images\image-20221128192828984.png" alt="image-20221128192828984" style="zoom:50%;" />
<p><strong>服务器负载均衡器结构图</strong></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128192836158.png" alt="image-20221128192836158" style="zoom:50%;" />
<h5 id="存在问题：">存在问题：</h5>
<p><span style="color: red;">当多线程开发时，可能会出现new出多个单例类，因此不能保证唯一性。</span></p>
<h2 id="u-单例模式的六种实现方法-u"><u>单例模式的六种实现方法</u></h2>
<h3 id="1-饿汉式单例">1️⃣饿汉式单例</h3>
<h5 id="饿汉式单例类-eager-singleton-结构图">饿汉式单例类(Eager Singleton)结构图</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128193745858.png" alt="image-20221128193745858" style="zoom:50%;" />
<h5 id="饿汉式单例类-eager-singleton-核心代码">饿汉式单例类(Eager Singleton)核心代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>(); </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">//定义的属性instance在此注入，符合聚合关系</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==关键：==不管客户端需不需要，EagerSingleton类<u><strong>先实例化了类的对象</strong></u>。</p>
<blockquote>
<p>启动一个虚拟机时会调用Runtime类</p>
</blockquote>
<h3 id="懒汉式单例">懒汉式单例</h3>
<h5 id="懒汉式单例类-lazy-singleton-结构图">懒汉式单例类(Lazy Singleton)结构图</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128194200875.png" alt="image-20221128194200875" style="zoom:50%;" />
<h5 id="2-延迟加载-lazy-load-：基础版">2️⃣延迟加载(Lazy Load)：基础版</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-延迟加载-lazy-load-：改进版之锁方法">3️⃣延迟加载(Lazy Load)：改进版之<mark>锁方法</mark></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">//加锁，但是锁住了对象导致性能下降</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-延迟加载-lazy-load-：改进版之锁代码段">4️⃣延迟加载(Lazy Load)：改进版之<mark>锁代码段</mark></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazySingleton.class) &#123; <span class="comment">//锁住代码片段，但是白锁</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance; </span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*白锁,多线程时可能会有两个及以上的线程都进入了if语句中，当一个线程创建完之后会解除锁，这时另一个线程会继续执行创建实例的代码，所以需要在锁之后再加上判断instance == null的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="5-延迟加载-lazy-load-：改进版之双重检查锁定">5️⃣延迟加载(Lazy Load)：改进版之<mark>双重检查锁定</mark></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//第一重判断-锁代码之前先判断一次</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁定代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="comment">//第二重判断-返回实例之前再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); <span class="comment">//创建单例实例</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>volatile：<mark>是Java提供的一种轻量级的同步机制</mark>。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p>
</blockquote>
<h4 id="饿汉式单例与懒汉式单例的比较">饿汉式单例与懒汉式单例的比较</h4>
<ol>
<li class="lvl-3">
<p><strong>饿汉式单例类：</strong><mark>无须考虑多个线程同时访问的问题</mark>；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；<mark>系统加载时间可能会比较长</mark></p>
</li>
<li class="lvl-3">
<p>**懒汉式单例类：**实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响</p>
</li>
</ol>
<h3 id="6-静态内部类实现单例模式-限java-iodh">6️⃣静态内部类实现单例模式(限Java)——IoDH</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialization on Demand Holder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HolderClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点：</p>
<ol>
<li class="lvl-3">只有在调用getInstance方法返回内部类实例的时候才会为内部类分配内存，不会影响性能。</li>
<li class="lvl-3">虚拟机会在创建内部类实例的时候自动为其加上锁，确保只能有一个线程访问，保证内部类的线程安全。</li>
</ol>
</blockquote>
<h3 id="模式优点">模式优点</h3>
<ol>
<li class="lvl-3">
<p>提供了<mark>对唯一实例的受控访问</mark></p>
</li>
<li class="lvl-3">
<p>可以<mark>节约系统资源</mark>，提高系统的性能</p>
</li>
<li class="lvl-3">
<p>允许可变数目的实例（<mark>多例类</mark>）</p>
<ul class="lvl-2">
<li class="lvl-5">多例：指定单例数量(种类)（可以指定i变量通过getInstance(int i)方法创建指定特征的单例实例）</li>
<li class="lvl-5"><u><strong>多例模式是单例模式的扩展</strong></u></li>
</ul>
</li>
</ol>
<h3 id="模式缺点">模式缺点</h3>
<ol>
<li class="lvl-3">
<p><mark>扩展困难</mark>（<u><strong>缺少抽象层</strong></u>）</p>
</li>
<li class="lvl-3">
<p>单例类的<mark>职责过重</mark></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>违背单一职责原则</strong></li>
</ul>
</li>
<li class="lvl-3">
<p>可能会导致共享的单例对象的<mark>状态丢失</mark></p>
<ul class="lvl-2">
<li class="lvl-5">一个客户端对单例对象的修改会影响到所有使用该单例对象的客户端。</li>
</ul>
</li>
</ol>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统只需要<mark>一个实例对象</mark>，或者因为<mark>资源消耗太大</mark>而只允许创建一个对象</p>
</li>
<li class="lvl-2">
<p>客户调用类的单个实例<mark>只允许使用一个公共访问点</mark>，除了该公共访问点，不能通过其他途径访问该实例</p>
</li>
</ul>
<h1>多例模式</h1>
<p>设计一个多例类(Multiton)，包含指定数量的实例。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128201942212.png" alt="image-20221128201942212" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128201929796.png" alt="image-20221128201929796" style="zoom:50%;" />
<blockquote>
<p>多例模式：可以指定i变量通过getInstance(int i)方法创建指定特征的单例实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialization on Demand Holder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HolderClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//i=0</span></span><br><span class="line">        <span class="keyword">return</span> 对应特征单例实例……</span><br><span class="line">        <span class="comment">//i=1</span></span><br><span class="line">        <span class="keyword">return</span> 对应特征单例实例……</span><br><span class="line">        <span class="comment">//i=2</span></span><br><span class="line">        <span class="keyword">return</span> 对应特征单例实例……</span><br><span class="line">        <span class="comment">//return HolderClass.instance;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>4-建造者模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%87%AA%E5%AD%A6%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>建造者模式</h1>
<h3 id="建造者模式的定义">建造者模式的定义</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221228183903445.png" alt="image-20221228183903445"></p>
<blockquote>
<p><mark>对象创建型模式</mark></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>将客户端与包含多个部件的复杂对象的创建过程分离，客户端<mark>无须知道复杂对象的内部组成部分与装配方式</mark>，只需要知道所需建造者的类型即可</p>
</li>
<li class="lvl-2">
<p><mark>关注如何逐步创建一个复杂的对象</mark>，不同的建造者定义了不同的创建过程</p>
</li>
</ul>
<h4 id="建造者模式结构">建造者模式结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211135212097.png" alt="image-20230211135212097"></p>
<h5 id="建造者模式包含以下4个角色：">建造者模式包含以下4个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Builder（抽象建造者）</p>
</li>
<li class="lvl-2">
<p>ConcreteBuilder（具体建造者）</p>
</li>
<li class="lvl-2">
<p>Product（产品）</p>
</li>
<li class="lvl-2">
<p>Director（指挥者）</p>
</li>
</ul>
<h5 id="典型的复杂对象类代码">典型的复杂对象类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String partA; <span class="comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span></span><br><span class="line">	<span class="keyword">private</span> String partB;</span><br><span class="line">	<span class="keyword">private</span> String partC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//partA的Getter方法和Setter方法省略</span></span><br><span class="line">	<span class="comment">//partB的Getter方法和Setter方法省略</span></span><br><span class="line">	<span class="comment">//partC的Getter方法和Setter方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的抽象建造者类代码">典型的抽象建造者类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体建造者类代码">典型的具体建造者类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;B1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;C1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的指挥者类代码">典型的指挥者类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder=builer;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户类代码片段">客户类代码片段</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder1</span>(); <span class="comment">//可通过配置文件实现</span></span><br><span class="line"><span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> director.construct();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="实例类图">实例类图</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211135901481.png" alt="image-20230211135901481"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230211135931553.png" alt="image-20230211135931553"></p>
<blockquote>
<p>(1) Actor：游戏角色类，充当复杂产品对象</p>
<p>(2) ActorBuilder：游戏角色建造者，充当抽象建造者</p>
<p>(3) HeroBuilder：英雄角色建造者，充当具体建造者</p>
<p>(4) AngelBuilder：天使角色建造者，充当具体建造者</p>
<p>(5) DevilBuilder：恶魔角色建造者，充当具体建造者</p>
<p>(6) ActorController：角色控制器，充当指挥者</p>
<p>(7) Client：客户端测试类</p>
</blockquote>
<h6 id="结果及分析">结果及分析</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果需要更换具体角色建造者，<mark>只需要修改配置文件</mark></p>
</li>
<li class="lvl-2">
<p>当需要增加新的具体角色建造者时，只需将新增具体角色建造者作为抽象角色建造者的子类，然后修改配置文件即可，原有代码无须修改，<mark>完全符合开闭原则</mark></p>
</li>
</ul>
<h5 id="配置文件代码">配置文件代码</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.builder.AngelBuilder<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="省略director">省略Director</h5>
<h6 id="1-将director和抽象建造者builder合并">1、将Director和抽象建造者Builder合并</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActorBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Actor</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildType</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSex</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFace</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildCostume</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildHairstyle</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Actor <span class="title function_">construct</span><span class="params">(ActorBuilder ab)</span> &#123;</span><br><span class="line">        ab.buildType();</span><br><span class="line">        ab.buildSex();</span><br><span class="line">        ab.buildFace();</span><br><span class="line">        ab.buildCostume();</span><br><span class="line">        ab.buildHairstyle();</span><br><span class="line">        <span class="keyword">return</span> actor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">ActorBuilder ab;</span><br><span class="line">ab = (ActorBuilder)XMLUtil.getBean();</span><br><span class="line">		</span><br><span class="line">Actor actor;</span><br><span class="line">actor = ActorBuilder.construct(ab);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h6 id="2-将construct-方法中的参数去掉-直接在construct-方法中调用buildpartx-方法">2、将construct()方法中的参数去掉，直接在construct()方法中调用buildPartX()方法</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActorBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Actor</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildType</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSex</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFace</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildCostume</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildHairstyle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Actor <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildType();</span><br><span class="line">        <span class="built_in">this</span>.buildSex();</span><br><span class="line">        <span class="built_in">this</span>.buildFace();</span><br><span class="line">        <span class="built_in">this</span>.buildCostume();</span><br><span class="line">        <span class="built_in">this</span>.buildHairstyle();</span><br><span class="line">        <span class="keyword">return</span> actor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">ActorBuilder ab;</span><br><span class="line">ab = (ActorBuilder)XMLUtil.getBean();</span><br><span class="line">		</span><br><span class="line">Actor actor;</span><br><span class="line">actor = ab.construct();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h5 id="钩子方法的引入">钩子方法的引入</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActorBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Actor</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildType</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSex</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFace</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildCostume</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildHairstyle</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//钩子方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBareheaded</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> Actor <span class="title function_">createActor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> actor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="覆盖钩子函数">覆盖钩子函数</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevilBuilder</span> <span class="keyword">extends</span> <span class="title class_">ActorBuilder</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildType</span><span class="params">()</span> &#123;</span><br><span class="line">		actor.setType(<span class="string">&quot;恶魔&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSex</span><span class="params">()</span> &#123;</span><br><span class="line">		actor.setSex(<span class="string">&quot;妖&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFace</span><span class="params">()</span> &#123;</span><br><span class="line">		actor.setFace(<span class="string">&quot;丑陋&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildCostume</span><span class="params">()</span> &#123;</span><br><span class="line">		actor.setCostume(<span class="string">&quot;黑衣&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHairstyle</span><span class="params">()</span> &#123;</span><br><span class="line">		actor.setHairstyle(<span class="string">&quot;光头&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖钩子方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBareheaded</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActorController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Actor <span class="title function_">construct</span><span class="params">(ActorBuilder ab)</span> &#123;</span><br><span class="line">        Actor actor;</span><br><span class="line">        ab.buildType();</span><br><span class="line">        ab.buildSex();</span><br><span class="line">        ab.buildFace();</span><br><span class="line">        ab.buildCostume();</span><br><span class="line">        <span class="comment">//通过钩子方法来控制产品的构建</span></span><br><span class="line">        <span class="keyword">if</span>(!ab.isBareheaded()) &#123;</span><br><span class="line">            ab.buildHairstyle();</span><br><span class="line">        &#125;</span><br><span class="line">        actor=ab.createActor();</span><br><span class="line">        <span class="keyword">return</span> actor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端不必知道产品内部组成的细节，<mark>将产品本身与产品的创建过程解耦</mark>，使得相同的创建过程可以创建不同的产品对象</p>
</li>
<li class="lvl-2">
<p>可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，<mark>符合开闭原则</mark></p>
</li>
<li class="lvl-2">
<p>可以<mark>更加精细地控制产品的创建过程</mark></p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<mark>如果产品之间的差异性很大，不适合使用建造者模式</mark>，因此其使用范围受到一定的限制</p>
</li>
<li class="lvl-2">
<p><u>如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化</u>，导致系统变得很庞大，增加了系统的理解难度和运行成本</p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>需要生成的产品对象有复杂的内部结构</mark>，这些产品对象通常包含多个成员变量</p>
</li>
<li class="lvl-2">
<p><u>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</u></p>
</li>
<li class="lvl-2">
<p><mark>对象的创建过程独立于创建该对象的类</mark>。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中</p>
</li>
<li class="lvl-2">
<p><mark>隔离复杂对象的创建和使用</mark>，并使得相同的创建过程可以创建不同的产品</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5-原型模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/5-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>原型模式</h1>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123192538698.png" alt="image-20221123192538698" style="zoom:50%;" />
<blockquote>
<p>第一个对象的创建：</p>
<ul class="lvl-1">
<li class="lvl-2">new创建</li>
<li class="lvl-2">工厂创建</li>
<li class="lvl-2">反射创建</li>
</ul>
<p>第二个对象及之后的对象创建：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>克隆创建</p>
<ul class="lvl-3">
<li class="lvl-4">浅克隆
<ul class="lvl-5">
<li class="lvl-6"><mark>引用对象</mark>的内存不复制</li>
</ul>
</li>
<li class="lvl-4">深克隆
<ul class="lvl-5">
<li class="lvl-6"><mark>引用对象</mark>的内存被复制</li>
</ul>
</li>
<li class="lvl-4"><mark>浅克隆与深克隆都会创建全新的内存，新对象都会是独立的。</mark></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="原型模式的定义">原型模式的定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123193316513.png" alt="image-20221123193316513" style="zoom:50%;" />
<blockquote>
<p>对象创建型模式</p>
<ol>
<li class="lvl-3">工作原理：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象<mark>通过请求原型对象复制自己来实现创建过程</mark></li>
<li class="lvl-3">创建新对象（也称为克隆对象）的<mark>工厂就是原型类自身</mark>，<mark>工厂方法</mark>由负责复制原型对象的<mark>克隆方法</mark>来实现</li>
<li class="lvl-3">通过<mark>克隆方法</mark>所创建的对象是<mark>全新的对象</mark>，它们在内存中拥有新的地址，<mark>每一个克隆对象都是独立的</mark></li>
</ol>
</blockquote>
<h4 id="原型模式结构">原型模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123193905923.png" alt="image-20221123193905923" style="zoom:50%;" />
<blockquote>
<p>clone()方法可能不同，所以由子类实现。</p>
</blockquote>
<h5 id="原型模式包含以下角色">原型模式包含以下角色</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Prototype（抽象原型类）</p>
</li>
<li class="lvl-2">
<p>ConcretePrototype（具体原型类）</p>
</li>
<li class="lvl-2">
<p>Client（客户类）</p>
</li>
</ul>
<h3 id="浅克隆与深克隆">浅克隆与深克隆</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>浅克隆(Shallow Clone)：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制</p>
<ul class="lvl-2">
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123194306144.png" alt="image-20221123194306144" style="zoom:50%;" />
</li>
</ul>
</li>
<li class="lvl-2">
<p>深克隆(Deep Clone)：<mark>除了对象本身被复制外，对象所包含的所有成员变量也将被复制</mark></p>
<ul class="lvl-2">
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123194358754.png" alt="image-20221123194358754" style="zoom:50%;" />
</li>
</ul>
</li>
</ul>
<blockquote>
<p>java内置了浅克隆</p>
</blockquote>
<h4 id="通用的克隆实现方法">通用的克隆实现方法</h4>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123194954934.png" alt="image-20221123194954934"  /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123195016487.png" alt="image-20221123195016487" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h6 id="类prototype与concreteprototype：">类Prototype与ConcretePrototype：</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String attr; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttr</span><span class="params">(String attr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.attr = attr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAttr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(); <span class="comment">//创建新对象</span></span><br><span class="line">        prototype.setAttr(<span class="built_in">this</span>.attr);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="客户端client：">客户端Client：</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line">prototype.setAttr(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">copy</span> <span class="operator">=</span> (ConcretePrototype)prototype.clone();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h5 id="java语言中的clone-方法和cloneable接口">Java语言中的clone()方法和Cloneable接口</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>在Java语言中，提供了一个clone()方法用于实现浅克隆，该方法使用起来很方便，直接调用<code>super.clone()方法</code>即可实现克隆</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123200112603.png" alt="image-20221123200112603" style="zoom:50%;" />
<blockquote>
<p><u><mark>需要将Object进行类型转换</mark></u></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端代码操作</span></span><br><span class="line"><span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line"><span class="type">Prototype</span> <span class="variable">copy</span> <span class="operator">=</span> prototype.clone();</span><br></pre></td></tr></table></figure>
<h5 id="实例类图1：">实例类图1：</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123200500730.png" alt="image-20221123200500730" style="zoom:50%;" />
<h6 id="浅克隆的实现方案：">浅克隆的实现方案：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123200510033.png" alt="image-20221123200510033" style="zoom:50%;" />
<blockquote>
<p><mark>浅克隆</mark></p>
<p>工作周报对象被成功复制，但是附件对象并没有复制，实现了浅克隆；</p>
<p>附件Attachment类要先new创建之后再注入到WeeklyLog中。存在Attachment的对象attachment为WeeklyLog<strong>类的属性</strong>并且存在attachment的<strong>注入</strong>，所以是<mark>聚合关系</mark>。</p>
</blockquote>
<h6 id="深克隆的实现方案：">深克隆的实现方案：</h6>
<p>工作周报类WeeklyLog和附件类Attachment实现==<code>Serializable接口</code>==</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123201320535.png" alt="image-20221123201320535" style="zoom:50%;" />
<p><strong><u>通过序列化和反序列化的方式获得深克隆对象</u></strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>（具体的代码参考书</mtext><mi>P</mi><mn>100</mn><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{（具体的代码参考书P100）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">（具体的代码参考书</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">P</span><span class="mord" style="color:red;">100</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span></p>
<blockquote>
<p><mark>深克隆</mark></p>
<p>工作周报对象和附件对象都成功复制，实现了深克隆</p>
</blockquote>
<blockquote>
<p>节点流：操纵内存、硬盘等</p>
<p>过滤流：连接</p>
<p>输入流与输出流：以程序为参照物</p>
<ol>
<li class="lvl-3">
<p>程序输出到文件为<mark>输出流</mark><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>写文件；</p>
</li>
<li class="lvl-3">
<p>文件输入到程序为<mark>输入流</mark><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>读文件；</p>
</li>
</ol>
</blockquote>
<h3 id="原型管理器">原型管理器</h3>
<p>原型管理器(Prototype Manager)将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。</p>
<h5 id="原型管理器结构">原型管理器结构</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221123202928444.png" alt="image-20221123202928444" style="zoom:50%;" />
<h6 id="代码实现：">代码实现：</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Hashtable prototypeTable=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();  <span class="comment">//使用Hashtable存储原型对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrototypeManager</span><span class="params">()</span> &#123;</span><br><span class="line">        prototypeTable.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcretePrototypeA</span>());</span><br><span class="line">        prototypeTable.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcretePrototypeB</span>());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key, Prototype prototype)</span> &#123;</span><br><span class="line">        prototypeTable.put(key,prototype);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        clone = ((Prototype) prototypeTable.get(key)).clone(); <span class="comment">//通过克隆方法创建新对象</span></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>简化对象的创建过程</strong>，通过复制一个已有实例可以提高新实例的创建效率</p>
</li>
<li class="lvl-2">
<p>扩展性较好</p>
<ul class="lvl-2">
<li class="lvl-4"><mark>符合开闭原则</mark></li>
</ul>
</li>
<li class="lvl-2">
<p>提供了简单的创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，<strong>无须专门的工厂类来创建产品</strong></p>
<ul class="lvl-2">
<li class="lvl-4"><mark>自己创建自己</mark></li>
</ul>
</li>
<li class="lvl-2">
<p>可以使用<u>深克隆的方式保存对象的状态</u>，以便在需要的时候使用，<mark>可辅助实现撤销操作</mark></p>
<ul class="lvl-2">
<li class="lvl-4">实现ctrl+C、ctrl+Z操作</li>
</ul>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，<mark>当对已有的类进行改造时，需要修改源代码，违背了开闭原则</mark></p>
</li>
<li class="lvl-2">
<p>在<mark>实现深克隆时</mark>需要<mark>编写较为复杂的代码</mark>，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆（每一层的对应的类都需要实现<mark>Serializable接口</mark>），实现起来可能会比较麻烦</p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>创建新对象成本较大</mark>，新对象可以通过复制已有对象来获得，<strong><u>如果是相似对象，则可以对其成员变量稍作修改</u></strong></p>
</li>
<li class="lvl-2">
<p>系统要保存对象的状态，而<mark>对象的状态变化很小</mark></p>
</li>
<li class="lvl-2">
<p>需要<mark>避免使用分层次的工厂类</mark>来创建分层次的对象</p>
</li>
<li class="lvl-2">
<p>Ctrl + C<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>Ctrl + V</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>8-桥接模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/8-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>桥接模式</h1>
<blockquote>
<p>参考：<a href="https://www.runoob.com/design-pattern/bridge-pattern.html">桥接模式 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221107195453733.png" alt="image-20221107195453733" style="zoom:50%;" />
<h3 id="桥接模式的定义">桥接模式的定义</h3>
<p>将两个独立的维度分离，然后在两者的抽象层进行关联。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130195047696.png" alt="image-20221130195047696" style="zoom:50%;" />
<blockquote>
<p><u>对象结构型模式</u></p>
<ul class="lvl-1">
<li class="lvl-2">又被称为<mark>柄体(Handle and Body)模式</mark>或<mark>接口(Interface)模式</mark></li>
<li class="lvl-2">用<mark>抽象关联</mark><code>取代</code>了传统的多层继承</li>
<li class="lvl-2"><u><em>将类之间的<mark>静态继承关系</mark>转换为<mark>动态的对象组合关系</mark></em></u></li>
</ul>
<p><span style="color: red;">一般将可能会被重用的部分作为实现部分，而将某些固有的特性作为抽象部分</span></p>
</blockquote>
<h4 id="桥接模式结构">桥接模式结构</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130200416474.png" alt="image-20221130200416474" style="zoom:50%;" />
<blockquote>
<p>两个继承部分：</p>
<ol>
<li class="lvl-3">抽象部分的继承结构
<ul class="lvl-3">
<li class="lvl-5"><u><em>Abstraction类不做成interface，因为Abstraction类会涉及到<mark>对象注入的set方法</mark></em></u></li>
</ul>
</li>
<li class="lvl-3">实现部分的继承结构</li>
</ol>
</blockquote>
<h5 id="桥接模式包含以下4个角色：">桥接模式包含以下4个角色：</h5>
<ol>
<li class="lvl-3">
<p>Abstraction（抽象类）</p>
</li>
<li class="lvl-3">
<p>RefinedAbstraction（扩充抽象类）</p>
</li>
<li class="lvl-3">
<p>Implementor（实现类接口）</p>
</li>
<li class="lvl-3">
<p>ConcreteImplementor（具体实现类）</p>
</li>
</ol>
<h5 id="典型的实现类接口代码">典型的实现类接口代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的具体实现类代码">典型的具体实现类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteImplementor</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的抽象类代码">典型的抽象类代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor impl; <span class="comment">//定义实现类接口对象</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImpl</span><span class="params">(Implementor impl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.impl=impl;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>; <span class="comment">//声明抽象业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的扩充抽象类-细化抽象类-代码">典型的扩充抽象类（细化抽象类）代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        impl.operationImpl(); <span class="comment">//调用实现类的方法，impl为父类的保护对象，子类可见的同时不破坏封装性</span></span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="桥接模式实现">桥接模式实现</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130200622245.png" alt="image-20221130200622245" style="zoom:50%;" />
<h6 id="实例类图：">实例类图：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130202031398.png" alt="image-20221130202031398" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130202039729.png" alt="image-20221130202039729" style="zoom:50%;" />
<p><span style="color: red;">imp:ImageImp对象设为保护类型(包内可见)，确保子类能够调用的同时，类外不能访问调用，保证了封装性！</span></p>
<blockquote>
<p>(1) Matrix：像素矩阵类，辅助类</p>
<p>(2) ImageImp：抽象操作系统实现类，充当实现类接口</p>
<p>(3) WindowsImp：Windows操作系统实现类，充当具体实现类</p>
<p>(4) LinuxImp：Linux操作系统实现类，充当具体实现类</p>
<p>(5) UnixImp：UNIX操作系统实现类，充当具体实现类</p>
<p>(6) Image：抽象图像类，充当抽象类</p>
<p>(7) JPGImage：JPG格式图像类，充当扩充抽象类</p>
<p>(8) PNGImage：PNG格式图像类，充当扩充抽象类</p>
<p>(9) BMPImage：BMP格式图像类，充当扩充抽象类</p>
<p>(10) GIFImage：GIF格式图像类，充当扩充抽象类</p>
<p>(11) Client：客户端测试类</p>
</blockquote>
<h3 id="配置文件优化">配置文件优化</h3>
<p>如果需要更换图像文件格式或者更换操作系统，只需修改配置文件即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RefinedAbstraction--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.bridge.JPGImage<span class="tag">&lt;/<span class="name">className</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--ConcreteImplementor--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.bridge.WindowsImp<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="模式连用">⭐️模式连用</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>桥接模式：用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化</p>
</li>
<li class="lvl-2">
<p>适配器模式：当发现系统与已有类无法协同工作时</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130203657692.png" alt="image-20221130203657692"></p>
<blockquote>
<p><u>桥接模式与适配器模式联用示意图</u></p>
</blockquote>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>分离抽象接口及其实现部分</u></p>
</li>
<li class="lvl-2">
<p>可以<mark>取代多层继承方案</mark>，极大地**<u>减少了子类的个数</u>**</p>
</li>
<li class="lvl-2">
<p><mark>提高了系统的可扩展性</mark>，在两个变化维度中任意扩展一个维度，不需要修改原有系统，<mark>符合开闭原则</mark></p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>会<mark>增加系统的理解与设计难度</mark>，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程</p>
</li>
<li class="lvl-2">
<p>正确识别出系统中两个独立变化的维度并不是一件容易的事情</p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>需要在抽象化和具体化之间增加更多的灵活性，<mark>避免在两个层次之间建立静态的继承关系</mark></p>
</li>
<li class="lvl-2">
<p>抽象部分和实现部分<mark>可以以继承的方式<strong>独立扩展</strong>而互不影响</mark></p>
</li>
<li class="lvl-2">
<p>一个类<mark>存在两个（或多个）独立变化的维度</mark>，且这两个（或多个）维度都需要独立地进行扩展</p>
</li>
<li class="lvl-2">
<p>不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统</p>
</li>
</ul>
<h4 id="课后思考">课后思考</h4>
<p>如果系统中存在两个以上的变化维度，是否可以使用桥接模式进行处理？如果可以，系统该如何设计？</p>
<blockquote>
<p>可以使用，可以将一个维度作为抽象部分，两个维度做成实现部分。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205191140659.png" alt="image-20221205191140659"></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>7-适配器模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>适配器模式</h1>
<h4 id="结构型模式">结构型模式</h4>
<p>关注如何将现有<mark>类或对象</mark>组织在一起<mark>形成更加强大的结构</mark></p>
<h5 id="结构型模式分类">结构型模式分类</h5>
<h6 id="类结构型模式">类结构型模式</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>关心类的组合，由多个类组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系</p>
</li>
</ul>
<h6 id="对象结构型模式">对象结构型模式</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>关心类与对象的组合，<mark>通过关联关系</mark>，在一个类中定义另一个类的实例对象，然后通过该对象调用相应的方法</p>
</li>
</ul>
<h3 id="适配器模式的定义">适配器模式的定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128203447563.png" alt="image-20221128203447563" style="zoom:80%;" />
<blockquote>
<p>对象<mark>结构型模式</mark> / 类<mark>结构型模式</mark></p>
<ul class="lvl-1">
<li class="lvl-2">别名为<mark>包装器(Wrapper)模式</mark></li>
<li class="lvl-2">定义中所提及的接口是指<mark>广义的接口</mark>，它可以表示<mark>一个方法或者方法的集合</mark></li>
</ul>
</blockquote>
<h4 id="适配器模式结构-类适配器">适配器模式结构（类适配器)</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128203615150.png" alt="image-20221128203615150" style="zoom:50%;" />
<h4 id="适配器模式结构-对象适配器">适配器模式结构（对象适配器）</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221128203750857.png" alt="image-20221128203750857" style="zoom:50%;" />
<h5 id="适配器模式包含以下3个角色：">适配器模式包含以下3个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Target（目标抽象类）</p>
</li>
<li class="lvl-2">
<p>Adapter（适配器类）</p>
</li>
<li class="lvl-2">
<p>Adaptee（适配者类）</p>
</li>
</ul>
<h5 id="典型的类适配器代码">典型的<mark>类适配器</mark>代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest();<span class="comment">//通过super转发调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="典型的对象适配器代码">典型的<mark>对象适配器</mark>代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee; <span class="comment">//维持一个对适配者对象的引用</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;<span class="comment">//不仅可以适配类，也可以适配类的子类（里氏替换原则）</span></span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest(); <span class="comment">//通过类名转发调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图：">实例类图：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130190502427.png" alt="image-20221130190502427" style="zoom: 50%;" />
<blockquote>
<p>上图为对象适配器。</p>
<p>move()直接在CarController中实现</p>
<p>phonate()、twinkle()做成抽象方法</p>
<p>(1) CarController：汽车控制类，充当目标抽象类</p>
<p>(2) PoliceSound：警笛类，充当适配者</p>
<p>(3) PoliceLamp：警灯类，充当适配者</p>
<p>(4) PoliceCarAdapter：警车适配器，充当适配器</p>
<p>(5) Client：客户端测试类</p>
</blockquote>
<h4 id="配置文件操作">配置文件操作</h4>
<ol>
<li class="lvl-3">
<p>将具体<u>适配器类的类名存储在配置文件中</u></p>
</li>
<li class="lvl-3">
<p>扩展方便</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.adapter.PoliceCarAdapter<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当需要增加救护车时，只需要增加新的警笛类、警灯类以及对应的救护车适配器类，然后改变相应的配置文件中适配器的名称即可完成扩展，<mark>符合开闭原则</mark>。</p>
</blockquote>
<h3 id="缺省适配器模式">缺省适配器模式</h3>
<h4 id="定义">定义</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130191924902.png" alt="image-20221130191924902" style="zoom:50%;" />
<h5 id="结构">结构</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130191958152.png" alt="image-20221130191958152" style="zoom:50%;" />
<blockquote>
<p>缺省适配器类为抽象类，但其中实现的方法都是具体的方法（空实现），具体的实际方法由缺省适配器类的子类实现。</p>
</blockquote>
<h5 id="缺省适配器类的典型代码片段">缺省适配器类的典型代码片段</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractServiceClass</span> <span class="keyword">implements</span> <span class="title class_">ServiceInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethod1</span><span class="params">()</span> &#123;  &#125;  <span class="comment">//空方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethod2</span><span class="params">()</span> &#123;  &#125;  <span class="comment">//空方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethod3</span><span class="params">()</span> &#123;  &#125;  <span class="comment">//空方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向适配器">双向适配器</h3>
<h5 id="结构">结构</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221130192249819.png" alt="image-20221130192249819" style="zoom:50%;" />
<blockquote>
<p>在request方法中调用adaptee.specificRequest()；（目标类是：ConcreteTarget类）</p>
<p>同样在specificRequest方法中可以调用target.request();（目标类是：ConcreteAdaptee类）</p>
</blockquote>
<h5 id="双向适配器典型代码片段">双向适配器典型代码片段</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span>,Adaptee &#123;</span><br><span class="line">    <span class="keyword">private</span> Target target;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Target target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式优点">模式优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>将<mark>目标类和适配者类解耦</mark>，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</p>
</li>
<li class="lvl-2">
<p>增加了类的透明性和复用性，<mark>提高了适配者的复用性</mark>，同一个适配者类可以在多个不同的系统中复用</p>
</li>
<li class="lvl-2">
<p><mark>灵活性和扩展性非常好</mark></p>
</li>
<li class="lvl-2">
<p>类适配器模式：<mark>置换一些适配者的方法很方便</mark></p>
<ul class="lvl-2">
<li class="lvl-4">类适配器<code>继承</code>的<mark>适配者类</mark></li>
</ul>
</li>
<li class="lvl-2">
<p>对象适配器模式：可以把<mark>多个不同的适配者适配到同一个目标</mark>，还可以适配一个适配者的子类</p>
</li>
</ul>
<h3 id="模式缺点">模式缺点</h3>
<h6 id="类适配器模式：">类适配器模式：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>一次最多只能适配一个适配者类</mark>，不能同时适配多个适配者</p>
</li>
<li class="lvl-2">
<p>适配者类不能为最终类</p>
</li>
<li class="lvl-2">
<p><mark>目标抽象类只能为接口</mark>，不能为类</p>
</li>
</ul>
<h6 id="对象适配器模式：">对象适配器模式：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>在适配器中置换适配者类的某些方法比较麻烦</p>
</li>
</ul>
<h3 id="模式适用环境">模式适用环境</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统<mark>需要使用一些现有的类（适配者）</mark>，而这些类的接口不符合系统的需要，<u>甚至没有这些类的源代码</u></p>
</li>
<li class="lvl-2">
<p><mark>创建一个可以重复使用的类（目标类/适配者）</mark>，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</p>
<ul class="lvl-2">
<li class="lvl-4">解决原本类之间不能连同工作的问题</li>
</ul>
</li>
</ul>
<h4 id="课后思考">课后思考</h4>
<ol>
<li class="lvl-3">
<p>在对象适配器中，一个适配器能否适配多个适配者？</p>
</li>
<li class="lvl-3">
<p>如果能，应该如何实现？</p>
</li>
<li class="lvl-3">
<p>如果不能，请说明原因？</p>
</li>
<li class="lvl-3">
<p>如果是类适配器呢？</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PowerDesigner使用指南</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/powerDesign%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>PowerDesigner使用指南</h1>
<h3 id="powerdesigner如何去掉黑色网格线">PowerDesigner如何去掉黑色网格线</h3>
<p>点击工具栏上的 Tools -&gt; Display Preferences 菜单选项，在弹出的Display Preferences窗口去掉“Show page delimiter”（显示页面分隔符）选项即可。</p>
<h3 id="powerdesigner更改图元素样式">PowerDesigner更改图元素样式</h3>
<p>鼠标右键点击Display Preferences选项</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024233609302.png" alt="image-20221024233609302"></p>
<h3 id="powerdesigner绘制用例图">PowerDesigner绘制用例图</h3>
<blockquote>
<p>参考：<a href="https://www.open-open.com/lib/view/open1449403961590.html">用Powerdesigner画用例图 - UML/模型工具 - 开发语言与工具 - 深度开源 (open-open.com)</a></p>
</blockquote>
<h3 id="powerdesigner更改字体">PowerDesigner更改字体</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024214342846.png" alt="image-20221024214342846"></p>
<h3 id="powerdesigner绘制状态图">PowerDesigner绘制状态图</h3>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/zsg88/p/7636415.html">PowerDesigner16 状态图 - 猪脚踏浪 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h3 id="powerdesigner绘制顺序图-时序图">PowerDesigner绘制顺序图/时序图</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/hhhhh2333/article/details/103148763">(77条消息) PowerDesigner16 画时序图教程_古尔光赫的博客-CSDN博客_powerdesigner时序图</a></p>
<p>⭐️以上参考很有价值</p>
</blockquote>
<h3 id="powerdesigner绘制类图">PowerDesigner绘制类图</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_35461948/article/details/112471194">(77条消息) PowerDesigner 画类图_天狼1222的博客-CSDN博客_powerdesigner画类图</a></p>
</blockquote>
<h6 id="类图快速生成set和get方法：">类图快速生成set和get方法：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221030162700052.png" alt="image-20221030162700052" style="zoom:50%;" />
<p>从下图菜单，生成Java代码；</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/2020111122504798.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Circle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> implement</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ellipse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ellipse</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> implement</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Rectangle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> implement</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> implement</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ShapeFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> shape <span class="title function_">createShape</span><span class="params">(<span class="type">char</span> type)</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> implement</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="powerdesigner在连接线上增加说明文字">PowerDesigner在连接线上增加说明文字</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/maoyeqiu/article/details/53690533">(77条消息) powerdesigner 在连接线上显示关系名_txxs的博客-CSDN博客_powerdesigner连接线</a></p>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221206213542587.png" alt="image-20221206213542587"></p>
<p>如果以上操作没有显示，则在Format出勾选Stereotype：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207222808277.png" alt="image-20221207222808277"></p>
<h3 id="powerdesigner在连接线上删除默认的多重性说明">PowerDesigner在连接线上删除默认的多重性说明</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221207223017827.png" alt="image-20221207223017827"></p>
<h3 id="powerdesigner中内部类的画法">PowerDesigner中内部类的画法</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/m_1153/article/details/111768834">(83条消息) PowerDesigner中内部类的画法_V_Vi3w的博客-CSDN博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
        <tag>PowerDesigner软件</tag>
      </tags>
  </entry>
  <entry>
    <title>9-组合模式</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/9-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>组合模式</h1>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205191757849.png" alt="image-20221205191757849"></p>
</blockquote>
<h4 id="分析">分析</h4>
<ol>
<li class="lvl-3">
<p>在树形目录结构中，包含文件和文件夹两类不同的元素</p>
<ul class="lvl-2">
<li class="lvl-5">在文件夹中可以包含文件，还可以继续包含子文件夹</li>
<li class="lvl-5">在文件中不能再包含子文件或者子文件夹</li>
</ul>
</li>
<li class="lvl-3">
<p>文件夹<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟷</mo></mrow><annotation encoding="application/x-tex">\longleftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟷</span></span></span></span>容器(Container)</p>
</li>
<li class="lvl-3">
<p>文件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟷</mo></mrow><annotation encoding="application/x-tex">\longleftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟷</span></span></span></span>叶子(Leaf)</p>
</li>
<li class="lvl-3">
<p>使用了递归调用的机制来对整个<mark>树型结构</mark>进行处理</p>
</li>
<li class="lvl-3">
<p>在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下客户端<mark>希望一致地处理它们</mark>（区别对待会<mark>增加代码复杂性</mark>）</p>
</li>
</ol>
<blockquote>
<p>树型结构：<u>文件系统、组件、菜单</u>等。</p>
</blockquote>
<h6 id="容器与叶子">容器与叶子</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205192258662.png" alt="image-20221205192258662" style="zoom:50%;" />
<blockquote>
<p>容器：一个（盘子）</p>
<p>叶子：三个（三种水果）</p>
</blockquote>
<h3 id="组合模式的定义">组合模式的定义</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205192352060.png" alt="image-20221205192352060" style="zoom:50%;" />
<blockquote>
<p><u><strong>对象</strong>结构型模式</u>（有<strong>关联关系</strong>）</p>
<ul class="lvl-1">
<li class="lvl-2">又称为==“部分-整体”(Part-Whole)模式==</li>
<li class="lvl-2">将对象组织到树形结构中，可以用来描述整体与部分的关系</li>
</ul>
</blockquote>
<h4 id="组合模式结构">组合模式结构</h4>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205193232372.png" alt="image-20221205193232372"></p>
<blockquote>
<p>三个关键：</p>
<ol>
<li class="lvl-3">
<p>抽象层：客户端面向抽象层编程，<mark>客户端可以一致地对待叶子和容器</mark></p>
</li>
<li class="lvl-3">
<p>容器与构件（Component）具有关联关系：保证了一个容器中的内容既可以是叶子也可以是容器，从而建立了多层嵌套结构。<mark>（即要与父类建立关联关系）</mark></p>
<ul class="lvl-3">
<li class="lvl-5">如果关联关系建立在容器（Composite）与叶子（Leaf）之间的话就会导致容器中只能有叶子而不能再由子容器。</li>
</ul>
</li>
<li class="lvl-3">
<p>叶子（Leaf）拥有不必要的操作方法，<u>破坏封装性</u></p>
</li>
</ol>
<ul class="lvl-1">
<li class="lvl-2">
<p>叶子包含业务方法</p>
</li>
<li class="lvl-2">
<p>容器包含业务方法外还包含访问和管理成员的方法</p>
</li>
</ul>
<p><mark>标准的组合模式破坏了封装性</mark>：</p>
<p>叶子Leaf类因为继承了Component从而不得不拥有add、remove、getChild等操作方法；但是叶子Leaf类只需要知道业务方法operation即可。</p>
</blockquote>
<h5 id="组合模式包含以下3个角色：">组合模式包含以下3个角色：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Component（抽象构件）</p>
</li>
<li class="lvl-2">
<p>Leaf（叶子构件）</p>
</li>
<li class="lvl-2">
<p>Composite（容器构件）</p>
</li>
</ul>
<h5 id="抽象构件角色典型代码">抽象构件角色典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>; <span class="comment">//增加成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>; <span class="comment">//删除成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//获取成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;  <span class="comment">//业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="叶子构件角色典型代码">叶子构件角色典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123; </span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;	</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123; </span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123; </span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//叶子构件具体业务方法的实现</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="容器构件角色典型代码">容器构件角色典型代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Component)list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//容器构件具体业务方法的实现，将递归调用成员构件的业务方法</span></span><br><span class="line">        <span class="comment">//如果obj是一个Composite，那么调用的operation方法将会是往下递归</span></span><br><span class="line">        <span class="comment">//当obj是一个Leaf时，那么调用的operation方法将会是一个具体的业务实现方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj:list) &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例类图：">实例类图：</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205194333176.png" alt="image-20221205194333176"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205194345973.png" alt="image-20221205194345973"></p>
<blockquote>
<p>(1) AbstractFile：抽象文件类，充当抽象构件类</p>
<p>(2) ImageFile：图像文件类，充当叶子构件类</p>
<p>(3) TextFile：文本文件类，充当叶子构件类</p>
<p>(4) VideoFile：视频文件类，充当叶子构件类</p>
<p>(5) Folder：文件夹类，充当容器构件类</p>
<p>(6) Client：客户端测试类</p>
</blockquote>
<h6 id="结果及分析">结果及分析</h6>
<p>如果需要更换操作节点，例如只对文件夹“文本文件”进行杀毒，客户端代码只需修改一行即可，例如将代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">folder1.killVirus();</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">folder3.killVirus();</span><br></pre></td></tr></table></figure>
<p>在具体实现时，可以创建图形化界面让用户来选择所需操作的根节点，<u>无须修改源代码</u>，<mark>符合开闭原则</mark></p>
<blockquote>
<p><u><strong>从拓展叶子上</strong></u>，组合模式<mark>符合开闭原则</mark>。</p>
</blockquote>
<h6 id="java-awt中的组件树">Java  AWT中的组件树</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205200718610.png" alt="image-20221205200718610" style="zoom: 50%;" />
<h3 id="透明组合模式">透明组合模式</h3>
<ol>
<li class="lvl-3">
<p>抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法</p>
</li>
<li class="lvl-3">
<p>在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象</p>
</li>
<li class="lvl-3">
<p>缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的</p>
</li>
</ol>
<h3 id="安全组合模式">安全组合模式</h3>
<ol>
<li class="lvl-3">
<p>抽象构件Component中<mark>没有声明任何用于管理成员对象的方法</mark>，而是在Composite类中声明并实现这些方法</p>
</li>
<li class="lvl-3">
<p><mark>对于叶子对象，客户端不可能调用到这些操作对象的方法</mark></p>
</li>
<li class="lvl-3">
<p>缺点是<mark>不够透明</mark>，<u>客户端不能完全针对抽象编程</u>，<u>必须有区别地对待叶子构件和容器构件</u></p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205201003756.png" alt="image-20221205201003756" style="zoom:50%;" />
<blockquote>
<p><mark>定义容器的时候只能用子类Composite来声明</mark>，客户端不能完全面向抽象编程。</p>
</blockquote>
<h3 id="模式优点">模式优点</h3>
<ol>
<li class="lvl-3">
<p>可以<mark>清楚地定义分层次的复杂对象</mark>，<u>表示对象的全部或部分层次</u>，让客户端忽略了层次的差异，方便对整个层次结构进行控制</p>
</li>
<li class="lvl-3">
<p>客户端<mark>可以一致地使用一个组合结构或其中单个对象</mark>，不必关心处理的是单个对象还是整个组合结构，<u>简化了客户端代码</u></p>
</li>
<li class="lvl-3">
<p><u>增加新的容器构件和叶子构件都很方便</u>，<mark>符合开闭原则</mark></p>
</li>
<li class="lvl-3">
<p>为<u>树形结构的面向对象实现</u>提供了一种灵活的解决方案</p>
</li>
</ol>
<h3 id="模式缺点">模式缺点</h3>
<ol>
<li class="lvl-3">
<p>在增加新构件时<mark>很难对容器中的构件类型进行限制</mark></p>
</li>
</ol>
<h3 id="模式适用环境">模式适用环境</h3>
<ol>
<li class="lvl-3">
<p>在具有<mark>整体和部分的层次结构</mark>中，希望通过一种方式<u><strong>忽略整体与部分的差异</strong></u>，<mark>客户端可以一致地对待它们</mark></p>
</li>
<li class="lvl-3">
<p>在一个使用<mark>面向对象语言开发的系统</mark>中需要处理一个<mark>树形结构</mark></p>
</li>
<li class="lvl-3">
<p>在一个系统中<mark>能够分离出叶子对象和容器对象</mark>，而且它们的类型不固定，<mark>需要增加一些新的类型</mark></p>
</li>
</ol>
<h4 id="思考题">思考题</h4>
<p>在组合模式的结构图中，如果聚合关联关系不是从Composite到Component的，而是从Composite到Leaf，如下图所示，会产生怎样的结果？</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221205201545575.png" alt="image-20221205201545575" style="zoom:50%;" />
<blockquote>
<p>容器（Composite）中就只能包含叶子（Leaf），最多只能形成两层结构，不能形成多层结构。</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>用例图绘制注意事项</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/%E7%94%A8%E4%BE%8B%E5%9B%BE%E7%BB%98%E5%88%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>用例图绘制注意事项</h1>
<blockquote>
<p><mark>虚线箭头</mark>表示<mark>依赖</mark>的关系：</p>
<p>&lt;<include>&gt;:有某个用例的进行需要依赖于另一个用例的意思</p>
<p>&lt;<extend>&gt;:扩展用例要依赖于Base用例的“扩展点”进行扩展</p>
</blockquote>
<h3 id="1-发布信息与审核信息">1、发布信息与审核信息</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230221225616654.png" alt="image-20230221225616654"></p>
<h3 id="2-参与购买-竞拍-与-通过其它系统-支付费用">2、参与购买（竞拍……）与（通过其它系统）支付费用</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230221230047046.png" alt="image-20230221230047046"></p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件体系结构1-2章</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-1_2%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>软件体系结构1-2章</h1>
<blockquote>
<p><mark>往年考试题（大概）</mark>：根据一个场景来选择自己认为合适的模式进行设计，画出UML类图（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>也可能是</mtext><mn>2</mn><mtext>个模式</mtext><mo>⟶</mo><mtext>最多两个连用</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{也可能是2个模式 \longrightarrow最多两个连用}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord cjk_fallback" style="color:red;">也可能是</span><span class="mord" style="color:red;">2</span><span class="mord cjk_fallback" style="color:red;">个模式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">最多两个连用</span></span></span></span>）</p>
</blockquote>
<h2 id="第一章-6分">第一章==（6分）==</h2>
<blockquote>
<p>MVC是<u><em><strong>架构模式</strong></em></u>，不是<u><em><strong>设计模型</strong></em></u></p>
</blockquote>
<h3 id="第一章教学内容">第一章教学内容</h3>
<ol>
<li class="lvl-3">
<p>引言</p>
</li>
<li class="lvl-3">
<p>软件体系结构的意义</p>
</li>
<li class="lvl-3">
<p>软件体系结构的定义</p>
</li>
<li class="lvl-3">
<p>软件体系结构的发展</p>
</li>
<li class="lvl-3">
<p>软件体系结构的优势</p>
</li>
</ol>
<h4 id="软件体系结构的定义">软件体系结构的定义</h4>
<p>国内普遍接受的定义：软件体系结构包括构件、连接件和约束，它是<mark>可预制</mark>和<mark>可重构</mark>的软件框架结构。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>构件</mark>是<u>可预制和可重用的</u>软件部件，是<mark>组成体系结构</mark>的<mark>基本计算单元</mark>或<mark>数据存储单元</mark></p>
</li>
<li class="lvl-2">
<p><mark>连接件</mark>也是可预制和可重用的软件部件，是<mark>构件之间</mark>的<mark>连接单元</mark></p>
</li>
<li class="lvl-2">
<p>构件和连接件<mark>之间的关系</mark>用<mark>约束来描述</mark></p>
</li>
</ul>
<p><mark>软件体系结构 <strong>=</strong> 构件 <strong>+</strong> 连接件 <strong>+</strong> 约束</mark></p>
<h6 id="软件体系结构包括三大要素：">软件体系结构包括三大要素：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>构件(Component)——项目文件也可以是构件，可简单可复杂，从<u>文件</u>到<u>系统</u>都<mark>能成为构件</mark>，<u>框架也可以是一种构件</u></p>
</li>
<li class="lvl-2">
<p>连接件(Connector)</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>连接件是体系结构的一个元素，它可以用于建模：</strong>
<ul class="lvl-4">
<li class="lvl-6">构件之间的相互作用</li>
<li class="lvl-6">控制这些相互作用的规则</li>
</ul>
</li>
<li class="lvl-4"><strong>简单相互作用：</strong>
<ul class="lvl-4">
<li class="lvl-6">过程的调用</li>
<li class="lvl-6">访问<mark>共享变量</mark></li>
</ul>
</li>
<li class="lvl-4"><strong>复杂和语义相关的相互作用：</strong>
<ul class="lvl-4">
<li class="lvl-6">客户端-服务器<mark>协议</mark></li>
<li class="lvl-6">数据库访问<mark>协议</mark></li>
<li class="lvl-6">异步事件的多点传送</li>
<li class="lvl-6"><u><strong>管道数据流</strong></u></li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>约束(Constraint)或配置(Configuration)</p>
<ul class="lvl-2">
<li class="lvl-4">正确的连接性</li>
<li class="lvl-4">并发和分布性</li>
<li class="lvl-4">符合设计的启发式和风格规则</li>
</ul>
</li>
</ul>
<blockquote>
<p>在类图中，<u><strong>类</strong></u>就是<mark>构件</mark>，<u><strong>类与类之间的关系</strong></u>就是<mark>连接件</mark>，绘制UML类图的规则以及java类的<u><strong>语法规则</strong></u>就是<mark>约束</mark>。</p>
<p>同比，在包图中，包就是构件（component），包与包之间的关系就是连接件，包的规则就是约束。</p>
</blockquote>
<h6 id="连接件">连接件</h6>
<blockquote>
<p>构件之间的连接件详细参考：<a href="https://blog.csdn.net/tianhai110/article/details/6339565?ops_request_misc=%7B%22request_id%22%3A%22165484978516781435484033%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165484978516781435484033&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-6339565-null-null.142%5Ev13%5Econtrol,157%5Ev14%5Enew_3&amp;utm_term=UML%E7%B1%BB%E5%9B%BE&amp;spm=1018.2226.3001.4187">(77条消息) UML类图几种关系的总结_挨踢大侠的博客-CSDN博客_类图的六种关系</a></p>
</blockquote>
<p>各种关系的强弱程度：</p>
<p><mark>泛化（继承）=实现&gt;组合&gt;聚合&gt;关联&gt;依赖</mark></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220610183303978.png" alt="image-20220610183303978" style="zoom: 67%;" />
<blockquote>
<p>泛化就是继承</p>
</blockquote>
<h4 id="软件体系结构具有四个角度">软件体系结构具有四个角度</h4>
<p>概念角度：<mark>描述</mark>系统的<mark>主要构件</mark>及它们<mark>之间的关系</mark>；</p>
<p>模块角度：<mark>包含</mark>功能分解与层次结构；</p>
<p>运行角度：描述了一个<mark>系统的动态结构</mark>；</p>
<p>代码角度：描述了<mark>各种代码和库函数</mark>在开发环境中<mark>的组织</mark>。</p>
<h4 id="考过-软件体系结构的优势">==（考过）==软件体系结构的优势</h4>
<ol>
<li class="lvl-3">
<p><u><em><strong>容易理解</strong></em></u></p>
<ul class="lvl-2">
<li class="lvl-5">它从一个高层设计的抽象层次来表征一个系统</li>
<li class="lvl-5">简化了我们理解庞大系统的能力</li>
</ul>
</li>
<li class="lvl-3">
<p><u><em><strong>重用</strong></em></u></p>
<ul class="lvl-2">
<li class="lvl-5">重用大的<mark>构件</mark></li>
<li class="lvl-5">重用一些<mark>集成构件</mark>的<mark>框架</mark></li>
<li class="lvl-5">特定领域的软件体系结构</li>
<li class="lvl-5"><mark>设计模式</mark></li>
</ul>
</li>
<li class="lvl-3">
<p><u><em><strong>控制成本</strong></em></u></p>
<ul class="lvl-2">
<li class="lvl-5">系统维护者可以<mark>更好的理解</mark><u><strong>变更</strong></u>带来<mark>的影响</mark>，因而可以<mark>更加精确的估算</mark>变更<mark>所需的成本</mark></li>
</ul>
</li>
<li class="lvl-3">
<p><u><em><strong>可分析性</strong></em></u></p>
<ul class="lvl-2">
<li class="lvl-5">对系统的**<u>一致性检查</u>**<mark>提供高层次的视图</mark></li>
<li class="lvl-5">研究系统是否<mark>与某种体系结构风格相符合</mark></li>
<li class="lvl-5">对符合特定风格的<mark>特定领域系统</mark>的<mark>体系结构分析</mark></li>
<li class="lvl-5"><mark>分析</mark>依赖于其中的<mark>构件</mark></li>
</ul>
</li>
</ol>
<h2 id="第二章">第二章</h2>
<h3 id="第二章教学内容-16分">第二章教学内容==（16分）==</h3>
<ol>
<li class="lvl-3">
<p>定义</p>
</li>
<li class="lvl-3">
<p>管道和过滤器</p>
</li>
<li class="lvl-3">
<p>数据抽象和面向对象组织</p>
</li>
<li class="lvl-3">
<p>基于事件的隐式调用</p>
</li>
<li class="lvl-3">
<p>分层系统</p>
</li>
<li class="lvl-3">
<p>仓库系统</p>
</li>
<li class="lvl-3">
<p>过程控制环路</p>
</li>
<li class="lvl-3">
<p>C/S风格</p>
</li>
<li class="lvl-3">
<p>三层C/S风格</p>
</li>
<li class="lvl-4">
<p>B/S风格</p>
</li>
</ol>
<h4 id="经典的体系结构风格">经典的体系结构风格</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据流风格</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{数据流风格}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">数据流风格</span></span></span></span>: 批处理序列; 管道/过滤器。</p>
</li>
<li class="lvl-2">
<p>调用/返回风格：主程序/子程序；面向对象风格；层次结构。</p>
</li>
<li class="lvl-2">
<p>独立构件风格：进程通讯；事件系统。</p>
</li>
<li class="lvl-2">
<p>虚拟机风格：解释器；基于规则的系统。</p>
</li>
<li class="lvl-2">
<p>仓库风格：数据库系统；超文本系统；黑板系统。</p>
</li>
<li class="lvl-2">
<p>过程控制环路</p>
</li>
<li class="lvl-2">
<p>C/S风格——客户端<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>服务器</p>
</li>
<li class="lvl-2">
<p>B/S风格——零客户端</p>
</li>
</ul>
<h5 id="管道和过滤器">管道和过滤器</h5>
<blockquote>
<p>编译器的组成：语法检查器，目标代码生成器，</p>
<p><mark>在某些语言中，函数是指有返回类型的方法，过程是指没有返回类型的方法，java中两者之间并无严格区分，统称为方法</mark></p>
</blockquote>
<h6 id="概述：">概述：</h6>
<p>每个构件<strong>都有</strong><mark>一组输入和输出</mark>，构件<strong>读</strong><mark>输入的数据流</mark>，经过<u><strong>内部处理</strong></u>，然后<strong>产生</strong><mark>输出数据流</mark>。</p>
<p><mark>过滤器风格</mark>的<u>连接件</u>就像<u>是</u>数据流传输的<u>管道</u>，将<u><strong>一个过滤器的输出</strong></u>传到<u><strong>另一个过滤器的输入</strong></u>。</p>
<h6 id="不变量：">不变量：</h6>
<p>过滤器虽然可以增量式地处理数据，但是它们是<mark>独立的</mark></p>
<p>管道和过滤器的正确输出<mark>不依赖其顺序</mark></p>
<h6 id="实例：">实例：</h6>
<p>编译器，功能程序，并行程序</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921201159798.png" alt="image-20220921201159798"></p>
<h5 id="数据抽象和面向对象组织">数据抽象和面向对象组织</h5>
<h6 id="概述：">概述：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>数据</u>的<u>表示方法</u>和它们的<u>相应操作</u>被<mark>封装在</mark>一个<mark>抽象数据类型</mark>或<mark>对象</mark>中</p>
</li>
<li class="lvl-2">
<p>这种风格的构件是**<u>对象或者说是抽象数据类型的实例</u>**</p>
</li>
<li class="lvl-2">
<p>对象通过函数和过程的调用来进行交互</p>
</li>
</ul>
<h5 id="基于事件的隐式调用">基于事件的隐式调用</h5>
<p><mark>事件源</mark>（Event Source）和<mark>事件处理</mark>（Event Handler）</p>
<blockquote>
<p>事件源（Event Source）与事件处理（Event Handler）两者之间通过<code>注册</code>进行连接，<code>注册</code>就是两个构件之间的连接件。</p>
</blockquote>
<p><mark>隐式调用</mark>：事件源没有直接与事件处理绑定，而是通过接口实现进行联系，故为<mark>隐式</mark>。</p>
<blockquote>
<p>里氏代换原则：父类都可以被子类替代</p>
</blockquote>
<h6 id="概述：">概述：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>构件<mark>不直接调用</mark>一个<strong>过程</strong>，而是<mark>触发或广播</mark><u><strong>一个或多个事件</strong></u></p>
</li>
<li class="lvl-2">
<p>系统中的<u>其他构件中的过程在一个或多个事件中注册</u>，<mark>当一个事件被触发</mark>，系统<u>自动调用在这个事件中注册的所有过程</u>。</p>
</li>
<li class="lvl-2">
<p>这种风格的构件是一个模块，这些模块可以是一些过程，又可以是一些事件的集合。</p>
</li>
</ul>
<h6 id="不变量：">不变量：</h6>
<p>事件的触发者并不知道哪些构件会被这些事件影响（观察者模式-Observer）</p>
<h6 id="实例：">实例：</h6>
<p>数据库管理系统，用户界面</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921203433739.png" alt="image-20220921203433739" style="zoom:50%;" />
<h5 id="分层系统">分层系统</h5>
<h6 id="概述：">概述：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>组织成一个<mark>层次结构</mark></p>
</li>
<li class="lvl-2">
<p>每一层都<mark>为上一层</mark>**<u>提供</u>**了相应的<mark>服务</mark>，并且<mark>接受下一层提供的服务</mark></p>
</li>
<li class="lvl-2">
<p>在分层系统的一些层次中<mark>构件实现了虚拟机</mark>的功能</p>
</li>
</ul>
<h6 id="实例：">实例：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>分层的通信协议</strong></u></p>
</li>
</ul>
<blockquote>
<p>最经典的分层就是<mark>OSI七层结构</mark></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921203652505.png" alt="image-20220921203652505" style="zoom:50%;" />
<h5 id="仓库系统">仓库系统</h5>
<p>概述：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>构件：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>中心数据结构（仓库）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{中心数据结构（仓库）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">中心数据结构（仓库）</span></span></span></span>和一些<mark>独立构件</mark>的集合</p>
</li>
<li class="lvl-2">
<p><mark>仓库</mark>和在系统中很重要的<mark>外部构件</mark>之间的<mark>相互作用</mark></p>
</li>
<li class="lvl-2">
<p>实例：<u><strong>需要使用一些复杂表征的信号处理系统</strong></u></p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921203825894.png" alt="image-20220921203825894" style="zoom:33%;" />
<h5 id="过程控制环路">过程控制环路</h5>
<h6 id="概述：">概述：</h6>
<p>源自于控制理论中的模型框架，将事务处理看成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>输入、加工、输出、反馈、再输入</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{输入、加工、输出、反馈、再输入}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">输入、加工、输出、反馈、再输入</span></span></span></span>的一个持续的过程模型。</p>
<p>通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>持续性的加工处理过程将输入数据转换成既定属性的“产品”</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{持续性的加工处理过程将输入数据转换成既定属性的“产品”}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">持续性的加工处理过程将输入数据转换成既定属性的</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">产品</span><span class="mord" style="color:red;">”</span></span></span></span>，在工控系统、供电、水利甚至可以推广到商务软件体现的管理模型中。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220921204205374.png" alt="image-20220921204205374" style="zoom:50%;" />
<h5 id="c-s风格">C/S风格</h5>
<p>C/S体系结构有三个主要组成部分：<mark>数据库服务器</mark>、<mark>客户应用程序</mark>和<mark>网络</mark>。</p>
<h6 id="服务器主要任务：">服务器主要任务：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据库安全性的要求；</p>
</li>
<li class="lvl-2">
<p>数据库访问并发性的控制；</p>
</li>
<li class="lvl-2">
<p>数据库前端的客户应用程序的<mark>全局数据完整性规则</mark>；</p>
</li>
<li class="lvl-2">
<p>数据库的<mark>备份和恢复</mark>。</p>
</li>
</ul>
<h6 id="客户应用程序主要任务：">客户应用程序主要任务：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>提供**<u>用户与数据库</u>**<mark>交互的界面</mark>；</p>
</li>
<li class="lvl-2">
<p>向数据库服务器<mark>提交用户请求</mark>并<mark>接收</mark>来自<mark>数据库服务器的信息</mark>；</p>
</li>
<li class="lvl-2">
<p>利用客户应用程序对存在于客户端的数据执行应用逻辑要求。</p>
</li>
</ul>
<h6 id="三层c-s风格">三层C/S风格</h6>
<h6 id="优点：">优点：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>允许<mark>合理地划分三层结构</mark>的功能，使之在逻辑上保持相对独立性，能<mark>提高</mark>系统和软件的<mark>可维护性和可扩展性</mark>。</p>
</li>
<li class="lvl-2">
<p>允许<mark>更灵活有效地选用</mark>相应的<mark>平台和硬件系统</mark>，使之在处理负荷能力上与处理特性上分别适应于结构清晰的三层；并且这些<mark>平台和各个组成部分</mark>可以<mark>具有</mark>良好的<mark>可升级性和开放性。</mark></p>
</li>
<li class="lvl-2">
<p>应用的<mark>各层</mark>可以<mark>并行开发</mark>，可以<mark>选择各自最适合的</mark>开发语言。</p>
</li>
<li class="lvl-2">
<p>利用<mark>功能层</mark>有效地<mark>隔离开</mark><strong><u>表示层与数据层</u></strong>，未授权的用户难以绕过功能层而利用数据库工具或黑客手段去非法地访问数据层，为<mark>严格的安全管理</mark>奠定了坚实的基础。</p>
</li>
</ul>
<h6 id="注意点：">注意点：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>三层C/S结构<mark>各层间的通信效率不高</mark>。</p>
</li>
<li class="lvl-2">
<p>设计时必须慎重考虑三层间的<u><strong>通信方法、通信频率及数据量</strong></u>。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220926200351945.png" alt="image-20220926200351945" style="zoom:33%;" />
<h5 id="b-s风格">B/S风格</h5>
<p>B/S体系结构具体为：<mark>浏览器、Web服务器、数据库服务器。</mark></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220926200214748.png" alt="image-20220926200214748" style="zoom:33%;" />
<h6 id="优点：">优点：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于B/S体系结构的软件，系统<u><strong>安装、修改和维护</strong></u>全在<mark>服务器端解决</mark>。用户在使用系统时，仅仅需要<mark>一个浏览器</mark>就可运行<mark>全部的模块</mark>，真正<mark>达到了“零客户端”的功能</mark>，很容易<mark>在运行时自动升级</mark>。</p>
</li>
<li class="lvl-2">
<p>B/S体系结构还<mark>提供了异种机、异种网、异种应用服务器的联机、联网、统一服务</mark>的最现实的<u><strong>开放性基础</strong></u>。</p>
</li>
<li class="lvl-2">
<p><u><strong>降低开发成本</strong></u>。</p>
</li>
</ul>
<h6 id="缺点：">缺点：</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>B/S体系结构==<strong>缺乏</strong>对动态页面的支持能力==，<mark>没有集成<strong>有效的</strong>数据库处理功能</mark>。</p>
</li>
<li class="lvl-2">
<p>B/S体系结构的<mark>系统<strong>扩展能力差</strong></mark>，<mark><strong>安全性</strong>难以控制</mark>。</p>
</li>
<li class="lvl-2">
<p>采用B/S体系结构的应用系统，<mark>在<strong>数据查询</strong>等<strong>响应速度上</strong>，要远远低于C/S体系结构。</mark></p>
</li>
<li class="lvl-2">
<p>B/S体系结构的数据提交一般以页面为单位，<mark>数据的<strong>动态交互性</strong>不强，不利于在线事务处理(OLTP)应用。</mark></p>
</li>
</ul>
<blockquote>
<p><u>交互性强的软件并不适合B/S，应该做成C/S。</u></p>
<p>考虑安全性和更新便利可以设置为：<strong><u>内网（局域网）B/S</u></strong>，<u><strong>外网则设计为C/S</strong></u>。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>除此之外还有其它的混合方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件体系结构——软件质量属性</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>软件质量属性==（8分）==</h1>
<h3 id="主要内容：">主要内容：</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>引言</p>
</li>
<li class="lvl-2">
<p>质量目标与商业目标</p>
</li>
<li class="lvl-2">
<p>外部质量</p>
</li>
<li class="lvl-2">
<p>内部质量</p>
</li>
<li class="lvl-2">
<p>过程质量</p>
</li>
</ul>
<h3 id="textcolor-red-第一次测试：-下周一晚上-11月7日"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>第一次测试：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{第一次测试：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">第一次测试：</span></span></span></span>下周一晚上（11月7日）</h3>
<blockquote>
<p>内容：20道选择题</p>
<p>范围：UML相关知识，每个图都会涉及到</p>
</blockquote>
<h5 id="质量的定义：">质量的定义：</h5>
<p>CMM 对质量的定义是：</p>
<p>① 一个系统、组件或过程符合特定需求的程度；</p>
<p>②一个系统、组件或过程符合客户或用户的要求或期望的程度。</p>
<p>软件质量是<u>许多质量属性的综合体现</u>，各种质量属性反映了软件质量的方方面面。人们通过<u>改善软件的各种质量属性</u>，从而提高软件的<u>整体质量</u>。</p>
<h5 id="质量目标与商业目标">质量目标与商业目标</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>具有质量的软件是那些与它们的最初目的相一致的软件</p>
</li>
<li class="lvl-2">
<p>高质量的软件符合<u>商业目标</u>和<u>用户需求</u></p>
</li>
<li class="lvl-2">
<p>它具有正确的功能和优良的属性</p>
</li>
</ul>
<h5 id="商业目标">商业目标</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>增加市场占有额</strong></p>
</li>
<li class="lvl-2">
<p><strong>快速而准确的市场化</strong></p>
</li>
<li class="lvl-2">
<p><strong>有效利用有限的资源</strong></p>
</li>
<li class="lvl-2">
<p><strong>产品的系列化</strong></p>
</li>
<li class="lvl-2">
<p><strong>低成本生产</strong></p>
</li>
<li class="lvl-2">
<p><strong>低成本维护</strong></p>
</li>
<li class="lvl-2">
<p><strong>市场的灵活性</strong></p>
</li>
<li class="lvl-2">
<p><strong>产品流水线</strong></p>
</li>
<li class="lvl-2">
<p>…</p>
</li>
</ul>
<h5 id="用户需求">用户需求</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>必要的功能</strong></p>
</li>
<li class="lvl-2">
<p><strong>低的学习成本</strong></p>
</li>
<li class="lvl-2">
<p><strong>使用容易</strong></p>
</li>
<li class="lvl-2">
<p><strong>可预测的行为</strong></p>
</li>
<li class="lvl-2">
<p><strong>可靠的服务</strong></p>
</li>
<li class="lvl-2">
<p><strong>快速的响应</strong></p>
</li>
<li class="lvl-2">
<p><strong>快速的输出</strong></p>
</li>
<li class="lvl-2">
<p><strong>对非法访问者和病毒的防范</strong></p>
</li>
<li class="lvl-2">
<p>…</p>
</li>
</ul>
<h6 id="商业目标决定质量目标">商业目标决定质量目标</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>企业的根本目标是为了获取尽可能多的利润，而不是生产完美无缺的产品。</p>
</li>
<li class="lvl-2">
<p>企业必须权衡质量、效率和成本，产品质量太低了或者太高了，都不利于企业获取利润。</p>
</li>
</ul>
<h4 id="软件开发流程">软件开发流程</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221102193953687.png" alt="image-20221102193953687" style="zoom:50%;" />
<h5 id="质量属性">质量属性</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>质量属性需求来源于商业和产品目标</p>
</li>
<li class="lvl-2">
<p>关键的质量属性必须刻画系统的细节特征</p>
</li>
<li class="lvl-2">
<p>质量属性场景是用于描述质量属性和表达项目干系人观点的强有力的工具</p>
</li>
<li class="lvl-2">
<p>软件的质量属性很多，如正确性、精确性，健壮性、可靠性、容错性、性能、易用性、安全性、可扩展性、可复用性、兼容性、可移植性、可测试性、可维护性等等</p>
</li>
<li class="lvl-2">
<p>软件质量属性场景用于描述软件的质量属性</p>
</li>
<li class="lvl-2">
<p>质量属性场景是一种面向特定的质量属性的需求</p>
</li>
</ul>
<h5 id="几个重要的质量属性">几个重要的质量属性</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221102194248718.png" alt="image-20221102194248718" style="zoom:50%;" />
<h4 id="外部质量-7个">外部质量（7个）</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>外部质量对于用户而言是可见的</mark></p>
</li>
<li class="lvl-2">
<p>包括正确性、健壮性、可靠性、性能、安全性、易用性、兼容性等</p>
<ul class="lvl-2">
<li class="lvl-4">正确性
<ul class="lvl-4">
<li class="lvl-6">正确性是指软件<mark>按照需求正确执行任务的能力</mark></li>
</ul>
</li>
<li class="lvl-4">健壮性
<ul class="lvl-4">
<li class="lvl-6">健壮性是指<mark>在异常情况下，软件能够正常运行的能力</mark></li>
</ul>
</li>
<li class="lvl-4">可靠性
<ul class="lvl-4">
<li class="lvl-6">可靠性是指在一定的环境下，在<u><strong>给定的时间内</strong></u>，系统<mark>不发生故障（可以正常运行）的概率</mark>
<ul class="lvl-6">
<li class="lvl-8">指标一：无故障运行时间</li>
<li class="lvl-8">指标二：故障恢复时间？（待定）</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-4">性能
<ul class="lvl-4">
<li class="lvl-6">性能通常是指软件的==“时间空间”效率==，而不仅是指软件的运行速度</li>
</ul>
</li>
<li class="lvl-4">安全性
<ul class="lvl-4">
<li class="lvl-6">安全性是指<mark>防止系统被非法入侵的能力</mark>，既属于技术问题又属于管理问题</li>
</ul>
</li>
<li class="lvl-4">易用性
<ul class="lvl-4">
<li class="lvl-6">易用性是指用户<mark>使用软件的容易程度</mark></li>
</ul>
</li>
<li class="lvl-4">兼容性
<ul class="lvl-4">
<li class="lvl-6"><strong>兼容性</strong>是指<mark>不同产品（或者新老产品）相互交换信息的能力</mark>。例如两个字处理软件的文件格式兼容，那么它们都可以操作对方的文件，这种能力对用户很有好处。兼容性又称为互操作性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="内部质量-6个">内部质量（6个）</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>内部质量只有开发人员关心</mark></p>
</li>
<li class="lvl-2">
<p>它们可以帮助开发人员实现外部质量</p>
</li>
<li class="lvl-2">
<p>包括易理解性、可测试性、可维护性、可扩展性、可移植性、可复用性等</p>
<ul class="lvl-2">
<li class="lvl-4">易理解性
<ul class="lvl-4">
<li class="lvl-6">易理解性是开发人员理解软件产品的能力，意味着所有的工作成果<mark>要易读、易理解</mark>，可以提高团队开发效率，降低维护代价</li>
</ul>
</li>
<li class="lvl-4">可测试性
<ul class="lvl-4">
<li class="lvl-6">可测试性指的是测试软件组件或集成产品时<mark>查找缺陷的难易程度</mark>，<mark>又称为可验证性</mark></li>
</ul>
</li>
<li class="lvl-4">可维护性
<ul class="lvl-4">
<li class="lvl-6">可维护性表明了在软件中<mark>纠正一个缺陷或做一次更改的难易程度</mark></li>
<li class="lvl-6">你可以根据修复<mark>一个问题所花的平均时间和修复正确的百分比</mark>来衡量可维护性。</li>
</ul>
</li>
<li class="lvl-4">可扩展性
<ul class="lvl-4">
<li class="lvl-6">可扩展性反映<mark>软件适应“变化”的能力</mark></li>
</ul>
</li>
<li class="lvl-4">可移植性
<ul class="lvl-4">
<li class="lvl-6">可移植性指的是软件不经修改或稍加修改就可以<mark>运行于不同软硬件环境（CPU、OS和编译器）的能力</mark>，主要体现为代码的可移植性</li>
</ul>
</li>
<li class="lvl-4"><mark>可复用性</mark>
<ul class="lvl-4">
<li class="lvl-6">可复用性是指一个<mark>软件的组成部分</mark>可以在同一个项目的不同地方甚至在不同的项目中<mark>重复使用的能力</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="过程质量">过程质量</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果想保持一如既往的开发高质量的产品，过程必须是<mark>可靠的</mark></p>
</li>
<li class="lvl-2">
<p>如果想适应无法预计的工具或环境改变，过程必须是<mark>稳健的</mark></p>
</li>
<li class="lvl-2">
<p>过程的执行必须是<mark>高效的</mark></p>
</li>
<li class="lvl-2">
<p>如果想适应新的管理方式或组织形式，过程必须是<mark>可扩展的</mark></p>
</li>
<li class="lvl-2">
<p>如果想跨项目和组织来使用，过程必须是<mark>可重用的</mark></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件体系结构——设计模式概述</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>设计模式概述</h1>
<blockquote>
<p>设计模式（Design Patterns）参考：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h4 id="textcolor-red-测试：-学完设计模式之后会有第二次随堂测试"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>测试：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{测试：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">测试：</span></span></span></span>学完设计模式之后会有第二次随堂测试</h4>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==：判断的是内存</span><br><span class="line">equal：比较的是内容</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><u>考试中的设计模式名称均以英文名的方式呈现</u></p>
</blockquote>
<h3 id="桥接模式：">桥接模式：</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221107195453733.png" alt="image-20221107195453733" style="zoom:50%;" />
<h3 id="策略模式：">策略模式：</h3>
<blockquote>
<p>详细参考：<a href="https://www.runoob.com/design-pattern/strategy-pattern.html">策略模式 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<p>策略类：用来封装算法的类</p>
<h3 id="适配器模式：">适配器模式：</h3>
<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>关键：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{关键：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">关键：</span></span></span></span>在Adapter 类中创建接口对象，接口对象在new对象的时候可以使用其子类进行替换。</p>
<p>从适配器模式的Adapter 类可以看出，接口对象是可以被实现接口的类替换掉的，类似于子类替换父类。</p>
<blockquote>
<p>参考：<a href="https://www.runoob.com/design-pattern/adapter-pattern.html">适配器模式 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<ol>
<li class="lvl-3">
<p>类适配器模式</p>
<ul class="lvl-2">
<li class="lvl-5">继承（extend）一个类，再实现（implement）一个接口</li>
</ul>
</li>
<li class="lvl-3">
<p>对象适配器模式（使用更多）</p>
<ul class="lvl-2">
<li class="lvl-5">使用更多的原因：
<ul class="lvl-4">
<li class="lvl-7">java不支持多重继承，所以至多能继承一个类，而与其它类只能通过关联关系来实现将多个类的联系</li>
<li class="lvl-7">final类不支持继承</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="单例模式：">单例模式：</h3>
<p>是目前最大的设计模式。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>关键：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{关键：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">关键：</span></span></span></span>构造函数私有</p>
<blockquote>
<p>详细参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h5 id="软件模式">软件模式</h5>
<p>在一定条件下的软件开发问题及其解法</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109190208258.png" alt="image-20221109190208258" style="zoom:50%;" />
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>问题描述</p>
</li>
<li class="lvl-2">
<p>前提条件（环境或约束条件）</p>
</li>
<li class="lvl-2">
<p>解法</p>
</li>
<li class="lvl-2">
<p>效果</p>
</li>
</ul>
</blockquote>
<h5 id="大三律-rule-of-three">大三律（Rule of Three）</h5>
<p>只有经过3个以上不同类型（或不同领域）的系统的校验，一个解决方案才能从候选模式升格为模式。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109190929244.png" alt="image-20221109190929244" style="zoom:33%;" />
<blockquote>
<p><mark>模式必须具有通用性。</mark></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>设计模式</p>
</li>
<li class="lvl-2">
<p>架构模式（关注如何分层）</p>
<ul class="lvl-2">
<li class="lvl-4">如：MVC模式</li>
</ul>
</li>
</ul>
<h3 id="设计模式的定义">设计模式的定义</h3>
<h5 id="普遍定义：设计模式">普遍定义：设计模式</h5>
<ol>
<li class="lvl-3">
<p>一套被<mark>反复使用的、多数人知晓的、经过分类编目的、代码设计经验</mark>的总结</p>
</li>
<li class="lvl-3">
<p>目的：为了可<mark>重用代码</mark>、让代码<mark>更容易被他人理解</mark>、提高代码的<mark>可靠性</mark></p>
</li>
<li class="lvl-3">
<p>是一种用于对软件系统中<mark>不断重现的设计问题</mark>的解决方案进行文档化的技术</p>
</li>
<li class="lvl-3">
<p>是一种共享专家设计经验的技术</p>
</li>
</ol>
<h5 id="gof的定义">GoF的定义</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109192758915.png" alt="image-20221109192758915" style="zoom: 50%;" />
<h6 id="策略模式示意图：">策略模式示意图：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109192947596.png" alt="image-20221109192947596" style="zoom:50%;" />
<h6 id="设计模式的基本要素">设计模式的基本要素</h6>
<ol>
<li class="lvl-3">
<p>模式名称 (Pattern Name)</p>
</li>
<li class="lvl-3">
<p>问题 (Problem)</p>
</li>
<li class="lvl-3">
<p>解决方案 (Solution)</p>
</li>
<li class="lvl-3">
<p>效果 (Consequences)</p>
</li>
</ol>
<h5 id="设计模式的分类">设计模式的分类</h5>
<h6 id="根据目的分类：">根据目的分类：</h6>
<p>1️⃣根据<code>目的</code>（模式是用来做什么的）可分为==创建型(Creational)，结构型(Structural)和行为型(Behavioral)==三类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>创建型</code>模式主要<u>用于创建对象</u>-5</p>
</li>
<li class="lvl-2">
<p><code>结构型模</code>式主要<u>用于处理类或对象的组合</u>-7</p>
</li>
<li class="lvl-2">
<p><code>行为型模式</code>主要<u>用于描述类或对象如何交互和怎样分配职责</u>-11</p>
</li>
</ul>
<blockquote>
<p><u>5+7+11=23个设计模式</u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109194722284.png" alt="image-20221109194722284" style="zoom: 25%;" />
</blockquote>
<h6 id="根据范围分类：">根据范围分类：</h6>
<p>2️⃣根据范围，即模式主要是处理类之间的关系还是处理对象之间的关系，可分为<mark>类模式</mark>和<mark>对象模式</mark>两种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是一种<mark>静态关系</mark></p>
</li>
<li class="lvl-2">
<p>对象模式处理对象间的关系，这些关系在运行时变化，更具<mark>动态性</mark></p>
<ul class="lvl-2">
<li class="lvl-4">类图中存在关联关系</li>
</ul>
</li>
</ul>
<h4 id="创建型模式">创建型模式</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109200309740.png" alt="image-20221109200309740" style="zoom:50%;" />
<h4 id="结构型模式">结构型模式</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109200326749.png" alt="image-20221109200326749" style="zoom:50%;" />
<h4 id="行为型模式">行为型模式</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109200341149.png" alt="image-20221109200341149" style="zoom:50%;" />
<h5 id="设计模式的优点">设计模式的优点</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109200529292.png" alt="image-20221109200529292"></p>
<blockquote>
<p>大部分设计模式都有抽象层，但单例模式没有抽象层。</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件体系结构第3章——统一建模语言UML</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-3%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第三章-统一建模语言uml-20分">第三章 统一建模语言UML==（20分）==</h2>
<blockquote>
<p>软件：powerDesigner 16.6</p>
</blockquote>
<h5 id="textcolor-blue-四种交互图："><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mtext>四种交互图：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{blue}{四种交互图：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:blue;">四种交互图：</span></span></span></span></h5>
<blockquote>
<ol>
<li class="lvl-3">
<p>顺序图</p>
</li>
<li class="lvl-3">
<p>通信图（与顺序图同构）</p>
</li>
<li class="lvl-3">
<p>定时图</p>
</li>
<li class="lvl-3">
<p>交互概览图（细化的活动图，采用顺序图来细化）</p>
</li>
</ol>
</blockquote>
<h5 id="textcolor-blue-面向对象系统的物理方面建模的两种图："><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mtext>面向对象系统的物理方面建模的两种图：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{blue}{面向对象系统的物理方面建模的两种图：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:blue;">面向对象系统的物理方面建模的两种图：</span></span></span></span></h5>
<blockquote>
<ol>
<li class="lvl-3">
<p>组件图</p>
</li>
<li class="lvl-3">
<p>部署图</p>
</li>
</ol>
</blockquote>
<h3 id="uml结构">UML结构</h3>
<h6 id="视图-view">视图(View)</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928190818136.png" alt="image-20220928190818136" style="zoom: 50%;" />
<blockquote>
<p><u><strong>结构、实现、行为、环境视图</strong></u></p>
</blockquote>
<h6 id="图-diagram">图(Diagram)</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928190858031.png" alt="image-20220928190858031" style="zoom:50%;" />
<blockquote>
<p>红色和绿色必须完全掌握，黑色的则要能够看懂。</p>
</blockquote>
<h6 id="模型元素-model-element">模型元素(Model element)</h6>
<ol>
<li class="lvl-3">
<p>模型元素包括<mark>事物</mark>以及<u>事物与事物之间</u>的<mark>联系</mark></p>
</li>
<li class="lvl-3">
<p>每一个模型元素都有一个与之相对应的<mark>图形元素</mark></p>
</li>
<li class="lvl-3">
<p>同一个模型元素<u><strong>可以在不同的UML图中使用</strong></u></p>
</li>
<li class="lvl-3">
<p>无论在哪个图中，同一个模型元素都保持<mark>相同的意义和符号</mark></p>
</li>
</ol>
<h6 id="通用机制-general-mechanism">通用机制(General mechanism)</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>额外的<strong>注释</strong>、修饰和语义等</p>
</li>
<li class="lvl-2">
<p>包括规格说明、修饰、公共分类和<strong>扩展机制</strong>四种</p>
</li>
<li class="lvl-2">
<p><u>允许用户对UML进行扩展</u></p>
</li>
</ul>
<h5 id="uml的特点-6个特点">UML的特点==（6个特点）==</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>工程化</p>
</li>
<li class="lvl-2">
<p>规范化</p>
</li>
<li class="lvl-2">
<p>可视化——图的可视化</p>
</li>
<li class="lvl-2">
<p>系统化——多种UML图从不同角度描述同一功能</p>
</li>
<li class="lvl-2">
<p>文档化——使文档更易理解</p>
</li>
<li class="lvl-2">
<p>智能化</p>
</li>
</ul>
<h3 id="uml构造需求模型">UML构造需求模型</h3>
<blockquote>
<p>重点：用例图、状态图、活动图、顺序图、用例文档</p>
</blockquote>
<h4 id="textcolor-red-用例图use-case-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>用例图</mtext><mi>U</mi><mi>s</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---用例图Use Case Diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">用例图</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord mathnormal" style="color:red;">se</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">seD</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<h4 id="用例建模">用例建模</h4>
<blockquote>
<p>重点：用例图、用例文档</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：考试时，用例数量在</mtext><mn>10</mn><mtext>个左右</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：考试时，用例数量在10个左右}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：考试时，用例数量在</span><span class="mord" style="color:red;">10</span><span class="mord cjk_fallback" style="color:red;">个左右</span></span></span></span></p>
</blockquote>
<p>主要内容：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>用例图(Use Case Diagram)</p>
</li>
<li class="lvl-2">
<p>用例描述文档 (Use Case Specification)</p>
</li>
</ul>
<p><code>术语表</code>是为开发人员<mark>解释业务专业名词</mark>，而<u>非面向用户</u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928194250542.png" alt="image-20220928194250542" style="zoom:33%;" />
<p>用例建模步骤==（5步骤）==</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>识别执行者</p>
</li>
<li class="lvl-2">
<p>识别用例</p>
</li>
<li class="lvl-2">
<p>绘制用例图</p>
</li>
<li class="lvl-2">
<p>书写用例文档</p>
</li>
<li class="lvl-2">
<p>检查用例模型</p>
</li>
</ul>
<h6 id="识别执行者">识别执行者</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928194442951.png" alt="image-20220928194442951" style="zoom: 50%;" />
<blockquote>
<p>执行者：直接操作系统的任何事物；</p>
<p><mark>执行者包含三类：人、其它系统（比如：支付宝支付系统）、自动发生的事件（比如：时间）</mark>；</p>
<p>功能相同的执行者之间可以合并，但是具有不同执行功能的执行者之间就不能合并，如若合并则会导致真正的业务被覆盖</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928200307684.png" alt="image-20220928200307684" style="zoom:50%;" />
<p>用户在手机上买票<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>用户是执行者；用户在车站买票<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>用户不是执行者，售票员才是执行者（售票员直接与系统进行交互）。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928200504887.png" alt="image-20220928200504887" style="zoom: 50%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>执行者与执行者之间只有继承关系</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{执行者与执行者之间只有继承关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">执行者与执行者之间只有继承关系</span></span></span></span>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928200527380.png" alt="image-20220928200527380" style="zoom:33%;" />
</blockquote>
<h6 id="识别用例">识别用例</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928200614839.png" alt="image-20220928200614839" style="zoom:50%;" />
<p><mark>用例要点：</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>有意义的目标</p>
</li>
<li class="lvl-2">
<p>价值结果由系统生成</p>
</li>
<li class="lvl-2">
<p>业务语言——用户观点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>不要有技术语言（MVC，JDBC，分布式集群等等），用户不能理解</p>
</li>
<li class="lvl-2">
<p>注意用例的命名<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>⟶</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel" style="color:red;">⟶</span></span></span></span>用户观点而非系统观点，即在命名用例时要以用户为主语</p>
</li>
<li class="lvl-2">
<p>用例的“粒度”</p>
</li>
</ul>
<p>⭕️<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mtext>形式检查</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{blue}{形式检查}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:blue;">形式检查</span></span></span></span></p>
<blockquote>
<p><code>执行者</code>通过（使用）系统来<code>用例</code>：</p>
<p>比如：<code>会员</code>通过（使用）系统来<code>查询商品信息</code>，这句话是通顺的，所以用例（<code>查询商品信息</code>）的取名可行。</p>
</blockquote>
<p>1️⃣用例命名：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928201657020.png" alt="image-20220928201657020" style="zoom:50%;" />
<p>慎用弱动词弱名词：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928201758262.png" alt="image-20220928201758262" style="zoom:50%;" />
<p>2️⃣用户的“粒度”</p>
<p>粒度原则：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>用例要有路径，路径要有步骤</u>。而这一切都是“可观测”的</p>
<ul class="lvl-2">
<li class="lvl-4">路径：正常路径+扩展路径</li>
</ul>
</li>
<li class="lvl-2">
<p>用户和系统的<mark>步骤都不能作为用例</mark></p>
</li>
</ul>
<h5 id="执行者之间的关联关系">执行者之间的关联关系</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928203647567.png" alt="image-20220928203647567" style="zoom:50%;" />
<h5 id="执行者之间的泛化关系-继承">执行者之间的泛化关系（继承）</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928203735811.png" alt="image-20220928203735811" style="zoom:50%;" />
<h5 id="包含关系">包含关系</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928204022864.png" alt="image-20220928204022864" style="zoom:50%;" />
<blockquote>
<p>依赖关系：一个事物使用了另一个事物</p>
</blockquote>
<h5 id="扩展关系">扩展关系</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20220928204128837.png" alt="image-20220928204128837" style="zoom:50%;" />
<blockquote>
<p>比如“现金支付”的扩展点就是“支付”，因此可以围绕“支付”得到新的扩展用例——信用卡支付</p>
<p><mark>注意：</mark></p>
<p>“支付”只是一个抽象出来的行为，而不是说两个用例之间一定要有相同的字</p>
</blockquote>
<h5 id="泛化关系">泛化关系</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005191535414.png" alt="image-20221005191535414" style="zoom:50%;" />
<h6 id="实例："><mark>实例：</mark></h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005191739294.png" alt="image-20221005191739294" style="zoom: 33%;" />
<blockquote>
<p>分两步：</p>
<ol>
<li class="lvl-3">识别执行者</li>
<li class="lvl-3">识别用例</li>
</ol>
<p>要求：不漏掉用例、不产生歧义。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005191937370.png" alt="image-20221005191937370" style="zoom: 33%;" />
</blockquote>
<p><u>1️⃣<mark>用例是文本文档</mark>，而非图形</u></p>
<p>2️⃣用例建模主要是<u>编写文本的活动</u>，而非制图</p>
<h4 id="书写用例文档">书写用例文档</h4>
<h5 id="用例的内容">用例的内容</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005193923898.png" alt="image-20221005193923898" style="zoom:33%;" />
<blockquote>
<p>红色**<u>（6个必须有）</u>**必须有，其他可以有</p>
</blockquote>
<h6 id="实例："><mark>实例：</mark></h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005194018599.png" alt="image-20221005194018599" style="zoom: 50%;" />
<h6 id="前置-后置条件">前置、后置条件</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005194429632.png" alt="image-20221005194429632" style="zoom:50%;" />
<p><mark>前置条件必须是系统在用例开始前能检测到的</mark></p>
<blockquote>
<p>前置条件、后置条件<strong>必须是系统能检测的</strong>。</p>
</blockquote>
<h6 id="涉众利益">涉众利益</h6>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>观众没有参与，但是<mark>用例结果与观众的利益息息相关</mark>。</p>
<h6 id="基本路径">基本路径</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>只书写“可观测”的（说人话）</p>
</li>
<li class="lvl-2">
<p>使用主动语句</p>
</li>
<li class="lvl-2">
<p>句子必须<u>以执行者或系统作为主语</u></p>
</li>
<li class="lvl-2">
<p>每一句都要朝目标迈进</p>
</li>
<li class="lvl-2">
<p><u>分支和循环</u></p>
</li>
<li class="lvl-2">
<p>不要涉及界面细节</p>
</li>
</ul>
<hr>
<p>用例交互四步曲：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005200447673.png" alt="image-20221005200447673" style="zoom:33%;" />
<h6 id="扩展路径">扩展路径</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005200706074.png" alt="image-20221005200706074" style="zoom:50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p>替换路径</p>
</li>
<li class="lvl-3">
<p>异常路径</p>
</li>
</ol>
</blockquote>
<h6 id="补充约束">补充约束</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005200812608.png" alt="image-20221005200812608" style="zoom:50%;" />
<p>用例实例：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221105112322378.png" alt="image-20221105112322378" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221005201238950.png" alt="image-20221005201238950" style="zoom: 50%;" />
<h4 id="检查用例模型">检查用例模型</h4>
<p>主要可以从以下几个方面来进行检查：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>功能需求的完备性</p>
</li>
<li class="lvl-2">
<p>模型是否易于理解</p>
</li>
<li class="lvl-2">
<p>是否存在不一致性</p>
</li>
<li class="lvl-2">
<p>避免语义二义性</p>
</li>
</ul>
<p>用例追踪矩阵：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221105112416870.png" alt="image-20221105112416870" style="zoom:50%;" />
<blockquote>
<p>用例模型完成之后，需要<mark>对用例模型进行检查</mark>，看看<mark>是否有遗漏或错误之处</mark>。</p>
</blockquote>
<h4 id="textcolor-red-状态图statechart-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>状态图</mtext><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>D</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---状态图Statechart Diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">状态图</span><span class="mord mathnormal" style="color:red;">St</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="color:red;">ec</span><span class="mord mathnormal" style="color:red;">ha</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">D</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<p>定义：用来描述一个特定**<mark>对象</mark><strong>的<u><strong>所有<mark>可能状态</mark></strong></u>及其<u></strong><mark>引起</mark>状态转移的<mark>事件</mark>**</u></p>
<blockquote>
<p><u>状态图</u>通常用来<mark>描述单个对象的行为</mark></p>
<p>只有那些具有重要交互行为的类，才会使用状态图来描述；<u>一个状态图包括一系列对象的状态及状态之间的转换</u>。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010192638748.png" alt="image-20221010192638748" style="zoom:50%;" />
<blockquote>
<p>状态图中<u>只有一个初始状态，而可以有多个结束状态</u>。</p>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010192712261.png" alt="image-20221010192712261"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010192729391.png" alt="image-20221010192729391"></p>
<blockquote>
<p>守护条件：<u><strong>事件名[条件]/动作名</strong></u></p>
</blockquote>
<h5 id="状态图组成元素">状态图组成元素</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>初始状态</p>
</li>
<li class="lvl-2">
<p>终止状态</p>
</li>
<li class="lvl-2">
<p>状态</p>
</li>
<li class="lvl-2">
<p>转移</p>
</li>
<li class="lvl-2">
<p>守护条件</p>
</li>
<li class="lvl-2">
<p>事件</p>
</li>
<li class="lvl-2">
<p>动作</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010192855708.png" alt="image-20221010192855708" style="zoom:33%;" />
<h6 id="状态图高级技巧">状态图高级技巧</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单状态：不包含其他状态的状态称为简单状态。</p>
</li>
<li class="lvl-2">
<p>复合状态：又称为<u>组合状态</u>，可以将若干状态组织在一起可以得到一个复合状态，包含在一个复合状态中的状态称为子状态。</p>
</li>
</ul>
<h6 id="复合状态：">复合状态：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010194319307.png" alt="image-20221010194319307" style="zoom:50%;" />
<blockquote>
<p>行驶状态时复合状态，其内有3个简单状态</p>
</blockquote>
<h6 id="带同步条的状态图：">带同步条的状态图：</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010194536450.png" alt="image-20221010194536450"></p>
<h5 id="状态图的绘制">状态图的绘制</h5>
<p>在绘制对象的状态图时，要考虑以下因素（5个）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象有哪些<u><strong>有意义的状态；</strong></u></p>
</li>
<li class="lvl-2">
<p>对象的哪<u><strong>些状态之间可以相互转换</strong></u>；</p>
</li>
<li class="lvl-2">
<p>对象状态之间<u><strong>何时发生转换</strong></u>；</p>
</li>
<li class="lvl-2">
<p>对象在不同状态下有哪些行为；</p>
</li>
<li class="lvl-2">
<p>对象的状态图和其他模型之间如何进行映射。</p>
</li>
</ul>
<p>技巧：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>状态图适合用于表述<mark>在不同用例之间的对象行为</mark>。</p>
</li>
<li class="lvl-2">
<p>系统设计中可能有多个对象，但并不需要给出每个对象的状态图，实际的做法是把注意力集中在整体系统或少数关键的对象上，特别是那些<mark>状态比较多的对象</mark>。</p>
</li>
</ul>
<h6 id="状态模式">状态模式</h6>
<p>状态图与类图相结合共同描述</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010200716354.png" alt="image-20221010200716354" style="zoom:50%;" />
<p>增加状态时直接增加子类即可</p>
<p>状态图实例分析：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010201202654.png" alt="image-20221010201202654" style="zoom:50%;" />
<hr>
<h4 id="textcolor-red-活动图activity-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>活动图</mtext><mi>A</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>t</mi><mi>y</mi><mi>D</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---活动图Activity Diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">活动图</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="color:red;">c</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">v</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">yD</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<p>定义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>表示系统中<strong>各种活动的次序</strong></mark>，可用来<u>描述用例的工作流程</u>，也可以用来<u>描述类中<mark>某个方法的操作行为</mark></u>。</p>
</li>
<li class="lvl-2">
<p>活动图<u>依据对象状态的变化</u>来捕获动作（将要执行的工作或活动）与动作的结果。活动图中一个活动结束后将立即进入下一个活动（在状态图中状态的变迁可能需要事件的触发）。</p>
</li>
</ul>
<blockquote>
<p>In UML,<mark>Activity</mark>  diagramgives a simplified representation of a process,showing <mark>control flows</mark> between actions performed in the system</p>
<p>control flows：控制流</p>
</blockquote>
<p>应用：</p>
<ol>
<li class="lvl-3">
<p>利用文本描述用例的事件流是很有用的，但如果事件流的逻辑复杂且有许多其他事件流，则文本形式可能较难阅读和理解，这时可使用活动图来描述事件流。</p>
</li>
<li class="lvl-3">
<p><u>活动图是UML中的流程图，它是事件流的另一种建模方式</u>。活动图用于以图形化的方式描述一个业务过程或者一个用例的活动的顺序流，它也可以用于建模一个操作要执行的动作，以及那些动作的结果。</p>
</li>
<li class="lvl-3">
<p>活动图是一种描述工作流的方式，它用来描述采取何种动作、做什么（对象状态改变）、何时发生（动作序列）以及在何处发生（泳道）。</p>
</li>
</ol>
<p>作用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>描述业务流程</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{描述业务流程}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">描述业务流程</span></span></span></span>（主要应用）</p>
</li>
<li class="lvl-2">
<p>描述用例路径</p>
</li>
<li class="lvl-2">
<p>描述方法执行流程（程序流程图）</p>
</li>
</ul>
<p>活动图实例分析：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010202430272.png" alt="image-20221010202430272"></p>
<blockquote></blockquote>
<h6 id="活动图组成元素">活动图组成元素</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>起始活动(Start Activity)</p>
</li>
<li class="lvl-2">
<p>终止活动(End Activity)</p>
</li>
<li class="lvl-2">
<p>活动(Activity)</p>
</li>
<li class="lvl-2">
<p>转移(Transition)或流(Flow)</p>
</li>
<li class="lvl-2">
<p>决策(Decision)</p>
</li>
<li class="lvl-2">
<p>守护条件(Condition)</p>
</li>
<li class="lvl-2">
<p>同步条(Synchronization)</p>
</li>
<li class="lvl-2">
<p>泳道(Swimlane)</p>
</li>
</ul>
<p>守护条件用来约束转移，守护条件为真时转移才可以开始。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010202855285.png" alt="image-20221010202855285" style="zoom:50%;" />
<p>在活动图中，<u>对象流</u>使用<u>带箭头的虚线</u>表示，<u>对象用矩形表示</u>，<u>矩形内是该对象的名称</u>，名称下的<u>方括号表示该对象此时的状态</u>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010203141748.png" alt="image-20221010203141748" style="zoom: 67%;" />
<p>B to B实例</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010203305166.png" alt="image-20221010203305166" style="zoom:50%;" />
<h6 id="泳道">泳道</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>泳道用于划分活动图，有助于更好地理解执行活动的场所。泳道划分负责活动的对象，<u>明确地表示哪些活动是由哪些对象进行的，<mark>每个活动只能明确地属于一个泳道</mark></u>。</p>
</li>
<li class="lvl-2">
<p>在活动图中，泳道一般用垂直实线绘出，垂直线分隔的区域就是泳道。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221010203431594.png" alt="image-20221010203431594" style="zoom:50%;" />
<blockquote>
<p><mark>泳道的加入不一定能够简化活动图，可能使得活动图更复杂。</mark></p>
</blockquote>
<h5 id="活动图的绘制技巧">活动图的绘制技巧</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用活动图来<u>描述用例路径更加直观</u>。</p>
</li>
<li class="lvl-2">
<p>对面向对象建模而言，用活动图描述业务流程并不是对每个系统都必不可少的工作。</p>
</li>
<li class="lvl-2">
<p>不要把描述业务流程的活动图看成可编程的模型，它与系统的实际构造情况和执行情况有很大的差距。</p>
</li>
<li class="lvl-2">
<p><u>首先要对主要的业务流建模</u>，然后<u>再标出分支、合并和对象流</u>。</p>
</li>
<li class="lvl-2">
<p><mark>尽量减少交叉线</mark>，如果图形较为复杂，适当使用颜色和注释。</p>
</li>
</ul>
<h6 id="实例："><mark>实例：</mark></h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012191357064.png" alt="image-20221012191357064" style="zoom:50%;" />
<h4 id="textcolor-red-顺序图sequence-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>顺序图</mtext><mi>S</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---顺序图Sequence Diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">顺序图</span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">S</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">q</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">ceD</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012191605666.png" alt="image-20221012191605666" style="zoom: 50%;" />
<blockquote>
<p>sequence Diagram</p>
</blockquote>
<h6 id="顺序图实例">顺序图实例</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012191958998.png" alt="image-20221012191958998" style="zoom:50%;" />
<blockquote>
<p>以上绘制的顺序图不是特别的严谨，因为小王和小张都需要一台电话，但是上图很好的展示了顺序图的时间顺序特点</p>
</blockquote>
<h5 id="顺序图组成元素">顺序图组成元素</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012192209175.png" alt="image-20221012192209175" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012192300054.png" alt="image-20221012192300054" style="zoom:33%;" />
<h6 id="对象">对象</h6>
<h6 id="生命线">生命线</h6>
<blockquote>
<p><u>对象就是一个类对象，或是类型定义的变量；</u></p>
<p><mark>生命线就是一个代码语句或是函数的从开始执行到结束花费的时间过程。</mark></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012192523494.png" alt="image-20221012192523494" style="zoom:50%;" />
<h6 id="实例：">实例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012192601501.png" alt="image-20221012192601501" style="zoom:50%;" />
<blockquote>
<p><mark>激活一般随着<code>return</code>结束</mark></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026184557410.png" alt="image-20221026184557410" style="zoom:50%;" />
<h6 id="调用消息">调用消息</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012192918606.png" alt="image-20221012192918606" style="zoom:50%;" />
<blockquote>
<p>调用消息只能是从左边向右边发送，或者一个对象自己想自己发送调用消息==？==</p>
<p>在源代码层面上：call 一个函数</p>
</blockquote>
<h6 id="自身消息">自身消息</h6>
<blockquote>
<p>在源代码层面上：call 一个函数</p>
</blockquote>
<h6 id="返回消息">返回消息</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012193649713.png" alt="image-20221012193649713" style="zoom:50%;" />
<blockquote>
<p>返回消息必须逐个对象地向左返回，不能出现跨对象的消息返回==？==（不一定，特别是在绘制源代码的顺序图时）</p>
<p>在源代码层面上：return 结果</p>
</blockquote>
<h6 id="发送消息">发送消息</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012193709104.png" alt="image-20221012193709104" style="zoom:50%;" />
<h6 id="创建消息">创建消息</h6>
<p>一条生命线的开始</p>
<blockquote>
<p>在源代码层面上：new 一个新的对象（当然也不只new，如：<code>Money subTotal = null;</code>也相当于创建了一个对象，Money是一个类型）</p>
</blockquote>
<h6 id="销毁消息">销毁消息</h6>
<p>一条生命线的结束</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012193453795.png" alt="image-20221012193453795"></p>
<p>绘制方法：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221026202651990.png" alt="image-20221026202651990" style="zoom: 33%;" />
<blockquote>
<p><mark>在源代码层面上：对象销毁</mark></p>
</blockquote>
<h6 id="同步消息">同步消息</h6>
<h6 id="异步消息">异步消息</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012193817042.png" alt="image-20221012193817042" style="zoom:50%;" />
<h5 id="交互片段">交互片段</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012200229504.png" alt="image-20221012200229504" style="zoom:50%;" />
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012200546412.png" alt="image-20221012200546412"></p>
<blockquote>
<p>alt：类似于if…else</p>
<p>opt：表示一个可能存在又可能不存在的消息通信过程</p>
<p>par：表示对象生命线中并行进行消息通信的部分</p>
<p>loop：类似于for</p>
<p>critical：</p>
</blockquote>
<h6 id="实例：">实例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012200722072.png" alt="image-20221012200722072" style="zoom: 50%;" />
<h5 id="顺序图作用">顺序图作用</h5>
<ol>
<li class="lvl-3">
<p>对于业务人员，顺序图可显示不同的业务对象如何交互，对于交流当前业务如何进行很有用。除记录组织的当前事件外，一个业务级的顺序图能被当作一个需求文件使用，为实现一个未来系统传递需求。</p>
</li>
<li class="lvl-3">
<p>对于需求分析人员，顺序图能通过提供一个深层次的表达，把用例带入下一层次。通常用例被细化为一个或者更多的顺序图。顺序图的主要用途之一，是<u>把用例表达的需求，转化为进一步、更深层次的精细表达</u>。</p>
</li>
<li class="lvl-3">
<p>对于技术人员，顺序图在记录一个未来系统的行为应该如何表现时非常有用。在设计阶段，架构师和开发者能使用顺序图挖掘出<mark>系统对象间的交互</mark>，进一步完善整个系统的设计。</p>
</li>
</ol>
<h5 id="顺序图绘制技巧">顺序图绘制技巧</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>以<mark>用例为单位</mark>创建顺序图</u>，针对每个用例，考察为完成它所描述的功能需要哪些对象的操作参与执行，并且进一步考察这些操作的执行需要通过消息而引起其他哪些对象操作的执行。把这些对象以及参与交互的执行者组织到一个顺序图中。</p>
</li>
<li class="lvl-2">
<p><u>理论上需要为每一个用例创建一个顺序图</u>，但是如果一个用例的交互对象很简单可以不需要创建顺序图。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012201012194.png" alt="image-20221012201012194" style="zoom:50%;" />
<h4 id="用例图-状态图-活动图以及顺序图联系">用例图、状态图、活动图以及顺序图联系</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012201150564.png" alt="image-20221012201150564" style="zoom:50%;" />
<blockquote>
<p>顺序图：<u><strong>多个对象的行为（用例中）</strong></u></p>
<p>状态图：<u><strong>单个对象的行为</strong></u></p>
<p>活动图：<u><strong>跨用例或跨线程的行为</strong></u></p>
</blockquote>
<h6 id="需求分析阶段的顺序图：">需求分析阶段的顺序图：</h6>
<p>主要用于<u>描述用例中对象之间的交互</u>，可以使用自然语言来绘制，<strong><u>用于细化需求</u></strong>。从业务的角度进行建模，用描述性的文字叙述消息的内容。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012201310859.png" alt="image-20221012201310859" style="zoom:67%;" />
<h6 id="系统设计阶段的顺序图：">系统设计阶段的顺序图：</h6>
<p>确切表示系统设计中对象之间的交互，考虑到具体的系统实现，<u>对象之间<mark>通过方法</mark>调用传递消息</u>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012201320452.png" alt="image-20221012201320452" style="zoom:67%;" />
<h6 id="实例："><mark>实例：</mark></h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012201607292.png" alt="image-20221012201607292" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012201715385.png" alt="image-20221012201715385" style="zoom:50%;" />
<h3 id="uml构造设计模型">UML构造设计模型</h3>
<h5 id="教学内容：">教学内容：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>类与类图（考试：40分）：类与类之间的关系</p>
</li>
<li class="lvl-2">
<p>正向工程与逆向工程：</p>
</li>
<li class="lvl-2">
<p>包图：包与包之间的关系</p>
</li>
<li class="lvl-2">
<p>组件图：文件与文件之间的关系</p>
</li>
<li class="lvl-2">
<p>部署图</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012202957477.png" alt="image-20221012202957477" style="zoom:50%;" />
<h6 id="定义属性">定义属性</h6>
<h6 id="img-src-https-wangguijie-typora-oss-cn-chengdu-aliyuncs-com-img-image-20221012203114976-png-alt-image-20221012203114976-style-zoom-50"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012203114976.png" alt="image-20221012203114976" style="zoom:50%;" /></h6>
<blockquote>
<p>+：public</p>
<p>#：protected</p>
<p>-：private</p>
</blockquote>
<h6 id="定义操作">定义操作</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221012203322475.png" alt="image-20221012203322475" style="zoom:50%;" />
<blockquote>
<p><u><em><strong>构造函数没有返回类型（连空类型也没有）</strong></em></u></p>
</blockquote>
<h6 id="重要的提示："><mark>重要的提示：</mark></h6>
<ol>
<li class="lvl-3">
<p>有抽象方法的类一定是抽象类</p>
</li>
<li class="lvl-3">
<p>抽象类中可以有实体类</p>
</li>
</ol>
<h3 id="textcolor-red-实验日期：10月26日-18：30-21：30"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>实验日期：</mtext><mn>10</mn><mtext>月</mtext><mn>26</mn><mtext>日</mtext><mo>−</mo><mn>18</mn><mtext>：</mtext><mn>30</mn><mtext>——</mtext><mn>21</mn><mtext>：</mtext><mn>30</mn></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{实验日期：10月26日-18：30——21：30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback" style="color:red;">实验日期：</span><span class="mord" style="color:red;">10</span><span class="mord cjk_fallback" style="color:red;">月</span><span class="mord" style="color:red;">26</span><span class="mord cjk_fallback" style="color:red;">日</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord" style="color:red;">18</span><span class="mord cjk_fallback" style="color:red;">：</span><span class="mord" style="color:red;">30——21</span><span class="mord cjk_fallback" style="color:red;">：</span><span class="mord" style="color:red;">30</span></span></span></span></h3>
<h4 id="textcolor-red-类图class-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>类图</mtext><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>D</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---类图Class Diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">类图</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">Cl</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">ssD</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<h5 id="类之间的关系">类之间的关系</h5>
<p>内容：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>关联关系</p>
<ul class="lvl-2">
<li class="lvl-4">双向关联</li>
<li class="lvl-4">自关联</li>
<li class="lvl-4">多重性关联</li>
</ul>
</li>
<li class="lvl-2">
<p>聚合关系</p>
</li>
<li class="lvl-2">
<p>组合关系</p>
</li>
<li class="lvl-2">
<p>依赖关系</p>
</li>
<li class="lvl-2">
<p>泛化/继承关系</p>
</li>
<li class="lvl-2">
<p>接口与实现关系</p>
</li>
<li class="lvl-2">
<p>注释(Comment)</p>
</li>
</ul>
<h6 id="关联关系">关联关系</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>关联关系(Association)是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。</p>
</li>
<li class="lvl-2">
<p>在UML类图中，用实线连接有关联的对象所对应的类，在使用Java、C#和C++等编程语言实现关联关系时，通常将<mark>一个类的对象作为另一个类的属性</mark>。</p>
</li>
<li class="lvl-2">
<p>在使用类图表示关联关系时可以在关联线上标注角色名。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019192539945.png" alt="image-20221019192539945" style="zoom:50%;" />
<blockquote>
<p>在LoginFrom类里面实例化了JButton的对象，并将JButton的对象作为自己的属性，所以说：LoginFrom类关联JButton类</p>
</blockquote>
<h6 id="双向关联">双向关联</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019192739848.png" alt="image-20221019192739848" style="zoom: 50%;" />
<h6 id="自关联">自关联</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019192918485.png" alt="image-20221019192918485" style="zoom:50%;" />
<h6 id="多重性关联-重数性关联关系">多重性关联 （重数性关联关系）</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019193004253.png" alt="image-20221019193004253" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019193329939.png" alt="image-20221019193329939" style="zoom:50%;" />
<h6 id="聚合关系">聚合关系</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>聚合关系(Aggregation)表示一个整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。</p>
</li>
<li class="lvl-2">
<p>在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是<u>成员对象<mark>可以脱离整体对象独立存在</mark></u>。在UML中，聚合关系用带<u>空心菱形的直线表示</u>。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019193526272.png" alt="image-20221019193526272" style="zoom:50%;" />
<blockquote>
<p>注入，类似于将多个部分装配在一起，形成整体，但部分可以单独存在。</p>
</blockquote>
<h6 id="组合关系">组合关系</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>组合关系(Composition)也表示类之间整体和部分的关系，但是<u>组合关系中部分和整体具有统一的生存期</u>。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有<u>同生共死的关系</u>。</p>
</li>
<li class="lvl-2">
<p>在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即<u>成员类的存在依赖于整体类</u>。在UML中，组合关系用带实心菱形的直线表示。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019193703268.png" alt="image-20221019193703268" style="zoom:50%;" />
<blockquote>
<p>显然，聚合关系的耦合度要小于组合关系。</p>
<p>month = new Mouth()，在整体类的构造函数中实例化了成员类的对象</p>
</blockquote>
<h6 id="依赖关系">依赖关系</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>依赖关系(Dependency)是一种使用关系，<u>特定事物的改变有可能会影响到使用该事物的其他事物</u>，在需要<mark>表示一个事物使用另一个事物时使用依赖关系</mark>。大多数情况下，<mark>依赖关系体现在某个类的方法使用另一个类的对象作为参数</mark>。</p>
</li>
<li class="lvl-2">
<p>在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。</p>
</li>
</ul>
<p>1️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019194116349.png" alt="image-20221019194116349" style="zoom:50%;" />
<blockquote>
<p>依赖关系体现在某个类的方法使用另一个类的对象作为参数；</p>
<p>由依赖的一方指向被依赖的地方：Driver依赖Car。</p>
</blockquote>
<p>2️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019194627683.png" alt="image-20221019194627683" style="zoom:50%;" />
<p>3️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019200241641.png" alt="image-20221019200241641" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019200205602.png" alt="image-20221019200205602" style="zoom:67%;" />
<blockquote>
<p>既有关联又有依赖，此时与聚合关系有些相同</p>
</blockquote>
<h6 id="泛化-继承关系">泛化/继承关系</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>泛化关系(Generalization)也就是继承关系，也称为“is-a-kind-of”关系，泛化关系用于描述父类与子类之间的关系，<u>父类</u>又称作<u>基类或超类</u>，<u>子类又称作派生类</u>。在UML中，泛化关系用带空心三角形的直线来表示。</p>
</li>
<li class="lvl-2">
<p>在代码实现时，使用面向对象的继承机制来实现泛化关系，如在Java语言中使用extends关键字、在C++/C#中使用冒号“：”来实现。</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019200429950.png" alt="image-20221019200429950" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019200503026.png" alt="image-20221019200503026" style="zoom:50%;" />
<blockquote>
<p>泛化/继承关系是<mark>为了实现扩展</mark></p>
</blockquote>
<h6 id="接口与实现关系">接口与实现关系</h6>
<p>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种<u>实现关系(Realization)</u>，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019200852726.png" alt="image-20221019200852726" style="zoom:50%;" />
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>一个非抽象类需要实现接口的所有方法；</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{一个非抽象类需要实现接口的所有方法；}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">一个非抽象类需要实现接口的所有方法；</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mtext>抽象类可以只实现接口中的部分方法，剩下的方法可以由抽象类的子类实现。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{blue}{抽象类可以只实现接口中的部分方法，剩下的方法可以由抽象类的子类实现。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:blue;">抽象类可以只实现接口中的部分方法，剩下的方法可以由抽象类的子类实现。</span></span></span></span></p>
<h5 id="缺省适配器模式：">缺省适配器模式：</h5>
<p>假设一个接口中的方法很多，可以创建一个抽象类来实现该接口(该抽象类可以没有抽象方法)，然后将其中所有的方法空实现（函数体均为空），之后想要实现该接口中的内容时只需要让子类继承抽象类并覆盖想要实现的方法即可。由此避免了直接实现该接口的所有的方法。</p>
<h5 id="常量接口模式：">常量接口模式：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_E</span> <span class="operator">=</span> <span class="number">2.71828</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MyConstants.*的方式进行调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> r;<span class="comment">//半径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> r)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCircumference</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * r * MyConstants.MATH_PI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="依赖倒转原则">依赖倒转原则</h6>
<p>参考：<a href="https://blog.csdn.net/Pastthewind/article/details/109576163">(77条消息) 设计模式-依赖倒转原则_Pastthewind的博客-CSDN博客</a></p>
</blockquote>
<h5 id="各关系之间的耦合程度">各关系之间的耦合程度</h5>
<blockquote>
<p>虚线代表耦合程度低于实线的耦合程度；线型箭头的耦合程度要低于三角箭头的耦合程度。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span><mark>不一定正确</mark></p>
<ul class="lvl-1">
<li class="lvl-2">依赖关系：虚线线型箭头</li>
<li class="lvl-2">关联关系：实线线型箭头</li>
<li class="lvl-2">接口实现关系：虚线三角箭头</li>
<li class="lvl-2">泛化/继承关系：实线三角箭头</li>
<li class="lvl-2">聚合关系：空心菱形实线线型箭头</li>
<li class="lvl-2">组合关系：实心菱形实线线型箭头</li>
</ul>
<p><strong><mark>泛化（继承）=实现&gt;组合&gt;聚合&gt;关联&gt;依赖</mark></strong>（耦合程度？）</p>
</blockquote>
<h6 id="注释-comment">注释(Comment)</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019202133822.png" alt="image-20221019202133822" style="zoom:50%;" />
<h6 id="实例分析">实例分析</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019202428659.png" alt="image-20221019202428659" style="zoom:50%;" />
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019202803274.png" alt="image-20221019202803274"></p>
<blockquote>
<p>DTO（Data Transfer Object）：数据传输对象，减少了参数的数量</p>
<p>UserDAO：实现对数据库的增删查改操作</p>
</blockquote>
<h4 id="正向工程与逆向工程">正向工程与逆向工程</h4>
<h6 id="适配器模式之加密算法适配">适配器模式之加密算法适配</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221019203216526.png" alt="image-20221019203216526" style="zoom:50%;" />
<h4 id="textcolor-red-绘图技巧"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>绘图技巧</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{绘图技巧}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">绘图技巧</span></span></span></span></h4>
<p>在正向工程生成代码时如果出现错误可以将类中的属性删去，因为类图中的属性与关联图线上的描述出现冲突；</p>
<h4 id="textcolor-red-包图package-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>包图</mtext><mi>P</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---包图Package diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">包图</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">P</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">c</span><span class="mord mathnormal" style="color:red;">ka</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord mathnormal" style="color:red;">d</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<p>概念：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>包是一种把元素组织到一起的通用机制</mark>，包可以嵌套于其他包中。</p>
</li>
<li class="lvl-2">
<p>包图用于<mark>描述包与包之间的关系</mark>，包的图标是一个带标签的文件夹。</p>
</li>
</ul>
<blockquote>
<p>Package diagrams are structural diagrams used to show the <mark>organization and arrangement</mark> of various model elements in the form of packages.</p>
</blockquote>
<h6 id="引入关系">引入关系</h6>
<p>一个包中的类可以被另一个指定包（以及嵌套于其中的那些包）中的类引用。</p>
<p><u><strong>引入关系是依赖关系的一种</strong></u>，需要在依赖线上增加一个&lt;<import>&gt;衍型，包之间一般依赖关系都属于引入关系。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024191612181.png" alt="image-20221024191612181" style="zoom:50%;" />
<h6 id="泛化关系">泛化关系</h6>
<p>表示一个包继承了另一个包的内容，同时又补充自己增加的内容。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024191634328.png" alt="image-20221024191634328" style="zoom:50%;" />
<h6 id="嵌套关系">嵌套关系</h6>
<p>一个包中可以包含若干个子包，构成了包的嵌套层次结构。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024191737056.png" alt="image-20221024191737056" style="zoom:50%;" />
<h5 id="包图绘制技巧">包图绘制技巧</h5>
<ol>
<li class="lvl-3">
<p>两种组包方式：</p>
<ul class="lvl-2">
<li class="lvl-5"><u>根据系统分层架构组包</u>（推荐使用）；</li>
<li class="lvl-5">根据系统业务功能模块组包。</li>
</ul>
</li>
<li class="lvl-3">
<p>参照类之间的关系确定包之间的关系；</p>
</li>
<li class="lvl-3">
<p>减少包的嵌套层次，一般不超过三层；</p>
</li>
<li class="lvl-3">
<p>每个包的子包控制在7±2个；</p>
</li>
<li class="lvl-3">
<p>可通过包图来<mark>体现系统的分层架构</mark>。</p>
</li>
</ol>
<h6 id="包图体现体系结构">包图体现体系结构</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024191925576.png" alt="image-20221024191925576" style="zoom: 33%;" />
<h6 id="包图实例-基于b-s的oa系统">包图实例（基于B/S的OA系统）</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024191954538.png" alt="image-20221024191954538" style="zoom:50%;" />
<blockquote>
<p><u><em><strong>包图有利于查看项目的层次</strong></em></u></p>
</blockquote>
<h4 id="textcolor-red-组件图component-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>组件图</mtext><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>D</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---组件图Component Diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">组件图</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="color:red;">m</span><span class="mord mathnormal" style="color:red;">p</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">D</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>用于表示文件之间的关系</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{用于表示文件之间的关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">用于表示文件之间的关系</span></span></span></span></p>
<p><mark>存在泛化和依赖关系</mark></p>
</blockquote>
<h6 id="组件图定义">组件图定义</h6>
<p>1、<u><mark>组件图</mark>又称为<mark>构件图</mark>(Component Diagram) 。</u>组件图中通常包括组件、接口，以及各种关系。组件图显示组件以及它们之间的依赖关系，它可以用来显示程序代码如何分解成模块或组件。</p>
<p>一般来说，组件就是一个实际文件，可以有以下几种类型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>源代码组件：一个源代码文件或者与一个包对应的若干个源代码文件。</p>
</li>
<li class="lvl-2">
<p>二进制组件：一个目标码文件，一个静态的或者动态的库文件。</p>
</li>
<li class="lvl-2">
<p>可执行组件：在一台处理器上可运行的一个可执行的程序单位，即所谓可执行程序。</p>
</li>
</ul>
<blockquote>
<p>这里的构件指的就是文件，区别于体系结构三要素中的构件。</p>
</blockquote>
<p>2、组件图可以用来显示<u>编译、链接或执行时组件</u>之间的依赖关系，以及<u>组件的接口和调用关系</u>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024193534495.png" alt="image-20221024193534495" style="zoom: 33%;" />
<p>3、组件间的关系有两种：<mark>泛化关系和依赖关系</mark>，<u>如果两个不同组件中的类存在泛化关系或依赖关系，那么两个组件之间的关系就表示为泛化关系或依赖关系</u>。</p>
<p>4、对于由多个组件组成的大系统来说，组件图非常重要。</p>
<h6 id="实例：">实例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024194425279.png" alt="image-20221024194425279" style="zoom:50%;" />
<h6 id="组件图组成元素">组件图组成元素</h6>
<p>组件：系统中<mark>可以替换的部分</mark>，一般对应一个实际文件，如exe、jar、dll等文件，它遵循并提供了一组接口的实现。</p>
<p>接口：一组<mark>操作的集合</mark>，它指明了由类或组件所请求或者所提供的服务。</p>
<p>部件：组件的局部实现。</p>
<p>端口：<mark>被封装的组件与外界的交互点</mark>，遵循指定接口的组件通过它来收发消息。</p>
<p>连接件：在特定语境下组件中<mark>两个部件之间或者两个端口之间的通信关系</mark>。</p>
<h6 id="实例：">实例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024195659233.png" alt="image-20221024195659233" style="zoom:33%;" />
<h5 id="组件图绘制技巧">组件图绘制技巧</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024200124495.png" alt="image-20221024200124495" style="zoom:50%;" />
<h5 id="组件图实例分析">组件图实例分析</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024200242114.png" alt="image-20221024200242114" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024200256001.png" alt="image-20221024200256001" style="zoom: 33%;" />
<h4 id="textcolor-red-部署图deployment-diagram"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>−</mo><mo>−</mo><mo>−</mo><mtext>部署图</mtext><mi>D</mi><mi>e</mi><mi>p</mi><mi>l</mi><mi>o</mi><mi>y</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>D</mi><mi>i</mi><mi>a</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mo>−</mo><mo>−</mo><mo>−</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{---部署图Deployment Diagram---}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord" style="color:red;">−</span><span class="mord cjk_fallback" style="color:red;">部署图</span><span class="mord mathnormal" style="color:red;">De</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">pl</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">oy</span><span class="mord mathnormal" style="color:red;">m</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord mathnormal" style="color:red;">n</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">D</span><span class="mord mathnormal" style="color:red;">ia</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="color:red;">am</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord" style="color:red;">−</span><span class="mord" style="color:red;">−</span></span></span></span></h4>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>描述硬件之间的关系</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{描述硬件之间的关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">描述硬件之间的关系</span></span></span></span></p>
</blockquote>
<h6 id="部署图定义">部署图定义</h6>
<p>部署图(Deployment Diagram)，也称为<mark>实施图</mark>，它和组件图一样，是<u><em><strong>面向对象系统的物理方面建模的两种图之一</strong></em></u>。组件图是说明组件之间的逻辑关系的，而部署图则是在此基础上更进一步，<mark>描述系统硬件的物理拓扑结构及在此结构上执行的软件</mark>。部署图可以<u>显示计算节点的拓扑结构和通信路径、节点上运行的软件组件</u>。</p>
<p>在UML中，部署图显示了系统的硬件和安装在硬件上的软件，以及用于连接异构计算机之间的中间件。部署图通常被认为是一个网络图或者物理架构图。</p>
<h6 id="实例：">实例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024201102067.png" alt="image-20221024201102067" style="zoom:50%;" />
<h6 id="部署图组成元素">部署图组成元素</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024201204897.png" alt="image-20221024201204897" style="zoom: 33%;" />
<blockquote>
<p>连接是没有箭头的实线，表示的是信息的<mark>双向通信</mark>。</p>
</blockquote>
<h5 id="部署图绘制技巧">部署图绘制技巧</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024201237102.png" alt="image-20221024201237102" style="zoom:33%;" />
<h5 id="部署图实例分析">部署图实例分析</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024201648903.png" alt="image-20221024201648903" style="zoom:50%;" />
<p>1️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024201656562.png" alt="image-20221024201656562" style="zoom: 50%;" />
<p>2️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024201708537.png" alt="image-20221024201708537" style="zoom: 33%;" />
<p>3️⃣</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024201750835.png" alt="image-20221024201750835" style="zoom:50%;" />
<hr>
<h4 id="更多图-要求能够看懂-：">更多图（要求能够看懂）：</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024202811148.png" alt="image-20221024202811148" style="zoom: 33%;" />
<hr>
<h5 id="对象图-object-diagram">对象图(Object diagram)</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031191956313.png" alt="image-20221031191956313"></p>
<h5 id="组合结构图-combined-structure-diagram">组合结构图(Combined structure diagram)</h5>
<h6 id="组合结构图的注意事项：">组合结构图的注意事项：</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221024204401865.png" alt="image-20221024204401865"></p>
<h5 id="通信图-communication-diagram">通信图(Communication diagram)</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>与顺序图同构</mark>（通信图在UML1.0时也称为协作图）</p>
</li>
<li class="lvl-2">
<p>通信图与顺序图可以相互转换</p>
</li>
<li class="lvl-2">
<p>当需要<u><em><strong>了解消息的先后顺序</strong></em></u>时选择<mark>通信图</mark></p>
</li>
</ul>
<blockquote>
<p>通信图由以下基本元素组成：执行者(Actor)、对象(Object)、连接(Link，也称为链)、消息(Message)和守护条件(Condition)。</p>
<p>在UML中，使用实线表示两个对象之间的连接；通信图中的消息，由在连接上方的带有标记的箭头表示，同时可以用数字注明消息的次序。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031192048386.png" alt="image-20221031192048386" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031192157721.png" alt="image-20221031192157721" style="zoom:50%;" />
<p>守护条件：以“[条件表达式]”格式表示</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031192322425.png" alt="image-20221031192322425" style="zoom:50%;" />
<h6 id="通信图绘制技巧">通信图绘制技巧</h6>
<ol>
<li class="lvl-3">
<p>通信图中的对象与顺序图中的对象对应；</p>
</li>
<li class="lvl-3">
<p>通信图中无法表示对象的生命线，因此无法显式表示对象的创建和销毁；</p>
</li>
<li class="lvl-3">
<p>通信图中的<mark>消息添加了顺序号</mark>，用于<mark>说明交互过程中消息的时间顺序</mark>；</p>
</li>
<li class="lvl-3">
<p>通信图用于表示对象之间的协作关系，即强调参与交互的对象的组织。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031192628451.png" alt="image-20221031192628451" style="zoom:50%;" />
<h6 id="通信图实例分析">通信图实例分析</h6>
<blockquote>
<p>某电梯控制系统：Elevator（电梯）、Queue（命令队列）、Order（指令）、Elevator Control（电梯控制器）、Button（按钮）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031192920138.png" alt="image-20221031192920138"  />
</blockquote>
<h6 id="通信图与领域建模">通信图与领域建模</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031193308758.png" alt="image-20221031193308758"></p>
<h5 id="定时图-timing-diagram">定时图(Timing diagram)</h5>
<h6 id="定时图定义">定时图定义</h6>
<p><u>定时图采用一种<mark>带数字刻度的时间轴</mark>来精确地<mark>描述消息的顺序</mark></u>，而不是像顺序图那样只是指定消息的相对顺序，而且它还允许可视化地表示每条生命线的状态变化，当需要<mark>对实时事件进行建模时</mark>，<u><strong>定时图可以很好地满足要求</strong></u>。</p>
<p>定时图的焦点集中于<u>生命线内部以及它们之间沿着时间轴的条件变化</u>。</p>
<p>定时图可以<u>把<mark>状态发生变化的时刻</mark>以及<mark>各个状态所持续的时间</mark>具体地表示出来</u>。如果把多个对象放在一个定时图中，还可以把它们之间发送和接收消息的时刻表示出来。在这方面，定时图与其他几种交互图相比具有独到的优势。</p>
<p>定时图来自于电子工程领域，在需要明确定时约束一些事件时可以使用它们。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031193915106.png" alt="image-20221031193915106"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031193950667.png" alt="image-20221031193950667"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031194032296.png" alt="image-20221031194032296"></p>
<blockquote>
<ol>
<li class="lvl-3">
<p><mark>增加了生命线的时间刻度</mark>；</p>
</li>
</ol>
</blockquote>
<h6 id="定时图绘制技巧">定时图绘制技巧</h6>
<ol>
<li class="lvl-3">
<p>定时图用于表示不同对象上状态改变之间的定时约束，如果需要对交互时间进行控制可使用定时图。</p>
</li>
<li class="lvl-3">
<p>对于那些<u>时间指标要求很高或者时序关系复杂而又敏感</u>的系统（例如嵌入式实时系统和通信领域的某些系统）而言，定时图是一种有力的描述手段。</p>
</li>
<li class="lvl-3">
<p>在大部分应用系统的建模中，一般不需要用定时图来描述对象的行为以及它们之间的交互，但是可能需要用它描述系统中某些局部对象的交互情况。</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031195141690.png" alt="image-20221031195141690"></p>
<h6 id="定时图练习">定时图练习</h6>
<p>有一个咖啡壶，它由<u>抽水泵和加热板</u>所组成。它的规则是：在抽水泵打开和加热板打开之间必须至少隔10秒钟。当储水容器变空时，抽水泵就要关闭，而加热板继续保持加热，但不能超过5分钟。试使用定时图来表示上述规则。</p>
<h5 id="交互概览图-interaction-overview-diagram">交互概览图(Interaction overview diagram)</h5>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>活动图与顺序图的组合</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{活动图与顺序图的组合}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">活动图与顺序图的组合</span></span></span></span></p>
</blockquote>
<h6 id="交互概览图定义">交互概览图定义</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><em>交互概览图是<mark>交互图（有4种）与活动图</mark>的混合物</em></u>，可以把交互概览图理解为**<u>细化的</u>**<mark>活动图</mark>，在其中的活动都通过一些小型的<mark>顺序图</mark>来表示；也可以将其理解为利用标明控制流的活动图分解过的顺序图。</p>
</li>
<li class="lvl-2">
<p>交互概览图用于将一些零散的顺序图组织在一起，它采用了活动图的构造方式，利用了活动图的各种控制节点，并把活动图的每个活动结点替换为一个交互或者交互使用。<mark>每个交互或者交互使用都使用一个顺序图表示</mark>。</p>
</li>
</ul>
<p>实例之一：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031200433652.png" alt="image-20221031200433652" style="zoom:50%;" />
<p>实例之二：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031200458992.png" alt="image-20221031200458992" style="zoom:50%;" />
<h6 id="交互概览图绘制步骤：">交互概览图绘制步骤：</h6>
<ol>
<li class="lvl-3">
<p>选择策略（对工作流建模或对操作建模）</p>
</li>
<li class="lvl-3">
<p>理清主线（绘制活动图）</p>
</li>
<li class="lvl-3">
<p>表述细节（用顺序图来表述详细细节）</p>
</li>
</ol>
<h3 id="uml扩展机制">UML扩展机制</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031201027489.png" alt="image-20221031201027489"></p>
<h6 id="实例：使用标记值增加模式标注信息">实例：使用<mark>标记值</mark>增加模式标注信息</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031201321773.png" alt="image-20221031201321773"></p>
<h2 id="图总结">图总结</h2>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031201637614.png" alt="image-20221031201637614"></p>
<table>
<thead>
<tr>
<th><strong>图名</strong></th>
<th><strong>概述</strong></th>
<th><strong>使用频率</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>用例图</td>
<td>描述用户与系统如何交互</td>
<td>★★★★★</td>
</tr>
<tr>
<td>类图</td>
<td>描述类、类的特性以及类之间的关系</td>
<td>★★★★★</td>
</tr>
<tr>
<td>包图</td>
<td>描述类的层次结构</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>顺序图</td>
<td>描述对象之间的交互，重点在于强调顺序</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>状态图</td>
<td>描述事件如何改变对象状态</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td>活动图</td>
<td>描述过程行为及其并发行为</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td>组件图</td>
<td>描述组件的结构与连接</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td>部署图</td>
<td>描述各个节点上组件的部署情况及节点间的连接</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td>通信图</td>
<td>描述对象之间的交互，重点在于连接</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>对象图</td>
<td>描述一个时间点上系统中各个对象的一个快照</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>组合结构图</td>
<td>描述类结构的分解</td>
<td>★☆☆☆☆</td>
</tr>
<tr>
<td>交互概览图</td>
<td>顺序图与活动图的混合</td>
<td>★☆☆☆☆</td>
</tr>
<tr>
<td>定时图</td>
<td>描述对象之间的交互，重点在于定时</td>
<td>★☆☆☆☆</td>
</tr>
</tbody>
</table>
<p><u>活动图：</u></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221031202105651.png" alt="image-20221031202105651"></p>
<h3 id="uml建模原则">UML建模原则</h3>
<ol>
<li class="lvl-3">
<p>适当增加注释，用于对图形和符号进行说明</p>
</li>
<li class="lvl-3">
<p>画图的目的是简化对系统的理解，而不是增加工作量</p>
</li>
<li class="lvl-3">
<p>注意折衷，既不能将图画得太复杂，同时也不能遗漏重要信息</p>
</li>
<li class="lvl-3">
<p>保持图的一致性</p>
</li>
<li class="lvl-3">
<p>需要什么就画什么，不需要就坚决不画，不要画多余的图</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章（多媒体技术概述）</title>
    <url>/2023/03/02/University/junior/course/multi-media-tech/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>多媒体技术概述</h1>
<p><span style="color: red;">媒体分类</span>：</p>
<ol>
<li class="lvl-3">
<p>感觉媒体</p>
<ul class="lvl-2">
<li class="lvl-5">图形图像、视频（直接作用于人的感官）</li>
</ul>
</li>
<li class="lvl-3">
<p>表示媒体</p>
<ul class="lvl-2">
<li class="lvl-5">编码形态的媒体，<strong>以模拟或数字编码形态出现的感觉媒体</strong></li>
</ul>
</li>
<li class="lvl-3">
<p>表现媒体</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>显示成感觉媒体的设备或技术</strong></li>
</ul>
</li>
<li class="lvl-3">
<p>存储媒体</p>
<ul class="lvl-2">
<li class="lvl-5">存放表示媒体的设备或技术</li>
</ul>
</li>
<li class="lvl-3">
<p>传输媒体</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用于传送表示媒体的设备或技术</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>代表：多媒体游戏、3D电影、网络视频、VR等</p>
</blockquote>
<p><strong>多媒体（技术）</strong>：指融合了两种以上感觉媒体的协同应用系统和技术，以帮助人们获得更丰富的应用体验</p>
<p>**多媒体技术的特征：**媒体类型和媒体技术的多样性、媒体内容的同步性和媒体应用的交互性</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章（图像处理程序设计）</title>
    <url>/2023/04/11/University/junior/course/multi-media-tech/%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>图像处理程序设计</h1>
<h3 id="显示灰度图像：">显示灰度图像：</h3>
<h5 id="灰度化方式：">灰度化方式：</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330105834269.png" alt="image-20230330105834269" style="zoom:50%;" />
<h2 id="滤波与合成">滤波与合成</h2>
<h3 id="图像滤波：">图像滤波：</h3>
<p>滤波是信号处理的基本操作之一。旨在消除或抑制信号中的特定频率成分。</p>
<h5 id="高斯滤波算法：">高斯滤波算法：</h5>
<p>一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。</p>
<p>从操作过程看，高斯滤波就是对整幅图像进行加权平均的过程。<mark>输出图像的每一个像素点的取值，都由原图像中该像素本身和其邻域内的其他像素值经过加权平均后得到。</mark></p>
<h5 id="高斯滤波的具体操作：">高斯滤波的具体操作：</h5>
<p>用一个模板（或称卷积模板）对图像中的每一个像素进行<mark>卷积运算</mark>，也就是用模板确定的邻域内像素的加权平均值代替模板中心像素点的值。</p>
<h5 id="高斯模版：">高斯模版：</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330110538787.png" alt="image-20230330110538787" style="zoom: 33%;" />
<h5 id="浮雕滤镜：">浮雕滤镜：</h5>
<p>浮雕滤镜（embossing filter）是一种获得浮雕效果的滤波算法。原理是，计算每一个像素与它右边（或者左边，或者同时考虑右边和下边）像素的颜色值之差，然后把这个差值加到一个平台值（例如128）上面，最后用这个结果取代当前像素值。</p>
<h5 id="图像融合：">图像融合：</h5>
<p>图像融合（image fusion）是指将两幅或多幅图像数据结合在一起形成一幅新的图像的技术。</p>
<p>图像融合方法有很多种，如图像合成、图像拼接等。</p>
<p>介绍一种基于<mark>像素叠加技术</mark>的图像合成方法，该方法是可见水印、透明处理的基础。</p>
<h5 id="水波纹模拟：">水波纹模拟：</h5>
<h6 id="水波纹模拟程序的实现：">水波纹模拟程序的实现：</h6>
<p>​	1）定义若干常量和全局变量</p>
<p>​	2）振动状态的初始化与位图加载</p>
<p>​	3）设置定时器</p>
<p>​	4）振动能量传递与衰减函数</p>
<p>​	5）图像渲染函数</p>
<p>​	6）投石入水函数</p>
<p>​	7）在主窗口过程中应用上述函数</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体期末复习总结</title>
    <url>/2023/04/25/University/junior/course/multi-media-tech/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>多媒体期末复习总结</h1>
<blockquote>
<p>根据2023年软件20级多媒体期末考试考点进行总结。</p>
</blockquote>
<h2 id="多媒体概念-特性">多媒体概念、特性</h2>
<h3 id="1-媒体-媒体可以分为哪些类型">1、媒体、媒体可以分为哪些类型</h3>
<p><strong>媒体：指信息<mark>传输</mark>、<mark>存储</mark>和<mark>呈现</mark>的载体</strong></p>
<p>媒体可以划分为5类：</p>
<ol>
<li class="lvl-3">
<p>感觉媒体：指直接<mark>作用于人的感觉器官</mark>、从而为人的感知系统所接受的信息形态或媒体形式</p>
</li>
<li class="lvl-3">
<p>表示媒体：指感觉媒体在电子设备、计算机、网络等<mark>内部的存在形式</mark>，即<mark>编码形态的媒体</mark>，是以模拟或数字编码形态出现的感觉媒体</p>
</li>
<li class="lvl-3">
<p>表现媒体：指将编码形式的媒体<mark>显示成感觉媒体的设备或技术</mark></p>
</li>
<li class="lvl-3">
<p>存储媒体：指用于<mark>存放表示媒体</mark>（即编码形态的媒体）的<strong>设备或技术</strong></p>
</li>
<li class="lvl-3">
<p>传输媒体：指用于<mark>传送表示媒体</mark>的<strong>设备或技术</strong></p>
</li>
</ol>
<h3 id="2-多媒体-多媒体技术的主要特点">2、多媒体、多媒体技术的主要特点</h3>
<p><strong>多媒体（技术）：指融合了两种以上感觉媒体的协同应用系统和技术，以帮助人们获得更丰富的应用体验</strong></p>
<p><strong>多媒体技术的特征</strong>：媒体类型和媒体技术的<mark>多样性</mark>、媒体内容的<mark>同步性</mark>和媒体应用的<mark>交互性</mark></p>
<blockquote>
<p>多媒体技术是涉及多种媒体形式的综合应用技术，<u><strong>主要技术特性</strong></u>包括以下几个方面：</p>
<ol>
<li class="lvl-3">整合性（集成性）：多媒体技术可以将不同媒体形式（如文字、图像、音频、视频等）整合在一起，形成更为丰富、生动、直观的信息表达方式。</li>
<li class="lvl-3">交互性：多媒体技术可以通过人机交互方式实现与用户之间的互动。用户可以通过输入设备（如键盘、鼠标、触摸屏等）对信息进行操作，从而实现个性化的信息获取和处理。</li>
<li class="lvl-3">实时性：多媒体技术可以基于实时流式传输技术，使得信息能够以较快的速度传递和处理，并且可以实现实时的沟通和交互。</li>
<li class="lvl-3">多样性：多媒体技术可以支持多种不同的媒体格式和编码方式，从而使得多种不同的应用场景都能够得到良好的支持。</li>
<li class="lvl-3">可扩展性（<em>不是主要特性/特点</em>）：多媒体技术可以根据需要灵活地<u><strong>扩展功能和应用范围</strong></u>，从而满足不同用户和应用的需求。</li>
</ol>
<p>——来源：GPT</p>
</blockquote>
<h3 id="3-多媒体技术的体系结构">3、多媒体技术的体系结构</h3>
<p>**体系结构：**指计算机系统的<u>一组硬件</u>与<u>软件部件</u>的集合，以及<u>各部件之间</u>的<u>联结方式与规则</u>。</p>
<p>多媒体技术的体系结构：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230419213518017.png" alt="image-20230419213518017" style="zoom: 50%;" />
<p><strong>硬件平台层 :硬件平台层的音视频数据采集（捕获）</strong></p>
<p>光盘驱动器、音频卡、图形加速卡、视频卡、扫描卡、交互控制接口、网络接口；</p>
<p><strong>操作系统层：多媒体数据的编码与解码、媒体服务、网络传输和多媒体编程接口</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>编解码器：(codec，coder和decoder合成词语）是系统中完成<u><strong>媒体数据压缩</strong></u>、<u><strong>解压缩</strong></u>、<u><strong>格式转换（转码）</strong></u>等操作的软件，在多媒体操作系统中居核心地位。</p>
</li>
<li class="lvl-2">
<p>媒体服务器（media server）：<u>是一种通过网络或平台向用户<mark>提供各种多媒体业务所需的媒体资源功能</mark>的<strong>系统软件</strong></u>，通常表现为操作系统中的媒体服务（media service）组件。</p>
<ul class="lvl-2">
<li class="lvl-4">媒体服务器的主要功能是<u><strong>多媒体数据流的传输和交换，</strong></u>但有时候也包括<u><strong>媒体会话的创建</strong></u>、<u><strong>交互式应答（IVR</strong></u>）、通知、统一消息、高级语音业务等</li>
</ul>
</li>
<li class="lvl-2">
<p>多媒体编程接口：应用编程接口是指一组数量可观、结构复杂的<mark>子程序、函数、变量、常量、类、数据结构</mark>，是应用系统设计与实现的<u>软件资源</u>。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>Windows 操作系统中常见的多媒体编程接口：</p>
<p>Directx 、 DirectShow、<mark>Media Foundation</mark>、SilverLight</p>
</li>
</ul>
</li>
</ul>
<p><strong>应用系统层：媒体播放、模拟仿真、多媒体通信</strong></p>
<p>整个多媒体技术架构的最上层是<u><strong>各类多媒体开发工具</strong></u>和<u><strong>应用系统</strong></u>。</p>
<p>如<u><strong>Photoshop</strong></u>、Authorware、Illustrator、<u><strong>PowerPoint</strong></u>、Premier、<u><strong>3D Max</strong></u>等等。</p>
<blockquote>
<p>主要讨论<mark>硬件平台层的音视频数据采集（捕获）</mark>，通过特定的应用系统设计，展示该类技术的特点和应用方法。</p>
<p>在操作系统层，重点是<mark>多媒体数据的编码与解码、媒体服务、网络传输和多媒体编程接口</mark>。</p>
<p>在应用层，主要通过应用程序设计，介绍<mark>媒体播放、模拟仿真、多媒体通信</mark>等系统的实现方法。</p>
</blockquote>
<h3 id="4-什么是新媒体">4、什么是新媒体?</h3>
<p>**新媒体：**基于<u>互联网、PC、移动智能终端、可穿戴设备</u>等<u><strong>新型数字技术</strong></u>的<u><strong>媒体</strong></u>称为新媒体。如<u><strong>网站、社交软件</strong></u>、博客、播客、微博、<u><strong>微信、手机APP</strong></u>、客户端…</p>
<p>是**<mark>艺术</mark>与<mark>现代数字媒体技术</mark>结合的新型媒体形态。**</p>
<h3 id="5-多媒体技术有哪些应用？描述一种多媒体应用场景">5、多媒体技术有哪些应用？描述一种多媒体应用场景</h3>
<p>1、多媒体电子消费领域</p>
<p>2、现代教育技术领域</p>
<p>3、通信领域</p>
<p>4、军事领域</p>
<p>5、管理与决策领域</p>
<p>6、表演与会展领域</p>
<p>7、信息可视化领域</p>
<p>8、物联网工程领域(**多媒体传感器：**摄像机、麦克风、拾音器)</p>
<p>9、游戏软件领域</p>
<p>10、大众传媒领域</p>
<p>多媒体应用场景：</p>
<p>一个典型的多媒体应用场景是<u><strong>在线直播</strong></u>。以一场赛事直播为例，观众可以通过<u>手机、电脑</u>等设备在线观看比赛转播，同时还可以享受到<u>实时评论、互动、回放</u>等多种功能。在这个过程中，多媒体技术被广泛应用，包括<u><strong>视频编解码</strong>、<strong>流媒体传输</strong>、<strong>直播平台</strong></u>等，为用户提供高质量的视听体验。</p>
<h3 id="6-什么是编解码器？在多媒体操作系统中-编解码器起什么作用">6、什么是编解码器？在多媒体操作系统中，编解码器起什么作用</h3>
<p>编解码器：(codec，coder和decoder合成词语）是系统中完成<u><strong>媒体数据压缩、解压缩、格式转换</strong></u>（转码）等操作的软件，在多媒体操作系统中居核心地位。</p>
<p><strong>作用：（可更详细）</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>编码器：负责将各种类型的<u><strong>多媒体数据</strong></u>（如音频、视频、图像等）转化为<u><strong>压缩格式</strong></u>，以便<mark>节省</mark><u>存储空间</u>和<u>带宽</u>，并<u>提高传输速度</u>。</p>
</li>
<li class="lvl-2">
<p>解码器：负责将压缩格式的数据<u><strong>解码回</strong></u>原始媒体数据。</p>
</li>
</ul>
<h3 id="7-媒体服务器及其功能">7、媒体服务器及其功能</h3>
<p>媒体服务器（media server）：是一种通过网络或平台向用户提供各种多媒体业务所需的媒体资源功能的系统软件，通常表现为操作系统中的媒体服务（media service）组件。</p>
<p>媒体服务器的<u>主要功能</u>是<u><strong>多媒体数据流的传输和交换</strong></u>，但有时候也包括<u><strong>媒体会话的创建</strong></u>、<u><strong>交互式应答（IVR）</strong></u>、通知、统一消息、高级语音业务等。</p>
<h3 id="8-windows-程序的核心机制">8、 Windows 程序的核心机制</h3>
<p>Windows 程序的核心是<mark>事件驱动</mark>和<mark>消息循环</mark>机制。</p>
<p>回调（Callback）：由系统根据应用程序返回的消息码调用对应事件消息处理函数的机制。所对应的事件消息处理函数称为<strong>回调函数</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>窗口过程</strong></u><mark>是</mark>典型的<u><strong>回调函数</strong></u>。（窗口过程函数：WndProc()函数）</p>
</li>
</ul>
<blockquote>
<p>回调是 Windows 程序的一种运行机制，但该机制本质上是一种<u><strong>实现多任务</strong></u>的方法</p>
</blockquote>
<p>Windows 程序的关键概念是*<u><strong>事件驱动、消息循环、回调机制和窗口过程</strong></u>*。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230419221156996.png" alt="image-20230419221156996" style="zoom:67%;" />
<h2 id="api编程-mf">API编程、MF</h2>
<h3 id="1-windows-程序的核心机制">1、 Windows 程序的核心机制。</h3>
<p>Windows 程序的核心是<mark>事件驱动</mark>和<mark>消息循环</mark>机制。</p>
<p>Windows 程序的关键概念是*<u><strong>事件驱动、消息循环、回调机制和窗口过程</strong></u>*。</p>
<h3 id="2-com组件-组件对象-接口">2、COM组件、组件对象、接口</h3>
<p><strong>组件</strong>：组件(或软件组件)是指构建软件系统的<u>基础性单元或模块</u>，它<u>封装了特定的设计策略</u>，通过标准化、可重用和开放的接口与其它组件进行组合，以便构建完整的应用系统。</p>
<p><strong>组件形式</strong>：COM规范中，一个<u>组件程序</u>被称为一个<u><strong>模块</strong></u>，可以是一个<u>动态连接库</u>，也可以是一个<u>可执行程序</u>。</p>
<p>COM (Component Object Model) 是一种面向对象的软件组件技术，它可以用于实现不同应用程序之间的交互和通信。<mark>COM 组件</mark>是 Windows 操作系统中基础的<u>构建单元</u>之一，提供了一种标准化的方法来创建可重用的软件组件。——来源：GPT</p>
<blockquote>
<p>COM是微软开发的<u><strong>组件标准或规范</strong></u>，定义了组件程序之间<u><strong>交互方式</strong></u>还提供了组件程序<u><strong>运行所需的环境</strong></u>（COM库）。</p>
</blockquote>
<p><strong>组件对象</strong>：<mark>COM对象</mark>，是组件<u><strong>以接口方式</strong></u>向外提供服务的实体。<u>COM组件</u>是建立在<u><strong>组件对象基础之上</strong></u>的程序，其他组件或普通程序(客户程序)<u>只能通过</u>组件对象提供的<u>接口</u>来<u>和组件打交道</u>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230419221943057.png" alt="image-20230419221943057"></p>
<p><strong>接口</strong>：<mark>COM 对象</mark>通过接口为外界提供服务，<mark>接口是 COM 对象与<u><strong>外部世界交互</strong></u>的唯一手段。</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>IUnknown 接口</strong> :它是任何 COM 对象都必须有的接口，不管它们是做什么用的，COM 对象都必须实现 IUnknown 接口。</p>
</li>
</ul>
<blockquote>
<p><u><strong>创建组件</strong></u>的关键是<mark>设计并封装 COM 对象，尤其是它的接口</mark>，包括继承而来的 IUnKnown 接口。</p>
</blockquote>
<h3 id="3-回调函数">3、回调函数</h3>
<p>回调（Callback）：由系统根据应用程序返回的消息码调用对应<u><strong>事件消息处理函数</strong></u>的机制。所对应的事件消息处理函数称为<strong>回调函数</strong>。</p>
<h3 id="4-mf架构-两种编程模型">4、MF架构、两种编程模型</h3>
<p><strong>Media Foundation架构</strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302102456749.png" alt="Media Foundation架构"></p>
<blockquote>
<p>Media Session用于<u><strong>管理媒体管道(pipeline)中的数据</strong></u>，从而实现<u><strong>音频数据的播放</strong></u>和<u><strong>文件输出</strong></u>。（试卷上有）</p>
<p>Media Session并<u><strong>不直接管理媒体数据</strong></u>，而是要借助<mark>Topology</mark></p>
<ul class="lvl-1">
<li class="lvl-2">
<p><mark>Media Session是一个Media Foundation对象</mark></p>
</li>
</ul>
<p><mark>Topology也是一个Media Foundation对象</mark>，用于表示媒体管道中的<u>数据如何流动</u>。</p>
<p>在Topology中，<u>数据流</u>所经过的<u>处理模块</u>称为<mark>节点(Node）</mark>，如<em><strong>媒体源、转换器、输出节点</strong></em>。</p>
</blockquote>
<p><strong>数据管道模式：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过Media Session控制其他组件</p>
</li>
<li class="lvl-2">
<p>Media Source、MFT、Media Sink</p>
</li>
<li class="lvl-2">
<p>MFT通常由MF平台自动处理</p>
</li>
<li class="lvl-2">
<p>应用<u><strong>不能直接处理数据</strong></u></p>
</li>
</ul>
<p><strong>数据源模式：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Source Reader、Sink Writer控制数据</p>
</li>
<li class="lvl-2">
<p>程序处理MFT(Encoder/Decoder)</p>
</li>
<li class="lvl-2">
<p>应用可以<u><strong>直接处理数据</strong></u></p>
</li>
</ul>
<h3 id="5-topology">5、Topology</h3>
<blockquote>
<p>Media Session并不直接管理媒体数据，而是要借助<mark>Topology</mark></p>
</blockquote>
<p><mark>Topology</mark>也是一个Media Foundation对象，用于表示<u>媒体管道中的数据如何流动</u>，应用程序通过<u><strong>Topology</strong></u>来<strong>描述</strong><u>媒体数据</u>从<u><strong>源端</strong></u>一直到<u><strong>输出端</strong></u>所经过的<u><mark>路径</mark></u>。</p>
<p>应用程序将Topology传给Media Session, Media Session<u><em><strong>借助Topology实现对媒体数据的管理</strong></em></u>。</p>
<p>在Topology中，数据流所经过的处理模块称为<mark>节点(Node）</mark>，如<mark>媒体源、转换器、输出节点</mark>。其中，<u>转换器</u>包括<u><strong>编码器和解码器</strong></u>，一般在<u>播放媒体文件时用到解码器</u>，<u>输出媒体文件时用到编码器</u>。<u><strong>数据的流动</strong></u>则通过节点之间的<mark>连接</mark>表示。</p>
<p><strong>基于Media Session的媒体播放应用的基本框架</strong>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230424153537514.png" alt="image-20230424153537514" style="zoom:50%;" />
<p><strong>通过节点连接起来的数据管道结构：</strong></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230419223239215.png" alt="image-20230419223239215" style="zoom:67%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：</mtext><mi>P</mi><mi>P</mi><mi>T</mi><mtext>上还有部分老师添加的复习内容</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{注意：PPT上还有部分老师添加的复习内容}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">PPT</span><span class="mord cjk_fallback" style="color:red;">上还有部分老师添加的复习内容</span></span></span></span></p>
<h2 id="音频基础-程序设计">音频基础、程序设计</h2>
<h3 id="1-声音的基本物理属性和基本特征-声卡的基本功能-了解">1、声音的基本物理属性和基本特征。声卡的基本功能。（了解）</h3>
<p>声音的基本物理属性：<strong>频率与振幅</strong></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230419223919662.png" alt="image-20230419223919662" style="zoom:50%;" />
<p><strong>声音的基本特征</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>声音的三要素：<u><strong>音高、音色、音强</strong></u></p>
<ul class="lvl-2">
<li class="lvl-4">音高：由<u><strong>基波频率</strong></u>决定的，基波频率越高，声音听起来也就越高。</li>
<li class="lvl-4">音色：由<u><strong>谐波成份的分布结构</strong></u>决定的，谐波构成不同，就会有不同的<mark>音质？</mark>（PPT上只有音质没有提到音色）</li>
<li class="lvl-4">音强：指声音的强弱，音强可以用声压大小表示。</li>
</ul>
</li>
</ul>
<p><strong>声卡的基本功能</strong>（了解）：完成数字音频信号与模拟音频信号的转换，并<u>将模拟信号通过音箱输出</u>。</p>
<p><span style="color: blue;">MIDI音频文件：</span></p>
<p>MIDI文件并不是录制好的音乐本身，而是描述音乐的<mark>一系列指令</mark>，<u>供声卡</u>通过合成技术产生音频。1分钟的音乐只需5～10KB。</p>
<h3 id="2-采样-量化-编码-量化间隔-量化误差-以及几种常见的采样频率">2、<mark>采样、量化、编码、量化间隔、量化误差</mark>（以及几种常见的采样频率）</h3>
<p><span style="color: blue;">采样 Sampling</span>：采样是指<u><strong>以一定的频率</strong></u>（或周期）<u>捕获模拟音频信号</u>，从而得到一系列<u><strong>离散化音频样本</strong></u>的过程。单位时间内捕获的样本个数称为<mark>采样频率（Sampling Rate）</mark>，是采样周期的倒数。</p>
<blockquote>
<p>采样：是指以一定的频率（或周期）捕获模拟音频信号，从而得到一系列离散化音频样本的过程。</p>
<p>采样频率：单位时间内捕获的<u>样本个数</u>称为<u><strong>采样频率</strong></u>（Sampling Rate）</p>
<p><strong><u>采样定理</u></strong>（奈奎斯特定理）：**<u>采样频率</u>**大于<mark>模拟信号频带F的两倍</mark>（即：采样频率大于(&gt;)该信号<mark>最高频率分量的两倍</mark>，则可以通过采样信号<u><strong>完全恢复</strong></u>原始信号）</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><mark>频带</mark>通常用于描述<u><em><strong>传输信号的带宽</strong></em></u>或<u><em><strong>可用频率范围</strong></em></u></p>
</li>
</ul>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307140528727.png" alt="image-20230307140528727" style="zoom:50%;" />
<blockquote>
<p>序号3、4、5的数据存在减半的规律。</p>
</blockquote>
<p><u><em><strong>人能听到的频率范围：20Hz～20000Hz（20Hz~20kHz）</strong></em></u></p>
<hr>
<p><span style="color: blue;">量化（Quantization ）</span>量化是指<u><strong>用若干比特</strong></u>表示<u>一个样本</u>的过程；表示一个样本的二进制的<u>位数</u>，即<u>样本的比特数</u>称为<mark>量化深度（bit depth）</mark>。</p>
<blockquote>
<p>量化：是指用若干比特表示一个样本的过程；</p>
<p>量化深度：表示一个样本所使用的<strong>比特数</strong>称为量化深度（bit depth）。</p>
</blockquote>
<hr>
<p><span style="color: blue;">编码（coding）</span>：编码实际上是<u><strong>以某种格式</strong></u>最终生成<u><strong>数字音频数据流</strong></u>的过程，所得到的数字音频数据将会被<u>存储</u>、<u>传输</u>或者进行<u>各种处理</u>。</p>
<blockquote>
<p>编码实际上是以某种格式最终生成数字音频数据流的过程</p>
</blockquote>
<p>音频编码：将<u>模拟信号转换为数字信号</u>并以某种格式存储的技术或过程。</p>
<hr>
<p><u><span style="color: blue;">量化间隔（量化阶跃）</span>：就是指将整个<strong>量化空间</strong>分割成<strong>若干离散的有限状态</strong>后，<strong>相邻的两个离散状态值之间</strong>的差值。（幅值平均划分之后的每一份平均幅值就是量化间隔。）</u></p>
<p><span style="color: blue;">量化误差</span>：模拟信号上点的实际值与进行量化之后近似的具体值之间的差值就是量化误差。</p>
<blockquote>
<p>在数字信号处理中，量化误差是将连续信号转换为离散信号时产生的误差。这个错误通常是由于数字信号采样率或量化级别的限制导致的。随着采样率和量化级别的增加，量化误差会减小。</p>
<p>量化误差可以通过<u><em>增加数字量化的精度来减小</em></u>，但这也会增加计算成本和存储空间占用。因此，在实际应用中需要平衡计算资源和误差之间的权衡。</p>
<p>——来源：GPT</p>
</blockquote>
<p><strong>编码流程：</strong></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302112947670.png" alt="实例"></p>
<blockquote>
<p>经过采样的时间离散之后波上有根据时间点均匀划分的值（点），再经过量化的空间离散之后将整个模拟信号根据振幅进行均匀划分（如量化深度为3，则将振幅划分为8份，也就是8个值），最后根据模拟信号上的点与量化划分线之间的远近进行近似拟合，因此可以近似为3、5、5、2、4、6、7等具体数值，然后转化为二进制形式即可（011、101、101、……）。</p>
</blockquote>
<h3 id="3-采样与量化如何影响数字音频质量">3、采样与量化如何影响数字音频质量</h3>
<blockquote>
<p><u><strong>模拟信号</strong></u>经过==采样（时间离散）<mark>和</mark>量化（空间离散）==得到离散化的<u><strong>数字信号</strong></u>。</p>
<ul class="lvl-1">
<li class="lvl-2">数字音频采样和量化过程所用的主要硬件是<mark>模数转换器</mark>（ADC）。</li>
</ul>
</blockquote>
<p>采样和量化对数字音频质量的影响：</p>
<ol>
<li class="lvl-3">
<p>采样频率：采样频率是指每秒钟对模拟信号进行采样的次数。采样频率越高，能够记录的音频细节就越多，音质也会相应提高。但是，采样频率越高，所需的存储空间和处理能力也就越大。</p>
</li>
<li class="lvl-3">
<p>量化深度：量化是指将连续的模拟信号转换成离散的数字信号。量化深度越大，数字信号的精度就越高，音质也就越好。同样随着量化深度的增大，所需要的存储空间越大，处理数据也会越多。</p>
<ul class="lvl-2">
<li class="lvl-5">补充：通常，CD音质的采样率为44.1kHz，量化位数为16位，而更高档次的音频设备可能会使用更高的采样率和量化位数来提高音质。</li>
</ul>
</li>
</ol>
<h3 id="4-pcm编码调制系统由哪几部分组成-pcm编码的本质">4、PCM编码调制系统由哪几部分组成，PCM编码的本质</h3>
<p><strong>PCM编码调制系统</strong>：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302113605304.png" alt="PCM编码框图"></p>
<p>系统由三个部分构成：</p>
<ol>
<li class="lvl-3">
<p>首先是<mark>防失真滤波器</mark>，它是一个<u>低通滤波器</u>，用来滤除音频信号以外的信号；</p>
</li>
<li class="lvl-3">
<p>其次是<mark>波形编码器</mark>，主要完成<u>采样</u>任务；</p>
</li>
<li class="lvl-3">
<p>而<mark>量化器</mark>负责对样本进行<u>量化</u>，即对每一个样本赋予一个对应的二进制数据，从而<u><strong>得到PCM样本序列</strong></u>，作为系统的输出。</p>
</li>
</ol>
<p>PCM编码的实质（本质）：即通过脉冲编码调制方法生成数字音频数据的技术或格式。（信号质量最好，数据量最大）——实质就是：<u><em><strong>通过采样、量化和编码的方式将模拟信号转换成数字信号的过程。</strong></em></u></p>
<h3 id="5-dm编码技术中的斜率过载与粒度噪声是如何产生的？怎样克服斜率过载与粒度噪声？">5、DM编码技术中的<mark>斜率过载与粒度噪声</mark>是如何产生的？怎样克服斜率过载与粒度噪声？</h3>
<p><span style="color: blue;">增量调制编码（DM）</span>：通过<u><strong>增量起伏</strong></u>来<mark>记录</mark>模拟音频信号<u><strong>实际变化过程</strong></u>的数字音频编码。</p>
<p><u><em><strong>针对<span style="color: red;">极性</span>进行编码</strong></em></u></p>
<p>只需要1位来表示0或者1即可。（针对极性编码）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307141721643.png" alt="image-20230307141721643" style="zoom: 50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p><span style="color: red;">红色</span>为预测值</p>
</li>
<li class="lvl-3">
<p><span style="color: blue;">蓝色</span>为实际值</p>
</li>
</ol>
<ul class="lvl-1">
<li class="lvl-2"><u><strong>实际值大于预测值，则为1；否则，为0。</strong></u></li>
</ul>
<ol>
<li class="lvl-3">
<p>斜率过载：即模拟信号的<u><strong>斜率太大</strong></u>，超过了量化阶跃允许的<u><strong>变化幅度</strong></u>（模拟的预测值的变化趋势要小于实际值）。</p>
<ul class="lvl-3">
<li class="lvl-5">解决：增大量化阶跃（间隔）</li>
</ul>
</li>
<li class="lvl-3">
<p>粒状噪声：当输入信号变化比较<u><strong>平缓</strong></u>时，增量调制器的<u><strong>编码输出</strong></u>为交错出现的0和1，即<u>数字信号并不平缓</u>，而是以量化阶跃Δ的大小<u><strong>起伏变化</strong></u>，这就<u>相当于引入了噪声信号</u>。</p>
<ul class="lvl-3">
<li class="lvl-5">解决：减小量化阶跃（间隔）</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="6-pcm编码-dm编码-dpcm编码的区别">6、<mark>PCM编码、DM编码、DPCM编码的区别</mark></h3>
<p>1、脉冲编码调制（PCM）⭐️</p>
<p>PCM编码：即通过脉冲编码调制方法生成数字音频数据的技术或格式。（<u>信号质量最好</u>，<u>数据量最大</u>）</p>
<blockquote>
<p>PCM是一种<mark>数字编码技术</mark>，用于将模拟信号转换为数字信号。</p>
</blockquote>
<p><u><em><strong>针对<span style="color: red;">样本</span>进行编码</strong></em></u></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302113605304.png" alt="PCM编码框图"></p>
<p><span style="color: red;">脉冲编码调制（Pulse Code Modulation，PCM）</span>的两种量化方式：</p>
<ol>
<li class="lvl-3">
<p>均匀量化（线性量化）</p>
</li>
<li class="lvl-3">
<p>非均匀量化（非线性量化）</p>
<ul class="lvl-2">
<li class="lvl-5">13折线（不做要求）</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>均匀量化</th>
<th>非均匀量化</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302113938730.png" alt="均匀量化"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302113958688.png" alt="非均匀量化"></td>
</tr>
</tbody>
</table>
<p>2、增量调制编码（DM）⭐️</p>
<p>DM编码：通过增量起伏来记录模拟音频信号实际变化过程的数字音频编码。</p>
<blockquote>
<p>增量调制是一种<mark>模拟编码技术</mark>（预测编码✔️）</p>
</blockquote>
<p><u><em><strong>针对<span style="color: red;">极性</span>进行编码</strong></em></u></p>
<p>只需要1位来表示0或者1即可。（针对极性编码）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307141721643.png" alt="image-20230307141721643" style="zoom: 50%;" />
<p>3、差分脉冲编码调制（DPCM）⭐️</p>
<p>DPCM编码：利用<u><strong>样本与样本之间</strong></u>存在<u><strong>相关性</strong></u>来进行编码的<u>数据压缩技术</u>。</p>
<p><u><em><strong>针对<span style="color: red;">实际信号值与预测值之差</span>进行编码</strong></em></u></p>
<p>思想：根据<u><strong>过去的样本幅值</strong></u>来估算<u><strong>下一个样本信号</strong></u>的幅度大小，这个值称为<u><strong>预测值</strong></u>，然后<u>计算实际信号值与预测值之差</u>，最后<u><strong>对这个差值进行量化编码</strong></u>。</p>
<blockquote>
<p>对差值（具体值）进行编码，会有多位（bits）去表示差值，不是对极性进行编码。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230419232919149.png" alt="image-20230419232919149" style="zoom:67%;" />
<p><span style="color: green;">区别：</span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PCM编码针对样本进行编码</p>
</li>
<li class="lvl-2">
<p>DM编码针对极性进行编码</p>
</li>
<li class="lvl-2">
<p>DPCM编码针对实际信号值与预测值之间的差值进行编码</p>
</li>
</ul>
<h3 id="7-设有一个wav文件-文件结构-存储了双声道的pcm音频数据-采样频率为44-1khz-位深度等于16-播放时间是1分30秒-试计算该wav文件中音频数据的字节数">7、设有一个WAV文件（文件结构），存储了双声道的PCM音频数据，采样频率为44.1kHz,位深度等于16，播放时间是1分30秒。试计算该WAV文件中音频数据的字节数。</h3>
<p><u><em><strong>波形音频文件有4个块组成。</strong></em></u></p>
<h5 id="wave文件由4个块组成：">WAVE文件由4个块组成：</h5>
<ol>
<li class="lvl-3">
<p>RIFF WAVE Chunk</p>
</li>
<li class="lvl-3">
<p>Format Chunk</p>
</li>
<li class="lvl-3">
<p>Fact Chunk（可选）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>一般当wav文件由某些软件转化而成时，则需要包含该Chunk</p>
</li>
<li class="lvl-3">
<p>Data Chunk</p>
<ul class="lvl-2">
<li class="lvl-5">双声道的<u>采样数要加倍</u></li>
<li class="lvl-5">小端序：低位字节存在地址空间中的低位（比如：Ox0782中的低位字节82存储在地址空间中的低位）</li>
<li class="lvl-5">大端序：低位字节存在地址空间中的高位</li>
</ul>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307151517811.png" alt="image-20230307151517811" style="zoom:50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p>ID都是4个字节，<u>比如<code>ID='fmt '</code>中fmt之后还有一个<strong>空字符</strong></u>（用“四字符码”作块ID，是RIFF文件的重要特点）</p>
</li>
</ol>
</blockquote>
<h5 id="码率计算公式：">码率计算公式：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307144339993.png" alt="image-20230307144339993"></p>
<h5 id="数据量公式：">数据量公式：</h5>
<p>数据量（字节/秒）=（采样频率（Hz）×采样位数（bit）×声道数）/8</p>
<h5 id="课堂练习：">课堂练习：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307144650999.png" alt="小练习"></p>
<blockquote>
<p>该文件的音频数据的字节数：（码率*播放时间）/8<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>结果：15876000字节</p>
<p>参考：<a href="https://zhidao.baidu.com/question/54537178.html">音频文件存储容量计算_百度知道 (baidu.com)</a></p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：</mtext><mi>P</mi><mi>P</mi><mi>T</mi><mtext>上还有部分老师添加的复习内容</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{注意：PPT上还有部分老师添加的复习内容}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">PPT</span><span class="mord cjk_fallback" style="color:red;">上还有部分老师添加的复习内容</span></span></span></span></p>
<h3 id="增加-转码程序设计：">（增加）转码程序设计：</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230424125027418.png" alt="image-20230424125027418"></p>
<h2 id="无损数据压缩算法">无损数据压缩算法</h2>
<blockquote>
<p>这一部分的详细算法思想和算法流程请看<mark>第五章PPT和第五章md笔记</mark>。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>P</mi><mi>S</mi><mtext>：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{PS：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">PS</span><span class="mord cjk_fallback" style="color:red;">：</span></span></span></span></p>
<ul class="lvl-1">
<li class="lvl-2">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420221409601.png" alt="image-20230420221409601"></p>
</li>
</ul>
</blockquote>
<p><strong>相关定义</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信源：指构成一类报文的基本符号的集合。</p>
</li>
<li class="lvl-2">
<p>报文：就是信息的载体</p>
</li>
<li class="lvl-2">
<p>码元（基本编码单元）：基本符号又称为码元</p>
</li>
<li class="lvl-2">
<p>信息熵：一个<u>信源</u>的<u>所有码元</u>的<u><strong>平均信息量</strong></u>就称为该信源的<mark>信息熵</mark>（<strong>entropy</strong>）</p>
</li>
<li class="lvl-2">
<p>熵编码：就是指在<u><strong>不丢失任何信息</strong></u>的前提下，基于<u><strong>码元的统计特性</strong></u>，对<u><strong>码元</strong></u>或直接对<u><strong>报文本身</strong></u>进行编码，使得最后存储该报文所需要的<u>平均比特数</u>接近信源的<u>信息熵</u>。</p>
</li>
</ul>
<h3 id="1-对某一串报文进行算术编码">1、对某一串报文进行<mark>算术编码</mark>。</h3>
<blockquote>
<p>算术编码并不对码元进行编码，而是直接<mark>对报文</mark>进行处理，即编码算法<u>直接作用于输入报文</u>，将其压缩成某种编码形式</p>
</blockquote>
<p>算术编码算法是一个对编码区间进行分割的循环过程，当前分割的区间是前一轮循环得到的编码区间，每一次循环都会从原始报文输入一个码元，直到输入最后一个码元，即中止分割循环。</p>
<h5 id="示例：">示例：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420002623370.png" alt="image-20230420002623370"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420002545624.png" alt="image-20230420002545624"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420222638224.png" alt="image-20230420222638224"></p>
<h3 id="2-行程编码算法主要适用于什么对象？">2、行程编码算法主要适用于什么对象？</h3>
<p>主要适用于：<strong>相同的数据单元连续排列在一起</strong></p>
<p>​		行程编码算法是一种常用的数据压缩算法，它<mark>主要适用于</mark>包含<u><strong>大量重复数据</strong></u>或者<u><strong>连续相同数据</strong></u>的对象。这些对象可能包括文本、图像、视频等各种类型的数据。行程编码算法通过将连续相同或重复的数据压缩为<u><strong>一个标记和一个计数值</strong></u>的形式来<mark>减少</mark><u><strong>数据存储空间</strong></u>，从而<u>实现数据压缩的效果</u>。在许多场合下，数据压缩可以提高数据传输速度、降低存储成本以及减少网络流量等优点，因此行程编码算法具有广泛的应用价值。——来源：GPT</p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316112837587.png" alt="image-20230316112837587"></p>
<p><strong>在这些图块中，许多行上都具有相同的颜色，或者说在一行上有许多连续的像素都具有相同的颜色值，只需要存储一个像素的颜色值，再加上相同颜色的像素的数目就可以了</strong></p>
</blockquote>
<h3 id="3-第一类与第二类词典编码的区别在哪里？">3、第一类与第二类词典编码的区别在哪里？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一类词典编码算法中并没有出现一个显式的（explicit）“词典”；</p>
</li>
<li class="lvl-2">
<p>第二类词典编码技术，它会从输入报文中<u><strong>显式地创建</strong></u>一个短语<u><strong>词典</strong></u>。</p>
</li>
</ul>
<h3 id="4-lzss算法在哪些地方改进了lz77算法？">4、LZSS算法在哪些地方改进了LZ77算法？</h3>
<p>LZSS算法在LZ77算法基础上改进而来的，<mark>主要区别在于它设置了一个最小匹配长度，并改进了输出数据格式</mark>。如果匹配模式的长度大于最小匹配长度，就输出(off,length），否则就直接输出原字符序列（其长度取决于最小匹配长度，例如，如果最小匹配长度为2，那么直接输出的原字符长度等于1）。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置了一个最小匹配长度，如果小于了最小匹配长度，则输出原字符序列</p>
</li>
<li class="lvl-2">
<p>改进了输出数据格式，不再输出下一个字符(Next Char)</p>
</li>
</ul>
<h3 id="5-画出词典编码算法lzss的流程图-并给出用lzss算法压缩报文abdabcabdebdabce的结果-设最小匹配长度等于2-匹配搜索窗口-即滑动窗口-大小等于20">5、 画出词典编码算法LZSS的流程图。并给出用LZSS算法压缩报文ABDABCABDEBDABCE的结果，设最小匹配长度等于2，匹配搜索窗口（即滑动窗口）大小等于20。</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321144512334.png" alt="image-20230321144512334" style="zoom:50%;" />
<h3 id="6-lz78算法-lzw算法">6、LZ78算法、LZW算法。</h3>
<h5 id="lz78算法">LZ78算法</h5>
<p>LZ78算法属于第二类词典编码技术，<mark>它会从输入报文中显式地创建一个短语词典</mark>。在数据结构上，短语词典实际上是一个<mark>二维数组，该数组的每一个成员记录了一个词条，而一个词条就是一个索引与一条短语的组合</mark>。有了短语词典，那么在压缩报文的时候，如果当前遇到的模式在短语词典中可以找到完全相同的词条（即模式），那就只要输出该词条的索引即可。</p>
<blockquote>
<p><mark>短语应当尽可能长</mark>，因为用<u><strong>有限长度的索引</strong></u>去代替<u>较长的短语</u>，会显著<u><strong>提高压缩效率</strong></u>，这正是词典压缩算法的精髓所在。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321150502859.png" alt="image-20230321150502859" style="zoom:50%;" />
<p><strong>LZ78示例</strong>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321151940604.png" alt="image-20230321151940604" style="zoom:50%;" />
<hr>
<h5 id="lzw算法">LZW算法</h5>
<h6 id="改进点：">改进点：</h6>
<ol>
<li class="lvl-3">
<p>第一，它的词典最初不是空的，而是一开始就包含了一些基本的词条，这些词条是字符流中可能出现的单个字符，例如ASCII字符集。</p>
</li>
<li class="lvl-3">
<p>第二，LZW算法的输出与LZ78不同，它只输出索引，不像LZ78那样输出（index，next char）对。</p>
</li>
</ol>
<blockquote>
<p><mark>注意LZ78算法在输出一次之后会有P=NULL；而LZW算法是P=X</mark></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321154017982.png" alt="image-20230321154017982" style="zoom:50%;" />
<p><strong>LZW示例</strong>：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323103109423.png" alt="image-20230323103109423" style="zoom:50%;" />
<h6 id="解码示例：">解码示例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323103218389.png" alt="image-20230323103218389" style="zoom:50%;" />
<h2 id="图像基础-程序设计">图像基础、程序设计</h2>
<h3 id="1-数字图像的像素-像素记录了图像的什么信息">1、数字图像的像素、像素记录了图像的什么信息。</h3>
<blockquote>
<p>数字图像（digital images）是用<u><strong>二维像素矩阵</strong></u>表示的图像。</p>
</blockquote>
<p><strong>像素</strong>：把构成数字<mark>图像的基本元素</mark>称为像素（pixel），是图像平面中特定位置上的一个点，<mark>具有</mark>一定的<mark>颜色属性</mark>。</p>
<p>位深度：表示<u>像素颜色属性值</u>的<u><strong>比特数</strong></u>称为位深度，或称图像深度。</p>
<h5 id="textcolor-red-示例：计算图像的数据量-试卷上有此类题"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>示例：计算图像的数据量</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{示例：计算图像的数据量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">示例：计算图像的数据量</span></span></span></span>——（试卷上有此类题）</h5>
<p>一幅彩色JPEG图像(RGB),设其分辨率为512×512，每种颜色用8 bit表示，则该彩色 JPEG图像的数据量为：</p>
<p><code>512×512×3×8 bit</code></p>
<h3 id="2-图像的分辨率-为什么说图像的大小不等于图像分辨率？">2、图像的分辨率、为什么说图像的大小不等于图像分辨率？</h3>
<p><strong>图像的分辨率</strong>：图像在水平和垂直方向上的<u>像素数的乘积</u>。实际上代表图像的像素（样本点）的多少，又称<u><strong>解析度</strong></u>，<mark>指单位面积或长度上的像素的数量。</mark></p>
<p><strong>为什么说图像的大小不等于图像分辨率？</strong></p>
<p>图像的大小指的是图像文件占据存储设备上的<u><strong>空间大小</strong></u>，通常用字节（Byte）来表示。而图像分辨率则是指图像中单位面积或长度上的<u><strong>像素的数量</strong></u>。<u><strong>压缩方式</strong></u>、<u><strong>文件格式</strong></u>以及<u><strong>色彩模式</strong></u>等因素都会影响图像文件的大小。</p>
<blockquote>
<p>图像的大小指的是图像文件占据存储设备上的空间大小，通常用字节（Byte）或千字节（KB）来表示。而图像分辨率则是指图像中每英寸所包含的像素数，通常用“像素/英寸”（PPI）或“点/英寸”（DPI）来表示。</p>
<p>因此，图像的大小与其分辨率并不一定相等。即使两个图像的分辨率相同，它们的大小也可能不同，这是因为它们所使用的<u><strong>压缩方式</strong></u>、<u><strong>文件格式</strong></u>以及<u><strong>色彩模式</strong></u>等因素都会影响图像文件的大小。</p>
<p>另外，需要注意的是，虽然分辨率可以影响图像的清晰度和细节程度，但并不是分辨率越高就代表图像质量越好，还需要考虑其他因素，如拍摄设备、光线条件、拍摄技巧等。</p>
<p>——来源：GPT</p>
</blockquote>
<h3 id="3-色彩模型">3、色彩模型。</h3>
<p><strong>色彩模型</strong>是对三维色彩空间中的<u><strong>可见光子集</strong></u>的一个描述，即用于表示<u><strong>颜色形成方式</strong></u>和<u><strong>取值范围</strong></u>的空间数学模型。(常用的模型有RGB、RGBA、CMYK、HSV和YUV等)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RGB模型：</p>
<ul class="lvl-2">
<li class="lvl-4">用红、绿、蓝三种<u><strong>基本颜色</strong></u>表示<u>其他颜色</u>的模型。RGB颜色模型<u>通常用一个三维立方体空间来表示</u>。</li>
</ul>
</li>
<li class="lvl-2">
<p>RGBA模型：</p>
<ul class="lvl-2">
<li class="lvl-4">代表Red（红色） Green（绿色） Blue（蓝色）和 Alpha参数（描述颜色的透明程度）的色彩空间模型。</li>
</ul>
</li>
<li class="lvl-2">
<p>HSV模型：  是RGB模型的一种非线性变换。</p>
<ul class="lvl-2">
<li class="lvl-4">HSV 模型中，H表示色相（hue）、S为饱和度（saturation）、V为亮度值 (value)。</li>
</ul>
</li>
<li class="lvl-2">
<p>CMYK模型：</p>
<ul class="lvl-2">
<li class="lvl-4">是用<u><strong>物质吸收光的数量</strong></u>表示色彩的方式，即通过青色©、品红色(M)、黄色(Y)三原色颜料混合表示颜色，称为CMY颜色空间。增加一个黑(K)，得到CMYK模型，应用于实际的<u><strong>印刷工业</strong></u>中。</li>
<li class="lvl-4">RGB模型中，当红、绿、蓝三原色混合时，产生白色。但CMYK模型中，混合青©、品(M)、黄(Y)三原色时会得到黑色。</li>
</ul>
</li>
<li class="lvl-2">
<p>YUV模型：Y代表亮度，U和V代表色差。</p>
<ul class="lvl-2">
<li class="lvl-4">指的是一个<u><strong>颜色空间族</strong></u>，即采用<u><strong>亮度值与颜色值分开</strong></u>编码的彩色空间。</li>
</ul>
</li>
</ul>
<h3 id="4-真彩图像-伪彩图像-灰度图像-如何将彩色图像转换成灰度图像">4、真彩图像、伪彩图像、灰度图像、如何将彩色图像转换成灰度图像。</h3>
<p>真彩图像：<strong>像素值</strong><mark>直接表示</mark>了<mark>颜色属性</mark>的彩色图像称为真彩图像。位深度为24。</p>
<p>伪彩图像：伪彩图像是指<strong>像素值</strong><mark>不直接表示颜色值本身</mark>而是<mark>表示</mark>了颜色在<strong>调色板中</strong><mark>索引</mark>的彩色图像。</p>
<p>灰度图像： 灰度图像（gray image）是每个像素<mark>只有一个采样颜色</mark>的图像。</p>
<p><strong>将彩色图像转换成灰度图像</strong></p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420011206647.png" alt="image-20230420011206647"></p>
</blockquote>
<h3 id="5-bmp文件的组成-offset-存储格式-两个层面">5、BMP文件的组成（offset），存储格式（两个层面）。</h3>
<p>BMP（Bitmap，位图）图像又称位图图像，是Microsoft、IBM等公司制定的图像文件标准。BMP文件中图像数据是以非常自然的位映射方式存储的，并且没有被压缩（绝大多数情况下如此），所以，BMP文件是<u><strong>最基本的图像文件</strong></u>。</p>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328141409884.png" alt="image-20230328141409884" style="zoom:50%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328142400896.png" alt="image-20230328142400896" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<hr>
<p><span style="color: red;">存储格式：</span></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420014202750.png" alt="image-20230420014202750" style="zoom:50%;" />
<p>位图数据(bitmap data)：就是图像数据，如图所示全部为图像数据，图像的像素点存储顺序是<mark>从左到右，从下倒上进行存储的</mark>，所以左下角的像素为第一个存储，右上角的像素为最后一个存储。<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330100736012.png" alt="image-20230330100736012"></p>
<p>如左边图所示，一行有三个像素，每个像素占3个字节，共9个字节，不能被4整除，所以要再补充3个值为0的字节，才能被4整除。（不能被4整除时要补0）</p>
<blockquote>
<p>图像在内存中是倒立存储。</p>
</blockquote>
<p><strong>位图数据的存储方式</strong>：</p>
<ol>
<li class="lvl-3">
<p>Top-down存储模式（从上到下）</p>
</li>
<li class="lvl-3">
<p>Bottom-up存储模式（从下到上）</p>
</li>
</ol>
<hr>
<p><span style="color: blue;">存储模式实际上包含两个层面的含义。</span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个层面是<mark>像素格式</mark>，即一种颜色模型下三个颜色分量的<u><strong>内部排列方式</strong></u>。</p>
</li>
<li class="lvl-2">
<p>第二个层面是<mark>图像的整体存储格式</mark>，也就是<u><strong>像素的外部排列方式</strong></u>。</p>
</li>
</ul>
<h3 id="6-数字图像的像素格式">6、数字图像的像素格式。</h3>
<p>（1）RGB555</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323113836163.png" alt="image-20230323113836163" style="zoom:50%;" />
<blockquote>
<p>采用<mark>小端序</mark>存储到地址空间中。</p>
</blockquote>
<p>（2）RGB565</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323113908526.png" alt="image-20230323113908526" style="zoom:50%;" />
<p>（3）RGB888</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323113939423.png" alt="image-20230323113939423" style="zoom:50%;" />
<h3 id="7-jpeg图像压缩过程包括哪些计算步骤？导致图像信息损失的操作步骤是哪些？">7、JPEG图像压缩过程包括哪些计算步骤？导致图像信息损失的操作步骤是哪些？</h3>
<p><strong>包括以下计算步骤</strong>：（<span style="color: red;">更为详细可分为7步，详见第6章PPT</span>）</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420012816001.png" alt="image-20230420012816001"></p>
<ol>
<li class="lvl-3">
<p>DCT变换将空域图像（由像素构成的空间）转换成频域表示的图像，从而<mark>把能量集中在低频系数上</mark>。</p>
<ul class="lvl-2">
<li class="lvl-5">经DCT变换之后，F(0,0)被称为直流系数（DC），其他是交流系数（AC）。
<ul class="lvl-4">
<li class="lvl-7">直流系数：使用差分脉冲调制编码（DPCM）</li>
<li class="lvl-7">交流系数：使用行程编码（RLE）——Z字型编排尽可能形成较多连续的0，从而方便行程编码</li>
<li class="lvl-7">然后使用熵编码（<strong>霍夫曼编码</strong>）进一步压缩</li>
<li class="lvl-7">最后组成位数据流</li>
</ul>
</li>
<li class="lvl-5">⭐️频域系数的特点：——（试卷上有）
<ol>
<li class="lvl-8">==大部分能量集中在低频系数上，而高频系数上的能量相对较少。==这是因为图像中的大部分信息都集中在低频区域，而高频系数则主要用于表示图像的细节信息。</li>
<li class="lvl-8"><mark>频域系数之间存在一定的相关性，即相邻的系数之间往往具有相似的取值</mark>。这种相关性可以被利用来进行数据压缩，因为一些系数可以通过近似表示来减少存储空间。</li>
<li class="lvl-8">频域系数通常会按照从左上角到右下角的<u><strong>顺序排列</strong></u>（<mark>对称性</mark>），并且在每个8x8的块内，第一个系数（也称为<mark>直流系数</mark>）<strong>表示</strong>该块的<mark>平均亮度值</mark>，<u>因此它的取值通常比其他系数都要大。</u></li>
</ol>
</li>
<li class="lvl-5">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420200819559.png" alt="image-20230420200819559" style="zoom: 33%;" />
</li>
</ul>
</li>
</ol>
<p><span style="color: red;">JPEG算法的具体处理步骤：</span></p>
<ol>
<li class="lvl-3">
<p>正向离散余弦变换</p>
</li>
<li class="lvl-3">
<p>量化</p>
<ul class="lvl-2">
<li class="lvl-5">量化是对经过FDCT变换后的频域系数进行一种有控制地丢失信息的处理过程。</li>
<li class="lvl-5">人眼对低频分量比对高频分量要敏感的多。</li>
<li class="lvl-5">借助优化设计的量化表，量化处理使得大量DCT高频系数被转换成了0，因此后续处理中就非常容易通过行程编码算法实现数据压缩。</li>
</ul>
</li>
<li class="lvl-3">
<p>Z字型编排</p>
<ul class="lvl-2">
<li class="lvl-5">充分利用DCT频域系数的对称性，使一行数据中相同的系数尽可能连在一起，从而为实施行程压缩创造最有利的条件。</li>
</ul>
</li>
<li class="lvl-3">
<p>直流系数的编码</p>
<ul class="lvl-2">
<li class="lvl-5">使用差分脉冲调制编码（DPCM）技术进行编码</li>
</ul>
</li>
<li class="lvl-3">
<p>使用RLE算法对交流系数进行压缩编码</p>
</li>
<li class="lvl-3">
<p>熵编码</p>
<ul class="lvl-2">
<li class="lvl-5">采用熵编码对数据进行再次压缩
<ul class="lvl-4">
<li class="lvl-7">JPEG2000以前，霍夫曼编码器</li>
<li class="lvl-7">JPEG2000，算术编码替代霍夫曼编码器</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>组成位数据流</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>把各种标记代码和编码后的图像数据组成一帧一帧的数据，这样做的目的是为了便于<mark>传输、存储和译码器进行译码</mark></strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>JPEG整个压缩过程基本上遵循以下步骤：</p>
<ul class="lvl-1">
<li class="lvl-2">把数据分为“重要部分”和“不重要部分”</li>
<li class="lvl-2">滤掉不重要的部分</li>
<li class="lvl-2">保存</li>
</ul>
</blockquote>
<p>对原始图像信息进行JPEG编码的过程就分为两大步：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一步，去除视觉上的多余信息，即空间冗余度；</p>
</li>
<li class="lvl-2">
<p>第二步，去除数据本身的多余信息，即结构冗余度。</p>
</li>
</ul>
<p><u><em><strong>JPEG标准包括两种基本压缩算法，一种是以<mark>离散余弦变换</mark>（Discrete Cosine Transform，DCT）为基础的有损压缩方法，另一种是以<mark>预测技术</mark>为基础的无损压缩方法。</strong></em></u></p>
<hr>
<p>⭐️<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>导致图像信息损失的操作步骤是：量化</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{导致图像信息损失的操作步骤是：量化}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">导致图像信息损失的操作步骤是：量化</span></span></span></span></p>
<p>量化就是来处理<u><strong>人眼视觉系统</strong></u>所<u><strong>不敏感的高频数据</strong></u>，从而极大地减少了需要处理的数据量。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>量化是对经过FDCT(正向离散余弦变换)变换后的频域系数进行一种<u><strong>有控制地丢失信息</strong></u>的处理过程。</p>
</li>
<li class="lvl-2">
<p><strong>量化表主要作用是损失掉一部分图像的高频部分，而保留低频部分。相当于一个低通滤波器。</strong></p>
</li>
</ul>
<blockquote>
<p><u><strong>JPEG压缩出现损失出现在量化过程。</strong></u></p>
<p>损失的是人不敏感的高频数据。</p>
</blockquote>
<h3 id="8-为什么jpeg技术在执行行程压缩的时候要采取z字形编排方式？">8、为什么JPEG技术在执行行程压缩的时候要采取Z字形编排方式？</h3>
<blockquote>
<p><u><em><strong>量化后的DCT系数要重新编排，也就是采取Z字形编排方式。</strong></em></u>（量化后才进行Z字形编排）</p>
</blockquote>
<p>目的是为了增加连续的“0”系数的个数，也就是“0”的行（游）程长度，因为这将显著<mark>提高</mark>运用<mark>行程压缩（RLE）算法</mark>的<strong>有效性</strong>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420013206336.png" alt="image-20230420013206336" style="zoom:33%;" />
<h3 id="9-理解和掌握位图数据在内存的排列">9、理解和掌握位图数据在内存的排列。</h3>
<p>位图数据(bitmap data)：就是图像数据，如图所示全部为图像数据，图像的像素点存储顺序是<mark>从左到右，从下倒上进行存储的</mark>，所以左下角的像素为第一个存储，右上角的像素为最后一个存储。<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330100736012.png" alt="image-20230330100736012"></p>
<blockquote>
<p>图像在内存中是倒立存储。（<u><strong>小端序存储</strong></u>）</p>
</blockquote>
<p><strong>位图数据的存储方式</strong>：</p>
<ol>
<li class="lvl-3">
<p>Top-down存储模式</p>
</li>
<li class="lvl-3">
<p>Bottom-up存储模式</p>
</li>
</ol>
<h3 id="10-水波纹模拟程序程序的主要步骤-函数">10、水波纹模拟程序程序的主要步骤、函数。</h3>
<p><strong>水波纹模拟程序的实现</strong>：</p>
<p>​	1）定义若干常量和全局变量</p>
<p>​	2）振动状态的初始化与位图加载</p>
<p>​	3）设置定时器</p>
<p>​	4）振动能量传递与衰减函数</p>
<p>​	5）图像渲染函数</p>
<p>​	6）投石入水函数</p>
<p>​	7）在主窗口过程中应用上述函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_WIDTH 640 <span class="comment">// 添加代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_HIGHT 480 <span class="comment">// 添加代码</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">COLOR</span> <span class="comment">// 添加代码</span></span><br><span class="line">&#123; <span class="comment">// 添加代码</span></span><br><span class="line">BYTE b; <span class="comment">// 添加代码</span></span><br><span class="line">BYTE g; <span class="comment">// 添加代码</span></span><br><span class="line">BYTE r; <span class="comment">// 添加代码</span></span><br><span class="line">&#125;RGBCOLOR; <span class="comment">// 添加代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> buffer_1[IMAGE_HIGHT][IMAGE_WIDTH], buffer_2[IMAGE_HIGHT][IMAGE_WIDTH];<span class="comment">//添加代码，用于计算波能</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tmp[IMAGE_HIGHT][IMAGE_WIDTH]; <span class="comment">// 添加代码，用于交换波能矩阵</span></span><br><span class="line"><span class="type">static</span> COLOR det_image[IMAGE_HIGHT][IMAGE_WIDTH];<span class="comment">// 添加代码，要显示的目标图像</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> imagebuf[IMAGE_WIDTH * IMAGE_HIGHT * <span class="number">3</span> + <span class="number">100</span>]; <span class="comment">//添加代码，内存，用于储源图像文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 振动状态的初始化与位图加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器</span></span><br><span class="line"><span class="built_in">SetTimer</span> (hWnd, ID_TIMER, <span class="number">33</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主窗口过程中添加应用代码:</span></span><br><span class="line"><span class="built_in">disturb</span>();<span class="comment">//投石入水</span></span><br><span class="line"><span class="built_in">NextFrameWaveEnerge</span>(); <span class="comment">//计算波能传递与衰减</span></span><br><span class="line"><span class="built_in">RenderRipple</span>();<span class="comment">//渲染目标图像</span></span><br><span class="line"><span class="built_in">SetDIBitsToDevice</span> ()<span class="comment">//显示目标图像</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>详细代码参考：多媒体实验笔记</mtext><mn>2.</mn><mi>m</mi><mi>d</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{详细代码参考：多媒体实验笔记2.md}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">详细代码参考：多媒体实验笔记</span><span class="mord" style="color:red;">2.</span><span class="mord mathnormal" style="color:red;">m</span><span class="mord mathnormal" style="color:red;">d</span></span></span></span></p>
</blockquote>
<h2 id="视频基础">视频基础</h2>
<h3 id="1-扫描-消隐？彩色电视制式有哪些？">1、扫描、消隐？彩色电视制式有哪些？</h3>
<p><mark>扫描：通过信号控制显示屏以得到电视图像的过程</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>逐行扫描</p>
<ul class="lvl-2">
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406101859627.png" alt="image-20230406101859627" style="zoom:33%;" />
</li>
</ul>
</li>
<li class="lvl-2">
<p>隔行扫描</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>隔行扫描的总行数是奇数。</strong>（因为最前面和最后面存在仅扫描了半行的情况）</li>
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406101803107.png" alt="image-20230406101803107" style="zoom: 33%;" />
</li>
</ul>
</li>
</ul>
<blockquote>
<p><u><em><strong>计算机使用逐行扫描；电视机使用隔行扫描。</strong></em></u></p>
</blockquote>
<hr>
<p><mark>消隐：准确地判断哪些部分应该被<u><strong>遮挡或隐藏起来</strong></u>，以保证最终呈现出来的图像<u><strong>真实而逼真</strong></u></mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>水平消隐：行与行之间的<u><strong>返回过程</strong></u>称为水平消隐。</p>
</li>
<li class="lvl-2">
<p>垂直消隐（场消隐）：扫描点<u><strong>扫描完一帧后</strong></u>，要从图像的右下角返回到图像的左上角，开始新一帧的扫描，这一<u><strong>时间间隔</strong></u>，叫做垂直消隐，也称场消隐</p>
<ul class="lvl-2">
<li class="lvl-4">一幅完整的图像扫描信号，由水平消隐间隔分开的行信号序列构成，称为一帧。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>彩色电视制式</strong>：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420121002577.png" alt="image-20230420121002577"></p>
<h3 id="2-试比较复合电视信号-分量电视信号和s-video信号的优缺点">2、试比较复合电视信号、分量电视信号和S-Video信号的优缺点。</h3>
<p><span style="color: red;">复合电视信号：</span></p>
<p><u>复合电视信号</u>是指在一路电流（或电压）中融合了<u>亮度和色差信息（图像信号）</u>，并与<u>同步信息</u>、<u>消隐</u>脉冲一起组成的<mark>单一信号</mark>。又被称为<u>全电视信号</u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406103404914.png" alt="image-20230406103404914" style="zoom: 50%;" />
<blockquote>
<p>这个64μs又分为四个阶段：</p>
<ul class="lvl-1">
<li class="lvl-2">第一段是行同步时间，为4.7μs；</li>
<li class="lvl-2">第二段是行消隐的后肩部分，为5.8μs；</li>
<li class="lvl-2">第三段是主体，即图像信号部分（亮度值），占52.2μs；</li>
<li class="lvl-2">第四段是消隐信号的前肩部分，为1.3μs。</li>
</ul>
<p>这样四段就构成一个行周期（64μs）。</p>
</blockquote>
<blockquote>
<p>同步信息：保持各种频率（行频、场频、帧频）的同步性。</p>
</blockquote>
<p><strong>优点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>传输方便，只需要一根信号传输线；</p>
</li>
<li class="lvl-2">
<p>普及度高，设备支持度高；</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>画质相对较差；</p>
</li>
<li class="lvl-2">
<p>稳定性差，容易受到电磁干扰；</p>
</li>
</ul>
<hr>
<p><span style="color: red;">分量电视信号：</span></p>
<p>分量电视信号<u><strong>由三个独立的基色分量构成</strong></u>，这三个独立基色可以是R、G和B,也可以是Y、I、O,或者Y、U、V。RGB/YUV/YIQ的<u>每一个分量分别被编码成一个信号</u>。</p>
<p><strong>优点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信号质量最佳；</p>
</li>
<li class="lvl-2">
<p>稳定性好，受到干扰少；</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>传输代价比较高，需要三根线；</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>比较适合短距离传输，如电视演播室内部的传输</strong></li>
</ul>
</li>
<li class="lvl-2">
<p>设备支持度相对较低；</p>
</li>
</ul>
<p><span style="color: red;">S-Video信号：</span></p>
<blockquote>
<p>也称<u><strong>分离电视信号</strong></u></p>
</blockquote>
<p>S-Video信号是对分量电视信号与复合电视信号的折中，<mark>S-Video信号的亮度占用一个信号</mark>，但是，<mark>色差的两个分量(UV或IQ)共用另一个信号。</mark></p>
<p><strong>优点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u><strong>减少</strong></u>了亮度信号与色差信号的<u><strong>相互干扰</strong></u>，<u><strong>稳定性较高</strong></u>；</p>
</li>
<li class="lvl-2">
<p>画质比复合电视信号高；</p>
<ul class="lvl-2">
<li class="lvl-4">可补充内容：（<u><strong>不需要使用</strong></u>梳状滤波器来分离亮度与色差信号，这样可提高亮度信号的带宽）</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>需要两条独立的信号传输线路;</p>
<ul class="lvl-2">
<li class="lvl-4">一条用于亮度信号，一条用于色差信号，<u>这两个信号合在一起称为Y/C信号</u>。</li>
</ul>
</li>
<li class="lvl-2">
<p>比分量电视信号的画质差；</p>
</li>
</ul>
<hr>
<blockquote>
<p>——来源：GPT</p>
</blockquote>
<p>复合电视信号、分量电视信号和S-Video信号都是视频传输中常用的方法。它们各自有优缺点，以下是它们的详细比较：</p>
<ol>
<li class="lvl-3">
<p>复合电视信号</p>
</li>
</ol>
<p>复合视频信号将亮度、色度和音频信号混合在一起传输。该信号经过编码后压缩，然后通过同一个电缆进行传输。由于信号经过了压缩和混合处理，因此图像质量相对较差，色彩饱和度和清晰度都不高。</p>
<p>优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>传输简单，<mark>只需要一根线</mark></p>
</li>
<li class="lvl-2">
<p>普及程度高，很多设备都支持复合信号输入和输出</p>
</li>
</ul>
<p>缺点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>画质相对较差，颜色和清晰度受到影响</p>
</li>
<li class="lvl-2">
<p>信号容易受到电磁干扰</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>分量电视信号</p>
</li>
</ol>
<p>分量视频信号将图像分离成三种颜色（红、绿、蓝）各自为一路信号进行传输。这种信号可以提供更好的色彩和清晰度，因为每个颜色通道都有自己的信号线，可以减少交错和噪声。</p>
<p>优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>图像质量更好，色彩更饱和、清晰度更高</p>
</li>
<li class="lvl-2">
<p>稳定性更好，信号受到的干扰较少</p>
</li>
</ul>
<p>缺点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>传输线路数量增加，<mark>需要三根线</mark></p>
</li>
<li class="lvl-2">
<p>设备支持度相对较低</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>S-Video信号</p>
</li>
</ol>
<p>S-Video信号是分量视频信号的一种变体，将色度和亮度分离为两个独立的信号进行传输。这种信号比复合视频信号提供了更好的画质，但比分量视频信号不稳定。</p>
<p>优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>图像质量比复合视频信号更好</p>
</li>
<li class="lvl-2">
<p>信号稳定性较高</p>
</li>
</ul>
<p>缺点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>比分量视频信号差一些，颜色与清晰度略低</p>
</li>
<li class="lvl-2">
<p><mark>需要两根线</mark></p>
</li>
</ul>
<p>综上所述，分量视频信号在图像质量和稳定性方面都是最好的选择，但需要更多的传输线路。复合视频信号则是最常见的选择，但画质相对较差。S-Video信号则是一个介于两者之间的选择。</p>
<h3 id="3-为什么视频信号常常采用yuv彩色模型？">3、为什么视频信号常常采用YUV彩色模型？</h3>
<p>视频信号常常采用YUV彩色模型是因为这种模型可以<mark>更好地适应</mark><u>人眼对颜色的感知方式</u>。（<strong>人类视觉系统对色差的敏感度低于对亮度的敏感度</strong>）</p>
<blockquote>
<p>在RGB彩色模型中，每个像素包含了红、绿、蓝三种色光的亮度和强度信息。但是，人类视网膜处理颜色的方式与RGB模型不同，它主要感知亮度和色度两个方面的信息。因此采用RGB模型表达视频信号可能会浪费大量的数据传输带宽。</p>
<p>相比之下，YUV彩色模型将每个像素的颜色信息分成了亮度（Y）和色度（U、V）两个部分，其中亮度指明像素的灰度水平，而色度则提供了关于色调和饱和度的信息。因此，使用YUV彩色模型可以减少传输带宽，同时也能够更好地适应人类视觉系统对颜色的感知方式。</p>
<p>除此之外，在视频压缩和编码过程中，YUV模型通常也被用作中间格式，因为它具有易于处理和压缩的优点。</p>
<p>——来源：GPT</p>
</blockquote>
<h3 id="4-模拟视频信号转换成数字视频的基本过程">4、模拟视频信号转换成数字视频的基本过程。</h3>
<p>三个主要步骤：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>采样</p>
</li>
<li class="lvl-2">
<p>量化</p>
</li>
<li class="lvl-2">
<p>编码</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420123034389.png" alt="image-20230420123034389"></p>
<blockquote>
<p>例如：将输入的<u><strong>模拟全电视信号</strong></u>分离为Y、U、V三个独立模拟信号，然后采用模数转换器分别对它们进行采样和量化。最后进行编码。</p>
</blockquote>
<h3 id="5-什么是数字视频的采样格式？4-4-4-4-2-2-4-2-0">5、什么是数字视频的采样格式？4:4:4/4:2:2/4:2:0。</h3>
<p><mark>采样格式</mark>是指对<u><strong>全电视信号</strong></u>进行<u><strong>数字化时</strong></u>，<u><strong>亮度通道</strong></u>与<u><strong>色差通道</strong></u>的<u>样本数量</u>的比例关系。</p>
<p><span style="color: red;">4:4:4</span></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420123839926.png" alt="image-20230420123839926"></p>
<p><span style="color: blue;">4:2:2</span></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420123851995.png" alt="image-20230420123851995"></p>
<p><span style="color: blue;">4:2:0</span></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420124001769.png" alt="image-20230420124001769"></p>
<h3 id="6-yuv数据流分为哪两类？都是用于什么场合？">6、YUV数据流分为哪两类？都是用于什么场合？</h3>
<p>YUV数据流可以分为两大类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>紧凑格式：<strong>主要适合<mark>实时应用场合</mark></strong></p>
</li>
<li class="lvl-2">
<p>平面格式：<strong>主要用于<mark>文件存储</mark></strong></p>
</li>
</ul>
<h2 id="视频程序设计">视频程序设计</h2>
<h3 id="1-视频压缩编码与静态图像压缩编码有何不同？视频压缩编码的基本原理是什么？">1、视频压缩编码与静态图像压缩编码有何不同？<mark>视频压缩编码的基本原理是什么？</mark></h3>
<p>视频压缩编码：利用相邻帧之间的相似性（相关性）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间冗余：<u>视频序列的相邻图像之间</u>存在很大的相关性，也就是相似性，由于这种相关性是在时间上<u><strong>前后帧之间</strong></u>发生的，所以被称为<mark>时间冗余</mark>（Temporal Redundancy）。</p>
</li>
</ul>
<p>静态图像压缩编码（JPEG）：没有利用相邻帧之间的相似性</p>
<blockquote>
<p>视频压缩编码和静态图像压缩编码有几个关键差异：</p>
<ol>
<li class="lvl-3">数据量：<u><em>视频包含多个帧</em></u>（每秒中通常有24到60帧），<u><em>而图像只有一个</em></u>。因此，视频压缩需要处理大量的数据，并尝试找出可重复使用的数据。</li>
<li class="lvl-3">时间相干性：在视频中，相邻帧之间通常存在时间上的相关性。这意味着，在编码时可以利用前一帧中提取的信息来编码下一帧，从而实现更高的压缩率。这种技术称为运动估计/补偿。</li>
<li class="lvl-3">压缩算法：视频压缩需要使用专门的算法来处理和压缩多个帧。经典的视频压缩算法包括基于H.264和HEVC的压缩标准。</li>
<li class="lvl-3">播放方式：<u><em>视频是以连续的方式播放的，而图像则是以瞬间的方式呈现的</em></u>。因此，在解码视频时，需要以与编码器相同的顺序恢复每个瞬间，从而获得完整的视频帧。</li>
</ol>
<p>——来源：GPT</p>
</blockquote>
<p>回答：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>时间相关性：视频压缩编码利用了相邻帧之间的相关性，而图像压缩编码没有用到相邻帧之间的相关性；</p>
</li>
<li class="lvl-3">
<p>数据量：视频包含多个帧，而图像只有一个。因此视频压缩编码需要处理大量的数据。</p>
</li>
<li class="lvl-3">
<p>播放方式：视频是以<u><strong>连续的方式</strong></u>播放的，而图像则是以<u><strong>瞬间的方式</strong></u>呈现的。</p>
</li>
</ol>
</blockquote>
<hr>
<p><span style="color: red;">视频压缩编码的基本原理</span>：</p>
<p>对于相关的视频图像，发送端不一定必须把每帧图像上所有的像素都传给接收端，而<strong>只要将</strong>图像内容（或摄像机）的<mark>运动信息</mark>告知接收端，接收端就可以<mark>根据运动信息</mark>和<mark>前一帧图像</mark>的内容来<mark>更新当前帧图像</mark>，这就比全部传送每帧图像的具体细节所需的<u><strong>数据量要小得多</strong></u>。</p>
<h3 id="2-什么是i帧-p帧和b帧？分别对它们采用什么方法进行压缩编码？">2、什么是I帧、P帧和B帧？分别对它们采用什么方法进行压缩编码？</h3>
<ol>
<li class="lvl-3">
<p>第一种是<u><em><strong>帧内编码图像</strong></em></u>，又称I帧（Intra pictures），<u>帧内编码算法就是<mark>JPEG</mark></u>；——采用JPEG编码</p>
</li>
<li class="lvl-3">
<p>第二种图像被称为P帧（Predicted pictures），<u>P帧就是指对其施加<mark>预测编码</mark>的图像</u>，这里的预测编码是通过首先为待编码图像（也就是P帧)确定一个<mark>预测图像</mark>（又称<mark>参考图像</mark>）例如I帧，再<u><strong>计算编码图像与预测图像之间的差值</strong></u>，并进一步压缩差值的一种编码方法。显然，这里的预测编码与我们熟悉的差分PCM技术类似。——采用DPCM编码</p>
</li>
<li class="lvl-3">
<p>第三种图像被称为B帧(Bidirectional prediction)，其中B取自英文Bidirectional一词的首字母，意思是“双向的技术上，<u>B帧就是指对其施加<mark>双向预测编码</mark>的图像</u>。双向预测编码是通过为待编码图像（也就是B帧)确定两个预测图像（这就是双向之意的来源例如相邻的I帧和P帧，再<u><strong>计算编码图像与这两个预测图像之间的差值</strong></u>，进而计算<u><strong>两个差值的平均值</strong></u>，最后<u><strong>压缩平均差值</strong></u>的一种编码方法。——采用双向预测编码</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420140918311.png" alt="image-20230420140918311" style="zoom:50%;" />
<p><span style="color: blue;">预测编码的基本过程: </span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>计算编码图像与预测图像之间的差值并不是直接对两幅图像进行相减运算，而是将<mark>待编码图像</mark><u><strong>分割成若干块</strong></u>，然后<u><strong>以块为单位</strong></u>逐块进行相减运算完成的。</p>
</li>
<li class="lvl-2">
<p>通常图像被分割成大小为<u><strong>16x16像素</strong></u>的块，我们称这种图像分块为<u><strong>宏块</strong></u>（即包含了四个8x8块的更大的块）。</p>
</li>
</ul>
<p><span style="color: red;">预测编码处理流程：</span></p>
<ol>
<li class="lvl-3">
<p>在参考图像中<u><strong>搜索</strong></u>出与编码图像宏块<u><strong>最相似的宏块</strong></u>（又称<u><strong>最佳匹配宏块</strong></u>）；</p>
</li>
<li class="lvl-3">
<p>计算两者的<u><strong>差分值</strong></u>（又称残差）；</p>
</li>
<li class="lvl-3">
<p>对差分值进行正交余弦变换（即DCT运算）；</p>
</li>
<li class="lvl-3">
<p>对结果进行行程压缩；</p>
</li>
<li class="lvl-3">
<p>最后进行Huffman编码，即输出压缩的块数据（这些压缩数据块还需要按照规定格式进行文件或比特流层面上的编排）。</p>
</li>
</ol>
<p><u><em>整个视频压缩算法中，差分运算实际上借用了DPCM的思想，而后续处理则借用了JPEG的相关技术。</em></u></p>
<h3 id="3-什么是运动估计？">3、什么是运动估计？</h3>
<p>在<mark>参考图像</mark>中<u><em><strong>搜索出最佳匹配宏块</strong></em></u>的计算过程称为<mark>运动估计</mark>（Motion Esitmation,ME)。</p>
<blockquote>
<p>运动估计算法有很多种，大体上可以把它们分成四类：<mark>块匹配法、递归估计法、贝叶斯估计法和光流法。</mark></p>
</blockquote>
<p>参考图像中最佳匹配宏块<u>相对于</u>编码图像宏块<u>基准位置</u>的<u><strong>偏移量</strong></u>（水平方向的为Δx，垂直方向上为Δy）称为<mark>运动向量</mark>（Motion Vector，MV）。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230423204449770.png" alt="image-20230423204449770" style="zoom:67%;" />
<h3 id="4-什么是运动补偿？">4、什么是运动补偿？</h3>
<p><mark>根据运动向量</mark><u><em><strong>将差分值补充到参考图像匹配宏块中</strong></em></u>去的过程称为<mark>运动补偿</mark>(Motion Compensation,MC)。</p>
<h3 id="5-有哪些运动搜索算法？-了解">5、有哪些运动搜索算法？（了解）</h3>
<blockquote>
<p>匹配准则：即绝对差和（SAD）、均方误差（MSE）和平均绝对差（MAD）。</p>
</blockquote>
<p>1）全搜索法：(Full Search Method，FS）：也称为穷尽搜索法</p>
<blockquote>
<p>是对搜索范围内所有可能的候选位置计算SAD值，从中找出最小的SAD，其对应偏移量即为所求运动向量。</p>
<p>该算法虽计算量大，但最简单最可靠，找到的匹配块必为全局最优值。</p>
<p><strong>SAD：绝对差和</strong></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420141410633.png" alt="image-20230420141410633" style="zoom: 50%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>P</mi><mi>S</mi><mtext>：详细流程参考第</mtext><mn>9</mn><mtext>章</mtext><mi>P</mi><mi>P</mi><mi>T</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{PS：详细流程参考第9章PPT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">PS</span><span class="mord cjk_fallback" style="color:red;">：详细流程参考第</span><span class="mord" style="color:red;">9</span><span class="mord cjk_fallback" style="color:red;">章</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">PPT</span></span></span></span></p>
<p>2）二维对数法（Two-Dimensional Logarithmic, TDL）：</p>
<blockquote>
<p>二维对数搜索法从原点开始，以“十”字形分布的五个点构成一次搜索的点群。每次搜索需要选取一定的步长，在以十字形分布的五个点处跟踪计算MSE值。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420141458621.png" alt="image-20230420141458621" style="zoom:50%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>P</mi><mi>S</mi><mtext>：详细流程参考第</mtext><mn>9</mn><mtext>章</mtext><mi>P</mi><mi>P</mi><mi>T</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{PS：详细流程参考第9章PPT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">PS</span><span class="mord cjk_fallback" style="color:red;">：详细流程参考第</span><span class="mord" style="color:red;">9</span><span class="mord cjk_fallback" style="color:red;">章</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">PPT</span></span></span></span></p>
<p>3）三步搜索法（Three Step Search, TSS）：</p>
<blockquote>
<p>采用一种由粗到细的搜索模式，从原点开始，按一定步长取周围8个点构成每次搜索的点群，然后进行匹配计算，跟踪最佳匹配块位置。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420141603154.png" alt="image-20230420141603154" style="zoom:50%;" />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>P</mi><mi>S</mi><mtext>：详细流程参考第</mtext><mn>9</mn><mtext>章</mtext><mi>P</mi><mi>P</mi><mi>T</mi></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{PS：详细流程参考第9章PPT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">PS</span><span class="mord cjk_fallback" style="color:red;">：详细流程参考第</span><span class="mord" style="color:red;">9</span><span class="mord cjk_fallback" style="color:red;">章</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">PPT</span></span></span></span></p>
<h3 id="6-运动搜索算法涉及的三个方面">6、运动搜索算法涉及的三个方面。</h3>
<p><strong>运动搜索算法涉及三方面问题：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一是<mark>搜索起始点的选择</mark>，即从参考图像的什么位置开始搜索，<u><strong>起点选择</strong></u>的不同对整个<u><strong>搜索效果</strong></u>存在影响；</p>
</li>
<li class="lvl-2">
<p>第二是<mark>匹配准则</mark>，即如何判定两个图像块的近似度；</p>
</li>
<li class="lvl-2">
<p>第三就是<mark>搜索过程</mark>。</p>
</li>
</ul>
<h3 id="7-通常情况下-h-26x-标准侧重于视频和音频信息的-span-style-color-blue-数据压缩效率-span-以适合调整该系统在特定的位速率下传输-实时视频通讯的应用；mpeg-系列则倾向于控制质量而不是控制位速率-视频数据的存储应用">7、通常情况下，H.26x 标准侧重于视频和音频信息的<span style="color: blue;">数据压缩效率</span>，以适合调整该系统在特定的位速率下传输，<mark>实时视频通讯的应用</mark>；MPEG 系列则倾向于控制质量而不是控制位速率，<mark>视频数据的存储应用</mark>。</h3>
<p>由ITU组织制定的标准主要是针对<mark>实时视频通讯的应用</mark>，如视频会议和可视电话等，它们以H.26x命名，<u><em><strong>如H.261、H.262、H.263和H.264等</strong></em></u>。</p>
<p>MPEG组织（Moving Picture Expert Group）制定的标准主要针对<mark>视频数据的存储应用</mark>，也应用于视频传输，如VCD、DVD、广播电视和流媒体等，它们以MEPG-x命名，如<u><em><strong>MEPG-1、MEPG-2和MEPG-4</strong></em></u>等。</p>
<blockquote>
<p>MEPG-1、MEPG-2：针对DVD、数字电视和高清电视等。</p>
<p>MEPG-4：针对<u><strong>流式媒体服务</strong></u>等领域。</p>
<p><mark>MPEG-7</mark>是<mark>多媒体内容描述标准</mark>，支持对<strong>多媒体资源</strong>的<u>组织管理</u>、<u>搜索</u>、<u>过滤</u>、<u>检索</u>。——（试卷上有）</p>
</blockquote>
<h3 id="8-什么是视频运动对象检测？什么是视频运动对象跟踪？两者有何区别与联系？">8、什么是视频运动对象检测？什么是视频运动对象跟踪？两者有何区别与联系？</h3>
<p><span style="color: red;">对象检测（object detecting）：</span>是指在视频图像中将<u><strong>对象</strong></u>与<u><strong>背景</strong></u>分离开来，并提取<u><strong>对象所包含的全部像素</strong></u>。检测算法的主要设计目标是<u>准确性</u>、<u>实时性</u>和<u>鲁棒性</u>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>准确性：即尽可能把属于对象的像素与背景分离开来。</p>
</li>
<li class="lvl-2">
<p>实时性：要求检测算法尽可能快。</p>
</li>
<li class="lvl-2">
<p>鲁棒性：要求检测算法能够<u><strong>适应</strong></u>视频图像的<u><strong>变化</strong></u>，在出现光照、遮挡等变化时，算法仍然能够保持稳定的检测率和准确性。</p>
</li>
</ul>
<p><span style="color: red;">对象跟踪（object tracking）：</span>是指在一段时间内，系统<u><strong>持续、实时地</strong></u><mark>标记</mark>运动对象，在帧与帧之间建立运动对象的特征（如速度、位置、形状、方向等）的联系，并计算出运动对象的<u><strong>运动轨迹</strong></u>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>跟踪算法的主要需求是<mark>连续性和稳定性</mark></p>
</li>
</ul>
<p><strong>区别与联系</strong></p>
<p><strong>对象检测与跟踪是两个紧密相关的过程，检测是跟踪的<mark>前提</mark>，没有检测就不可能实现跟踪。跟踪是检测的<mark>结果</mark>，持续的跟踪需要通过持续的检测来实现。</strong></p>
<h2 id="网络多媒体基础">网络多媒体基础</h2>
<h3 id="1-组播-ip组播">1、组播、IP组播。</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>组播：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{组播：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">组播：</span></span></span></span></p>
<p><mark>组播是指将<u><em><strong>源端的数据</strong></em></u>传送给<u><em><strong>一组特定接收者</strong></em></u>的传输方式</mark>。这个特定的<u><strong>一组接收者</strong></u>称为<u><strong>群组（group）</strong></u>。组播可以在网络的各个层次上实现，但主要在物理层、<mark>网络层</mark>、应用层上实现。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>I</mi><mi>P</mi><mtext>组播：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{IP组播：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">P</span><span class="mord cjk_fallback" style="color:red;">组播：</span></span></span></span></p>
<p><mark>IP组播</mark>是网络组播的一种具体实现，它通过IP路由器构造互联网中的<u><strong>组播分发树</strong></u>，并使用<u>IP组地址</u>标识<u><strong>群组</strong></u>，通过IGMP（Internet Group Management Protocol）协议管理**<u>群组关系</u>**，并包含若干<u><strong>IP组播路由协议</strong></u>。</p>
<p><strong>IP组播涵盖三个方面的内容</strong>：</p>
<ol>
<li class="lvl-3">
<p>用户模型，即IP组播作为一种网络服务所呈现给用户的描述；</p>
</li>
<li class="lvl-3">
<p>群组关系管理协议；</p>
</li>
<li class="lvl-3">
<p>组播路由协议；</p>
</li>
</ol>
<blockquote>
<p><strong>IP组播的用户模型包括7个要点</strong>——<mark>详见PPT第11章</mark></p>
</blockquote>
<p><span style="color: green;">用户模型包含以下7个要点：</span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一，使用IP组地址标识群组；</p>
</li>
<li class="lvl-2">
<p>第二，发送者（源主机）不需要知道接收主机；</p>
</li>
<li class="lvl-2">
<p>第三，群组成员主机可以位于互联网的任何地方；</p>
</li>
<li class="lvl-2">
<p>第四，一个群组所包含的成员主机数量是任意的，即<u><strong>群组规模（group size）是任意的</strong></u>；</p>
</li>
<li class="lvl-2">
<p>第五，成员主机可以在任何时候加入或退出群组。该特性使得IP组播成为一个十分动态化的过程，路由器必须有能力适应群组的变化。IGMP协议扮演了关键角色。</p>
</li>
<li class="lvl-2">
<p>第六，任何子网不能出现同一个数据的两个副本。</p>
</li>
<li class="lvl-2">
<p>最后，路由器通过建立<u><strong>组播分发树</strong></u>实现<u><strong>组播传输</strong></u>。</p>
</li>
</ul>
<h3 id="2-流媒体应用系统由哪些部分组成？各个部分的作用是什么？">2、<mark>流媒体应用系统由哪些部分组成？各个部分的作用是什么？</mark></h3>
<blockquote>
<p><mark>流媒体技术</mark>：就是把<u><strong>连续的多媒体数据</strong></u>经过压缩处理后放到<u><strong>网络媒体服务器</strong></u>上，<mark>允许用户一边下载一边播放</mark>，而不需要等待整个压缩文件下载到本地计算机上之后才可以观看的<u><strong>网络传输技术</strong></u>。（试卷上有）</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>流媒体应用系统</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{流媒体应用系统}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">流媒体应用系统</span></span></span></span></p>
<blockquote>
<p>它通常以<u><strong>互联网</strong></u>为平台，利用<u><strong>媒体服务器</strong></u>（Media Server）、 <u><strong>Web服务器</strong></u>（Web Server）、<u><strong>编码器</strong></u>（Encoder）、<u><strong>终端浏览器</strong></u>（Internet Browser）和<u><strong>媒体播放器</strong></u>（Media Player）来搭建。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>媒体服务器（Media Server）：</p>
<ul class="lvl-2">
<li class="lvl-4">一个媒体服务器可以将内容传送到另一个媒体服务器，由此构成<u><strong>大规模的内容分发网络</strong></u>（Content Distribution Network，CDN）</li>
</ul>
</li>
<li class="lvl-2">
<p>编码器（Encoder）：</p>
<ul class="lvl-2">
<li class="lvl-4">用于采集实时音视频数据，并允许用户配置和管理多媒体采集设备、媒体数据格式、传输端口等。</li>
</ul>
</li>
<li class="lvl-2">
<p>文件服务器：用于<u><strong>存储和管理</strong></u>流媒体文件。</p>
</li>
<li class="lvl-2">
<p>Web服务器（Web Server）：</p>
<ul class="lvl-2">
<li class="lvl-4"><u>发布含有媒体服务器URLs的 Web网页</u>，用户则可以首先<mark>访问Web页面</mark>，再打开<mark>媒体播放器</mark>并通过从页面获取的URLs连接到<mark>媒体服务器</mark>。</li>
</ul>
</li>
<li class="lvl-2">
<p>终端浏览器（Internet Browser）：</p>
</li>
<li class="lvl-2">
<p>媒体播放器（Media Player）：</p>
<ul class="lvl-2">
<li class="lvl-4">作为<mark>客户端</mark></li>
</ul>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230420143057729.png" alt="流媒体系统的结构"></p>
<h3 id="3-什么是视频点播？什么是视频广播？两者的区别在哪里？">3、什么是视频点播？什么是视频广播？两者的区别在哪里？</h3>
<p><strong>视频点播</strong></p>
<p>视频点播系统是指通过媒体服务器发布<mark>存储流媒体文件</mark>的应用系统，用户可以通过<u><strong>流媒体协议</strong></u>控制服务器的播放过程，实现开始、暂停、停止、快进、快退和任意位置播放等功能。</p>
<hr>
<p><strong>视频广播</strong></p>
<p>视频广播系统则是指通过媒体服务器发布<mark>实时流媒体数据</mark>的应用系统，用户只能通过流媒体协议连接服务器，接收并播放实时的数据流，不能进行暂停、快进、快退和任意位置播放等控制。容易理解为什么视频广播系统不允许用户控制播放过程，<u>因为实况是一个独立的连续播放过程，理应由源端完全控制</u>。</p>
<hr>
<p><strong>视频点播和视频广播的主要区别在于</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>视频点播：为用户提供随时观看已制作好的视频内容（发布<u>存储流媒体文件</u>）</p>
</li>
<li class="lvl-2">
<p>视频广播：实时传输视频内容，观众需要在指定时间观看（发布实时流媒体数据）</p>
</li>
</ul>
<h3 id="4-网络源实现的功能有：缓冲管理-代理服务器定位-自动重连接-带宽选择">4、网络源实现的功能有：<mark>缓冲管理、代理服务器定位、自动重连接、带宽选择</mark>。</h3>
<p>在Media Foundation平台上，网络源（Network source）是<u><strong>使用流媒体</strong></u>的基本实现手段。</p>
<h3 id="5-视频会议系统一般由哪些组件-设备-构成？">5、视频会议系统一般由哪些组件（设备）构成？</h3>
<p>视频会议系统通常由<u><mark>会议终端</mark>、<mark>会议控制器</mark>、<mark>多点控制单元（MCU）<mark>以及</mark>外部影音设备</mark></u>构成。</p>
<p><strong>会议终端</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>从<u><em>内部工作原理</em></u>看，系统主要包含<mark>视频编解码器</mark>、<mark>音频编解码器</mark>、<mark>数据通道</mark>等模块。⭐️</p>
</li>
<li class="lvl-2">
<p>从<u>外部设备来</u>看，视频会议终端需要摄像头、显示设备、麦克风、音响、传输网络接口等，这些设备有机地结合在计算机平台上。</p>
</li>
</ul>
<p><strong>会议控制器执行两个重要的控制功能</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一是<mark>地址翻译</mark>，将终端的别名翻译为IP地址；</p>
</li>
<li class="lvl-2">
<p>第二是<mark>带宽管理</mark>，它可以定义同时参加会议的<u>用户数</u>，以便进行<u>限制性管理</u>，一旦用户数到达限制值，会议控制器就可以拒绝任何超过该限值的连接请求。</p>
</li>
</ul>
<blockquote>
<p><u><mark>会议控制器</mark>又称为<mark>网守</mark>（Gatekeeper），是<mark>完成会议管理</mark>的设备。</u></p>
</blockquote>
<h3 id="6-mcu的主要作用是什么？">6、MCU的主要作用是什么？</h3>
<p>多点控制单元（Multipoint Controller Unit，MCU）是==用于协调和控制终端间<u><strong>音视频与信息传输</strong></u>==的设备。</p>
<blockquote>
<p>一个完整的MCU通常由两部分组成，分别是多点控制器（Multipoint Controller，MC）及多点处理器（Multipoint Processor，MP）。</p>
</blockquote>
<h3 id="新增-多媒体传输协议">(新增)多媒体传输协议</h3>
<p>由于<mark>RTP协议</mark>与<mark>RTCP协议</mark>主要是针对<u><strong>多媒体传输</strong></u>以及<u><strong>传输控制</strong></u>设计的，因此被称为<mark>多媒体传输协议</mark>。</p>
<p><span style="color: red;">RTP（Real-time Transport Protocol，实时传输协议）协议</span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>主要目标是<u><em>解决多媒体数据流的同步问题</em></u></p>
</li>
<li class="lvl-2">
<p>RTP协议不是一种独立应用的协议，它本身并不传输多媒体数据，实际上它还是依赖UDP协议来传输媒体数据（也可以使用TCP协议或者ATM协议），RTP的任务只是提供<u><strong>多媒体数据的同步</strong></u>和<u><strong>时间描述信息</strong></u>。</p>
</li>
<li class="lvl-2">
<p>RTP协议用于封装媒体数据，并提供时序信息</p>
</li>
</ul>
<p><span style="color: red;">RTCP（Real Time Control Protocol）协议</span></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RTCP协议配合RTP协议使用</p>
</li>
<li class="lvl-2">
<p>其主要任务是为通信双方的应用程序提供统计信息，这些信息包括实时数据包的数量、传输过程中丢失的数据包数量、往返延时、延时抖动等。</p>
</li>
</ul>
<h3 id="新增-典型流媒体协议">（新增）典型流媒体协议</h3>
<ol>
<li class="lvl-3">
<p><mark>RTSP协议</mark>是一种被用来建立和控制在客户端和服务器端之间的时间同步的多媒体流的协议。</p>
</li>
<li class="lvl-3">
<p><mark>MMS</mark>（Microsoft Media Server，微软媒体服务器）协议是微软公司开发的一种用来访问Windows Media Server上的流媒体文件的流媒体传输协议。</p>
</li>
<li class="lvl-3">
<p><mark>HTTP</mark>（Hyper Text Transfer Protocol）是超文本传输协议的缩写，该协议用于传送Web标准格式的数据。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章（数字音频编码）</title>
    <url>/2023/03/02/University/junior/course/multi-media-tech/%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>数字音频编码</h1>
<p>声卡的作用：将数字信号与模拟信号进行相互转换。</p>
<p>数模转换器（DAC）：将数字信号转换为模拟信号。</p>
<p>模数转换（ADC）：将模拟信号转换为数字信号。</p>
<p>Audio Codec（数/模转换器）：数字信号与模拟信号的转换。</p>
<p>软波表（可以刷新）与波表（不可刷新）</p>
<h5 id="声音的三要素：-u-音色-音强-音高-u">声音的三要素：<u>音色、音强、音高</u></h5>
<h4 id="模拟信号经过采样-时间离散-和量化-空间离散-得到离散化的数字信号">模拟信号经过采样（时间离散）和量化（空间离散）得到离散化的数字信号。</h4>
<h5 id="u-模拟音频数字化-u-的三个步骤：采样-量化-编码"><u>模拟音频数字化</u>的三个步骤：采样、量化、编码。</h5>
<h3 id="采样">采样</h3>
<blockquote>
<p>采样：是指以一定的频率（或周期）捕获模拟音频信号，从而得到一系列离散化音频样本的过程。</p>
<p>采样频率：单位时间内捕获的样本个数称为<u><strong>采样频率</strong></u>（Sampling Rate）</p>
<p><strong><u>采样定理</u></strong>：**<u>采样频率</u>**大于模拟信号频带F的两倍</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307140528727.png" alt="image-20230307140528727" style="zoom:50%;" />
<p><u><em><strong>人能听到的频率范围：20Hz～20000Hz（20Hz~2kHz）</strong></em></u></p>
<h3 id="量化">量化</h3>
<blockquote>
<p>量化：是指用若干比特表示一个样本的过程；</p>
<p>量化深度：表示一个样本所使用的<strong>比特数</strong>称为量化深度（bit depth）。</p>
</blockquote>
<p><u><strong>量化间隔</strong>（量化阶跃）：就是指将整个量化空间分割成若干离 散的有限状态后，相邻的两个离散状态值之间的差值。（幅值平均划分之后的每一份平均幅值就是量化间隔。）</u></p>
<h3 id="编码">编码</h3>
<blockquote>
<p>编码实际上是以某种格式最终生成数字音频数据流的过程</p>
</blockquote>
<p>音频编码：将<u>模拟信号转换为数字信号</u>并以某种格式存储的技术或过程。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302112947670.png" alt="实例"></p>
<blockquote>
<p>经过采样的时间离散之后波上有根据时间点均匀划分的值（点），再经过量化的空间离散之后将整个模拟信号根据振幅进行均匀划分（如量化深度为3，则将振幅划分为8份，也就是8个值），最后根据模拟信号上的点与量化划分线之间的远近进行近似拟合，因此可以近似为3、5、5、2、4、6、7等具体数值，然后转化为二进制形式即可（011、101、101、……）。</p>
</blockquote>
<h2 id="数字音频编码">数字音频编码</h2>
<ol>
<li class="lvl-3">
<p>参数编码（了解）</p>
</li>
<li class="lvl-3">
<p><u>波形编码（要考，重点）</u></p>
<ul class="lvl-2">
<li class="lvl-5">以下都是波形编码</li>
<li class="lvl-5">⭐️标记的部分必须掌握。</li>
</ul>
</li>
</ol>
<h3 id="1-脉冲编码调制-pcm">1、脉冲编码调制（PCM）⭐️</h3>
<p>在各种音频编码技术中，<mark>脉冲编码调制</mark>（Pulse Code Modulation，PCM）是<u>最重要、最完善</u>的编码系统，应用范围最广。</p>
<p><u><em><strong>针对<span style="color: red;">样本</span>进行编码</strong></em></u></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302113605304.png" alt="PCM编码框图"></p>
<p><span style="color: red;">脉冲编码调制（Pulse Code Modulation，PCM）</span>的两种量化方式：</p>
<ol>
<li class="lvl-3">
<p>均匀量化（线性量化）</p>
</li>
<li class="lvl-3">
<p>非均匀量化（非线性量化）</p>
<ul class="lvl-2">
<li class="lvl-5">13折线（不做要求）</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>均匀量化</th>
<th>非均匀量化</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302113938730.png" alt="均匀量化"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302113958688.png" alt="非均匀量化"></td>
</tr>
</tbody>
</table>
<p><mark>三种编码方式的本质和区别？</mark></p>
<h4 id="1-自适应脉冲编码调制-apcm">1）自适应脉冲编码调制（APCM）</h4>
<p>APCM是根据输入<strong>信号幅度大小</strong>来改变量化阶跃大小的一种波形编码技术。</p>
<blockquote></blockquote>
<h4 id="2-差分脉冲编码调制-dpcm">2）差分脉冲编码调制（DPCM）⭐️</h4>
<blockquote>
<p>思想：根据过去的样本幅值来估算下一个样本信号的幅度大小，这个值称为预测值，然后计算实际信号值与预测值之差，最后<u><strong>对这个差值进行量化编码</strong></u>。</p>
<p>对差值（具体值）进行编码，会有多位（bits）去表示差值，不是对极性进行编码。</p>
</blockquote>
<h4 id="3-自适应差分脉冲编码调制-adpcm">3）自适应差分脉冲编码调制（ADPCM）</h4>
<p>ADPCM是利用样本与样本之间的高度相关性和量化阶自适应来压缩数据的一种波形编码技术。</p>
<blockquote>
<p><u><strong>对实际样本值和预测值之间的差值进行编码</strong></u></p>
</blockquote>
<h5 id="码率计算公式：">码率计算公式：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307144339993.png" alt="image-20230307144339993"></p>
<h5 id="数据量公式：">数据量公式：</h5>
<p>数据量（字节/秒）=（采样频率（Hz）×采样位数（bit）×声道数）/8</p>
<h5 id="课堂练习：">课堂练习：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307144650999.png" alt="小练习"></p>
<blockquote>
<p>该文件的音频数据的字节数：（码率*播放时间）/8<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>结果：15876000字节</p>
<p>参考：<a href="https://zhidao.baidu.com/question/54537178.html">音频文件存储容量计算_百度知道 (baidu.com)</a></p>
</blockquote>
<h3 id="2-增量调制编码-dm">2、增量调制编码（DM）⭐️</h3>
<p><span style="color: blue;">增量调制编码（DM）</span>：通过增量起伏来记录模拟音频信号实际变化过程的数字音频编码。</p>
<p><u><em><strong>针对<span style="color: red;">极性</span>进行编码</strong></em></u></p>
<p>只需要1位来表示0或者1即可。（针对极性编码）</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307141721643.png" alt="image-20230307141721643" style="zoom: 50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p><span style="color: red;">红色</span>为预测值</p>
</li>
<li class="lvl-3">
<p><span style="color: blue;">蓝色</span>为实际值</p>
</li>
</ol>
<ul class="lvl-1">
<li class="lvl-2"><u><strong>实际值大于预测值，则为1；否则，为0。</strong></u></li>
</ul>
<ol>
<li class="lvl-3">
<p>斜率过载：即模拟信号的斜率太大，超过了量化阶跃允许的变化幅度（模拟的预测值的变化趋势要小于实际值）。</p>
<ul class="lvl-3">
<li class="lvl-5">解决：增大量化阶跃（间隔）</li>
</ul>
</li>
<li class="lvl-3">
<p>粒状噪声：当输入信号变化比较平缓时，增量调制器的编码输出为交错出现的0和1，即数字信号并不平缓，而是以量化阶跃Δ的大小起伏变化，这就相当于引入了噪声信号。</p>
<ul class="lvl-3">
<li class="lvl-5">解决：减小量化阶跃（间隔）</li>
</ul>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章（数字视频编码）</title>
    <url>/2023/04/11/University/junior/course/multi-media-tech/%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>数字视频编码</h1>
<blockquote>
<p>课程内容：</p>
<ol>
<li class="lvl-3">视频编码算法（<span style="color: red;">重点</span>）</li>
<li class="lvl-3">运动搜索算法（了解）</li>
<li class="lvl-3">视频编码标准（自学、了解）</li>
</ol>
</blockquote>
<h2 id="视频编码算法">视频编码算法</h2>
<h5 id="span-style-color-red-时间冗余-span-："><span style="color: red;">时间冗余</span>：</h5>
<p>视频序列的相邻图像之间存在很大的相关性，也就是相似性，由于这种相关性是在时间上前后帧之间发生的，所以被称为<mark>时间冗余</mark>（Temporal Redundancy）。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230411141808830.png" alt="image-20230411141808830" style="zoom: 33%;" />
<h3 id="span-style-color-red-视频压缩编码的基本原理-span-："><span style="color: red;">视频压缩编码的基本原理</span>：</h3>
<p>对于相关的视频图像，发送端不一定必须把每帧图像上所有的像素都传给接收端，而只要将图像内容（或摄像机）的<mark>运动信息</mark>告知接收端，接收端就可以<mark>根据运动信息</mark>和<mark>前一帧图像</mark>的内容来更新当前帧图像，这就比全部传送每帧图像的具体细节所需的数据量要小得多。</p>
<h4 id="编码器首先需要将视频图像分成三种类型：">编码器首先需要将视频图像分成三种类型：</h4>
<ol>
<li class="lvl-3">
<p>第一种是帧内编码图像，又称I帧（Intra pictures），帧内编码算法就是JPEG；</p>
</li>
<li class="lvl-3">
<p>第二种图像被称为P帧（Predicted pictures），P帧就是指对其施加预测编码的图像，这里的预测编码是通过首先为待编码图像（也就是P帧)确定一个预测图像（又称参考图像）例如帧，再计算编码图像与预测图像之间的差值，并进一步压缩差值的一种编码方法。显然，这里的预测编码与我们熟悉的差分PCM技术类似。</p>
</li>
<li class="lvl-3">
<p>第三种图像被称为B帧(Bidirectional prediction)，其中B取自英文Bidirectional一词的首字母，意思是“双向的技术上，B帧就是指对其施加<mark>双向预测编码</mark>的图像。双向预测编码是通过为待编码图像（也就是B帧)确定两个预测图像（这就是双向之意的来源例如相邻的I帧和P帧，再计算编码图像与这两个预测图像之间的差值，进而计算两个差值的平均值，最后压缩平均差值的一种编码方法。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230411142508346.png" alt="image-20230411142508346" style="zoom:33%;" />
<h5 id="宏块：">宏块：</h5>
<p>将图像分为大小为16x16像素的块。</p>
<h5 id="预测编码的基本过程：">预测编码的基本过程：</h5>
<p>计算编码图像与预测图像之间的差值并不是直接对两幅图像进行相减运算，而是将待编码图像分割成若干块，然后以块为单位逐块进行相减运算完成的通常图像被分割成大小为16x6像素的块，我们称这种图像分块为宏块（即包含了四个8x8块的更大的块）</p>
<h4 id="编码处理流程：">编码处理流程：</h4>
<ol>
<li class="lvl-3">
<p>在参考图像中搜索出与编码图像宏块最相似的宏块(又称最佳匹配宏块)；</p>
</li>
<li class="lvl-3">
<p>计算两者的差分值（又称残差）；</p>
</li>
<li class="lvl-3">
<p>对差分值进行正交余弦变换（即DCT运算）；</p>
</li>
<li class="lvl-3">
<p>对结果进行行程压缩；</p>
</li>
<li class="lvl-3">
<p>最后进行Huffman编码，即输出压缩的块数据（这些压缩数据块还需要按照规定格式进行文件或比特流层面上的编排)。</p>
</li>
</ol>
<p>整个视频压缩算法中，差分运算实际上借用了DPCM的思想，而后续处理则借用了PEG的相关技术。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230411143109840.png" alt="image-20230411143109840"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230411143122146.png" alt="image-20230411143122146"></td>
</tr>
</tbody>
</table>
<h3 id="预测计算处理">预测计算处理</h3>
<p>预测计算处理的关键是搜索出最佳匹配宏块。</p>
<p>在参考图像中搜索出最佳匹配宏块的计算过程称为运动估计（Motion Esitmation,ME)。</p>
<p>参考图像中最佳匹配宏块相对于编码图像宏块基准位置的偏移量（水平方向的为△x,垂直方向上为△y)称为运动向量(Motion Vector,MV)。</p>
<p>运动向量是非常重要的参数，必须发送给解码方，参与最后的压缩编码运算，一般是加入Huffman编码过程。</p>
<blockquote>
<p>运动估计：</p>
<p>搜索运动矢量需要很大的开销；运动矢量作用于定位参考块。</p>
</blockquote>
<h3 id="双向预测计算处理">双向预测计算处理</h3>
<p>双向预测计算与上述预测计算类似，区别在于一个编码图像有前后两个参考图像，分别在参考图像中搜索出两个最佳匹配宏块（注意，会得到两个运动向量），接着求这两个匹配宏块的平均值，然后用这个平均值与编码图像块进行差分运算，这之后是DCT变换、RLE编码和Huffman编码，与P帧的对应处理完全一样。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230411143657312.png" alt="image-20230411143657312" style="zoom: 50%;" />
<h3 id="解码过程：">解码过程：</h3>
<p>逐块进行，首先是Huffman解码并分离出运动向量，接着是行程解码和反向正交余弦变换，得到差分值（残差)，与此同时，利用分离得到的运动向量，在参考图像（必须先解码）中迅速定位出最佳匹配宏块，最后把残差补充上去（叠加），就解码出了一个宏块。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>双向预测解码测是在两个最佳匹配宏块的平均值上补充残差。</p>
</li>
<li class="lvl-2">
<p>根据运动向量将差分值补充到参考图像匹配宏块中去的过程称为运动补偿(Motion Compensation,MC)。</p>
</li>
</ul>
<p><span style="color: red;">运动估计和运动补偿是视频编解码算法的核心。</span></p>
<blockquote>
<p>由于这种基于块匹配的运动估计和补偿技术具有计算简单、效果好和便于大规模集成电路(VLS引)实现等优点，因而得到广泛应用，成为当前众多视频编码标准的基础，如MPEG-I、MPEG-2、MPEG-4、H.261、H.263和H.264等。另外运动估计在整个处理过程中的计算复杂度最大，占了整个计算量的50%以上。运动估计得越准确，补偿的残差就越小，编码的效率就越高，解码出来的图像质量越好。</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>软件体系结构——面向对象设计的原则</title>
    <url>/2023/05/11/University/junior/course/Software%20Architecture/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>面向对象设计的原则（10分）</h1>
<blockquote>
<p>“Clean Code”——《代码整合之道》</p>
</blockquote>
<h3 id="面向对象设计的七大原则">面向对象设计的七大原则</h3>
<ol>
<li class="lvl-3">
<p>单一职责原则</p>
</li>
<li class="lvl-3">
<p>开闭原则</p>
</li>
<li class="lvl-3">
<p>里氏代换原则</p>
</li>
<li class="lvl-3">
<p>依赖倒转原则</p>
</li>
<li class="lvl-3">
<p>接口隔离原则</p>
</li>
<li class="lvl-3">
<p>合成复用原则</p>
</li>
<li class="lvl-3">
<p>迪米特法则（最少知识原则）</p>
<ul class="lvl-2">
<li class="lvl-5">降低耦合度</li>
</ul>
</li>
</ol>
<h5 id="面向对象设计的原则意义：">面向对象设计的原则意义：</h5>
<ol>
<li class="lvl-3">
<p>提高可维护性：指软件能够被理解、改正、适应及扩展的难易程度</p>
</li>
<li class="lvl-3">
<p>提高可复用性：指软件能够被重复使用的难易程度</p>
</li>
</ol>
<h3 id="单一职责原则">单一职责原则</h3>
<p>单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109202250394.png" alt="image-20221109202250394" style="zoom:50%;" />
<blockquote>
<p>不同的职责封装到不同的类中</p>
<p>单一职责原则是实现高内聚、低耦合的指导方针</p>
</blockquote>
<h5 id="单一职责原则实例">单一职责原则实例</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109203444461.png" alt="image-20221109203444461" style="zoom:50%;" />
<p>使用单一职责原则重构：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109203533601.png" alt="image-20221109203533601" style="zoom:50%;" />
<h3 id="开闭原则">开闭原则</h3>
<p>开闭原则是面向对象的可复用设计的<u>第一块基石</u>，是<mark>最重要的面向对象设计原则</mark></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221109203752430.png" alt="image-20221109203752430" style="zoom:50%;" />
<blockquote>
<p>在开闭原则的定义中，软件实体可以是一个软件模块、一个由多个类组成的局部结构或一个独立的类</p>
<p>开闭原则是指软件实体应尽量在不修改原有代码的情况下进行扩展</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>抽象化</mark>是开闭原则的<code>关键</code></p>
</li>
<li class="lvl-2">
<p>相对<mark>稳定的抽象层</mark>+ <mark>灵活的具体层</mark></p>
</li>
<li class="lvl-2">
<p>对<mark>可变性封装原则</mark>(Principle of Encapsulation of Variation, EVP)：找到系统的可变因素并将其封装起来</p>
</li>
</ul>
<h3 id="里氏代换原则">里氏代换原则</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114191822905.png" alt="image-20221114191822905" style="zoom:50%;" />
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114191931634.png" alt="image-20221114191931634" style="zoom:50%;" />
<blockquote>
<p>如果用基类替换子类对象则会抛出：ClassCastException(类型转换错误)</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象</p>
</li>
<li class="lvl-2">
<p>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型</p>
</li>
</ul>
<h3 id="依赖倒转原则">依赖倒转原则</h3>
<p>高层和低层都应该依赖抽象（接口、父类）进行编程</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114192505018.png" alt="image-20221114192505018" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>要针对接口（interface）编程，不要针对实现编程</p>
</li>
<li class="lvl-2">
<p>Program to an interface, not an implementation.</p>
</li>
<li class="lvl-2">
<p>在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即<u>使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换</u>等</p>
</li>
<li class="lvl-2">
<p>在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中</p>
</li>
<li class="lvl-2">
<p>针对抽象层编程，将具体类的对象通过依赖注入(Dependency Injection, DI)的方式注入到其他对象</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>构造注入</p>
</li>
<li class="lvl-4">
<p>设值注入（Setter注入）</p>
</li>
<li class="lvl-4">
<p>接口注入</p>
</li>
</ul>
</li>
</ul>
<h5 id="依赖倒转原则实例">依赖倒转原则实例</h5>
<p>原始类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114194039193.png" alt="image-20221114194039193" style="zoom:50%;" />
<p>采用依赖倒转方法之后的类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114194557579.png" alt="image-20221114194557579" style="zoom:50%;" />
<h3 id="接口隔离原则">接口隔离原则</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114195729933.png" alt="image-20221114195729933" style="zoom:50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p>“接口”定义(1)：一个类型所提供的所有方法特征的集合。一个接口代表一个角色，每个角色都有它特定的一个接口<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>“角色隔离原则”</p>
</li>
<li class="lvl-3">
<p>“接口”定义(2)：狭义的特定语言的接口。接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口，每个接口中只包含一个客户端所需的方法<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>“定制服务”</p>
</li>
</ol>
<p><mark>广义的接口指的是API，即一组操作的集合</mark></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>当一个接口太大时，需要将它分割成一些更细小的接口</p>
</li>
<li class="lvl-2">
<p>使用该接口的客户端仅需知道与之相关的方法即可</p>
</li>
<li class="lvl-2">
<p>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干</p>
</li>
</ul>
<h5 id="接口隔离原则实例">接口隔离原则实例</h5>
<p>原始类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114200533784.png" alt="image-20221114200533784" style="zoom:50%;" />
<p>使用接口隔离原则之后的类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114200544474.png" alt="image-20221114200544474" style="zoom: 50%;" />
<h3 id="合成复用原则">合成复用原则</h3>
<blockquote>
<p><mark>继承复用：类B通过继承获得类A的方法</mark></p>
<p><u>存在的问题：</u></p>
<ol>
<li class="lvl-3">
<p>但是继承复用存在继承了不需要的方法的情况，特别是存在三个及以上的继承链的情况，会继承太多不需要的方法——破坏了封装性</p>
</li>
<li class="lvl-3">
<p>如果类A是final类，此时不能继承类A</p>
</li>
<li class="lvl-3">
<p>静态关系，无法在运行时动态的改变父类，改变父类需要修改源代码——耦合度高</p>
</li>
</ol>
<p>final修饰变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>常量</p>
<p>final修饰类<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>最终类（不可被继承）</p>
<p>final修饰方法<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>不能被子类覆盖</p>
<p><mark>合成复用</mark>完美解决继承复用存在的问题：</p>
<ol>
<li class="lvl-3">
<p>在类B中定义类A的对象，并通过类A的对象精准调用目标方法</p>
</li>
<li class="lvl-3">
<p>如果类A是final类，不能被继承但是可以被关联，因此可以通过1的方式调用类A的方法</p>
</li>
<li class="lvl-3">
<p>可以通过Adapter（适配器）实现不修改源代码（但可以增加代码）的情况下，实现对类B调用方法的修改，以此符合开闭原则</p>
<ul class="lvl-3">
<li class="lvl-5"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114222324757.png" alt="image-20221114222324757"></li>
<li class="lvl-5">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114225248369.png" alt="image-20221114225248369" style="zoom:50%;" />
</li>
<li class="lvl-5">以上图：通过Adapter类继承类A，并重写m1()方法，同时Adapter类关联类A1，不能够在重写的m1()方法中通过类A1的对象调用了类A中的m3()方法，因此实现了在不改变源代码的情况下完成了对类B调取方法的转换（由调用原来的类A中的m1()方法变为了调用类A1中的m3()方法）</li>
</ul>
</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在扩展时使用继承，调用已存在类的方法时使用关联</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{在扩展时使用继承，调用已存在类的方法时使用关联}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在扩展时使用继承，调用已存在类的方法时使用关联</span></span></span></span></p>
<p>除了扩展的时候必用继承，其它时候尽量使用关联关系（降低耦合度）</p>
</blockquote>
<p>合成复用原则又称为组合/聚合复用原则(Composition/ Aggregate Reuse Principle, CARP)</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114201630080.png" alt="image-20221114201630080" style="zoom:50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p><mark>继承复用</mark>：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）</p>
</li>
<li class="lvl-3">
<p><mark>组合/聚合复用</mark>：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用 ）</p>
</li>
</ol>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分</p>
</li>
<li class="lvl-2">
<p>新对象通过委派调用已有对象的方法达到复用功能的目的</p>
</li>
<li class="lvl-2">
<p>复用时要尽量使用组合/聚合关系（关联关系），少用继承</p>
</li>
</ul>
<h5 id="合成复用原则实例">合成复用原则实例</h5>
<p>原始类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114202357231.png" alt="image-20221114202357231" style="zoom:50%;" />
<p>使用合成复用原则之后的类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114202538396.png" alt="image-20221114202538396" style="zoom:50%;" />
<h3 id="迪米特法则-最少知识原则">迪米特法则（最少知识原则）</h3>
<p>迪米特法则又称为最少知识原则(Least Knowledge Principle, LKP)。引入一个中间类降低对象之间的耦合度，但是因此中间类的功能会很复杂，因此这个中间类是违反了单一职责原则的。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114202705360.png" alt="image-20221114202705360" style="zoom:50%;" />
<blockquote>
<p>迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目</p>
<p>迪米特法则要求<u>一个</u>软件<u>实体</u>应当<u>尽可能少地与</u>其他<u>实体发生相互作用</u></p>
<p>应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系</p>
<p><mark>加入中间类的方式类似于QQ群的机制，降低了对象之间的耦合度</mark></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>迪米特法则要求在设计系统时，应该尽量减少对象之间的交互</p>
</li>
<li class="lvl-2">
<p>如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用</p>
</li>
<li class="lvl-2">
<p>如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用</p>
</li>
<li class="lvl-2">
<p>通过引入一个合理的“第三者”来降低现有对象之间的耦合度</p>
</li>
</ul>
<h5 id="迪米特法则实例">迪米特法则实例</h5>
<p>原始类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114203217733.png" alt="image-20221114203217733" style="zoom:50%;" />
<p>使用迪米特法则之后的类图：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221114203304703.png" alt="image-20221114203304703" style="zoom:50%;" />
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章（无损数据压缩编码）</title>
    <url>/2023/04/11/University/junior/course/multi-media-tech/%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>无损数据压缩编码</h1>
<h3 id="数据压缩">数据压缩</h3>
<p><strong>数据压缩</strong>可分成两种类型，一种是无损压缩（lossless compression），另一种是有损压缩（lossy compression）</p>
<p><strong>无损压缩</strong>：重构后的数据与原来的数据完全相同</p>
<p><strong>有损压缩</strong>：重构后的数据与原来的数据有所不同，但不会导致对原始数据的误解</p>
<h3 id="熵编码">熵编码</h3>
<blockquote>
<p><strong>所谓熵编码算法，就是一种用于确定码元的比特组合的计算方法。</strong></p>
<p><strong>所谓熵编码，就是指在不丢失任何信息的前提下，<span style="color: red;">基于码元的统计特性</span>，对码元或直接对报文本身进行编码，使得最后存储该报文所需要的平均比特数接近信源的信息熵。</strong></p>
</blockquote>
<p>信源：指构成一类报文的基本符号的集合。</p>
<p>报文：就是信息的载体</p>
<p>码元（基本编码单元）：基本符号又称为码元</p>
<p>一个信源的所有码元的平均信息量就称为该信源的<mark>信息熵</mark>（<strong>entropy</strong>）</p>
<h5 id="信息熵公式：">信息熵公式：</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316101213347.png" alt="image-20230316101213347"></p>
<h4 id="香农-范诺编码-自上而下">香农-范诺编码（自上而下）</h4>
<h6 id="香农-范诺算法">香农-范诺算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一步：<mark>对码元</mark>的概率（次数或频度）进行排序。</p>
</li>
<li class="lvl-2">
<p>第二步：进入一个循环处理，将排列好的码元分割成两个部分</p>
</li>
<li class="lvl-2">
<p>第三步：编码，对二叉树每一分支赋值0或1</p>
<ul class="lvl-2">
<li class="lvl-4">不等长编码</li>
</ul>
</li>
</ul>
<blockquote>
<p>分割的原则是，两个部分的次数之和（或频度之和）最接近，换句话说，就是使两部分的次数之和的差最小。</p>
</blockquote>
<h6 id="示例：">示例：</h6>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316101828013.png" alt="image-20230316101828013"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316101836779.png" alt="image-20230316101836779"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><mark>压缩比</mark>是指压缩前的原始报文所需要的存储空间与压缩后所需要的存储空间之比。</p>
<blockquote>
<p>压缩比为120:91</p>
</blockquote>
<h4 id="霍夫曼编码-自下而上">霍夫曼编码（自下而上）</h4>
<p>霍夫曼编码算法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一步：<mark>对码元</mark>的概率（次数或频度）进行排序，升序和降序均可</p>
</li>
<li class="lvl-2">
<p>第二步：把概率最小的两个码元的概率相加，得到一个新的根节点；重复第二步直到形成二叉树</p>
</li>
<li class="lvl-2">
<p>第三步：编码，对二叉树每一分支赋值0或1（大概率分支赋1或赋0均可）</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316103020622.png" alt="image-20230316103020622" style="zoom:50%;" />
<p>压缩比为120:90</p>
<blockquote>
<p>霍夫曼算法比香农-范诺算法的压缩效率要高。</p>
</blockquote>
<h5 id="textcolor-red-平时分："><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>平时分：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{平时分：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">平时分：</span></span></span></span></h5>
<p>设计无损压缩算法得到压缩文件发到老师QQ邮箱</p>
<h4 id="算术编码-考试会考-编码或者解码">算术编码（<mark>考试会考-编码或者解码</mark>）</h4>
<blockquote>
<p>算术编码并不对码元进行编码，而是直接<mark>对报文</mark>进行处理，即编码算法直接作用于输入报文，将其压缩成某种编码形式</p>
</blockquote>
<p>算术编码算法是一个对编码区间进行分割的循环过程，当前分割的区间是前一轮循环得到的编码区间，每一次循环都会从原始报文输入一个码元，直到输入最后一个码元，即中止分割循环。</p>
<h4 id="行程编码-rle">行程编码-RLE</h4>
<blockquote>
<p>行程编码（run length encoding，<mark>RLE</mark>），是指对报文逐行进行统计，通过记录连续排列在一起的相同数据单元的数量、以及该数据单元本身，以压缩存储空间的一种编码算法</p>
</blockquote>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230316112837587.png" alt="image-20230316112837587"></p>
<p><strong>在这些图块中，许多行上都具有相同的颜色，或者说在一行上有许多连续的象素都具有相同的颜色值，只需要存储一个象素的颜色值，再加上相同颜色的象素的数目就可以了</strong></p>
</blockquote>
<h3 id="词典编码-考：算法流程-伪代码-计算">词典编码（考：算法流程，伪代码，计算）</h3>
<blockquote>
<p>词典编码（Dictionary Encoding）就是典型的通用无损压缩方法</p>
<p>词典编码的根据是<u><span style="color: red;">数据本身存在大量的重复或者说冗余</span></u></p>
</blockquote>
<h4 id="第一类字词编码-隐式词典">第一类字词编码（隐式词典）</h4>
<p>基本思想：用指向早期曾经出现过的字符串的指针来表示当前被编码字符串</p>
<p>第一类词典编码算法中并没有出现一个显式的（explicit）“词典”，但实际上存在一组“指针+模式”这样的数据集合，指针就是“索引”，模式就是“词条”，这个“索引+词条”构成的词典没有明显地表示出来，而是融合到编码中去了。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321141306574.png" alt="image-20230321141306574"></p>
<h5 id="lz77-算法-by-abraham-lempel-and-jakob-ziv">LZ77 算法( by Abraham Lempel and Jakob Ziv)</h5>
<p>LZ77的关键是搜索，即在已经处理过的符号序列（数据流）中，寻找与待编码符号序列相同的模式，如果找到匹配的模式，就设法对这个模式进行索引，也就是生成一个指针，然后输出该索引即可</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321142032510.png" alt="image-20230321142032510" style="zoom: 33%;" />
<blockquote>
<p>总体上LZ77算法就是一个搜索匹配模式、输出匹配长度和偏移量的循环过程。</p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321142828190.png" alt="image-20230321142828190" style="zoom:50%;" />
<h6 id="lz77示例：">LZ77示例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321143959880.png" alt="image-20230321143959880" style="zoom:50%;" />
<p>LZ77解码：</p>
<h5 id="lzss算法">LZSS算法</h5>
<h6 id="改进点：">改进点：</h6>
<p>在LZ77算法基础上改进而来的，主要区别在于它设置了一个最小匹配长度，并改进了输出数据格式。如果匹配模式的长度大于最小匹配长度，就输出(off,length），否则就直接输出原字符序列（其长度取决于最小匹配长度，例如，如果最小匹配长度为2，那么直接输出的原字符长度等于1）。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321144441989.png" alt="image-20230321144441989" style="zoom:50%;" />
<h6 id="lzss示例：">LZSS示例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321144512334.png" alt="image-20230321144512334" style="zoom:50%;" />
<h4 id="第二类字词编码-显式词典">第二类字词编码（显式词典）</h4>
<p>基本思想：从输入的数据流中创建一个短语词典，后续数据流中若出现词典中的短语，则可用该短语在词典中的索引表示该短语，而不需要输出短语本身。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321141515804.png" alt="image-20230321141515804"></p>
<h5 id="lz78算法">LZ78算法</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321150502859.png" alt="image-20230321150502859" style="zoom:50%;" />
<h6 id="lz78示例：">LZ78示例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321151940604.png" alt="image-20230321151940604" style="zoom:50%;" />
<h5 id="lzw算法">LZW算法</h5>
<h6 id="改进点：">改进点：</h6>
<ol>
<li class="lvl-3">
<p>第一，它的词典最初不是空的，而是一开始就包含了一些基本的词条，这些词条是字符流中可能出现的单个字符，例如ASCII字符集。</p>
</li>
<li class="lvl-3">
<p>第二，LZW算法的输出与LZ78不同，它只输出索引，不像LZ78那样输出（index，next char）对。</p>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230321154017982.png" alt="image-20230321154017982" style="zoom:50%;" />
<h6 id="lzw示例：">LZW示例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323103109423.png" alt="image-20230323103109423" style="zoom:50%;" />
<h6 id="解码示例：">解码示例：</h6>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323103218389.png" alt="image-20230323103218389" style="zoom:50%;" />
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章（编程环境与平台）</title>
    <url>/2023/03/02/University/junior/course/multi-media-tech/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>编程环境与平台</h1>
<blockquote>
<p><span style="color: red;">课程要求</span>：<u><em><strong>自学（2小时）：Windows运行机制。</strong></em></u></p>
<p>链接：<a href="https://www.bilibili.com/video/av42464433/?spm_id_from=333.788.videocard.5">https://www.bilibili.com/video/av42464433/?spm_id_from=333.788.videocard.5</a></p>
</blockquote>
<h3 id="数据流">数据流</h3>
<p>数据流： 数据流是同一类型的媒体数据的一种序列。</p>
<h3 id="媒体容器">媒体容器</h3>
<p>媒体容器（相当于<mark>文件</mark>）：</p>
<ol>
<li class="lvl-3">
<p>文件头部：描述流的个数，以及每一个流的格式等。</p>
</li>
<li class="lvl-3">
<p>索引：用于随机存取内容。</p>
</li>
<li class="lvl-3">
<p>元数据：即数据的数据，也就是用于描述内容的数据（例如作者或标题）。</p>
</li>
<li class="lvl-3">
<p>数据包头部：用于网络传输或随机存取Media Foundation使用术语“容器”来描述<u><strong>数据流、头部、索引、元数据</strong></u>等等的整个包。</p>
</li>
</ol>
<p>Windows程序的核心是<mark>事件驱</mark>动和<mark>消息循环机制</mark>以及回调机制（<strong>窗口过程</strong>是典型的回调函数）</p>
<h3 id="media-foundation架构">Media Foundation架构</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230302102456749.png" alt="Media Foundation架构"></p>
<blockquote>
<p>Media Session并不直接管理媒体数据，而是要借助<mark>Topology</mark></p>
<p>Topology也是一个Media Foundation对象，用于表示媒体管道中的数据如何流动。</p>
<p>在Topology中，数据流所经过的处理模块称为<mark>节点(Node）</mark>，如<em><strong>媒体源、转换器、输出节点</strong></em>。</p>
</blockquote>
<p>数据管道模式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过Media Session控制其他组件</p>
</li>
<li class="lvl-2">
<p>Media Source、MFT、Media Sink</p>
</li>
<li class="lvl-2">
<p>MFT通常由MF平台自动处理</p>
</li>
<li class="lvl-2">
<p>应用不能直接处理数据</p>
</li>
</ul>
<p>数据源模式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Source Reader、Sink Writer控制数据</p>
</li>
<li class="lvl-2">
<p>程序处理MFT(Encoder/Decoder)</p>
</li>
<li class="lvl-2">
<p>应用可以直接处理数据</p>
</li>
</ul>
<h3 id="媒体信道">媒体信道</h3>
<p>媒体信道<strong>包括三种类型的对象，以生成或处理媒体数据。</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>媒体源（Media Source）：将数据引入管道。一个媒体源可以从本地文件中获取数据，如以一个视频文件；也可以从网络流或是硬件捕获设备中获取数据。</p>
</li>
<li class="lvl-2">
<p>Media Foundation变换（MFTs）：在数据流中处理数据，编码器和译码器是作为MFT的实现。</p>
</li>
<li class="lvl-2">
<p>媒体信宿（Media Sink）：使用数据；例如在显示屏上播放视频、播放音频、或是把数据写入一个媒体文件等。</p>
</li>
</ul>
<h2 id="windows运行机制">Windows运行机制</h2>
<blockquote>
<p>链接：<a href="https://www.bilibili.com/video/av42464433/?spm_id_from=333.788.videocard.5">https://www.bilibili.com/video/av42464433/?spm_id_from=333.788.videocard.5</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章（数字视频基础）</title>
    <url>/2023/04/11/University/junior/course/multi-media-tech/%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>数字视频基础</h1>
<h3 id="模拟电视信号">模拟电视信号</h3>
<h3 id="两种扫描方式">两种扫描方式</h3>
<p>扫描：通过信号控制显示屏以得到电视图像的过程</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>逐行扫描</p>
<ul class="lvl-2">
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406101859627.png" alt="image-20230406101859627" style="zoom:33%;" />
</li>
</ul>
</li>
<li class="lvl-2">
<p>隔行扫描</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>隔行扫描的总行数是奇数。</strong></li>
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406101803107.png" alt="image-20230406101803107" style="zoom: 33%;" />
</li>
</ul>
</li>
</ul>
<blockquote>
<p><u><em><strong>计算机使用逐行扫描；电视机使用隔行扫描。</strong></em></u></p>
</blockquote>
<h4 id="消隐">消隐</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>水平消隐</p>
</li>
<li class="lvl-2">
<p>垂直消隐（场消隐）</p>
</li>
</ul>
<blockquote>
<p>屏蔽</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>行频：每秒钟扫描多少行</p>
</li>
<li class="lvl-2">
<p>场频：每秒钟扫描多少场</p>
</li>
<li class="lvl-2">
<p>帧频：每秒扫描多少帧</p>
</li>
</ul>
<h4 id="模拟彩色电视制式：">模拟彩色电视制式：</h4>
<ol>
<li class="lvl-3">
<p><strong>NTSC</strong>：<strong>称为正交平衡调幅制式</strong></p>
</li>
<li class="lvl-3">
<p><strong>SECAM</strong>：<strong>逐行倒相正交平衡调幅制式</strong></p>
</li>
<li class="lvl-3">
<p><strong>PAL</strong>：<strong>顺序传送彩色与存储制式</strong></p>
</li>
</ol>
<h3 id="复合电视信号">复合电视信号</h3>
<p><u>复合电视信号</u>是指在一路电流（或电压）中融合了<u>亮度和色差信息（图像信号）</u>，并与<u>同步信息</u>、<u>消隐</u>脉冲一起组成的单一信号。又被称为<u>全电视信号</u></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406103404914.png" alt="image-20230406103404914" style="zoom: 50%;" />
<blockquote>
<p>同步信息：保持各种频率（行频、场频、帧频）的同步性。</p>
</blockquote>
<h3 id="分量电视信号">分量电视信号</h3>
<p>分量电视信号由三个独立的基色分量构成，这三个独立基色可以是R、G和B,也可以是Y、I、O,或者Y、U、V。RGB/YUV/YIQ的<u>每一个分量分别被编码成一个信号</u>。</p>
<h3 id="s-video信号">S-Video信号</h3>
<blockquote>
<p>也称<u><strong>分离电视信号</strong></u></p>
</blockquote>
<p>S-Video信号是对分量电视信号与复合电视信号的折中，S-Video信号的亮度占用一个信号，但是，色差的两个分量(UV或IQ)共用另一个信号。</p>
<blockquote>
<p><mark>总结以上三个信号的优缺点</mark></p>
</blockquote>
<h4 id="采样格式">采样格式</h4>
<p>采样格式是指对全电视信号进行数字化时：亮度通道与色差通道的样本数量的比例关系。</p>
<h5 id="4-4-4格式">4:4:4格式</h5>
<p>4:4:4格式：表示色差通道没有下采样（sub sampling)，即每行扫描线中，每对应4个亮度Y样本，也包含4个U样本和4个V样本，如图所示。亮度样本由灰色表示，色差样本由红色和蓝色表示。又称为全采样格式。</p>
<h5 id="4-2-2格式">4:2:2格式</h5>
<h5 id="4-2-0格式">4:2:0格式</h5>
<h5 id="4-1-1格式">4:1:1格式</h5>
<h4 id="yuv数据流">YUV数据流</h4>
<p>YUV数据流可以分为两大类，一类是<mark>紧凑格式</mark>，另一类是<mark>平面格式</mark>。紧凑格式主要适合实时应用场合，而平面格式主要用于文件存储。</p>
<h4 id="yuv视频的存储格式">YUV视频的存储格式</h4>
<p>(1)<mark>AYUV格式</mark>：AYUV格式表示4：4：4格式下，每像素占用32位。AYUV格式推荐使用单一的4：4：4采样格式，其四字符编码(FOURCC)是AYUV。该格式是一个所谓的<mark>紧凑格式</mark>(packed format),即每个像素使用4个连续的字节编码，依次排列。A字节表示透明度值。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230406111052053.png" alt="image-20230406111052053" style="zoom:50%;" />
<p>(2)YUY2格式</p>
<p>(3)UYVY格式</p>
<p>(4)IMC1格式</p>
<p>(5)IMC3格式</p>
<p>(6)IMC2格式</p>
<p>(7)IMC4格式</p>
<p>(8)YV12格式</p>
<p>(9)NV12格式</p>
<h4 id="考虑两种rgb编码方案：">考虑两种RGB编码方案：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一种是8位计算机RGB,也称为sRGB或是全尺度RGB;</p>
</li>
<li class="lvl-2">
<p>第二种是演播室视频RGB(studio video RGB)。</p>
</li>
</ul>
<h3 id="颜色空间和色差采样率的变换">颜色空间和色差采样率的变换</h3>
<p><mark>非全采样格式的YUV必须转换成全采样格式（4:4:4）的YUV才能够进一步转换为RGB。</mark></p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章（视频应用程序设计）</title>
    <url>/2023/04/11/University/junior/course/multi-media-tech/%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>视频应用程序设计</h1>
<blockquote>
<p>教学内容：</p>
<ul class="lvl-1">
<li class="lvl-2">视频播放</li>
<li class="lvl-2">视频特效方法</li>
<li class="lvl-2">视频捕获程序设计</li>
<li class="lvl-2">运动对象检测与跟踪（了解）</li>
</ul>
</blockquote>
<h2 id="视频播放">视频播放</h2>
<p><span style="color: red;">详见PPT</span></p>
<h2 id="视频特效方法">视频特效方法</h2>
<blockquote>
<p>运用图像融合：</p>
<ul class="lvl-1">
<li class="lvl-2">在视频图像里添加字幕和图标；</li>
<li class="lvl-2">视频场景切换中的淡入淡出。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章（数字图像基础）</title>
    <url>/2023/04/11/University/junior/course/multi-media-tech/%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>数字图像基础</h1>
<h5 id="色彩的三特性：">色彩的三特性：</h5>
<ol>
<li class="lvl-3">
<p>亮度（与光通量相关）</p>
</li>
<li class="lvl-3">
<p>色调</p>
</li>
<li class="lvl-3">
<p>饱和度（色调的深浅程度）</p>
</li>
</ol>
<h5 id="真彩图像">真彩图像</h5>
<p>像素值直接表示了<mark>颜色属性</mark>的彩色图像称为真彩图像。位深度为24。</p>
<h5 id="伪彩图像">伪彩图像</h5>
<p>伪彩图像是指像素值不直接表示颜色值本身而是表示了颜色在调色板中索引的彩色图像。</p>
<h4 id="数字图像相关概念">数字图像相关概念</h4>
<h6 id="1-数字图像">1、数字图像</h6>
<p>数字图像（digital images）是用二维像素矩阵表示的图像。</p>
<h6 id="2-像素">2、像素</h6>
<p>把构成数字图像的基本元素称为像素（pixel），是图像平面中特定位置上的一个点，具有一定的颜色属性。</p>
<h6 id="3-位深度">3、位深度</h6>
<p>表示像素颜色属性值的比特数称为位深度，或称图像深度。</p>
<h5 id="数字图像的像素格式">数字图像的像素格式</h5>
<p>（1）RGB555</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323113836163.png" alt="image-20230323113836163" style="zoom:50%;" />
<blockquote>
<p>采用小端序存储到地址空间中。</p>
</blockquote>
<p>（2）RGB565</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323113908526.png" alt="image-20230323113908526" style="zoom:50%;" />
<p>（3）RGB888</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230323113939423.png" alt="image-20230323113939423" style="zoom:50%;" />
<h3 id="bmp-图像">BMP 图像</h3>
<p>BMP（Bitmap，位图）图像又称位图图像，是Microsoft、IBM等公司制定的图像文件标准。BMP文件中图像数据是以非常自然的位映射方式存储的，并且没有被压缩（绝大多数情况下如此），所以，BMP文件是最基本的图像文件。</p>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328141409884.png" alt="image-20230328141409884" style="zoom:50%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328142400896.png" alt="image-20230328142400896" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h6 id="图像文件的格式：">图像文件的格式：</h6>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328141822213.png" alt="image-20230328141822213"></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328141839123.png" alt="image-20230328141839123"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328141854688.png" alt="image-20230328141854688"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328142324777.png" alt="image-20230328142324777" style="zoom: 33%;" /></td>
</tr>
</tbody>
</table>
<h5 id="位图数据">位图数据</h5>
<p>位图数据(bitmap data)：就是图像数据，如图所示全部为图像数据，图像的像素点存储顺序是<mark>从左到右，从下倒上进行存储的</mark>，所以左下角的像素为第一个存储，右上角的像素为最后一个存储。<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230330100736012.png" alt="image-20230330100736012"></p>
<blockquote>
<p>图像在内存中是倒立存储。</p>
</blockquote>
<h6 id="位图数据的存储方式">位图数据的存储方式</h6>
<ol>
<li class="lvl-3">
<p>Top-down存储模式</p>
</li>
<li class="lvl-3">
<p>Bottom-up存储模式</p>
</li>
</ol>
<blockquote>
<p>图像每行像素所占字节，不能被4整除时，自动补齐值为0的字节，直到能被4整除。</p>
</blockquote>
<p>如图所示，一行有三个像素，每个像素占3个字节，共9个字节，不能被4整除，所以<u><strong>要再补充3个值为0的字节，才能被4整除</strong></u>：</p>
<table>
<thead>
<tr>
<th>位图数据(bitmap data)</th>
<th>补0字节</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328144010443.png" alt="image-20230328144010443" style="zoom:50%;" /></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328143738697.png" alt="image-20230328143738697" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
<h3 id="gif图像">GIF图像</h3>
<p><strong>GIF文件采用了第二类字典编码算法LZW来压缩图像数据</strong></p>
<h4 id="图像压缩标准-jpeg">图像压缩标准:JPEG</h4>
<p>JPEG整个压缩过程基本上遵循以下步骤：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>把数据分为“重要部分”和“不重要部分”</p>
</li>
<li class="lvl-2">
<p>滤掉不重要的部分</p>
</li>
<li class="lvl-2">
<p>保存</p>
</li>
</ul>
<p>对原始图像信息进行JPEG编码的过程就分为两大步：</p>
<p>第一步，去除视觉上的多余信息，即空间冗余度；——采用有损压缩的方式</p>
<p>第二步，去除数据本身的多余信息，即结构冗余度。——采用无损压缩的方式（比如：熵编码等）</p>
<p>JPEG标准包括两种基本压缩算法：</p>
<p>一种是以离散余弦变换（Discrete Cosine Transform，DCT）为基础的有损压缩方法；</p>
<p>另一种是以预测技术为基础的无损压缩方法。</p>
<blockquote>
<p><u><strong>JPEG压缩出现损失出现在量化过程。</strong></u></p>
</blockquote>
<p>JPEG算法整个编码过程大致分成三步：</p>
<p>第一步，使用正向离散余弦变换（forward discrete cosine transform，FDCT）将图像数据从空间域变换成频率域表示的图像。</p>
<p>第二步，使用量化表对变换后的数据（又称DCT系数）进行量化，这实际上是利用人类视觉系统对高频成分欠敏感而丢失一些信息的过程。（去掉一部分图像的高频部分）</p>
<p>第三步，使用差分脉冲编码调制、行程压缩算法和霍夫曼可变字长编码器对量化系数进行编码。</p>
<p>JPEG压缩的编解码互逆过程：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230328152123274.png" alt="image-20230328152123274"></p>
<blockquote>
<p>直流系数：使用差分脉冲调制编码（DPCM）</p>
<p>交流系数：使用行程编码（RLE）——Z字型编排尽可能形成较多连续的0，从而方便行程编码</p>
<p>然后使用熵编码（<strong>霍夫曼编码</strong>）进一步压缩</p>
<p>最后组成位数据流</p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章（音频数据处理程序设计）</title>
    <url>/2023/03/08/University/junior/course/multi-media-tech/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>音频数据处理程序设计</h1>
<p>Media Session（媒体会话）：管理媒体数据、实现播放、暂停操作。</p>
<h5 id="wave文件由4个块组成：">WAVE文件由4个块组成：</h5>
<ol>
<li class="lvl-3">
<p>RIFF WAVE Chunk</p>
</li>
<li class="lvl-3">
<p>Format Chunk</p>
</li>
<li class="lvl-3">
<p>Fact Chunk（可选）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>一般当wav文件由某些软件转化而成时，则需要包含该Chunk</p>
</li>
<li class="lvl-3">
<p>Data Chunk</p>
<ul class="lvl-2">
<li class="lvl-5">双声道的采样数要加倍</li>
<li class="lvl-5">小端序：低位字节存在地址空间中的低位（比如：Ox0782中的低位字节82存储在地址空间中的低位）</li>
<li class="lvl-5">大端序：低位字节存在地址空间中的高位</li>
</ul>
</li>
</ol>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307151517811.png" alt="image-20230307151517811" style="zoom:50%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p>ID都是4个字节，<u>比如<code>ID='fmt '</code>中fmt之后还有一个<strong>空字符</strong></u>（用“四字符码”作块ID，是RIFF文件的重要特点）</p>
</li>
</ol>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230309095659190.png" alt="四个块的关系" style="zoom: 50%;" />
<h5 id="wave文件的地址空间">WAVE文件的地址空间</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230307153329553.png" alt="WAVE文件的地址空间" style="zoom: 67%;" />
<p><u><strong>将10进制转换为16进制来存储到地址空间中。</strong></u></p>
<blockquote>
<ol>
<li class="lvl-3">
<p>每个块的ID和RIFF块的Type（WAVE）的端序是<strong>大端存储</strong>，其他都是<strong>小端存储</strong></p>
</li>
<li class="lvl-3">
<p>16进制存储</p>
</li>
</ol>
</blockquote>
<h3 id="音频播放与编程接口">音频播放与编程接口</h3>
<p>方法1：使用PlaySound函数播放音频文件</p>
<p>方法2：使用MCI（Multimedia Control Interface）函数</p>
<p>方法3：基于DirectShow开发包的应用程序</p>
<p>方法4：基于Media Foundation开发包的应用程序</p>
<h4 id="基于mf-media-session的音频">基于MF Media Session的音频</h4>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230309103609827.png" alt="基于Media Session的媒体播放应用的基本框架" style="zoom:50%;" />
<h5 id="播放音频文件">播放音频文件</h5>
<p>利用 Media Session播放音频文件的基础过程如下：</p>
<ol>
<li class="lvl-3">
<p><span style="color: red;">调用MFStartup函数</span>进行Media Foundation platform的初始化；</p>
</li>
<li class="lvl-3">
<p><span style="color: red;">调用MFCreateMediaSession函数</span>创建一个Media Session对象实例；</p>
</li>
<li class="lvl-3">
<p>利用<span style="color: red;">Source Resolver</span>创建媒体源。</p>
</li>
<li class="lvl-3">
<p><span style="color: red;">创建Topology，并将媒体源节点与SAR节点连接起来</span>。实际上，应用程序在这里只需要创建一个Partial Topology（部分拓扑），然后将媒体源与输出节点SAR连接，这时，Partial Topology能够自动在两者之间插入必要的解码器，这体现出Media Foundation的智能性；</p>
</li>
<li class="lvl-3">
<p><span style="color: red;">调用IMFMediaSession::SetTopology</span>将Topology设置到Media Session；</p>
</li>
<li class="lvl-3">
<p><span style="color: red;">使用IMFMediaEventGenerator接口</span>从Media Session取得事件；</p>
</li>
<li class="lvl-3">
<p><span style="color: red;">调用IMFMediaSession::Start启动播放</span>。之后，可以调用IMFMediaSession::Pause、IMFMediaSession::Stop暂停、停止播放。</p>
</li>
<li class="lvl-3">
<p>退出应用程序时，需<span style="color: red;">调用IMFMediaSession::Close关闭Media Session</span>。该方法是异步的，因此，当调用完毕，Media Session发送MESessionClosed事件，并能够安全处理后面的操作。</p>
</li>
</ol>
<blockquote>
<p><u><em><strong>如果需要对3个音频文件进行（同时）播放则需要创建3个媒体会话。</strong></em></u></p>
</blockquote>
<h3 id="基于mf的音频转码程序设计">基于MF的音频转码程序设计</h3>
<h5 id="程序模块结构设计">程序模块结构设计</h5>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230309110147616.png" alt="程序模块结构设计" style="zoom:50%;" />
<blockquote>
<p>采用的是数据源模式（MF架构之一）：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230309110527721.png" alt="数据源模式" style="zoom:50%;" />
</blockquote>
<h4 id="相关函数分析">相关函数分析</h4>
<h5 id="1-writewavefile函数">1、WriteWaveFile函数</h5>
<p>WriteWaveFile(IMFSourceReader*, HANDLE, LONG)函数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>调用ConfigureAudioStream(IMFSourceReader*, IMFMediaType **）函数，从输入源文件中挑选出音频流，然后设置目标音频的格式，从而告知源阅读器调用相应的解码器；</p>
</li>
<li class="lvl-2">
<p>调用WriteWaveHeader(hFile, pAudioType, &amp;cbHeader）函数，将任意输入的音频文件中的数据流或多媒体文件中的音频流，转码成未压缩的PCM格式的Wave文件；</p>
</li>
<li class="lvl-2">
<p>调用CalculateMaxAudioDataSize(pAudioType, cbHeader, msecAudioData）函数，计算准备写入到输出文件中的音频片断的最大数据量；</p>
</li>
<li class="lvl-2">
<p>调用WriteWaveData(hFile, pReader, cbMaxAudioData, &amp;cbAudioData）函数，写入音频数据；</p>
</li>
<li class="lvl-2">
<p>调用FixUpChunkSizes(hFile, cbHeader, cbAudioData）函数，对输出文件进行数据补充；</p>
</li>
</ul>
<h5 id="2-calculatemaxaudiodatasize函数">2、CalculateMaxAudioDataSize函数</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>计算原理：</p>
<ul class="lvl-2">
<li class="lvl-4">
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230309111702551.png" alt="计算原理" style="zoom:50%;" />
</li>
</ul>
</li>
</ul>
<h5 id="3-configureaudiostream函数">3、ConfigureAudioStream函数</h5>
<p>ConfigureAudioStream(IMFSourceReader*, IMFMediaType**)函数</p>
<ul class="lvl-0">
<li class="lvl-2">
</li>
</ul>
<h5 id="4-writewaveheader函数">4、WriteWaveHeader函数</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义了一个WAVEFORMATEX的结构指针pWav：</p>
<ul class="lvl-2">
<li class="lvl-4">WAVEFORMATEX的结构：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WAVEFORMATEX结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; </span><br><span class="line">WORD wFormatTag; 		<span class="comment">//格式标识</span></span><br><span class="line">WORD nChannels; 		<span class="comment">//声道数</span></span><br><span class="line">DWORD nSamplesPerSec; 	<span class="comment">//采样频率</span></span><br><span class="line">DWORD nAvgBytesPerSec; 	<span class="comment">//数据率</span></span><br><span class="line">WORD nBlockAlign; 		<span class="comment">//样本对齐单位</span></span><br><span class="line">WORD wBitsPerSample; 	<span class="comment">//样本的量化深度</span></span><br><span class="line">WORD cbSize; 			<span class="comment">//附加数据:存储非PCM格式音频的补充信息，如果没有附加信息，该数据需要置为0</span></span><br><span class="line">&#125; WAVEFORMATEX</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-writewavedata函数">5、WriteWaveData函数</h5>
<h5 id="6-fixupchunksizes函数">6、FixUpChunkSizes函数</h5>
<h5 id="7-writetofile函数">7、WriteToFile函数</h5>
<h4 id="7个函数的作用：">7个函数的作用：</h4>
<blockquote>
<ol>
<li class="lvl-3">
<p>调用WriteWaveFile(IMFSourceReader*, HANDLE, LONG)函数，建立在其它含有实际动作的函数基础之上的控制性模块；</p>
</li>
<li class="lvl-3">
<p>调用ConfigureAudioStream(IMFSourceReader*, IMFMediaType **）函数，从输入源文件中挑选出音频流，然后设置目标音频的格式，从而告知源阅读器调用相应的解码器；</p>
</li>
<li class="lvl-3">
<p>调用WriteWaveHeader(hFile, pAudioType, &amp;cbHeader）函数，将任意输入的音频文件中的数据流或多媒体文件中的音频流，转码成未压缩的PCM格式的Wave文件；</p>
</li>
<li class="lvl-3">
<p>调用CalculateMaxAudioDataSize(pAudioType, cbHeader, msecAudioData）函数，计算准备写入到输出文件中的音频片断的最大数据量；</p>
</li>
<li class="lvl-3">
<p>调用WriteWaveData(hFile, pReader, cbMaxAudioData, &amp;cbAudioData）函数，写入音频数据；</p>
</li>
<li class="lvl-3">
<p>调用FixUpChunkSizes(hFile, cbHeader, cbAudioData）函数，对输出文件进行数据补充；</p>
</li>
<li class="lvl-3">
<p>调用WriteToFile函数，完成数据的最后输出。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>多媒体技术与应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年期末考试复习总结</title>
    <url>/2023/05/11/University/junior/course/electronic_commerce/2022%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E5%BA%94%E7%94%A8%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>期末考试复习总结</h1>
<h3 id="第一章">第一章</h3>
<h5 id="1-结合实际案例-分析电子商务的概念与特点">1、结合实际案例，分析<mark>电子商务的概念与特点</mark>。</h5>
<p>案例：网上书店、超市、</p>
<p>概念：电子商务是指通过互联网进行销售商品、提供服务等的商务活动</p>
<p>特点：</p>
<ol>
<li class="lvl-3">
<p>普遍性：是现代经济发展型社会的主角</p>
</li>
<li class="lvl-3">
<p>方便性</p>
</li>
<li class="lvl-3">
<p>虚拟性：在虚拟环境中进行</p>
</li>
<li class="lvl-3">
<p>商务性：提供买卖交易的服务、手段和机会</p>
</li>
<li class="lvl-3">
<p>低成本：无店面、无专门的销售人员、无库存压力、行销成本低</p>
</li>
<li class="lvl-3">
<p>电子化：无纸贸易</p>
</li>
<li class="lvl-3">
<p>服务性：突破了时空限制，以服务为中心的商务活动</p>
</li>
<li class="lvl-3">
<p>集成性：事务处理的整体性和统一性</p>
</li>
<li class="lvl-3">
<p>可拓展性</p>
</li>
<li class="lvl-4">
<p>安全性</p>
</li>
<li class="lvl-4">
<p>协调性：多行业各部门通力合作</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213173003543.png" alt="image-20230213173003543"></p>
<h5 id="2-电子商务系统的各个组成部分及分工">2、电子商务系统的<mark>各个组成部分及分工</mark>。</h5>
<p><mark>电子商务系统</mark>是指商务活动的各方,包括企业和商家、工商管理等行政部门、客户、银行等金融机构，利用计算机通信网络等技术实现商务活动的信息系统。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213171928516.png" alt="image-20230213171928516"></p>
<p>组成部分：</p>
<ol>
<li class="lvl-3">
<p>基础设备</p>
<ul class="lvl-2">
<li class="lvl-5">电子商务赖以运行的网络服务平台，支撑着商务活动的全过程。
<ul class="lvl-4">
<li class="lvl-7">一般有因特网、企业内部网、企业外联网等。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>电子支付环境</p>
<ul class="lvl-2">
<li class="lvl-5">电子支付是电子商务活动的关键环节和重要组成部分，是电子商务能够顺利发展的基础条件。</li>
</ul>
</li>
<li class="lvl-3">
<p>信用环境</p>
<ul class="lvl-2">
<li class="lvl-5">建立和完善电子商务认证中心。认证中心是改善电子商务信用环境必要保障。</li>
<li class="lvl-5">制定相关法律和制度，保障正常的电子商务活动的进行。</li>
<li class="lvl-5">建立社会信用评价制度和体系，为电子商务交易提供资信服务。</li>
</ul>
</li>
<li class="lvl-3">
<p>物流环境</p>
<ul class="lvl-2">
<li class="lvl-5">物流是指物质实体从供应者向需求者的物理移动，包括运输、保管、配送、包装、装卸、流通、加工及物流信息处理等多项基本活动，是这些活动的统一。</li>
</ul>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213172049808.png" alt="image-20230213172049808"></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>市场：寻找和保持客户/优化产品/客户管理；</p>
</li>
<li class="lvl-2">
<p>销售：为客户提供可组合的、灵活的购买计划，提供方便易用的产品搜索/销</p>
</li>
<li class="lvl-2">
<p>售分析；</p>
</li>
<li class="lvl-2">
<p>采购：联机采购在线报价/电子支付；</p>
</li>
<li class="lvl-2">
<p>配送/后勤：交付的可视化/订单可跟踪；</p>
</li>
<li class="lvl-2">
<p>客户服务：新的客户服务，每周7天、每天24小时服务，服务的及时反馈，一对一个性化服务和自助式服务/服务过程记录。</p>
</li>
</ul>
</blockquote>
<h5 id="3-电子商务的分类">3、电子商务的分类</h5>
<ol>
<li class="lvl-3">
<p>按商业活动运作方式分类</p>
<ol>
<li class="lvl-6">完全电子商务</li>
<li class="lvl-6">不完全电子商务</li>
</ol>
</li>
<li class="lvl-3">
<p>按交易对象分类</p>
<ol>
<li class="lvl-6">企业对消费者的电子商务（B to C）</li>
<li class="lvl-6">企业对企业的电子商务（B to B）</li>
<li class="lvl-6">消费者对消费者的电子商务（C to C）</li>
<li class="lvl-6">消费者对企业的电子商务（C to B）</li>
<li class="lvl-6">线上到线下的电子商务（O to O）</li>
<li class="lvl-6">面向市场营销的电子商务（B to M）</li>
<li class="lvl-6">生产厂家直接对消费者的电子商务（M to C）</li>
</ol>
</li>
<li class="lvl-3">
<p>按电子交易的网络平台分类</p>
<ol>
<li class="lvl-6">基于Intranet的电子商务</li>
<li class="lvl-6">基于Extranet的电子商务</li>
<li class="lvl-6">基于Internet的电子商务</li>
<li class="lvl-6">基于其他网络的电子商务</li>
</ol>
</li>
<li class="lvl-3">
<p>按开展电子商务的信息网络范围分类</p>
<ol>
<li class="lvl-6">本地电子商务</li>
<li class="lvl-6">远程电子商务</li>
<li class="lvl-6">全球电子商务</li>
</ol>
</li>
<li class="lvl-3">
<p>按商务与电子的融合程度分类</p>
<ol>
<li class="lvl-6">初级层次</li>
<li class="lvl-6">中级层次</li>
<li class="lvl-6">高级层次</li>
</ol>
</li>
</ol>
<h3 id="第二章">第二章</h3>
<h5 id="1-结合案例分析-理解电子商务模式">1、结合案例分析，理解电子商务模式</h5>
<ol>
<li class="lvl-3">
<p>B2C（Business to Customer）模式</p>
<ul class="lvl-2">
<li class="lvl-5">关键：企业与消费者</li>
<li class="lvl-5">交易过程：
<ul class="lvl-4">
<li class="lvl-7">购买前的准备</li>
<li class="lvl-7">购买过程</li>
<li class="lvl-7">售后服务</li>
</ul>
</li>
<li class="lvl-5">B2C模式是我国最早产生的电子商务模式，以8848网上商城正式运营为标志。</li>
<li class="lvl-5">问题❓：小红书是C2B-B2C
<ul class="lvl-4">
<li class="lvl-7">（待定）小红书的电商模式有哪些特点：
<ul class="lvl-6">
<li class="lvl-9">社区+电商</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>C2C（ Customer to Customer）模式</p>
<ul class="lvl-2">
<li class="lvl-5">关键：消费者与消费者</li>
<li class="lvl-5">典型例子：淘宝网、拍拍网……</li>
<li class="lvl-5">特点：
<ul class="lvl-4">
<li class="lvl-7">用户数量多，身份复杂；</li>
<li class="lvl-7">商品信息多，商品质量参差不齐；</li>
<li class="lvl-7">交易次数多，但每次交易成交额较小；</li>
<li class="lvl-7">柔性价格机制；</li>
<li class="lvl-7">为买卖双方交易提供系列配套服务。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>C2B（ Customer to Business ）模式</p>
<ul class="lvl-2">
<li class="lvl-5">关键：消费者与企业</li>
<li class="lvl-5">典型例子：中国团购在线、一起买……</li>
<li class="lvl-5">特点：
<ul class="lvl-4">
<li class="lvl-7">买方议价能力增强；</li>
<li class="lvl-7">降低买卖双方的交易成本和时间；</li>
<li class="lvl-7">降低了交易的不确定性；</li>
<li class="lvl-7">利于消费者维权与厂商售后服务；</li>
<li class="lvl-7">有利于商品信息资源的开发与利用。</li>
</ul>
</li>
<li class="lvl-5">问题❓：
<ul class="lvl-4">
<li class="lvl-7">拼多多是C2B模式吗？✔️</li>
<li class="lvl-7">美团是C2B模式吗？✔️</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>B2B（ Business to Business ）模式</p>
<ul class="lvl-2">
<li class="lvl-5">关键：企业与企业</li>
<li class="lvl-5">典型例子：阿里巴巴、百纳网、中国网库、中国制造网、敦煌网、慧聪网、瀛商网等</li>
<li class="lvl-5">按行业性质可分为综合B2B和垂直B2B。</li>
<li class="lvl-5">B2B模式分类：
<ul class="lvl-4">
<li class="lvl-7">内部网模式</li>
<li class="lvl-7">企业与外部企业间的模式</li>
<li class="lvl-7">中介模式</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>O2O（ Online to Offline ）模式</p>
<ul class="lvl-2">
<li class="lvl-5">关键：线上到线下</li>
<li class="lvl-5">消费者通过线上筛选商品，线下体验服务，成交可以在线上进行支付</li>
<li class="lvl-5">特点：
<ul class="lvl-4">
<li class="lvl-7">线上引导，线下消费</li>
<li class="lvl-7">推广效果可查，每笔交易可跟踪
<ul class="lvl-6">
<li class="lvl-9">更省钱</li>
<li class="lvl-9">更高效</li>
<li class="lvl-9">更合理</li>
<li class="lvl-9">更便捷</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-5">问题❓：设计一个餐馆座位预约的O2O应用方案</li>
</ul>
</li>
<li class="lvl-3">
<p>二维码电子商务模式</p>
<ul class="lvl-2">
<li class="lvl-5">关键：二维码-云服务-移动支付</li>
<li class="lvl-5">二维码功能：
<ul class="lvl-4">
<li class="lvl-7">信息获取（名片、地图、WIFI 密码、资料）</li>
<li class="lvl-7">网站跳转（跳转到微博、手机网站、网站）</li>
<li class="lvl-7">广告推送（用户扫码，直接浏览商家推送的视频、音频广告）</li>
<li class="lvl-7">手机电商（用户扫码、手机直接购物下单）</li>
<li class="lvl-7">防伪溯源（用户扫码、即可查看生产地；同时后台可以获取最终消费地􀀀</li>
<li class="lvl-7">优惠促销（用户扫码，下载电子优惠券，抽奖）</li>
<li class="lvl-7">会员管理（用户手机上获取电子会员信息、VIP 服务）􀀀</li>
<li class="lvl-7">手机支付（扫描商品二维码，通过银行/第三方支付提供的手机端通道完成支付）</li>
</ul>
</li>
<li class="lvl-5">二维码按原理分类：
<ul class="lvl-4">
<li class="lvl-7">堆叠式/行排式二维条码，又称堆积式</li>
<li class="lvl-7">矩阵式二维码</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>电子商务商业模式</p>
<ul class="lvl-2">
<li class="lvl-5">关键：</li>
</ul>
</li>
</ol>
<h3 id="第三章">第三章</h3>
<h5 id="1-万维网的基本概念和工作流程">1、万维网的基本概念和工作流程。</h5>
<ol>
<li class="lvl-3">
<p>基本概念：万维网WWW（World Wide Web）是环球信息网的缩写，也写作“Web”、“3W”等。</p>
</li>
<li class="lvl-3">
<p>工作流程：</p>
<ol>
<li class="lvl-6">万维网以客户/服务器方式工作。</li>
<li class="lvl-6">浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。</li>
<li class="lvl-6">客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。</li>
<li class="lvl-6">在一个客户程序主窗口上显示出的万维网文档称为页面（page）。</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213175910391.png" alt="image-20230213175910391"></p>
</li>
</ol>
<h5 id="2-域名规则和域名分类">2、域名规则和域名分类。</h5>
<ol>
<li class="lvl-3">
<p>域名规则：</p>
<ol>
<li class="lvl-6">英文命名规则：
<ul class="lvl-4">
<li class="lvl-8">域名中包含以下字符：
<ul class="lvl-6">
<li class="lvl-10">26个英文字母</li>
<li class="lvl-10">0-9十个数字</li>
<li class="lvl-10">“-”英文中的连字符</li>
</ul>
</li>
<li class="lvl-8">域名中字符的组合规则：
<ul class="lvl-6">
<li class="lvl-10">在域名中，<mark>不区分英文字母的大小写</mark></li>
<li class="lvl-10">域名长度有一定限制</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-6">中文命名规则：
<ul class="lvl-4">
<li class="lvl-8">域名中包含以下字符：
<ul class="lvl-6">
<li class="lvl-10">至少包含1个汉字</li>
<li class="lvl-10">其余部分可包含26个英文字母</li>
<li class="lvl-10">0-9十个数字</li>
<li class="lvl-10">“-”英文中的连字符</li>
</ul>
</li>
<li class="lvl-8">域名中字符的组合规则：
<ul class="lvl-6">
<li class="lvl-10">简繁体只需一个</li>
<li class="lvl-10">开头结尾不能有非法字符，例如，连接符、加号、@、&amp;、空格等</li>
<li class="lvl-10">域名不能是纯英文或数字</li>
<li class="lvl-10">域名长度转换成Punycode后不超过63个字符</li>
<li class="lvl-10">部分域名不支持中文前缀，例如“.com.cn”、“.net.cn”、“.org.cn”等</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<p>域名分类：</p>
<ol>
<li class="lvl-6">从地域范围分类：国际域名和国家域名</li>
<li class="lvl-6">从域名的级别进行分类：
<ul class="lvl-4">
<li class="lvl-8">顶级域名</li>
<li class="lvl-8">二级域名
<ul class="lvl-6">
<li class="lvl-10">我国二级域名又分为类别域名和行政区域名两类</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="3-网络空间-虚拟主机和双线接入的概念和特点">3、（网络空间）虚拟主机和双线接入的概念和特点。</h5>
<ol>
<li class="lvl-3">
<p>（网络空间）虚拟主机：</p>
<ol>
<li class="lvl-6">概念：网站空间(Web Host)，又称为虚拟主机空间或虚拟主机，指<mark>存放网站内容的空间</mark>。</li>
<li class="lvl-6">特点：
<ul class="lvl-4">
<li class="lvl-8">大幅降低费用（购买服务器、租用专线、维护费用等）</li>
<li class="lvl-8">性能相对较好（合租服务器）</li>
<li class="lvl-8">无需专门的维护和管理人员</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-3">
<p>（全网路由）双线接入：</p>
<ol>
<li class="lvl-6">概念：是指服务器所在的数据中心机房<mark>同时拥有网通与电信等多种网络出口</mark>，在机房的上层交换机上设置了全网路由技术，使服务器每次向外部网络连接时<mark>可以自动被分配到最快速的链路上</mark>。从而实现了电信与网通用户都可以同时高速访问。</li>
<li class="lvl-6">特点：</li>
<li class="lvl-6"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213180912744.png" alt="image-20230213180912744"></li>
</ol>
</li>
</ol>
<h5 id="4-常见的主机服务的特点">4、常见的主机服务的特点。</h5>
<ol>
<li class="lvl-3">
<p>虚拟主机</p>
</li>
<li class="lvl-3">
<p>独立主机</p>
</li>
<li class="lvl-3">
<p>主机托管</p>
<ul class="lvl-2">
<li class="lvl-5">用户自备服务器硬件，自己安装软件或付费委托服务商安装，将自己的服务器委托在服务商处保管和维护。</li>
</ul>
</li>
</ol>
<h5 id="5-不同类型服务器的特点">5、不同类型服务器的特点。</h5>
<ol>
<li class="lvl-3">
<p>文件服务器(File Server)</p>
</li>
<li class="lvl-3">
<p>数据库服务器(Database Server)</p>
</li>
<li class="lvl-3">
<p>应用程序服务器(Application Server)</p>
</li>
</ol>
<p>服务器分类——按机箱结构划分：</p>
<ol>
<li class="lvl-3">
<p>塔式服务器</p>
<ul class="lvl-2">
<li class="lvl-5">优点：
<ul class="lvl-4">
<li class="lvl-7"><mark>单个成本较低</mark></li>
<li class="lvl-7">由于机箱较大，<mark>具备良好的扩展能力和散热能力</mark></li>
<li class="lvl-7">可以配置多路处理器、多根内存、多块硬盘、多个冗余电源和散热风扇</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>机架式服务器</p>
<ul class="lvl-2">
<li class="lvl-5">优点：
<ul class="lvl-4">
<li class="lvl-7">相对塔式服务器，<mark>大大节省了空间占用</mark>，使布线、管理更为简洁</li>
<li class="lvl-7"><mark>节省了机房的托管费用</mark></li>
<li class="lvl-7">随着技术的发展，<mark>有着不逊色于塔式服务器的性能</mark></li>
<li class="lvl-7"><mark>平衡了性能和空间</mark></li>
</ul>
</li>
<li class="lvl-5">缺点：
<ul class="lvl-4">
<li class="lvl-7">由于机身的限制，在扩展能力和散热能力上不如塔式服务器</li>
<li class="lvl-7">对制冷要求较高</li>
<li class="lvl-7">需要对机架式服务器的体系结构专门进行设计，如主板、接口、散热系统等，设计成本较高，价格一般也高于塔式服务器</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>刀片服务器</p>
<ul class="lvl-2">
<li class="lvl-5">优点：
<ul class="lvl-4">
<li class="lvl-7">扩展方便，支持热插拔</li>
<li class="lvl-7">通过刀片架组成服务器集群，提供高速的网络服务</li>
<li class="lvl-7">每个刀片不需要独立的电源、显示器、制冷装置，降低功耗，减少整体成本</li>
</ul>
</li>
<li class="lvl-5">缺点：
<ul class="lvl-4">
<li class="lvl-7">刀片机箱的成本昂贵</li>
<li class="lvl-7">刀片技术更新变化频繁</li>
<li class="lvl-7">各大厂商锁定各自技术、没有形成统一的标准</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="第四章">第四章</h3>
<h5 id="1-理解电子商务的各种基础理论">1、理解电子商务的各种基础理论。</h5>
<ol>
<li class="lvl-3">
<p>网络经济的基础理论</p>
<ol>
<li class="lvl-6">梅特卡夫定理</li>
<li class="lvl-6">摩尔定律</li>
<li class="lvl-6">吉尔德定律</li>
<li class="lvl-6">非摩擦经济效应</li>
<li class="lvl-6">网络外部性</li>
<li class="lvl-6">双螺旋理论</li>
<li class="lvl-6">锁定效应</li>
<li class="lvl-6">维达多定律</li>
</ol>
</li>
<li class="lvl-3">
<p>电子商务中的基础理论</p>
<ol>
<li class="lvl-6">长尾理论</li>
<li class="lvl-6">注意力经济</li>
<li class="lvl-6">维基经济学</li>
<li class="lvl-6">威克理论</li>
</ol>
</li>
</ol>
<h3 id="第五章">第五章</h3>
<h5 id="1-理解竞争性和互补相关性的概念">1、理解竞争性和互补相关性的概念。</h5>
<ol>
<li class="lvl-3">
<p>竞争性（替代性）：<u>不同产品在具体的有用性质（功能）上互相代替的属性。</u></p>
</li>
<li class="lvl-3">
<p>互补相关性：</p>
</li>
</ol>
<h5 id="2-熟悉compkey方法">2、熟悉Compkey方法。</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>Step1：通过对查询日志的搜索，提取出所有与种子关键词𝑠 同时出现的中介关键词𝑎；</p>
</li>
<li class="lvl-2">
<p>Step2：计算出所有包含𝑠 与𝑠𝑎的查询搜索量；</p>
</li>
<li class="lvl-2">
<p>Step3：计算所有中介关键词权重；</p>
</li>
<li class="lvl-2">
<p>Step4：对查询日志进行搜索以确定不同时与𝑠出现，但与某一中介关键词同时出现的竞争性关键词集合，然后计算每个关键词的竞争度。</p>
</li>
<li class="lvl-2">
<p>Step5: 对所有计算得到的竞争性关键字按照竞争度大小进行降序排列。</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213210934536.png" alt="image-20230213210934536"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>❓问题：该方法的时间复杂度和空间复杂度是多少？</p>
</li>
</ul>
<h3 id="第七章">第七章</h3>
<h5 id="1-理解搜索引擎分类及其原理">1、理解搜索引擎分类及其原理。</h5>
<p>搜索引擎分类：</p>
<ol>
<li class="lvl-3">
<p>全文搜索引擎：</p>
<ul class="lvl-2">
<li class="lvl-5">原理：全文搜索引擎是从互联网提取各个网站的信息（以网页文字为主），建立起数据库，并能检索与用户查询条件相匹配的记录，按一定的排列顺序返回结果。</li>
<li class="lvl-5">典型例子：百度、谷歌Google</li>
<li class="lvl-5">特点：<mark>搜全率比较高</mark></li>
</ul>
</li>
<li class="lvl-3">
<p>目录搜索引擎：</p>
<ul class="lvl-2">
<li class="lvl-5">原理：将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li>
<li class="lvl-5">典型例子：</li>
<li class="lvl-5">特点：<mark>查找的准确率比较高</mark></li>
</ul>
</li>
<li class="lvl-3">
<p>元搜索引擎：</p>
<ul class="lvl-2">
<li class="lvl-5">原理：元搜索引擎（Meta Search Engine）接受用户查询请求后，同时在多个搜索引擎上搜索，并将结果返回给用户。</li>
<li class="lvl-5">典型例子：360搜索、InfoSpace、Dogpile、Vivisimo等</li>
<li class="lvl-5">特点：</li>
</ul>
</li>
<li class="lvl-3">
<p>垂直搜索引擎：</p>
<ul class="lvl-2">
<li class="lvl-5">原理：不同于通用的网页搜索引擎，垂直搜索专注于特定的搜索领域和搜索需求（例如：机票搜索、旅游搜索、生活搜索、小说搜索、视频搜索等等），在其特定的搜索领域有更好的用户体验。</li>
<li class="lvl-5">典型例子：</li>
<li class="lvl-5">特点：<mark>垂直搜索需要的硬件成本低、用户需求特定、查询的方式多样</mark></li>
</ul>
</li>
</ol>
<h5 id="2-理解搜索引擎的各组成部分">2、理解搜索引擎的各组成部分。</h5>
<p>搜索引擎的各组成部分：</p>
<ol>
<li class="lvl-3">
<p>搜索器：其功能是在互联网中漫游，发现和搜集信息</p>
</li>
<li class="lvl-3">
<p>索引器：其功能是理解搜索器所搜索到的信息，从中抽取出索引项，用于表示文档以及生成文档库的索引表</p>
</li>
<li class="lvl-3">
<p>检索器：其功能是根据用户的查询在索引库中快速检索文档，进行相关度评价，对将要输出的结果排序，并能按用户的查询需求合理反馈信息</p>
</li>
<li class="lvl-3">
<p>用户接口（HTML页面）：其作用是接纳用户查询、显示查询结果、提供个性化查询项</p>
</li>
</ol>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213212208109.png" alt="image-20230213212208109"></p>
<h5 id="3-理解网络蜘蛛的基本原理">3、理解网络蜘蛛的基本原理。</h5>
<p>1️⃣网络蜘蛛的基本原理：</p>
<ol>
<li class="lvl-3">
<p>网络蜘蛛是通过网页的链接地址来寻找网页，从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，这样一直循环下去，直到把这个网站所有的网页都抓取完为止。</p>
</li>
<li class="lvl-3">
<p>蜘蛛是一种半自动的程序，就象现实当中的蜘蛛在它的Web（蜘蛛网）上旅行一样，蜘蛛程序也按照类似的方式在Web链接织成的网上旅行。</p>
</li>
<li class="lvl-3">
<p>它总是需要一个初始链接（出发点），但此后的运行情况就要由它自己决定了，蜘蛛程序会扫描起始页面包含的链接，然后访问这些链接指向的页面，再分析和追踪那些页面包含的链接。</p>
</li>
<li class="lvl-3">
<p>从理论上看，最终蜘蛛程序会访问到Internet上的几乎每一个页面，因为Internet上几乎每一个页面总是被其他或多或少的页面引用。</p>
</li>
</ol>
<p>2️⃣在抓取网页的时候，网络蜘蛛一般有两种策略：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>广度优先：</p>
<ul class="lvl-2">
<li class="lvl-4">广度优先是指网络蜘蛛会<mark>先抓取起始网页中链接的所有网页</mark>，然后再选择其中的一个链接网页，继续抓取在此网页中链接的所有网页。</li>
<li class="lvl-4">优点：可以让网络蜘蛛并行处理，提高其抓取速度</li>
</ul>
</li>
<li class="lvl-2">
<p>深度优先：</p>
<ul class="lvl-2">
<li class="lvl-4">深度优先是指网络蜘蛛会从起始页开始，一个链接一个链接跟踪下去，处理完这条线路之后再转入下一个起始页，继续跟踪链接。</li>
<li class="lvl-4">优点：设计时比较容易</li>
</ul>
</li>
</ul>
<h5 id="4-理解不同类型分词方法及其难点">4、理解不同类型分词方法及其难点。</h5>
<ol>
<li class="lvl-3">
<p>基于词典的分词方法</p>
<ul class="lvl-2">
<li class="lvl-5">按照一定策略将待分析的汉字串与一个词典中的词条进行匹配，若在词典中找到该字符串，则匹配成功。</li>
<li class="lvl-5">最大匹配法(Maximum Matching, MM)——有词典切分、机械切分
<ul class="lvl-4">
<li class="lvl-7">正向最大匹配算法(Forward MM, FMM)</li>
<li class="lvl-7">逆向最大匹配算法(Reverse MM, RMM)</li>
<li class="lvl-7">双向最大匹配算法(Bi-directional, BMM)</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>基于统计的分词方法</p>
<ul class="lvl-2">
<li class="lvl-5">把每个词看做是由词的最小单位各个字总成的，<u><em>如果相连的字在不同的文本中出现的次数越多，就证明这相连的字很可能就是一个词。</em></u></li>
<li class="lvl-5">可以利用字与字相邻出现的频率来反应成词的可靠度，<u><em>统计语料中相邻共现的各个字的组合的频度，当组合频度高于某一个临界值时，便可认为此字组可能会构成一个词语。</em></u></li>
</ul>
</li>
<li class="lvl-3">
<p>基于理解的分词方法</p>
<ul class="lvl-2">
<li class="lvl-5">基于理解的分词方法是通过让计算机模拟人对句子的理解，达到识别词的效果。</li>
<li class="lvl-5">基本思想：就是在分词的同时进行句法、语义分析，利用句法信息和语义信息来处理歧义现象。</li>
<li class="lvl-5">通常包括三个部分：<u>分词子系统、句法语义子系统、总控部分</u></li>
</ul>
</li>
</ol>
<p>中文分词的难点：</p>
<ol>
<li class="lvl-3">
<p>歧义识别</p>
</li>
<li class="lvl-3">
<p>新词（未登录词）识别</p>
</li>
</ol>
<h5 id="5-pagerank算法">5、PageRank算法。</h5>
<p>基本思想：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可度越高的网页越重要，即<mark>反向链接（入链）(backlink)越多的网页越重要</mark></p>
</li>
<li class="lvl-2">
<p>反向链接的源网页质量越高，<mark>被这些高质量网页的链接指向的网页越重要</mark></p>
</li>
<li class="lvl-2">
<p><mark>链接数越少的网页越重要</mark></p>
</li>
</ul>
<p>算法思想：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213213920468.png" alt="image-20230213213920468"></p>
<p>例子：</p>
<p>步骤1：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213214051007.png" alt="image-20230213214051007"></p>
<p>步骤2：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213214242309.png" alt="image-20230213214242309"></p>
<p>步骤3：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213214354801.png" alt="image-20230213214354801"></p>
<blockquote>
<p>Web图：</p>
<p>如果将一个网页抽象成一个节点，而将网页之间的链接理解为一条有向边，则可以把整个互联网抽象为一个包含页面节点和节点之间联系边的有向图，称之为Web图。</p>
<p>入链与出链：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>出链：自己网页到别的网页</p>
</li>
<li class="lvl-2">
<p>入链：别的网页到自己网页</p>
</li>
<li class="lvl-2">
<p>外链：来源于/去往别的网站的别的网页</p>
</li>
<li class="lvl-2">
<p>内链：来源于/去往本网站的别的网页</p>
</li>
<li class="lvl-2">
<p>反向链接=入链</p>
<ul class="lvl-3">
<li class="lvl-4">A→B是A的出链， D→A是A的入链</li>
</ul>
</li>
</ul>
<p>锚文字：</p>
<p>所谓锚文字，就是页面内某个出链附近的一些描述文字。</p>
</blockquote>
<p><u><em><strong><span style="color: red;">课后学习：</span></strong></em></u></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213214439823.png" alt="image-20230213214439823"></p>
<h3 id="第八章">第八章</h3>
<h5 id="1-理解seo相关术语">1、理解SEO相关术语。</h5>
<p>SEO (Search Engine Optimization)，译为<mark>搜索引擎优化</mark></p>
<p>SEO相关术语：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PV (Page View)：<u><em>PV是用户访问网站时所浏览的总网页数</em></u></p>
</li>
<li class="lvl-2">
<p>百度快照：<u><em>百度蜘蛛在爬取网页内容时，将网页文本内容独立创建一个文本文件，保存在百度数据库中的网页的“照片”。</em></u></p>
</li>
<li class="lvl-2">
<p>SEO黑帽（SEO black hat）：<u><em>简单来说，SEO黑帽就是采用了搜索引擎所禁止的方法（作弊），对网站在搜索引擎的排名进行优化，在短时间内排到搜索引擎前列。</em></u></p>
</li>
<li class="lvl-2">
<p>SEO白帽（SEO white hat）：<u><em>白帽所指的是采用合理的SEO行为优化网站，提高用户的体验，合理与其他网站互联，从而达到网站在搜索引擎排名的稳步提升。</em></u></p>
</li>
<li class="lvl-2">
<p>跳出率：<u><em>是指来到网站只浏览了一个页面就离开的用户占网站总浏览用户的百分比。</em></u></p>
</li>
<li class="lvl-2">
<p>沙盒效应(Sandbox)：<u><em>指一个新建立的网站在刚上线的一个或几个月内，在搜索引擎上很难有好的排名，甚至没有排名。</em></u></p>
</li>
<li class="lvl-2">
<p>SPAM(Specially Processed Assorted Meat): <u><em>指专门针对那些欺骗搜索引擎的技术。搜索引擎垃圾技术是利用不道德的技巧去提高自己搜索引擎上的排名</em></u></p>
</li>
</ul>
<h5 id="2-熟悉seo常用的技术">2、熟悉SEO常用的技术。</h5>
<ol>
<li class="lvl-3">
<p>网页title的优化</p>
</li>
<li class="lvl-3">
<p>关键词的选取</p>
</li>
<li class="lvl-3">
<p>关键词的优化</p>
</li>
<li class="lvl-3">
<p>元标签及网页描述的优化</p>
</li>
<li class="lvl-3">
<p>网站结构和URL优化</p>
</li>
<li class="lvl-3">
<p>robots.txt文件</p>
</li>
<li class="lvl-3">
<p>网页链接的优化</p>
</li>
<li class="lvl-3">
<p>Heading标签的优化</p>
</li>
<li class="lvl-3">
<p>图片优化</p>
</li>
<li class="lvl-4">
<p>网页减肥</p>
</li>
</ol>
<p>SEO常用作弊方法：</p>
<ol>
<li class="lvl-3">
<p>桥页(Doorway Pages)</p>
</li>
<li class="lvl-3">
<p>关键词堆砌(Keyword Stuffing)</p>
</li>
<li class="lvl-3">
<p>隐藏文字(Hidden Text)</p>
</li>
<li class="lvl-3">
<p>隐藏链接(Hidden Link)</p>
</li>
<li class="lvl-3">
<p>隐藏页面(Cloaked Page)</p>
</li>
</ol>
<h5 id="3-能够编辑robots文件">3、能够编辑Robots文件。</h5>
<h3 id="第九章">第九章</h3>
<h5 id="1-熟悉关联分析方法-如apriori">1、熟悉关联分析方法，如Apriori。</h5>
<p>Apriori算法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个关联规则挖掘算法</p>
</li>
<li class="lvl-2">
<p><mark>频繁项集的子集也一定是频繁的</mark>，如果{A，B}是频繁项集，则{A}和{B}也一定是频繁项集</p>
</li>
<li class="lvl-2">
<p>从1到k（k项集）<mark>递归查找频繁项集</mark></p>
</li>
<li class="lvl-2">
<p>用得到的频繁项集生成关联规则</p>
</li>
<li class="lvl-2">
<p>首先我们需要求出最终频繁项集，即满足最小支持度的频繁k项集（k尽可能大）</p>
</li>
<li class="lvl-3">
<p>频繁项集主要通过迭代计算获取频繁k项集，迭代过程如下：<br>
1、计算候选区中k项集的支持度；<br>
2、通过枝剪过滤掉不满足最小支持度的项集，得到频繁k项集；<br>
3、通过全连接（或并操作）获取k+1项集；<br>
4、计算k+1项集的支持度，并将k+1项集移入候选区，令k=k+1；<br>
5、重复（1）。<br>
6、迭代终止条件为不存在k+1项集时，上次迭代的频繁k项集便是最终项集。</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213221003683.png" alt="image-20230213221003683"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在找到所有频繁项集之后，再根据这些频繁项集来确定关联规则，步骤如下：<br>
1、遍历所有的最终频繁项集，对于每个频繁项集A：</p>
<ul class="lvl-2">
<li class="lvl-4">求出A的所有非空真子集的集合U，对U中任意互补集X和Y，利用公式<br>
confidence(X-&gt;Y) = P(Y|X) = P(XY)/P(X)求出置信度c，如果c小于设置的最小置信度则舍弃，如果大于则保留</li>
</ul>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213221239021.png" alt="image-20230213221239021"></p>
<h6 id="习题：">习题：</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213221726958.png" alt="image-20230213221726958"></p>
<blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213220312446.png" alt="image-20230213220312446"></p>
<p>关联规则挖掘方法：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>设定最小支持度和置信度的阈值： minsup 和minconf</p>
</li>
<li class="lvl-2">
<p>目标：support ≥ minsup 且confidence ≥ minconf</p>
</li>
<li class="lvl-2">
<p><mark>找出所有的频繁项集</mark></p>
</li>
<li class="lvl-2">
<p><mark>由频繁项集产生强关联规则</mark></p>
</li>
</ul>
</blockquote>
<h5 id="2-熟悉分类与预测算法-如knn">2、熟悉分类与预测算法，如KNN。</h5>
<h6 id="习题：">习题：</h6>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213222035609.png" alt="image-20230213222035609"></p>
<h5 id="3-熟悉聚类分析算法-如k-means">3、熟悉聚类分析算法，如K- means。</h5>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230213222211203.png" alt="image-20230213222211203"></p>
<h5 id="4-结合实际电商案例-思考如何将数据挖掘技术应用于电商领域">4、结合实际电商案例，思考如何将数据挖掘技术应用于电商领域。</h5>
<p>电子商务中常用数据挖掘：</p>
<ol>
<li class="lvl-3">
<p>路径分析：</p>
<ol>
<li class="lvl-6">用于判断在一个Web站点中最频繁访问的路径，还有一些其他相关路径的信息也通过路径分析可以得到（例如路径访问序列）</li>
<li class="lvl-6"><mark>通过路径分析， 可以改进页面及网站结构的设计</mark></li>
</ol>
</li>
<li class="lvl-3">
<p>关联规则：</p>
<ol>
<li class="lvl-6">找到客户对网站上各种文件和资源之间访问的相互联系</li>
<li class="lvl-6"><mark>利用这些相关性， 可以更好的组织站点， 实施有效的市场策略</mark></li>
</ol>
</li>
<li class="lvl-3">
<p>序列模式：</p>
<ol>
<li class="lvl-6">与时间相关， 找到那些“ 一些项跟随另一个项” 的内部事务模式</li>
<li class="lvl-6"><mark>发现序列模式能够用于预测客户的访问模式， 对客户开展有针对性的广告和促销服务</mark></li>
</ol>
</li>
<li class="lvl-3">
<p>分类：</p>
<ol>
<li class="lvl-6">给出识别一个特殊群体的公共属性的描述</li>
<li class="lvl-6"><mark>得到分类后， 就可以进行适合某一类客户的商务活动</mark></li>
</ol>
</li>
<li class="lvl-3">
<p>聚类：</p>
<ol>
<li class="lvl-6">从Web访问信息数据中聚集出具有相似特性的那些客户</li>
<li class="lvl-6">==聚类顾客信息或数据项能够便于开发和执行未来的市场战略。==例如: 自动给一个特定的顾客聚类发送销售邮件等</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>电子商务应用</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>电子商务</tag>
      </tags>
  </entry>
  <entry>
    <title>16级电子商务试卷总结（部分）</title>
    <url>/2023/05/11/University/junior/course/electronic_commerce/16%E7%BA%A7%E8%AF%95%E5%8D%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>16级试卷总结（部分）</h1>
<h2 id="选择题">选择题</h2>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219174734639.png" alt="image-20230219174734639" style="zoom: 50%;" />
<ol>
<li class="lvl-3">
<p>长尾关键词(Long Tail Keyword)是指网站上的非<a href="https://baike.baidu.com/item/%E7%9B%AE%E6%A0%87%E5%85%B3%E9%94%AE%E8%AF%8D/7023941?fromModule=lemma_inlink">目标关键词</a>但与目标关键词相关的也可以带来搜索流量的组合型关键词。</p>
<ul class="lvl-2">
<li class="lvl-5">长尾关键词的特征是比较长，往往是2-3个词组成，甚至是短语，存在于内容页面，除了内容页的标题，还存在于内容中。 搜索量非常少，并且不稳定。 长尾关键词带来的客户，转化为<a href="https://baike.baidu.com/item/%E7%BD%91%E7%AB%99%E4%BA%A7%E5%93%81/5318548?fromModule=lemma_inlink">网站产品</a>客户的概率比<a href="https://baike.baidu.com/item/%E7%9B%AE%E6%A0%87%E5%85%B3%E9%94%AE%E8%AF%8D/7023941?fromModule=lemma_inlink">目标关键词</a>高很多，因为长尾词的<a href="https://baike.baidu.com/item/%E7%9B%AE%E7%9A%84%E6%80%A7/56032889?fromModule=lemma_inlink">目的性</a>更强。 存在大量长尾关键词的大中型网站，其带来的总流量非常大。例如，目标关键词是服装，其长尾关键词可以是男士服装、<a href="https://baike.baidu.com/item/%E5%86%AC%E8%A3%85/10065107?fromModule=lemma_inlink">冬装</a>、户外<a href="https://baike.baidu.com/item/%E8%BF%90%E5%8A%A8%E8%A3%85/7516107?fromModule=lemma_inlink">运动装</a>等。长尾关键词基本属性是：可延伸性，针对性强，范围广。长尾关键词是<a href="https://baike.baidu.com/item/%E9%95%BF%E5%B0%BE%E7%90%86%E8%AE%BA/1002?fromModule=lemma_inlink">长尾理论</a>在关键词研究上的延伸。“长尾”具有两个特点：细和长。细，说明长尾是份额很少的市场，在以前这是不被重视的市场；长，说明这些市场虽小，但数量众多。众多的微小市场累积起来就会占据市场中可观的份额——这就是长尾的思想。</li>
</ul>
</li>
<li class="lvl-3">
<p>被搜索引擎蜘蛛抓取的网页称为==<strong>网页快照</strong>==</p>
</li>
<li class="lvl-3">
<p>可以给一个须图提供多个访问入口，但要确保网站中的每一个网页都有独一无二的内容——SEO作弊：桥页</p>
</li>
<li class="lvl-3">
<p>域名规范的识别</p>
<ul class="lvl-2">
<li class="lvl-5">域名没有数字后缀，比如：<strong><a href="http://0731.86.info">0731.86.info</a>(错误的)</strong></li>
</ul>
</li>
<li class="lvl-3">
<p>被称为博客女王的是**<mark>徐静蕾</mark>**</p>
</li>
<li class="lvl-3">
<p>关键词密度：<u><em><strong><mark>指一个网页中某个词与所有文本之间的比例</mark></strong></em></u></p>
</li>
<li class="lvl-3">
<p>==<strong>细微文字</strong>==也是一种SEO的作弊方法</p>
<p>十、 禁止使用的非正规方法</p>
<p>1、桥页</p>
<blockquote>
<p>所谓桥页，就是利用软件生成大量包含关键词的网页，然后从这些网页自动转向到主页。目的是希望这些以不同关键词为目标的桥页在搜索引擎中得到好的排名。当用户点击搜索结果的时候，会自动转到主页。有时是在桥页上放上一个通往主页的链接，而不自动转向。大部分情况下，这些桥页都是由软件生成的。你可以想象，生成的文字是杂乱无章的，没有什么逻辑。如果是由人写出来的真正包含关键词的文章，就不是桥页了。</p>
</blockquote>
<p>2、关键词堆砌</p>
<blockquote>
<p>在网页中大量堆砌关键词，如标题，Tag、关键词标签、说明标签、文章内容页高度重复关键词等。</p>
</blockquote>
<p>3、隐藏文字</p>
<blockquote>
<p>隐藏文字是在网页的HTML文件中放上含有关键词的文字，但这些字不能被用户看到，只能被搜索引擎看到。隐藏文字的方法有背景色相同的隐藏，小字号隐藏(像素设置成1)，CSS隐藏(挂黑链常用此手段)等等。</p>
</blockquote>
<p>4、隐藏链接</p>
<blockquote>
<p>隐藏链接和隐藏文字相似，但是区别是把关键词放在链接里面，而这个链接也是用户所看不到的。</p>
</blockquote>
<p>5、隐藏页面</p>
<blockquote>
<p>有的网页使用程序或脚本来检测访问的是搜索引擎还是普通用户。如果是搜索引擎，网页就返回经过优化的网页版本。如果来访问的是普通人，返回的是另外一个版本。这种作弊方式，通常用户无法发现。因为一旦你的浏览器去看这个网页，无论是在页面上还是在HTML源文件中，你所得到的都已经是与搜索引擎看到的不同的版本。检测的方法是看一下这个网页的快照。</p>
</blockquote>
<p>6、细微文字</p>
<blockquote>
<p>许多做SEO的人士明白隐藏文字可能会遭到惩罚，所以就将本来隐藏的文字以细微的字体暴露出来。细微文字即使用微小的字体在网页不显眼的地方书写带有关键词的句子。一般这些文字放在网页的顶端或底部。这些文字的色彩虽然不像隐藏文字那样与背景使用相同颜色，但是经常以非常相近的颜色出现。在搜索引擎眼中，像“版权所有”这样的声明性的文字一般是用迷你字体来显示的。这些细微文字一般会被浏览者忽视，但是它们组成的句子会有滥用的嫌疑。</p>
</blockquote>
<p>7、障眼法</p>
<blockquote>
<p>障眼法就是我们常见的cloaking的中文意思，是指采用伪装网页的方式，先判断来访者是普通浏览者还是搜索引擎蜘蛛程序，从而展示不同的网页。这种黑帽SEO的方法是典型的欺骗搜索引擎的障眼法。搜索引擎看到的网页是一个优化非常严重的一篇内容，而浏览者看到的则是完全普普通通的内容。</p>
</blockquote>
<p>8、网页劫持</p>
<blockquote>
<p>网页劫持也就是我们经常所说的page jacking，是将别人的网站内容或者整个网站全面复制下来，偷梁换柱放在自己的网站上。这个黑帽SEO方法对网页内容极其匮乏的站长是有吸引力的。但是，这个做法是相当冒险的，更是为人所不齿的。搜索引擎的专利技术能从多个因素上来判断这个被复制的网页或网站不是原创，而不予以收录。</p>
</blockquote>
<p>9、购买的链接</p>
<blockquote>
<p>虽然在其他网站买广告是很正常的一件事，但有的时候如果所购买的广告链接纯粹是为了提高网页级别或为了操纵搜索引擎排名，也会被当做作弊手段。在怎样区别正常广告和作弊手段之间有一个很模糊的界限。但是这样做的人自己心里很清楚。如果你的网站被认为是通过购买链接来作弊，也没办法去和搜索引擎争辩。因为搜索引擎的决定就是最后的决定。当然更严重的是，如果你的网站是出卖链接的那个网站，你的麻烦就更大了。</p>
</blockquote>
</li>
</ol>
<h2 id="判断题">判断题</h2>
<ol>
<li class="lvl-3">
<p>可以通过在搜索引擎中输入site：网站域名来查着一个网站被搜索引擎收录的网页数量</p>
</li>
<li class="lvl-3">
<p>4Cs理论是由美国营销专家罗伯特·劳特朋教授针对4Ps营销理论存在的问题于1990年提出来的，即顾客(Customer)、成本(Cost)、便利(Convenience)、沟通（ Communication ）组成的营销手段——网络营销应用的是4Cs理论</p>
</li>
<li class="lvl-3">
<p>美国营销学学者杰罗姆·麦卡锡(Jerome McCarthy)教授在20世纪60年代提出了著名的4Ps营销组合策略，即产品（Product）、价格（Price）、渠道（Place）和促销（Promotion）组成的营销手段。</p>
</li>
</ol>
<h2 id="简答题">简答题</h2>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219211145917.png" alt="image-20230219211145917"></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219212348372.png" alt="image-20230219212348372" style="zoom:50%;" />
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219212447391.png" alt="image-20230219212447391"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219212735694.png" alt="image-20230219212735694"></p>
<h2 id="综合题">综合题</h2>
<p>1、<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219214808394.png" alt="image-20230219214808394"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230220181415474.png" alt="image-20230220181415474"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230220105419917.png" alt="image-20230220105419917"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230220105453770.png" alt="image-20230220105453770"></p>
<p>2、</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219214845830.png" alt="image-20230219214845830"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219215923540.png" alt="image-20230219215923540"></p>
<blockquote>
<ol>
<li class="lvl-3">
<p>2%-8%</p>
</li>
<li class="lvl-3">
<p>_（下划线）</p>
</li>
<li class="lvl-3">
<p>keywords</p>
</li>
<li class="lvl-3">
<p>description</p>
</li>
<li class="lvl-3">
<p>h1</p>
</li>
<li class="lvl-3">
<p>？</p>
</li>
<li class="lvl-3">
<p>同行业</p>
</li>
<li class="lvl-3">
<p>alt</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>可以使用<meta>标签的&quot;keywords&quot;属性来设置网页的关键词。这个属性可以在网页的<head>元素中添加，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php</span><br><span class="line">Copy code</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta name=&quot;keywords&quot; content=&quot;关键词1, 关键词2, 关键词3&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>
<p>可以使用<meta>标签的&quot;description&quot;属性来概括网页的主题内容。这个属性可以在网页的<head>元素中添加，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php</span><br><span class="line">Copy code</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta name=&quot;description&quot; content=&quot;这里填写网页主题内容的概括&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>
<h3 id="meta属性">meta属性</h3>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/tags/att_meta_charset.asp">charset</a></td>
<td style="text-align:left"><em>character_set</em></td>
<td style="text-align:left">规定 HTML 文档的字符编码。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/tags/att_meta_content.asp">content</a></td>
<td style="text-align:left"><em>text</em></td>
<td style="text-align:left">定义与 http-equiv 或 name 属性相关的元信息。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/tags/att_meta_http_equiv.asp">http-equiv</a></td>
<td style="text-align:left">content-security-policy content-type default-style refresh</td>
<td style="text-align:left">把 content 属性关联到 HTTP 头部。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/tags/att_meta_name.asp">name</a></td>
<td style="text-align:left">application-name author description generator keywords viewport</td>
<td style="text-align:left">把 content 属性关联到一个名称。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/tags/tag_meta.asp#meta_prop_scheme">scheme</a></td>
<td style="text-align:left">some_text</td>
<td style="text-align:left">定义用于翻译 content 属性值的格式。</td>
</tr>
</tbody>
</table>
</blockquote>
<p>3、</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219221524951.png" alt="image-20230219221524951" style="zoom:150%;" />
<blockquote>
<ol>
<li class="lvl-3">
<p>KNN算法流程：</p>
<ul class="lvl-3">
<li class="lvl-5">计算测试数据与各个训练数据之间的距离</li>
<li class="lvl-5">按照升序（从小到大）对距离（欧氏距离）进行排序</li>
<li class="lvl-5">选取距离最小的前k个点</li>
<li class="lvl-5">确定前k个点所在类别出现的频率</li>
<li class="lvl-5">返回前k个点中出现频率最高的类别作为测试数据的分类</li>
</ul>
</li>
<li class="lvl-3">
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219232432692.png" alt="image-20230219232432692"></p>
<p><mark>可以看出未知样本的性质为恶性</mark></p>
</li>
</ol>
</blockquote>
<p>4、</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230219222510192.png" alt="image-20230219222510192"></p>
<blockquote>
<ol>
<li class="lvl-3">
<p>因为ABCDEF，所以总共是6个项目，则d=6，根据公式关联规则总数**<mark>R=3<sup>d</sup>-2<sup>d+1</sup>+1</mark>**，得到R=602</p>
</li>
<li class="lvl-3">
<p>根据计算过程可以知道{ACDE}的四个3-项集都存在，{ACDE}为频繁项集，因此最大长度是4</p>
</li>
<li class="lvl-3">
<p>{ADE}、{CDE}支持度均为30%</p>
</li>
<li class="lvl-3">
<p>{DE}，支持度为50%</p>
</li>
<li class="lvl-3">
<p>根据置信度的公式{I1}<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>{I2}的置信度为（I1，I2）/I1，同样会有（I1，I2）/I2，根据题意两者相等，则有I1=I2，同时要保证I1与I2最大，所以：</p>
<table>
<thead>
<tr>
<th>I1</th>
<th>I2</th>
<th>置信度</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>D</td>
<td>50%</td>
</tr>
<tr>
<td>A</td>
<td>E</td>
<td>50%</td>
</tr>
<tr>
<td>D</td>
<td>E</td>
<td>50%</td>
</tr>
</tbody>
</table>
<p>补充（草稿）：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230220184910020.png" alt="image-20230220184910020"></p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>电子商务应用</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>电子商务</tag>
      </tags>
  </entry>
  <entry>
    <title>电商实验记录（个人）</title>
    <url>/2023/05/11/University/junior/course/electronic_commerce/%E7%94%B5%E5%95%86%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>电商实验记录</h1>
<h2 id="阶段一-二">阶段一、二</h2>
<h3 id="算法流程">算法流程</h3>
<ol>
<li class="lvl-3">
<p>首先通过dataPreprocess函数读取查询记录：user_tag_query.train文件，之后将搜索信息一行一行地存储到1_raws_words文件中；</p>
</li>
<li class="lvl-3">
<p>之后通过dataCleanWord函数读取1_raws_words文件中的数据，一行一行地判断是否是汉字，将所有字母数字以及特殊字符全部去除，只留下了中文汉字，将得到的结果按行存在2_without_useless_words文件中；（<mark>这里只保留汉字的做法是不对的，我之后会改</mark><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>去除链接）</p>
</li>
<li class="lvl-3">
<p>然后通过函数findRelatedWords读取2_without_useless_words文件中的数据，并根据种子关键词挑选出于种子关键词相关的搜索条目，同样按行存储在文件3_related_words中；</p>
</li>
<li class="lvl-3">
<p>又通过函数dataSegmention读取3_related_words中一行一行的数据，然后调用jieba库采用jieba的精确模式（jieba.cut()）对每一行中文文本信息进行分词，并存储到4_seg_words文件中；</p>
</li>
<li class="lvl-3">
<p>然后通过函数dataStopWord读取4_seg_words中的数据，并根据事先设定好的停用词列表，去除4_seg_words中的停用词，之后将结果存储在5_without_stopped_words文件中；</p>
</li>
<li class="lvl-3">
<p>之后就可以通过函数dataWordCounter对5_without_stopped_words文件中的数据进行词频统计，并按照降序方式存储到文件6_counts_words中；</p>
</li>
<li class="lvl-3">
<p>然后就能根据函数findMediKeywords找到权重最大（词频数最大）的前10个词作为中介关键词，并将结果按词频数降序存储到7_mediation_words文件中；</p>
</li>
<li class="lvl-3">
<p>最后就是计算竞争性comp测度：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-4">
<p>通过dataCompkey函数读取7_mediation_words文件中的数据，然后利用for循环将每一个中介关键词产生的与种子关键词具有竞争性的竞争关键词的候选集合以及竞争测度计算出来</p>
<ul class="lvl-2">
<li class="lvl-6">从2_without_useless_words文件中读取数据，然后对数据进行分析，找到包含中介关键词的搜索条目，并存储到8_with_mediation_words文件中；</li>
<li class="lvl-6">然后对得到的8_with_mediation_words文件内容进行分词、去除停用词、词频统计；</li>
<li class="lvl-6">最后从得到的11_with_counts_words文件中挑选出既不含种子关键词，也不含中介关键词同时保证词长度大于等于2的竞争关键词；</li>
</ul>
</li>
<li class="lvl-4">
<p>设定a、ka、sa并统计相应的搜索量，然后根据竞争度计算公式进行计算得到最后的竞争度；</p>
</li>
<li class="lvl-4">
<p>之后重复循环直到完成10个中介关键词的所有相关竞争关键词竞争度的计算，然后降序排序存入对应的文件中。</p>
</li>
</ul>
<h3 id="进一步优化">进一步优化</h3>
<p>当前存在的缺陷：</p>
<ol>
<li class="lvl-3">
<p>在数据处理阶段采用了一刀切的方式将除了汉字之外的所有的符号、链接等全部去除，但是就一般来说，有些字母符号以及英文缩写对分析是十分重要的；</p>
</li>
<li class="lvl-3">
<p>现有的分词方法采用的是jieba库，对于新词和歧义词的辨识较差；</p>
</li>
<li class="lvl-3">
<p>停用词列表有待扩充，现阶段只是设计了简单的单个词以及少量的两个词和三个词，但是实际情况应该是多字词都可能存在停用的可能<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span><mark>自动化词库</mark></p>
<ul class="lvl-2">
<li class="lvl-5">
<pre><code class="language-Python">stop_word_list = &#123;'\n', '\t', '\r', '为什么', '怎么办', '哪个', '之', '多少', '可以', '的', '与', '了', &quot;在&quot;,
                          '是', &quot;我&quot;, &quot;和&quot;, &quot;就&quot;, &quot;不&quot;, &quot;都&quot;, &quot;一&quot;, &quot;一个&quot;, &quot;上&quot;, &quot;也&quot;, &quot;很&quot;, &quot;到&quot;, &quot;说&quot;, &quot;要&quot;, &quot;去&quot;,
                          &quot;你&quot;, &quot;会&quot;, &quot;着&quot;, &quot;没有&quot;, &quot;看&quot;, &quot;好&quot;, &quot;自己&quot;, &quot;这&quot;, '呢', '怎样', '如何', '什么', '', ' ',
                          '怎么', '吗', '有'&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - </span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"># 一些分词的事例</span><br><span class="line">三国演义	小说	百度	云</span><br><span class="line">陈赫	玩	王者	荣耀</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ol>
<p>优化的方向和方法：</p>
<ol>
<li class="lvl-3">
<p>考虑根据词性进行分词操作，分析是否能够提升效率以及降低成本</p>
</li>
<li class="lvl-3">
<p>jieba库支持用户自己添加的词典：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span><mark>自动化词库</mark></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>在分词前通过<code>jieba.load_userdict(file_name)</code>来加载分词字典</p>
</li>
<li class="lvl-5">
<p>在每次启动项目时都需要重新加载个人词典（在对应的搜索类型上加载对应的词库即可）</p>
</li>
<li class="lvl-5">
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/yoyowin/p/12856964.html">python使用结巴分词(jieba)创建自己的词典/词库 - cknds - 博客园 (cnblogs.com)</a></p>
<p>参考之二：<a href="https://blog.csdn.net/qq_29202513/article/details/85236995">(77条消息) 解决jieba分词 load_userdict 加载自定义词库太慢的问题_10086_的博客-CSDN博客_jieba.load_userdict</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># jieba的缓存位置</span><br><span class="line">C:\Users\wgj\AppData\Local\Temp\jieba.cache</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-3">
<p>变体词识别和替换</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>定义：网络书写具有随意性、非正规性等特点。变体词就是网络语言作为一种不规范语言的显著特色, 人们往往出于避免审查、表达情感、讽刺、娱乐等需求将相对严肃、规范、敏感的词用相对不规范、不敏感的词来代替, 用来代替原来词的新词就叫做<strong>变体词(Morph)</strong> 。</p>
</li>
<li class="lvl-5">
<p>由于变体词的隐喻，导致需要将变体词的还原成本来的词语，避免对文义分析产生偏差</p>
</li>
<li class="lvl-5">
<p>例如：<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221021114639593.png" alt="image-20221021114639593"></p>
</li>
<li class="lvl-5">
<blockquote>
<p>参考：<a href="https://blog.csdn.net/wyq_wyj/article/details/81837353">(77条消息) 文本信息过滤中的变体词识别（一）_wuyijian_ml的博客-CSDN博客_变体词</a></p>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-3">
<p>不同搜索类型</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>可以为用户提供不同的关键词搜索类型，不同的搜索类型将使用不同的常用词库来进行分词，提高种子关键词的相关竞争性关键词的准确率</p>
<ul class="lvl-4">
<li class="lvl-8">例如：用户选择饮食相关的搜索类型时可以使用对应的常用词库（**词条样例：**土豆、火锅、意大利面、果佳、猴头菇……），如此提高结果的准确率</li>
</ul>
</li>
<li class="lvl-5">
<p>搜索类型：</p>
<ul class="lvl-4">
<li class="lvl-8">饮食</li>
<li class="lvl-8">汽车</li>
<li class="lvl-8">电商</li>
<li class="lvl-8">医学</li>
<li class="lvl-8">法律</li>
<li class="lvl-8">动植物</li>
<li class="lvl-8">地域（中国、意大利、德国……）</li>
</ul>
</li>
<li class="lvl-5">
<blockquote>
<p>词库参考：<a href="http://thuocl.thunlp.org/#%E5%9C%A8%E7%BA%BF%E6%BC%94%E7%A4%BA">THUOCL：清华大学开放中文词库 (thunlp.org)</a></p>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-3">
<p>jieba库支持4种分词模式（扩展分词模式的选择？）</p>
<ul class="lvl-2">
<li class="lvl-5">精确模式：试图将句子最精确地切开，适合文本分析；</li>
<li class="lvl-5">全模式：把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义</li>
<li class="lvl-5">搜索引擎模式：在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词</li>
<li class="lvl-5">paddle模式：利用PaddlePaddle深度学习框架，训练序列标注（双向GRU）网络模型实现分词。同时支持词性标注。（应该是百度提供的分词模型）</li>
</ul>
</li>
</ol>
<blockquote>
<p><u>老师建议</u>：词库要做成自动化的；<mark>每一个中介关键词都会产生多个竞争性关键词，不能简单地只取其中词频数最多的作为竞争关键词。</mark></p>
</blockquote>
<h2 id="阶段三">阶段三</h2>
<blockquote>
<p>关键词工具参考：</p>
<ol>
<li class="lvl-3">谷歌关键词工具：kwfinder、keywordtool</li>
<li class="lvl-3">网站流量、关键词分析：semrush</li>
</ol>
</blockquote>
<p>内容：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>软件系统概述</p>
<ul class="lvl-2">
<li class="lvl-4">竞争性关键词推荐系统</li>
</ul>
</li>
<li class="lvl-2">
<p>软件系统结构设计</p>
<ul class="lvl-2">
<li class="lvl-4">子系统之一：用户服务子系统</li>
<li class="lvl-4">子系统之二：分词算法子系统</li>
</ul>
</li>
<li class="lvl-2">
<p>功能模块设计</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>用户服务子系统</p>
<ul class="lvl-4">
<li class="lvl-6">用户管理模块（用户的登录注册以及信息修改等）</li>
<li class="lvl-6">文档管理模块（用于管理推荐输出的文档，可以查看历史文档并下载等、问卷的填写和问卷数据的查看）</li>
<li class="lvl-6">分词管理模块（用户可以选择多种分词方法，同时能够根据不同分词方法得到的结果进行比较；用户根据需要选择不同的搜索类型，提高结果的精确度）</li>
<li class="lvl-6">图表展示模块（用户能够查看得到的算法的效率曲线图、分词结果的反映竞争性程度的柱状图、展示的关键词的区域热度图）</li>
</ul>
</li>
<li class="lvl-4">
<p>分词算法子系统</p>
<ul class="lvl-4">
<li class="lvl-6">数据预处理模块（将原始数据处理成一行一行的形式存储到指定文件1中）</li>
<li class="lvl-6">分词处理模块（包含了从上一模块（预处理）的文件中查找包含了种子关键词的所有搜索条目并存储到指定文件2中、对文件2中的所有搜索条目进行分词处理并存储到文件3中）</li>
<li class="lvl-6">清洗与统计模块（包含将得到的文件3中所有词进行清除停用词处理以及变体词识别和替换处理、统计得到的所有词并按词频降序存入指定文件中、根据词频统计结果找到中介关键词）</li>
<li class="lvl-6">竞争度计算模块（计算comp测度，计算出每一个输入种子关键词的所有通过对应中介关键词联系起来的竞争关键词，并最后根据对应的竞争度降序输出呈现在前端）</li>
</ul>
</li>
<li class="lvl-4">
<p>补充：</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>停用词和常用词库会存在文件服务器上，数据库中存储相应的路径信息，管理员可以修改停用词和常用词库以达到更新的目的，用户可以增加自己的个人词典并提交存储到文件服务器上</p>
<ul class="lvl-6">
<li class="lvl-8">
<p><u>常用词库和自建个人词典的意义在于</u>：分词会将例如王者荣耀四个字分为王者和荣耀，在我们的认知中这四个字最好是作为一个整体，所以通过添加自建词典可以避免这样的问题；</p>
<ul class="lvl-8">
<li class="lvl-10">
<pre><code class="language-python"># 一些分词的事例
三国演义	小说	百度	云
陈赫	玩	王者	荣耀
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>数据库设计</p>
</li>
</ul>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221104101304242.png" alt="image-20221104101304242" style="zoom:50%;" />
<blockquote>
<p>系统设计参考：<a href="https://www.4xseo.com/thinking/3867/">一个完整推荐系统的设计实现-以百度关键词搜索推荐为例 - 思享SEO博客 (4xseo.com)</a></p>
<p>详细参考：<a href="http://www.semocean.com/">Semocean – 和自己赛跑的人</a></p>
</blockquote>
<p>在实践中， 一个完整的推荐系统会主要由3部分组成：</p>
<ol>
<li class="lvl-3">
<p>User Profile</p>
</li>
<li class="lvl-3">
<p>基础推荐挖掘算法</p>
</li>
<li class="lvl-3">
<p>Ranking</p>
</li>
</ol>
<p>user profile主要是用户（注册）信息，以及对用户反馈的信息进行处理，聚合，用于描述用户的特征； 是后续推荐和排序的基石。</p>
<h3 id="变体词的识别和替换实现思路">变体词的识别和替换实现思路</h3>
<blockquote>
<p>参考之一：<a href="https://www.codetd.com/article/2877964">文本信息过滤中的变体词识别（一） - 代码天地 (codetd.com)</a></p>
<p>参考之二：<a href="https://www.codetd.com/article/5172418">文本信息过滤中的变体词识别（二） - 代码天地 (codetd.com)</a></p>
</blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/20180819114636399" alt="img" style="zoom:50%;" />
<h2 id="阶段四">阶段四</h2>
<h5 id="基本功能：">基本功能：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>去停用词</p>
</li>
<li class="lvl-2">
<p>分词</p>
</li>
<li class="lvl-2">
<p>找到竞争关键词</p>
<ul class="lvl-2">
<li class="lvl-4">每个中介关键词会对应多个竞争性关键词</li>
</ul>
</li>
</ul>
<h5 id="拓展功能：">拓展功能：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>多样化搜索类型（……）✔️</p>
<ul class="lvl-2">
<li class="lvl-4"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221110162141456.png" alt="image-20221110162141456"></li>
</ul>
</li>
<li class="lvl-2">
<p>将拼音转换为汉字（还原原始数据信息的完善性）</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2">参考：<a href="https://www.cnblogs.com/acheng1011/p/15822080.html#">Python 将拼音和汉字互相转换 - Acheng1011 - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
</li>
<li class="lvl-2">
<p>中文繁简体互转✔️</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2">参考：<a href="https://github.com/berniey/hanziconv">berniey/hanziconv: Hanzi Converter for Traditional and Simplified Chinese (github.com)</a></li>
<li class="lvl-2">参考之二：<a href="https://github.com/skydark/nstools/tree/master/zhtools">nstools/zhtools at master · skydark/nstools (github.com)</a></li>
</ul>
</blockquote>
</li>
<li class="lvl-2">
<p>变体词的识别和替换？？？——<mark>可能无法实现，资源太少了</mark>❌</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221110162243614.png" alt="image-20221110162243614"></p>
<ol>
<li class="lvl-3">
<p><u>在数据清洗时就将变体词识别并替换掉</u>✔️</p>
</li>
</ol>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/wyq_wyj/article/details/81837353">(77条消息) 文本信息过滤中的变体词识别（一）_wuyijian_ml的博客-CSDN博客_变体词</a></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>别名的识别（包含了<u>数据的清洗以及繁体转简体功能</u>）——<mark>作为变体词的阉割功能</mark></p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2">参考：<a href="https://github.com/blmoistawinde/HarvestText/blob/master/examples/entity_discover/entity_discover.ipynb">HarvestText/entity_discover.ipynb at master · blmoistawinde/HarvestText (github.com)</a></li>
</ul>
</blockquote>
</li>
</ul>
<p><strong><u>可以考虑的功能：</u></strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>人名信息抽取</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221110171300648.png" alt="image-20221110171300648"></li>
<li class="lvl-2">参考：<a href="https://github.com/fighting41love/cocoNLP">fighting41love/cocoNLP: A Chinese information extraction tool. (github.com)</a></li>
</ul>
</blockquote>
</li>
<li class="lvl-2">
<p>智能客户</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221110170821923.png" alt="image-20221110170821923"></li>
<li class="lvl-2">参考：<a href="https://github.com/wangguijiepedeval/funNLP">wangguijiepedeval/funNLP: 中英文敏感词、语言检测 (github.com)</a></li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="性能方面的优化：">性能方面的优化：</h5>
<p>提前缓存：读结果</p>
<p>多线程</p>
<h2 id="关键词推荐系统设计">关键词推荐系统设计</h2>
<h3 id="功能方面：">功能方面：</h3>
<ol>
<li class="lvl-3">
<p>搜索（多种选择-分类搜索、多种分词方法、数据量选择、多线程、词库选择（系统或是用户：变体词库、常用词库、停用库、各种领域的词库）、是否考虑繁体中文（即：是否将繁体转换为简体））</p>
<ul class="lvl-2">
<li class="lvl-5">分类搜索：（动物、财经、交通、成语、地名、食物、IT、法律、历史名人、医疗、诗词）
<ul class="lvl-4">
<li class="lvl-7">首先在项目内部的/static/tmp下寻找是否有对应的词库，如果有则直接使用本地词库即可，如果没有说明是系统新增词库，这时再执行从文件服务器上下载词库的操作——<mark>提高效率</mark></li>
</ul>
</li>
<li class="lvl-5">多种分词方法（目前是jieba、ltp、HanTP）</li>
<li class="lvl-5">数据量选择（单位是……行）</li>
<li class="lvl-5">多线程（线程数选择）</li>
<li class="lvl-5">词库选择（变体词库、常用词库、停用库、各种领域的词库）</li>
<li class="lvl-5">是否考虑繁体中文（是否将繁体转换为简体）</li>
<li class="lvl-5">对字母不区分大小写（如：QQ与qq相同）</li>
<li class="lvl-5">用户指定一个中介关键词产生竞争性关键词的数量</li>
<li class="lvl-5">
</li>
</ul>
</li>
<li class="lvl-3">
<p>呈现结果（结果：以列表形式呈现，如果之前已经搜索过就直接从文件服务器上获取，用户自行设置是否发送文件到邮箱？）</p>
<ul class="lvl-2">
<li class="lvl-5">将所有文件放到文件服务器中，直接对文件服务器上的文件进行读写操作</li>
</ul>
</li>
<li class="lvl-3">
<p>查看词库（以列表形式呈现基本信息，用户可以选择下载-别人提供的词库等）</p>
</li>
<li class="lvl-3">
<p>上传用户词库（填表单（后端拿userid，用户填词库名称、词库的类型-自定义、词库的简介、是否共享），然后上传文件）</p>
</li>
<li class="lvl-3">
<p>展示分词方法的信息板块-丰富系统内容</p>
</li>
<li class="lvl-3">
<p>呈现所有的用户得到的结果（列表形式展现结果文件信息，可以选择下载）</p>
</li>
</ol>
<h3 id="性能优化方面：">性能优化方面：</h3>
<ol>
<li class="lvl-3">
<p>提前缓存：读已有结果（其他用户搜索过的结果）</p>
</li>
<li class="lvl-3">
<p>多线程</p>
</li>
</ol>
<h2 id="分词方法">分词方法</h2>
<blockquote>
<p>python分词中文分词包—分别是snownlp,thulac和pynlpir，最后再结合pyecharts以词云的方式显示最终分词结果</p>
</blockquote>
<h3 id="jieba✔">jieba✔️</h3>
<h3 id="ltp✔">ltp✔️</h3>
<blockquote>
<p>官方文档：<a href="https://pyltp.readthedocs.io/zh_CN/latest/api.html#id2">使用 pyltp — pyltp 0.2.0 文档</a></p>
</blockquote>
<h3 id="hantp✔">HanTP✔️</h3>
<blockquote>
<p>官网参考：<a href="https://www.hanlp.com/">HanLP官网</a></p>
<p>GitHub：<a href="https://github.com/hankcs/HanLP">hankcs/HanLP: 中文分词 词性标注 命名实体识别 依存句法分析 成分句法分析 语义依存分析 语义角色标注 指代消解 风格转换 语义相似度 新词发现 关键词短语提取 自动摘要 文本分类聚类 拼音简繁转换 自然语言处理 (github.com)</a></p>
<p>官方演示文档：<a href="https://hanlp.hankcs.com/demos/tok.html">中文分词 | 在线演示 (hankcs.com)</a></p>
<p>申请免费密钥：<a href="https://bbs.hanlp.com/t/hanlp2-1-restful-api/53">https://bbs.hanlp.com/t/hanlp2-1-restful-api/53</a></p>
<p>pyhanlp ：<a href="https://pypi.org/project/pyhanlp/0.1.26/">pyhanlp · PyPI</a></p>
</blockquote>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116002211509.png" alt="image-20221116002211509"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20221116002331227.png" alt="image-20221116002331227"></p>
<h3 id="none"></h3>
<blockquote></blockquote>
<h2 id="django框架">Django框架</h2>
<blockquote>
<p>参考：<a href="https://www.runoob.com/django/django-intro.html">Django 简介 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h3 id="工厂设计模式">工厂设计模式</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/Burgess_zheng/article/details/86762248">(77条消息) Python之23种设计模式_Burgess_zheng的博客-CSDN博客_python 设计模式</a></p>
</blockquote>
<p>重写（Override）是<mark>父类与子类之间多态性</mark>的一种表现。如果在<u>子类中定义某方法与其父类有相同的名称和参数</u>，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。</p>
<p>重载（Overload）是<mark>一个类中多态性</mark>的一种表现。如果在<u>一个类中定义了多个同名的方法，它们参数列表不同</u>，则称为方法的重载(Overload)</p>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>电子商务应用</category>
      </categories>
      <tags>
        <tag>电子商务</tag>
        <tag>课程实验</tag>
      </tags>
  </entry>
  <entry>
    <title>2023软件度量考点</title>
    <url>/2023/04/27/University/junior/course/software-metrics/2023%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E8%80%83%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>2023软件度量考点</h1>
<h3 id="textcolor-red-考试：软件生命周期"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：软件生命周期</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：软件生命周期}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：软件生命周期</span></span></span></span>⭐️</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230303153507082.png" alt="生命周期"></p>
<p>序列图（活动图）——高级基本控制结构：自递归调用、中断、并行三种</p>
<blockquote>
<p>需求分析：</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>功能点度量，大题</strong></li>
<li class="lvl-2">用例点度量</li>
<li class="lvl-2">size、Effort、cost、Schedule</li>
</ul>
<p>概要设计（模块）：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>内聚、耦合</p>
</li>
<li class="lvl-2">
<p>数据流结构度量</p>
</li>
</ul>
<p>详细设计：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>控制流结构度量</p>
</li>
<li class="lvl-2">
<p>数据结构度量，面向对象度量（CK，LK）。<strong>面向对象的度量会出大题</strong></p>
</li>
<li class="lvl-2">
<p>试运行、维护、质量度量</p>
</li>
</ul>
</blockquote>
<p><span style="color: red;">软件度量方法分为三种：</span></p>
<ol>
<li class="lvl-3">
<p>软件规模度量方法：这种方法旨在测量软件项目的规模，以便对开发工作量和项目时间表进行估计。通常使用<u><strong>行数、功能点数</strong></u>等指标来度量软件规模。</p>
</li>
<li class="lvl-3">
<p>软件复杂度度量方法：这种方法旨在测量软件系统的复杂性。软件复杂度通常包括模块之间的相互作用、代码结构、程序流程、数据结构等。通常使用<u><strong>代码行数、圈复杂度</strong></u>等指标来度量软件复杂度。</p>
</li>
<li class="lvl-3">
<p>软件质量度量方法：这种方法旨在测量软件系统的质量。软件质量通常包括正确性、可靠性、可用性、可维护性、可扩展性等方面。通常使用<u><strong>缺陷密度、代码可读性、代码复杂度</strong></u>等指标来度量软件质量。</p>
</li>
</ol>
<p><u><em><strong>助记部分（共27点）：</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>软件测试、测量、度量</p>
</li>
<li class="lvl-2">
<p>对实体属性的测量，度量点……</p>
</li>
<li class="lvl-2">
<p>软件度量的3p</p>
</li>
<li class="lvl-2">
<p>软件质量包括：功能性、可靠性……</p>
</li>
<li class="lvl-2">
<p>软件度量方法分为：软件规模、软件复杂性、软件质量……</p>
</li>
<li class="lvl-2">
<p>测量的目的：了解、预测、控制、提升……</p>
</li>
<li class="lvl-2">
<p>测量要明确的4个问题</p>
</li>
<li class="lvl-2">
<p>测量尺度</p>
</li>
<li class="lvl-2">
<p>测量方式分为：……</p>
</li>
<li class="lvl-2">
<p>什么是度量？……</p>
</li>
<li class="lvl-2">
<p>度量方式分为：……</p>
</li>
<li class="lvl-2">
<p>度量的3个实体</p>
</li>
<li class="lvl-2">
<p>度量的属性：内在、外在</p>
</li>
<li class="lvl-2">
<p>软件过程中的一些重要点</p>
</li>
<li class="lvl-2">
<p>Halstead预测法</p>
</li>
<li class="lvl-2">
<p>LOC度量</p>
</li>
<li class="lvl-2">
<p>各阶段涉及到的图</p>
</li>
<li class="lvl-2">
<p>设计方面</p>
<ul class="lvl-2">
<li class="lvl-4">功能点度量</li>
<li class="lvl-4">用例点度量</li>
<li class="lvl-4">对象点（OP）</li>
<li class="lvl-4">特征点</li>
</ul>
</li>
<li class="lvl-2">
<p>软件结构</p>
</li>
<li class="lvl-2">
<p>软件结构度量</p>
<ul class="lvl-2">
<li class="lvl-4">数据流结构</li>
<li class="lvl-4">控制流结构</li>
<li class="lvl-4">数据结构</li>
</ul>
</li>
<li class="lvl-2">
<p>控制结构度量</p>
</li>
<li class="lvl-2">
<p>面向对象度量</p>
<ul class="lvl-2">
<li class="lvl-4">LK 度量（4）</li>
<li class="lvl-4">CK 度量（6）</li>
<li class="lvl-4">MOOD 度量</li>
</ul>
</li>
<li class="lvl-2">
<p>软件代码度量</p>
</li>
<li class="lvl-2">
<p>数据结构度量</p>
</li>
<li class="lvl-2">
<p>软件质量模型</p>
</li>
<li class="lvl-2">
<p>软件错误、缺陷……</p>
</li>
<li class="lvl-2">
<p>软件质量度量</p>
</li>
</ul>
<h2 id="chapter-1">Chapter 1</h2>
<h3 id="textcolor-red-考试：iso-9126是专门针对软件质量的定义"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：</mtext><mi>I</mi><mi>S</mi><mi>O</mi><mtext> </mtext><mn>9126</mn><mtext>是专门针对软件质量的定义</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：ISO \ 9126是专门针对软件质量的定义}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">SO</span><span class="mspace" style="color:red;"><span style="color:red;"> </span></span><span class="mord" style="color:red;">9126</span><span class="mord cjk_fallback" style="color:red;">是专门针对软件质量的定义</span></span></span></span></h3>
<h4 id="软件质量模型"><mark>软件质量模型</mark></h4>
<p>软件质量模型：软件质量是**<u>软件产品的外部属性</u><strong>，而不是内部属性。软件质量的含义包括：要满足软件的</strong><u>功能需求</u><strong>且尽量不出错，要达到用户的期望且方便适用。<mark>软件质量的定义为</mark>：</strong><u>软件</u><strong>与<u><strong>明确的</strong></u>和<u><strong>隐含的</strong></u>定义的</strong><u>需求</u><strong><mark>相一致</mark>的程度，是<u><em>软件符合</em></u>明确的</strong><u>功能需求</u><strong>与</strong><u>性能需求</u><strong>，文档中有明确描述的</strong><u>开发标准</u><strong>以及所有专业开发的软件都应该具有的</strong><u>隐含特征</u>**的程度。</p>
<table>
<thead>
<tr>
<th>McCall 质量模型：</th>
<th><strong>Boehm 质量模型</strong>：</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422214221131.png" alt="image-20230422214221131"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422214130920.png" alt="image-20230422214130920"></td>
</tr>
<tr>
<td><strong>ISO 9126 质量模型</strong>：</td>
<td><strong>CMM 模型</strong>：</td>
</tr>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422214143616.png" alt="image-20230422214143616"></td>
<td>没有给出**<u>度量</u>**<u>软件质量</u>的<mark>框架</mark></td>
</tr>
</tbody>
</table>
<h2 id="chapter-3">Chapter 3</h2>
<h3 id="textcolor-red-考试：loc-代码行度量-简答题"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：</mtext><mi>L</mi><mi>O</mi><mi>C</mi><mtext>（代码行度量）简答题</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：LOC（代码行度量）简答题}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：</span><span class="mord mathnormal" style="color:red;">L</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">OC</span><span class="mord cjk_fallback" style="color:red;">（代码行度量）简答题</span></span></span></span></h3>
<p>代码行LOC：一般指所有的<u>可执行的源代码行数</u>，包括可交付的工作控制语句、数据定义、类型声明、输入输出声明等。</p>
<p><strong>常用的单位有 ：</strong><br>
①源代码行SLOC：有两种测量方法，一种是测量物理代码行<mark>PLOC</mark>，即注释外源程序行数；另一种是测量逻辑代码行<mark>LLOC</mark>，即可执行的源程序行数<br>
②非注释代码行<mark>NCLOC</mark><br>
③注释代码行<mark>CLOC</mark><br>
④千代码行<mark>KLOC</mark></p>
<p>Advantages of LOC</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>简单</u>且可<u>自动测量</u>，可以<u>直接反映</u>软件的<u>规模大小</u></p>
</li>
<li class="lvl-2">
<p>与<mark>程序</mark>的<u>工作量及成本</u>呈现正相关</p>
</li>
</ul>
<p>Disadvantage of LOC</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义模糊</p>
</li>
<li class="lvl-2">
<p>与程序语言相关</p>
</li>
<li class="lvl-2">
<p>与程序员的能力相关</p>
</li>
<li class="lvl-2">
<p>不适合于<u>早期阶段</u>对规模的<u><mark>预测</mark></u></p>
</li>
</ul>
<p>可以用代码行来<u><mark>间接得到</mark></u><u><strong>代码注释密度</strong></u>，可以一定程度上反映程序的<u><strong>可理解性</strong></u>、<u><strong>可修改性</strong></u>与<u><strong>可维护性</strong></u></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ρ</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>L</mi><mi>O</mi><mi>C</mi></mrow><mrow><mi>C</mi><mi>L</mi><mi>O</mi><mi>C</mi><mo>+</mo><mi>N</mi><mi>C</mi><mi>L</mi><mi>O</mi><mi>C</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\rho=\frac{C L O C}{C L O C+N C L O C}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">NC</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<p>LOC（line of code）</p>
<ul class="lvl-1">
<li class="lvl-2">缺点：定义模糊，与程序语言相关，与程序员的能力相关，不适合于早期阶段对规模的预测</li>
<li class="lvl-2">优点：可以自动测量，可以直接反映软件的规模大小，与程序的工作量及成本直接相关</li>
</ul>
</blockquote>
<h3 id="textcolor-red-考试：功能点度量有一个大题"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：功能点度量有一个大题</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：功能点度量有一个大题}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：功能点度量有一个大题</span></span></span></span></h3>
<p>功能点：由<strong>数据流图</strong>来测量，利用<strong>软件需求分析</strong>度量软件规模。向用户提供的功能分为<strong>数据功能</strong>和<strong>交易功能</strong>两种类型，前者包括 EIF 和 ILF，后者包括 EI，EO，EQ。功能点度量一般用 <strong>UFC</strong> 和 <strong>VAF</strong> 来计算，<mark>UFC</mark> 测量<u><strong>功能需求</strong></u>，<mark>VAF</mark> 测量<u><strong>非功能需求</strong></u>。</p>
<blockquote>
<p>软件的功能点是<u><strong>未调整功能计数</strong></u>（UFC）和<u><strong>价值调整因子</strong></u>（VAF）的乘积。</p>
<ul class="lvl-1">
<li class="lvl-2">UFC：Unadjusted Function Count</li>
<li class="lvl-2">VAF：Value Adjustment Factor</li>
</ul>
</blockquote>
<h5 id="1-ufc计算方法">1、UFC计算方法</h5>
<p>UFC 而言用下表来计算：</p>
<table>
<thead>
<tr>
<th>Weight Factor（右边为权重因子）</th>
<th><strong>Simple</strong></th>
<th><mark><strong>Average</strong></mark></th>
<th><strong>Complex</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Number of <strong>External Inputs</strong>  外部输入（EI）</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>Number of <strong>External Outputs</strong>  外部输出（EO）</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>Number of <strong>External Queries</strong>  外部查询（EQ）</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>Number of <strong>External Interfaces  Files</strong>  外部接口文件（EIF）</td>
<td>5</td>
<td>7</td>
<td>10</td>
</tr>
<tr>
<td>Number of <strong>Internal Logic  Files</strong>  内部逻辑文件（ILF）</td>
<td>7</td>
<td>10</td>
<td>15</td>
</tr>
</tbody>
</table>
<p>其中因为 Queries 相比于 Input，还需要考虑点击事件、查询后还必须由反馈信息，所以两者区分开来。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><u>外部输入</u>是指用户或其他系统向软件系统<u><strong>输入数据</strong></u>的功能，数据可以是单个数据项或数据集合。</p>
</li>
<li class="lvl-2">
<p><u>外部查询</u>是指软件系统向用户或其他系统<u><strong>提供查询结果</strong></u>的功能，查询结果可以是单个数据项或数据集合。</p>
</li>
</ul>
<blockquote>
<p><span style="color: red;"><u><em><strong>功能点度量方法中，需要测量程序的哪五个主要成分？</strong></em></u></span></p>
<ol>
<li class="lvl-3">外部输入（External Inputs，EI）：指用户或其他系统向软件系统<u><strong>输入数据</strong></u>的功能。例如，用户在一个电子商务系统中输入商品信息和订单信息就是外部输入。</li>
<li class="lvl-3">外部输出（External Outputs，EO）：指软件系统向用户或其他系统提供<u><strong>输出结果</strong></u>的功能。例如，在一个学生信息管理系统中，用户可以查询某个学生的信息，该查询结果就是外部输出。</li>
<li class="lvl-3">外部查询（External Inquiries，EQ）：指用户或其他系统<u><strong>查询</strong></u>软件系统中的<u><strong>数据</strong></u>的功能。例如，在一个银行系统中，用户可以查询自己的账户余额，该查询就是外部查询。</li>
<li class="lvl-3">外部接口文件（External Interface Files，EIF）：指软件系统与外部系统或组件之间进行<u><strong>数据交换</strong></u>的文件。例如，在一个在线支付系统中，<u>与第三方支付接口交换</u>的数据文件就是外部接口文件。</li>
<li class="lvl-3">内部逻辑文件（Internal Logical Files，ILF）：指软件系统<u><strong>内部维护</strong></u>的<u>数据文件</u>或<u>数据集合</u>，例如，在一个库存管理系统中，库存信息和供应商信息就是内部逻辑文件。</li>
</ol>
</blockquote>
<h5 id="2-vaf计算方法">2、VAF计算方法</h5>
<p>VAF 而言，一共 14 个指标，每个指标都有如下六个等级，计算时需要统计这 14 个指标的等级和，VAF∈[0.65, 1.35]：</p>
<p>0=factor not present or has no influence</p>
<p>1=insignificant influence</p>
<p>2=moderate influence</p>
<p>3=average influence</p>
<p>4=significant influence</p>
<p>5=strong influence</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">F</mi></mrow><mo>=</mo><mn>0.65</mn><mo>+</mo><mn>0.01</mn><mi mathvariant="normal">Σ</mi><msub><mi mathvariant="normal">F</mi><mi mathvariant="normal">i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="normal">U</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">C</mi></mrow><mo>×</mo><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">F</mi></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} &amp; \mathrm{VAF}=0.65+0.01 \Sigma \mathrm{F}_{\mathrm{i}} \\ &amp; \mathrm{FP}=\mathrm{UFC} \times \mathrm{VAF}\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathrm">VAF</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0.65</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0.01Σ</span><span class="mord"><span class="mord mathrm">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathrm">FP</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathrm">UFC</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathrm">VAF</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230425144329042.png" alt="image-20230425144329042" style="zoom:67%;" />
<p>计算得到FP值（<mark>功能点数</mark>）之后可以进行如下功能点度量：</p>
<p>1、生产能力</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mi>r</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>P</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>o</mi><mi>n</mi><mo>−</mo><mi>M</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Productivity = \frac{FP }{Person-Months}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">d</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">erso</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">FP</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<p>FP是指软件项目的总功能点数，Person-Months是指完成该项目所需的总人月数。</p>
</blockquote>
<p>2、每个功能点所需的平均文档页面数量</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>o</mi><mi>c</mi><mi>u</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mfrac><mrow><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>d</mi><mi>o</mi><mi>c</mi><mi>u</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><mrow><mi>F</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Documentation = \frac{pages \ of \ documentation}{FP}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">Doc</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">FP</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">es</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal">d</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<p>Pages of Documentation是指在软件开发过程中需要编写的文档总页数，FP是指软件项目的总功能点数。</p>
</blockquote>
<p><mark>功能点度量</mark>可以用于**<u>预测软件规模</u><strong>，</strong><u>计算缺陷密度</u><strong>，</strong><u>估算软件工作量</u><strong>，</strong><u>估算软件成本</u><strong>，</strong><u>计划开发时间</u><strong>，</strong><u>计划人员安排</u>**</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：简单（准确），早期，泛用性强</p>
</li>
<li class="lvl-2">
<p>缺点：主观，不直观</p>
</li>
</ul>
<blockquote>
<p>优点：</p>
<ol>
<li class="lvl-3">与代码行数等物理度量方法相比，功能点度量<u><strong>更为准确</strong></u>。这是因为功能点度量是基于软件系统的实际功能需求进行测量，而不是基于代码行数等技术细节进行测量。</li>
<li class="lvl-3">功能点度量可以在<u><strong>早期对规模进行度量</strong></u>。</li>
<li class="lvl-3">功能点度量可以<u><strong>用于不同编程语言和技术平台</strong></u>的软件项目。这是因为功能点度量与具体的编程语言和技术平台无关，而是基于软件系统的功能需求进行测量。</li>
<li class="lvl-3">功能点度量可以帮助管理者<u><strong>更好地了解</strong></u>软件项目的规模和开发工作量。这有助于管理者做出更明智的决策，并合理分配资源。</li>
</ol>
<p>缺点：</p>
<ol>
<li class="lvl-3">
<p><u><strong>功能点度量可能存在主观性和误差</strong></u>。<u>不同的评估人员</u>可能会对同一个软件系统<u>得出不同的功能点数</u>，这可能会影响度量的准确性和可信度。</p>
</li>
<li class="lvl-3">
<p><u><strong>功能点度量不能很直观地反映软件系统的复杂性和质量</strong></u>。虽然功能点度量可以帮助评估软件系统的规模和开发工作量，但它并不能很好地反映软件系统的复杂性和质量，这<u>需要使用其他软件度量方法</u>进行评估。</p>
</li>
</ol>
</blockquote>
<p>适合：<strong>数据处理较多的项目</strong></p>
<h3 id="textcolor-red-考试：用例点的度量"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：用例点的度量</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：用例点的度量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：用例点的度量</span></span></span></span></h3>
<ol>
<li class="lvl-3">
<p>复杂角色与简单角色的判断；（参考：UAW计算步骤下的角色权重评估表）</p>
</li>
<li class="lvl-3">
<p>是否有SLA；</p>
</li>
<li class="lvl-3">
<p>角色的权重（权重分析）</p>
</li>
</ol>
<p>用例点：用例图中包含的角色越多，用例越多，用户的需求功能也就越多，软件的规模也就越大。一般分为六个步骤：</p>
<p>①计算未调整前的角色权重 <strong><u>UAW</u></strong>：</p>
<table>
<thead>
<tr>
<th>角色权重评估表</th>
<th>计算示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230421221334589.png" alt="image-20230421221334589"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230421223414039.png" alt="image-20230421223414039" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
<p>②计算未调整前的用例权重 <strong><u>UUCW</u></strong>：一般来说，用例中包含的<strong>操作处理</strong>越多，或实现用例功能涉及的<strong>类</strong>越多，用例就越复杂。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>有以下 3 种评估方法：</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230421221455186.png" alt="image-20230421221455186"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>针对以上 3 种评估方法，分别由对应的用例权重评估表：</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230421221544169.png" alt="image-20230421221544169"></p>
<p>③计算未调整前的用例点 <strong><u>UUCP</u>=UAW+UUCW</strong></p>
<p>④计算技术复杂因子 <strong><u>TCF</u>=0.6+（0.01* TFactor）</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>技术复杂性因素权重表如下：</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230421221822400.png" alt="image-20230421221822400"></p>
<blockquote>
<p>每个 Ti 都有 0-5 六个等级，需要加权求。</p>
</blockquote>
<p>⑤计算环境因子 <strong><u>EF</u>=1.4+（-0.03*EFactor）</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>环境复杂性因素权重表如下：</p>
</li>
</ul>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230421222028278.png" alt="image-20230421222028278"></p>
<p><u>权重正负</u>表示环境对项目产生的影响是<strong>正影响</strong>还是<strong>负影响</strong>。每个 Fi 都有 0-5 六个等级，需要加权求和：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>𝑬</mi><mi>𝑭</mi><mi>𝒂</mi><mi>𝒄</mi><mi>𝒕</mi><mi>𝒐</mi><mi>𝒓</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>8</mn></munderover><msub><mi>F</mi><mi>i</mi></msub><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">𝑬𝑭𝒂𝒄𝒕𝒐𝒓 = \sum_{i=1}^{8}F_iW_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord boldsymbol" style="margin-right:0.11111em;">EFactor</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，Fi的值如下：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230421222820125.png" alt="image-20230421222820125" style="zoom: 67%;" />
<p>⑥计算调整后的用例点 <strong><u>UCP</u>=UUCP*TCF*EF</strong></p>
<p>最后可能会需要通过 <strong><u>UCP</u></strong> 计算开发工作量 <u><strong>Effort</strong></u>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>f</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo>=</mo><mi>U</mi><mi>C</mi><mi>P</mi><mo>∗</mo><mi>p</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>o</mi><msub><mi>n</mi><mrow><mi>h</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Effort = UCP*person_{hours}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">erso</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">rs</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p>一个用例点可能需要花费15-30 person-hours。</p>
</blockquote>
<p>一个用例点花费 15-30 人时/UCP</p>
<blockquote>
<p>补充：</p>
<p>（3）对象点：𝑶𝑷 = 𝑶𝑷 ∗ (𝟏 − 𝒓%)，其中r%表示的是<strong>从先前项目中重用的部分</strong></p>
<p>（4）特征点：以功能点为基础，还要考虑<strong>算法复杂度</strong>。</p>
</blockquote>
<blockquote>
<p>术语：</p>
<ul class="lvl-1">
<li class="lvl-2">SLA = Service Level Agreement = 服务质量/水平协议</li>
<li class="lvl-2">SLO = Service Level Objective = 服务质量/水平目标</li>
<li class="lvl-2">SLI = Services Level Indicator = 服务质量/水平指标</li>
</ul>
</blockquote>
<h3 id="textcolor-red-考试：计算uaw-未调整前的角色权重"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：计算</mtext><mi>U</mi><mi>A</mi><mi>W</mi><mtext>（未调整前的角色权重）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：计算UAW（未调整前的角色权重）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：计算</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">W</span><span class="mord cjk_fallback" style="color:red;">（未调整前的角色权重）</span></span></span></span></h3>
<p><mark>这里的内容详见用例点度量：</mark></p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/20230324141509.png" style="zoom:33%;" />
<p>角色复杂程度的判断：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单：通过接口连接的另一个系统；</p>
<ul class="lvl-2">
<li class="lvl-4">具有定义的应用程序编程接口的系统</li>
</ul>
</li>
<li class="lvl-2">
<p>普通：通过协议连接的另一个系统；</p>
<ul class="lvl-2">
<li class="lvl-4">一个普通的参与者要么是另一个通过协议如TCP/IP进行交互的系统，要么是一个人通过基于文本的界面如ASCII终端进行交互</li>
</ul>
</li>
<li class="lvl-2">
<p>复杂：通过人机交互界面进行交互的人。</p>
<ul class="lvl-2">
<li class="lvl-4">一个通过人机交互界面进行交互的人</li>
</ul>
</li>
</ul>
<blockquote>
<p><span style="color: red;">From Chapter 3 Page：54</span></p>
</blockquote>
<h5 id="span-style-color-blue-以上内容均来自chapter-3-span"><span style="color: blue;">—以上内容均来自Chapter 3—</span></h5>
<h2 id="chapter-4">Chapter 4</h2>
<h3 id="textcolor-red-考试：能够分清是什么样的耦合？"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：能够分清是什么样的耦合？</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：能够分清是什么样的耦合？}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：能够分清是什么样的耦合？</span></span></span></span></h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230414141237426.png" alt="image-20230414141237426" style="zoom:33%;" />
<h4 id="软件结构度量"><mark>软件结构度量</mark></h4>
<p><mark>软件结构度量</mark>：分布在概要设计、详细设计、编码、测试和质量维护。软件模块化与<u><strong>内聚、耦合、信息隐藏、信息流</strong>和<strong>扇入扇出</strong></u>有关。软件模块化以**<u>分治法</u><strong>为依据，<u><strong>程序是模块</strong>而</strong>模块不仅仅是程序**</u>，要求每个模块只完成软件需求中的**<u>独立子功能</u><strong>，并且与其他模块的</strong><u>联系最少</u><strong>且</strong><u>接口简单</u><strong>，模块化的度量标准有</strong><u>内聚性</u><strong>和</strong><u>耦合性</u><strong>，目标是</strong><u>高内聚、低耦合</u>**</p>
<h5 id="模块内聚性度量">模块内聚性度量</h5>
<p>（1） <mark>模块内聚性度量</mark>：是指完成同一任务时对模块**<u>各个组成部分的需要程度</u>**。根据内聚程度由高到低分别分为<u><strong>功能内聚</strong>、<strong>顺序内聚</strong>、<strong>通信内聚</strong>、<strong>过程内聚</strong>、<strong>时间内聚</strong>、<strong>逻辑内聚</strong>、<strong>偶然内聚</strong></u>。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>内聚率</mtext><mo>=</mo><mfrac><mtext>功能内聚模块数</mtext><mtext>总模块数</mtext></mfrac></mrow><annotation encoding="application/x-tex">内聚率 = \frac{功能内聚模块数}{总模块数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">内聚率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总模块数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">功能内聚模块数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<ol>
<li class="lvl-3">
<p>功能内聚：将所有<mark>完成同一功能的元素</mark>放到一个模块中，如<mark>输入输出处理模块、数据存储模块</mark>等。</p>
<ul class="lvl-3">
<li class="lvl-5">（强调模块内元素的功能相关性，意味着，模块中的所有元素都应该属于同一类别）</li>
<li class="lvl-5">例如，一个处理用户信息的模块应该包含所有与用户信息有关的元素，比如用户输入、用户验证、用户数据库查询等等。</li>
</ul>
</li>
<li class="lvl-3">
<p>顺序内聚：将一系列<u><strong>相互依赖的操作</strong></u>放到同一个模块中，这些操作<mark>必须按照<u><strong>特定的顺序</strong></u>依次执行</mark>。</p>
</li>
<li class="lvl-3">
<p>通信内聚：将需要<mark>进行<u><strong>相互通信</strong></u>的元素</mark>放到同一个模块中，例如消息处理器或邮件发送器等。</p>
</li>
<li class="lvl-3">
<p>过程内聚：将<u><strong>相关联的操作</strong></u>放到同一个模块中，在该模块内可以<mark>共享相同的数据结构和变量</mark>。</p>
</li>
<li class="lvl-3">
<p>时间内聚：将<mark>需要<u><strong>同时执行</strong></u>的操作</mark>放到同一个模块中，例如计时器或周期性任务调度器等。</p>
</li>
<li class="lvl-3">
<p>逻辑内聚：指模块内的<u>各个元素之间</u>存在一定的<u>逻辑关系</u>，这些元素共同完成一个特定的功能或者任务。</p>
<ul class="lvl-3">
<li class="lvl-5">（强调模块内元素的逻辑关系）</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="模块耦合性度量">模块耦合性度量</h5>
<p>（2） <mark>模块耦合性度量</mark>：模块耦合是指**<u>两个模块之间的相互依赖程度</u><strong>。可以利用系统中模块对的耦合性来计算全局的耦合性，一般来说，模块之间的联系越多，模块的调用关系越复杂，模块对的耦合性越高，系统的全局耦合性也就越高。根据耦合程度由低到高可以分为<u><strong>无耦合</strong>、<strong>数据耦合</strong>、<strong>标记耦合</strong>、<strong>控制耦合</strong>、<strong>公共耦合</strong></u>和</strong><u>内容耦合</u>**。</p>
<p>假设系统中的两个模块 x 和 y，两者的耦合关系记为 Ri。则：</p>
<p>①无耦合关系 R0：表示 x 和 y 无联系，完全独立</p>
<p>②数据耦合关系 R1：表示 x 和 y 通过**<u>参数</u><strong>发生联系，参数要么是</strong><u>数据元素</u><strong>要么是<u><strong>不含控制元素</strong></u>的</strong><u>同类数据项的集合</u>**</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个模块向另一个模块传入的参数是<u><strong>普通数据</strong></u>；</p>
</li>
<li class="lvl-2">
<pre><code class="language-cpp">sum (int a, int b)
&#123;
    int c;
    c=a+b;
    return(c);
&#125;
main()
&#123;
    int x, y;
    printf (sum(x, y)); //数据
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">③标记耦合关系 R2：表示通过参数表传递**&lt;u&gt;相同的记录类型&lt;/u&gt;**，这个类型==不是基本类型==， 是&lt;u&gt;**例如结构体、类这样的类型**&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">- 一个模块向另一个模块传入的参数是一个&lt;u&gt;**数据结构**&lt;/u&gt;(数组、记录、图、文件、对象等)；</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  Class Student ( ) // Student 类</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  StuInfo(Student Stu)</span><br><span class="line">  &#123; </span><br><span class="line">      string sno = Stu.getSno();</span><br><span class="line">      string name = Stu.getName();</span><br><span class="line">      string major = Stu.getMajor();</span><br><span class="line">      string cclass = Stu.getCClass();</span><br><span class="line">      string info = sno + name + mojor + cclass;</span><br><span class="line">      return(info);</span><br><span class="line">  &#125;</span><br><span class="line">  main()</span><br><span class="line">  &#123;</span><br><span class="line">      Student Tom = new Student ( ); // Student 对象</span><br><span class="line">      printf (StuInfo(Tom)); // 传入参数是对象</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<p>④控制耦合关系 R3：表示 x **<u>为了控制 y 的行为</u>**而向其传递了一个表示控制信息的参数。我们<u><em><strong>要尽量避免 R3，可以把 R3 通过分解功能转变为R1</strong></em></u></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个模块向另一个模块传入的参数是<u><strong>开关、标志或名字信息</strong></u>，其<u>作用</u>是明显<u>控制另一个模块的功能</u>；</p>
</li>
<li class="lvl-2">
<pre><code class="language-cpp">output (flag)
&#123;
    if (flag) //标志控制
    	printf (“Yes!”);
    else
    	printf (“No!”);
&#125;
main()
&#123;
    bool flag;
    output (flag); //标志
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">⑤公共耦合关系 R4：表示 x 和 y 都访问了一个**&lt;u&gt;公共数据环境&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">- ==公共耦合==是指两个或多个模块共享同一组&lt;u&gt;**全局数据**&lt;/u&gt;，而==数据耦合==是指两个或多个模块共享同一组&lt;u&gt;**局部数据**&lt;/u&gt;。</span><br><span class="line"></span><br><span class="line">⑥内容耦合关系 R5：表示 x 引用到了 y 的内部，当出现**&lt;u&gt;一个模块直接访问另一个模块的内部数据&lt;/u&gt;**或者**&lt;u&gt;一个模块不通过正常入口转到另一模块内部&lt;/u&gt;**或者**&lt;u&gt;两个模块有一部分程序代码重叠&lt;/u&gt;**或者**&lt;u&gt;一个模块有多个入口&lt;/u&gt;**，则表示发生了 R5</span><br><span class="line"></span><br><span class="line">结构化程序设计要尽量保证**&lt;u&gt;单入口单出口&lt;/u&gt;**，要**&lt;u&gt;避免使用 goto 语句&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">![image-20230422124255309](https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422124255309.png)</span><br><span class="line"></span><br><span class="line">局部耦合度：模块 x 和 y 之间的耦合紧密程度通过耦合度 **c(x,y)**来计算，</span><br><span class="line">$$</span><br><span class="line">𝒄(𝒙, 𝒚) = 𝒌 + \frac&#123;𝒏&#125;&#123;𝒏+𝟏&#125;</span><br><span class="line">$$</span><br><span class="line">，其中 k 是 x 和 y 之间**&lt;u&gt;最紧密的耦合关系 Rk&lt;/u&gt;**，n 是 x 和 y 之间的**&lt;u&gt;相互连接数&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">全局耦合度：C(S)是系统 S 中两两模块间&lt;u&gt;耦合度集合&lt;/u&gt;的**&lt;u&gt;中位数&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">&gt; &lt;span style=&quot;color: red;&quot;&gt;&lt;u&gt;***思考：如何消除控制耦合？如何修改上述控制耦合所示程序？***&lt;/u&gt;&lt;/span&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```cpp</span><br><span class="line">&gt; outputY //Yes控制程序</span><br><span class="line">&gt; &#123; </span><br><span class="line">&gt;     printf (“Yes!”);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; output //No控制程序</span><br><span class="line">&gt; &#123; </span><br><span class="line">&gt;     printf(“No!”);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; main()</span><br><span class="line">&gt; &#123;// 不再向另一个模块传递开关/标志等，由此更改了控制耦合</span><br><span class="line">&gt;     bool flag;</span><br><span class="line">&gt;     if (flag) //Yes控制逻辑</span><br><span class="line">&gt;     	outputY;</span><br><span class="line">&gt;     else //No控制逻辑</span><br><span class="line">&gt;     	outputN;</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote></blockquote>
<h5 id="信息流结构度量">信息流结构度量</h5>
<p>（3） <mark>信息流结构度量</mark>：一个模块**<u>调用</u><strong>另一个模块并且向它</strong><u>传递</u><strong>信息或者被调用模块向调用模块</strong><u>返回</u><strong>一个返回值就会产生信息流。模块中用于描述信息流的两个特殊属性是</strong><u>扇入</u><strong>和</strong><u>扇出</u><strong>。扇入指的是</strong><u>直接调用该模块的上级模块的个数</u><strong>，扇出指的是</strong><u>模块直接调用的下级模块的个数</u>**。</p>
<p>一个模块**<u>扇入大</u><strong>说明其</strong><u>可重用性高</u><strong>，一个模块的<u><strong>扇出大</strong></u>说明其</strong><u>复杂度高</u>**。扇入扇出不可过多或过少。</p>
<p><u><strong>信息流结构复杂性度量</strong></u>有两种方法：</p>
<p>①<strong>Henry-Kafura</strong>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信息流复杂性</mtext><mo stretchy="false">(</mo><mi>𝑴</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>长度</mtext><mo stretchy="false">(</mo><mi>𝑴</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mtext>扇入</mtext><mo stretchy="false">(</mo><mi>𝑴</mi><mo stretchy="false">)</mo><mo>∗</mo><mtext>扇出</mtext><mo stretchy="false">(</mo><mi>𝑴</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">信息流复杂性(𝑴) = 长度(𝑴) ∗ ( 扇入(𝑴) ∗ 扇出(𝑴))^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">信息流复杂性</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.17208em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">长度</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.17208em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">扇入</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.17208em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">扇出</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.17208em;">M</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>长度可以用**<u>代码行数</u>**来代替。</p>
<p>②<strong>Shepperd</strong>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信息流复杂性</mtext><mo stretchy="false">(</mo><mi>𝑴</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mtext>扇入</mtext><mo stretchy="false">(</mo><mi>𝑴</mi><mo stretchy="false">)</mo><mo>∗</mo><mtext>扇出</mtext><mo stretchy="false">(</mo><mi>𝑴</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">信息流复杂性(𝑴) = (扇入(𝑴) ∗ 扇出(𝑴))^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">信息流复杂性</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.17208em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">扇入</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.17208em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">扇出</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.17208em;">M</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这是一种**<u>纯信息流结构</u>的**算法。</p>
<p><mark>但是以上两种方法都有同一个问题：当某模块的扇入或者扇出为 0 时，复杂性也会是 0</mark></p>
<h3 id="textcolor-red-考试：程序控制流图-一个控制流结构大题"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：程序控制流图</mtext><mi mathvariant="normal">/</mi><mtext>一个控制流结构大题</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：程序控制流图/一个控制流结构大题}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">考试：程序控制流图</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">一个控制流结构大题</span></span></span></span></h3>
<p>圈(环形)复杂度、画程序流程图、理解圈复杂度的意义（反映出了什么，圈复杂度越大的话，这个程序代码坏味道）</p>
<table>
<thead>
<tr>
<th>PPT知识点位置（计算示例）</th>
<th>类型题</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407144813765.png" alt="image-20230407144813765" style="zoom: 33%;" /></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422110239187.png" alt="image-20230422110239187"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>补充：计算圈复杂度、、圈复杂度的意义、.程序流程图、反映出了什么，圈复杂度越大的话，这个程序是不是有一种代码坏味道啊</p>
</blockquote>
<hr>
<h4 id="控制结构度量"><mark>控制结构度量</mark></h4>
<p>控制结构度量：<strong><u>基本控制结构（BCSs）</u><strong>是一组用于创建程序逻辑结构的基本控制流机制， 包括<u><strong>条件</strong>、<strong>循环</strong>和</strong>顺序</strong></u>三种类型。而高级基本控制结构有<u><strong>自递归调用</strong>、<strong>中断</strong>、<strong>并行</strong></u>这三种， 可以通过面向对象设计中的**<u>活动图</u>**来反映。</p>
<p>控制流结构复杂性的度量可以用 **<u>McCabe’s <mark>圈复杂度</mark>度量</u>**来做。如果图 G 有 n 个顶点，e 条边，连通分量是 P，则</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>𝑽</mi><mo stretchy="false">(</mo><mi>𝑮</mi><mo stretchy="false">)</mo><mo>=</mo><mi>𝒆</mi><mo>−</mo><mi>𝒏</mi><mo>+</mo><mi>𝑷</mi></mrow><annotation encoding="application/x-tex">𝑽(𝑮) = 𝒆 − 𝒏 + 𝑷
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.07347em;">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord boldsymbol" style="margin-right:0.085em;">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord boldsymbol" style="margin-right:0.09426em;">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord boldsymbol" style="margin-right:0.0992em;">P</span></span></span></span></span></p>
<p>一般一个模块的圈复杂度不超过 <u><strong>10</strong></u>，数量表现为**<u>独立线性路径</u><strong>条数，也可以理解为覆盖所有可能情况使用最少的测试用例数，程序的可能错误与</strong><u>高的圈复杂度</u><strong>有着很大关系， 圈复杂度可以通过设计实现</strong><u>自动化</u><strong>的程序来计算，可以通过图论的方法计算</strong><u>判定节点</u><strong>来设计自动化程序。该方法最好是在</strong><u>详细设计阶段</u><strong>完成，用</strong><u>程序流程图</u><strong>和</strong><u>控制流图</u>**来度量。</p>
<blockquote>
<p><span style="color: red;"><u><em><strong>环形复杂度对于软件开发过程能起到哪些积极的作用？</strong></em></u></span></p>
<p>环形复杂度（圈复杂度）在软件开发过程中可以起到以下积极的作用：</p>
<ol>
<li class="lvl-3">
<p><mark>识别</mark>潜在问题：环形复杂度可用于<u>分析</u>代码中的<u>循环结构</u>，可以帮助开发人员<u>识别</u><mark>潜在的</mark><u><strong>性能问题</strong></u>、<u><strong>错误</strong></u>和<u><strong>代码逻辑混乱</strong></u>等。</p>
</li>
<li class="lvl-3">
<p><mark>改进</mark>代码质量：通过使用环形复杂度分析工具，开发人员可以<u>更好地了解</u>其代码的<u>复杂程度</u>并<u><strong>进行必要的优化和重构</strong></u>，以<u>提高代码质量和可维护性</u>。</p>
</li>
<li class="lvl-3">
<p><mark>提高</mark>程序性能：环形复杂度可用于分析程序中的循环结构，并确定需要优化的区域。这<u>有助于编写<strong>更有效率</strong>的代码，从而提高程序的<strong>执行速度</strong></u>。</p>
</li>
<li class="lvl-3">
<p><mark>预测</mark>系统行为：环形复杂度可用于<u><strong>预测系统行为</strong></u>，以便开发人员可以<u><strong>及早识别</strong></u>可能<u>导致系统<strong>故障</strong>或<strong>崩溃</strong></u>的问题，以便<u>及时进行修复</u>。</p>
</li>
</ol>
</blockquote>
<h2 id="chapter-5">Chapter 5</h2>
<h5 id="专有术语">专有术语</h5>
<p>LK度量：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CS (Class Size)</p>
</li>
<li class="lvl-2">
<p>NOO (Number of Operations Overridden)</p>
</li>
<li class="lvl-2">
<p>NOA (Number of Added)</p>
</li>
<li class="lvl-2">
<p>SI (Specialization Index)</p>
</li>
</ul>
<p>CK度量：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422012522763.png" alt="image-20230422012522763" style="zoom:50%;" />
<hr>
<h3 id="textcolor-red-考试：面向对象度量-解答题："><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：面向对象度量</mtext><mo>−</mo><mtext>解答题：</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：面向对象度量-解答题：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：面向对象度量</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">解答题：</span></span></span></span></h3>
<p>1、为什么要提出一套专门的面向对象的方法？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>封装性</p>
</li>
<li class="lvl-2">
<p>继承性</p>
</li>
<li class="lvl-2">
<p>多态性：体现在方法的重载和重写</p>
</li>
<li class="lvl-2">
<p>局部性</p>
</li>
</ul>
<blockquote>
<p>面向对象的软件的特性：继承性、多态性、封装性、局部性</p>
</blockquote>
<hr>
<p><mark>面向对象度量(OO metrics)方法</mark>：面向对象技术<mark>采用</mark><strong><u>抽象</u></strong>、<strong><u>封装</u></strong>、<strong><u>继承</u></strong>、<strong><u>多态</u></strong>、<strong><u>信息隐藏</u><strong>和</strong><u>重用性</u><strong>等来度量，对于子类规模的度量方法：计算子类</strong><u>在父类的基础上</u></strong>，增加了多少个属性和方法， 增加的越多，子类规模越大。</p>
<p>面向对象度量方法从五个方面来<mark>考虑</mark>：<u><strong>局部性</strong>、<strong>封装性</strong>、<strong>继承性</strong>、<strong>多态性</strong>和<strong>信息隐藏</strong></u></p>
<p><mark>主要有以下度量方法：</mark></p>
<h4 id="1-lk-度量法：考虑四个度量点">1、LK 度量法：考虑四个度量点</h4>
<p>①类规模度量 <strong><u>CS</u></strong>：从属性总数量和方法总数量两个点来考虑</p>
<p>②方法重写数 <u><strong>NOO</strong></u>：计算子类继承父类时**<u>重写父类方法的数量</u>**，NOO 过大表示父类抽象不够好</p>
<p>③增加方法数量 <u><strong>NOA</strong></u>：子类继承父类时**<u>增加的方法的数量</u>**，随着深度越深，NOA 越小越好</p>
<p>④特征化指数 <strong><u>SI</u></strong>：用来度量每一个子类在类图设计中的特征化等级，属于**<u>间接测量</u><strong>的综合属性，SI 过大说明</strong><u>类不符合抽象层次结构</u><strong>，体现了面向对象的<u><strong>抽象性</strong>和</strong>继承性**</u>。公式如下：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422010743473.png" alt="image-20230422010743473"></p>
<h4 id="2-ck-度量法：考虑六个度量点">2、CK 度量法：考虑六个度量点</h4>
<p><mark>（详细请见下一考点处：“考试：CK——LCOM：缺乏内聚”）</mark></p>
<h4 id="3-mood-度量法：考虑四类-六个度量点">3、MOOD 度量法：考虑四类，六个度量点</h4>
<p>①封装性度量点 MHF 和 AHF：方法、属性的隐藏程度</p>
<p>②继承性度量点 MIF 和 AIF：方法、属性的继承比例</p>
<p>③多态性度量点 PF：子类重写父类方法的比例</p>
<p>④消息传递度量点 CF：类间方法消息交互，表示耦合</p>
<h3 id="textcolor-red-考试：ck-lcom：缺乏内聚"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：</mtext><mi>C</mi><mi>K</mi><mtext>——</mtext><mi>L</mi><mi>C</mi><mi>O</mi><mi>M</mi><mtext>：缺乏内聚</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：CK——LCOM：缺乏内聚}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">K</span><span class="mord" style="color:red;">——</span><span class="mord mathnormal" style="color:red;">L</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">COM</span><span class="mord cjk_fallback" style="color:red;">：缺乏内聚</span></span></span></span></h3>
<table>
<thead>
<tr>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407141723134.png" alt="image-20230407141723134" style="zoom:33%;" /></th>
<th><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230407141427355.png" alt="image-20230407141427355" style="zoom: 50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>方法数增加，内聚数会不会陡然增加，LCOM缺乏内聚</p>
</blockquote>
<h4 id="ck-度量法：考虑六个度量点">CK 度量法：考虑六个度量点</h4>
<p>①类的加权方法 <strong><u>WMC</u></strong>：是对<strong>类规模</strong>和<strong>类复杂度</strong>的度量，设类有方法 M1~Mn，它们的复杂度分别为 C1~Cn，则</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>𝑾</mi><mi>𝑴</mi><mi>𝑪</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">𝑾𝑴𝑪 = \sum_{i=1}^nC_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord boldsymbol" style="margin-right:0.14208em;">WMC</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p>可以用**<u>圈复杂度</u><strong>来作为方法的复杂度，当 C1=C2=…Cn 时，</strong><u>将它们均记为 1</u>**</p>
<p>子类在计算 WMC 时<u><strong>只计算子类本身的方法数</strong></u></p>
<p>复杂度低的方法**<u>可以忽略不计</u>**或者设置为较小值</p>
</blockquote>
<p>②类的响应数量 <strong><u>RFC</u></strong>：计算一个类的对象对接受的消息进行<strong>响应的方法集合的数目</strong>， 是对<strong>类复杂性</strong>和<strong>类之间耦合度</strong>的一种度量。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi><mrow><mi mathvariant="bold-italic">R</mi><mi mathvariant="bold-italic">F</mi><mi mathvariant="bold-italic">C</mi></mrow></mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi><mrow><mi mathvariant="bold-italic">R</mi><mi mathvariant="bold-italic">S</mi></mrow></mi><mi mathvariant="normal">∣</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi><mrow><mi mathvariant="bold-italic">R</mi><mi mathvariant="bold-italic">S</mi></mrow></mi><mo>=</mo><mo stretchy="false">{</mo><mi mathvariant="bold-italic">M</mi><mo stretchy="false">}</mo><msub><mo>∪</mo><mtext>alli </mtext></msub><mrow><mo fence="true">{</mo><msub><mi mathvariant="bold-italic">R</mi><mi>i</mi></msub><mo fence="true">}</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered}
\boldsymbol{R F C}=|\boldsymbol{R S}| \\
\boldsymbol{R S}=\{\boldsymbol{M}\} \cup_{\text {alli }}\left\{\boldsymbol{R}_i\right\}
\end{gathered}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.06979em;">RFC</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.05382em;">RS</span></span></span><span class="mord">∣</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.05382em;">RS</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11424em;">M</span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∪</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">alli </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.00421em;">R</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p>{M}是类中方法的集合（包括<u><strong>继承来的</strong></u>），{Ri}是被类中第 i 个方法所调用的其他方法集合。</p>
</blockquote>
<p>③继承树的深度  <strong><u>DIT</u></strong>：计算某个类在系统类设计的继承树中<strong>最大深度</strong>，也就是<strong>最深层</strong>次。一般我们认为继承层次不要超过 <strong>6</strong></p>
<p>④子类数量 <strong><u>NOC</u></strong>：计算一个父类拥有多少个<strong>直接继承的子类</strong>，也是对继承性的度量。</p>
<p>⑤对象间的耦合度 <u><strong>CBO</strong></u>：用来计算一个类和其他类之间的耦合性，这里考虑的耦合关系只包括类之间的**<u>依赖、实现、关联、组合、聚合</u>**，<strong>不包括继承</strong>。</p>
<p>⑥类缺乏内聚性 <strong><u>LCOM</u></strong>：通过类中的属性和方法来衡量<strong>类中方法之间的相关性</strong>。高内聚要求一个模块承担一个单一职责。LCOM 越大则反映类设计存在缺陷，要考虑是否要将类中方法分解。</p>
<p>假设一个类中有 n 个方法 M1，M2…Mn，方法 Mi 使用的<u><em>实例变量集合</em></u>记作 Ii，因此 n个方法形成了 n 个集合I1，I2…In.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="bold-italic">P</mi><mo>=</mo><mrow><mo fence="true">{</mo><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold-italic">I</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="bold-italic">I</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo>∣</mo><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold-italic">I</mi><mi mathvariant="bold-italic">i</mi></msub><mo>∩</mo><msub><mi mathvariant="bold-italic">I</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><mi mathvariant="bold-italic">ϕ</mi><mo fence="true">}</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="bold-italic">Q</mi><mo>=</mo><mrow><mo fence="true">{</mo><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold-italic">I</mi><mi mathvariant="bold-italic">i</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="bold-italic">I</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo>∣</mo><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold-italic">I</mi><mi mathvariant="bold-italic">i</mi></msub><mo>∩</mo><msub><mi mathvariant="bold-italic">I</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo mathvariant="normal">≠</mo><mi mathvariant="bold-italic">ϕ</mi><mo fence="true">}</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi><mrow><mi mathvariant="bold-italic">L</mi><mi mathvariant="bold-italic">C</mi><mi mathvariant="bold-italic">O</mi><mi mathvariant="bold-italic">M</mi></mrow></mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="bold-italic">P</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi mathvariant="bold-italic">Q</mi><mi mathvariant="normal">∣</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="bold-italic">P</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi mathvariant="normal">∣</mi><mi mathvariant="bold-italic">Q</mi><mi mathvariant="normal">∣</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="bold-italic">P</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi mathvariant="bold-italic">Q</mi><mi mathvariant="normal">∣</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered}
\boldsymbol{P}=\left\{\left(\boldsymbol{I}_i, \boldsymbol{I}_j\right) \mid\left(\boldsymbol{I}_{\boldsymbol{i}} \cap \boldsymbol{I}_j\right)=\boldsymbol{\phi}\right\} \\
\boldsymbol{Q}=\left\{\left(\boldsymbol{I}_{\boldsymbol{i}}, \boldsymbol{I}_j\right) \mid\left(\boldsymbol{I}_{\boldsymbol{i}} \cap \boldsymbol{I}_j\right) \neq \boldsymbol{\phi}\right\} \\
\boldsymbol{L C O M}=\left\{\begin{array}{cc}
|\boldsymbol{P}|-|\boldsymbol{Q}|, &amp; |\boldsymbol{P}|&gt;|\boldsymbol{Q}| \\
0, &amp; |\boldsymbol{P}| \leq|\boldsymbol{Q}|
\end{array}\right.
\end{gathered}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.7em;vertical-align:-2.6em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1em;"><span style="top:-5.71em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.15972em;">P</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3353em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord boldsymbol mtight">i</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">ϕ</span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">Q</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3353em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord boldsymbol mtight">i</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3353em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord boldsymbol mtight">i</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">ϕ</span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span><span style="top:-2.1em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11424em;">LCOM</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.15972em;">P</span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord boldsymbol">Q</span></span></span><span class="mord">∣</span><span class="mpunct">,</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.15972em;">P</span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord boldsymbol">Q</span></span></span><span class="mord">∣</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.15972em;">P</span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord boldsymbol">Q</span></span></span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<table>
<thead>
<tr>
<th>Example 1</th>
<th>Example 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422010115544.png" alt="image-20230422010115544"></td>
<td><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422010134142.png" alt="image-20230422010134142"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><mark>LCOM = P集合的元素个数 - Q集合的元素个数</mark></p>
</blockquote>
<h3 id="textcolor-red-考试：dit会有一道大题-20或15分"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：</mtext><mi>D</mi><mi>I</mi><mi>T</mi><mtext>会有一道大题（</mtext><mn>20</mn><mtext>或</mtext><mn>15</mn><mtext>分）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：DIT会有一道大题（20或15分）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">会有一道大题（</span><span class="mord" style="color:red;">20</span><span class="mord cjk_fallback" style="color:red;">或</span><span class="mord" style="color:red;">15</span><span class="mord cjk_fallback" style="color:red;">分）</span></span></span></span></h3>
<blockquote>
<p><mark>这里应该是关于面向对象度量的大题：</mark></p>
<ol>
<li class="lvl-3">LK度量</li>
<li class="lvl-3">CK度量</li>
<li class="lvl-3">MOOD度量</li>
</ol>
</blockquote>
<p>CK：Depth of Inheritance Tree（DIT）</p>
<blockquote>
<p>继承树深度的计算：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230331154105008.png" alt="image-20230331154105008" style="zoom:50%;" />
<p>CBO的计算：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422211303572.png" alt="image-20230422211303572" style="zoom: 50%;" />
</blockquote>
<p><mark>类型题：</mark></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20230422011537076.png" alt="image-20230422011537076"></p>
<h2 id="chapter-6">Chapter 6</h2>
<h3 id="textcolor-red-考试：可靠性和可用性的区别"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>考试：可靠性和可用性的区别</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{考试：可靠性和可用性的区别}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">考试：可靠性和可用性的区别</span></span></span></span></h3>
<blockquote>
<p>考察软件的可靠性：每时间故障数</p>
</blockquote>
<p>可靠性（responsibility）——某段时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一段时间内能够正常使用</p>
</li>
</ul>
<p>可用性（reliability）——某个时刻（某个时间点）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>某一个时刻软件是否能够正常运行</p>
</li>
</ul>
<hr>
<p>（1） <mark>软件可靠性</mark>：软件产品在**<u>规定的条件下</u><strong>和</strong><u><mark>规定的时间区间</mark></u><strong>完成</strong><u>规定功能</u><strong>的能力。<u>条件</u>是直接与软件运行相关的</strong><u>计算机系统状态</u><strong>和</strong><u>软件输入条件</u><strong>，时间区间是软件的</strong>实际运行时间区间**，功能是<u>软件产品必须具备</u>的功能。软件可靠性与**<u>软件缺陷、系统输入、系统使用</u>**有关。一般有三种度量方法：</p>
<p>①**<u>故障率</u>**度量：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>λ</mi><mo>=</mo><mfrac><mtext> 总故障次数 </mtext><mtext> 总工作时间 </mtext></mfrac><mo>=</mo><mfrac><mi>n</mi><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\lambda=\frac{\text { 总故障次数 }}{\text { 总工作时间 }}=\frac{n}{\sum_{i=1}^n t_i}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">总工作时间</span><span class="mord"> </span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">总故障次数</span><span class="mord"> </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1016em;vertical-align:-0.994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.3057em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>, <u><strong>故障率</strong></u>表示<u>单位运行时间内</u>发生<u>故障的次数</u>。<br>
②**<u>平均故障间隔时间(MTBF)</u>**度量： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>B</mi><mi>F</mi><mo>=</mo><mfrac><mn>1</mn><mi>λ</mi></mfrac></mrow><annotation encoding="application/x-tex">M T B F=\frac{1}{\lambda}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MTBF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">λ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, 反映了软件的运行能力, 越大越好。</p>
<p>③**<u>平均维修时间(MTTR)</u>**度量： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi><mo>=</mo><mfrac><mtext> 总维修时间 </mtext><mtext> 维修次数 </mtext></mfrac><mo>=</mo><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>t</mi><mi>i</mi></msub></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>μ</mi></mfrac></mrow><annotation encoding="application/x-tex">M T T R=\frac{\text { 总维修时间 }}{\text { 维修次数 }}=\frac{\sum_{i=1}^n t_i}{n}=\frac{1}{\mu}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">MTTR</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> </span><span class="mord cjk_fallback mtight">维修次数</span><span class="mord mtight"> </span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> </span><span class="mord cjk_fallback mtight">总维修时间</span><span class="mord mtight"> </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.405em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.06em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.535em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">μ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, 反映了软件的修复能力。</p>
<p>（2）<mark>软件可用性</mark>：软件产品在<u>规定的条件下</u>和==<u><strong>规定的时间点</strong></u>==完成<u>规定功能</u>的能力。</p>
<p>（3）软件易用性：使用菜单和图形界面, 具有一致的用户界面, 提供丰富全面的错误信息, 具有结构良好的用户手册，实时提供软件帮助功能。可以用<u>任务有效性</u>度量。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext> Task Effectiveness </mtext><mo>=</mo><mfrac><mrow><mtext> 数量 </mtext><mo>∗</mo><mtext> 质量 </mtext></mrow><mn>100</mn></mfrac><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">\text { Task Effectiveness }=\frac{\text { 数量 } * \text { 质量 }}{100} \%
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord"> Task Effectiveness </span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">100</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">数量</span><span class="mord"> </span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">质量</span><span class="mord"> </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">%</span></span></span></span></span></p>
<p>（4）软件维护性：通过 <u><strong>平均维修时间（MTTR ）</strong></u>来度量，也可以用修复时间中位数度量。</p>
<p>（5）软件可移植性：指软件产品从一种环境迁移到另一种环境的能力</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext> 可移植性</mtext><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi>E</mi><mi>T</mi></mrow><mrow><mi>E</mi><mi>R</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{ 可移植性}=1-\frac{E T}{E R}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">可移植性</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">ER</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">ET</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>ET 是将系统移植到目标环境所需要的资源，ER 是未固定环境创建系统所需要的资源</p>
<h2 id="补充必要知识">补充必要知识</h2>
<h3 id="类之间的关系">类之间的关系</h3>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/s1mmons/p/15978698.html">设计模式：类之间的关系 - blakee - 博客园 (cnblogs.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大学</category>
        <category>大三</category>
        <category>软件度量及应用</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>软件度量</tag>
      </tags>
  </entry>
  <entry>
    <title>Vision Transformer基础</title>
    <url>/2023/11/02/University/AI/ModelLearning/Vision%20Transformer%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Vision Transformer基础</h1>
<h2 id="模型介绍">模型介绍</h2>
<blockquote>
<p>ViT原论文中最核心的结论是，<strong>当拥有足够多的数据进行预训练的时候，ViT的表现就会超过CNN</strong>，突破<strong>transformer缺少归纳偏置</strong>的限制，可以在下游任务中获得较好的迁移效果。</p>
<p>但是当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，因为Transformer和CNN相比缺少归纳偏置（inductive bias），即一种先验知识，提前做好的假设。CNN具有两种归纳偏置，一种是<strong>局部性</strong>（locality/two-dimensional neighborhood structure），即图片上相邻的区域具有相似的特征；一种是<strong>平移不变形</strong>（translation equivariance）， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(x))=g(f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span> ，其中g代表卷积操作，f代表平移操作。当CNN具有以上两种<u><strong>归纳偏置</strong></u>，就有了很多先验信息，需要<strong>相对少的数据就可以学习一个比较好的模型</strong>。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>Transformer相较于CNN结构，缺少一定的平移不变性和局部感知性，因此在数据量不充分时，很难达到同等的效果。具体表现为使用中等规模的ImageNet训练的Transformer会比ResNet在精度上低几个百分点。</p>
</li>
<li class="lvl-2">
<p>当有大量的训练样本时，结果则会发生改变。使用大规模数据集进行预训练后，再使用迁移学习的方式应用到其他数据集上，可以达到或超越当前的SOTA水平。</p>
</li>
</ul>
<h2 id="ViT的结构">ViT的结构</h2>
<blockquote>
<p>参考：</p>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://zhuanlan.zhihu.com/p/445122996">https://zhuanlan.zhihu.com/p/445122996</a></li>
<li class="lvl-2"><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/classification/ViT.html">https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/classification/ViT.html</a></li>
</ul>
</blockquote>
<p>ViT将输入图片分为多个patch（16x16），再将每个patch投影为固定长度的向量送入Transformer，后续encoder的操作和原始Transformer中完全相同。但是因为对图片分类，因此在输入序列中加入一个特殊的token，该token对应的输出即为最后的类别预测。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-5afd38bd10b279f3a572b13cda399233_r.jpg" alt="img"></p>
<h3 id="Patch-Position-Embedding">Patch+Position Embedding</h3>
<p>考虑到在Transformer结构中，输入是一个二维的矩阵，矩阵的形状可以表示为 (N,D)，其中 N是sequence的长度，而 D 是sequence中每个向量的维度。因此，在ViT算法中，首先需要设法将 H×W×C的三维图像转化为 (N,D)的二维输入。</p>
<p>ViT中的具体实现方式为：将 H×W×C的图像，变为一个 N×(P<sup>2</sup>∗C)的序列。这个序列可以看作是一系列展平的图像块，也就是将图像切分成小块后，再将其展平。该序列中一共包含了 N=HW/P<sup>2</sup>个图像块，每个图像块的维度则是 (P<sup>2</sup>∗C)。其中 <strong>P 是图像块的大小</strong>，<strong>C 是通道数量</strong>。经过如上变换，就可以将 N 视为sequence的长度了。</p>
<p>但是，此时每个图像块的维度是 (P<sup>2</sup>∗C)，而我们实际需要的向量维度是 D，因此我们还需要对图像块进行 Embedding。这里 Embedding 的方式非常简单，只需要对每个 (P<sup>2</sup>∗C)的图像块做一个<u><strong>线性变换</strong></u>，<strong>将维度压缩为D即可</strong>。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/VIT_pic2.png" alt="图2 图像分块嵌入示意图" style="zoom: 25%;" />
<p>例如：输入图片大小为224x224，将图片分为固定大小的patch，patch大小为16x16，则每张图像会生成224x224/16x16=196个patch，即输入序列长度为<strong>196</strong>，每个patch维度16x16x3=<strong>768</strong>，线性投射层的维度为768xN (N=768)，因此输入通过线性投射层之后的维度依然为196x768，即一共有196个token，每个token的维度是768。这里还需要加上一个特殊字符cls，因此最终的维度是<strong>197x768</strong>。到目前为止，已经通过patch embedding将一个视觉问题转化为了一个seq2seq问题。</p>
<h3 id="Encoder：Multi-Head-Attention">Encoder：Multi-Head Attention</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/VIT_pic3.png" alt="图3 多头注意力示意图" style="zoom:25%;" />
<p>Transformer 结构中最重要的结构就是 Multi-head Attention，即多头注意力结构。具有2个head的 Multi-head Attention 结构如下图所示。输入 a<sup>i</sup> 经过转移矩阵，并切分生成 q<sup>(i,1)</sup>、q<sup>(i,2)</sup>、k<sup>(i,1)</sup>、k<sup>(i,2)</sup>、v<sup>(i,1)</sup>、v<sup>(i,2)</sup>，然后 q<sup>(i,1)</sup>与 k<sup>(i,1)</sup>做 attention，得到权重向量 α，将 α 与 v<sup>(i,1)</sup>进行加权求和，得到最终的 b<sup>(i,1)</sup>(i=1,2,…,N)，同理可以得到 b<sup>(i,2)</sup>(i=1,2,…,N)。接着将它们拼接起来，通过一个线性层进行处理，得到最终的结果。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/Multi-head_Attention.jpg" alt="图4 多头注意力" style="zoom: 50%;" />
<p>其中，使用 q<sup>(i,j)</sup>、k<sup>(i,j)</sup>与 v<sup>(i,j)</sup>计算 b<sup>(i,j)</sup>(i=1,2,…,N)的方法是缩放点积注意力 (Scaled Dot-Product Attention)。 首先使用每个 q<sup>(i,j)</sup>去与 k<sup>(i,j)</sup>做 attention，这里说的 attention 就是<strong>匹配这两个向量有多接近</strong>，具体的方式就是计算向量的<strong>加权内积</strong>，得到 α(i,j)。这里的加权内积计算方式如下所示：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>q</mi><mn>1</mn></msup><mo>∗</mo><msup><mi>k</mi><mi>i</mi></msup><mi mathvariant="normal">/</mi><msqrt><mi>d</mi></msqrt></mrow><annotation encoding="application/x-tex">α(1,i)=q^1∗k^i/ \sqrt{d}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0585em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2311em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9811em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">d</span></span></span><span style="top:-2.9411em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0589em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>其中，d 是 q 和 k 的维度，因为 q∗k 的数值会随着维度的增大而增大，因此除以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>d</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1078em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">d</span></span></span><span style="top:-2.8922em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1078em;"><span></span></span></span></span></span></span></span></span> 的值也就相当于归一化的效果。</p>
<p>接下来，把计算得到的 α(i,j) 取 softmax 操作，再将其与 v(i,j) 相乘。</p>
<blockquote>
<p>多头注意力机制的<mark>详细计算过程</mark>参考：<a href="https://www.wgj.ink/2023/10/23/University/AI/ModelLearning/ChatGPT/Transformer%E5%9F%BA%E7%A1%80/#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6">Transformer基础</a></p>
</blockquote>
<h3 id="Encoder：MLP（多层感知机）">Encoder：MLP（多层感知机）</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/VIT_pic6.png" alt="图6 MLP多层感知机的结构" style="zoom:25%;" />
<p>多层感知机由<u><strong>输入层、输出层和至少一层的隐藏层</strong></u>构成。网络中各个隐藏层中神经元可接收相邻前序隐藏层中所有神经元传递而来的信息，经过加工处理后将信息输出给相邻后续隐藏层中所有神经元。在多层感知机中，相邻层所包含的神经元之间通常使用“全连接”方式进行连接。多层感知机可以模拟复杂非线性函数功能，所模拟函数的复杂性取决于网络隐藏层数目和各层中神经元数目。多层感知机的结构如下图所示。</p>
<img src="https://paddlepedia.readthedocs.io/en/latest/_images/MLP.png" alt="图7 多层感知机" style="zoom:33%;" />
<h3 id="DropPath">DropPath</h3>
<p>代码实现过程中还使用了<strong>DropPath</strong>（Stochastic Depth）来代替传统的<strong>Dropout结构</strong>，DropPath可以理解为<u><strong>一种特殊的Dropout</strong></u>。其作用是在训练过程中<strong>随机丢弃子图层</strong>（randomly drop a subset of layers），而在预测时正常使用完整的 Graph。</p>
<p>DropPath的主要优势在于它可以减少网络的复杂性，降低过拟合的风险，同时增加了网络的鲁棒性和泛化能力。</p>
<h3 id="细节：Class-Token">细节：Class Token</h3>
<p>假设我们将原始图像切分成 3×3共9个小图像块，最终的输入序列长度却是10，也就是说我们这里人为的增加了一个向量进行输入，我们通常将人为增加的这个向量称为 Class Token。那么这个 Class Token 有什么作用呢？</p>
<p>我们可以想象，如果没有这个向量，也就是将 N=9个向量输入 Transformer 结构中进行编码，我们最终会得到9个编码向量，可对于图像分类任务而言，我们应该选择哪个输出向量进行后续分类呢？因此，ViT算法提出了一个可学习的嵌入向量 Class Token，将它与9个向量一起输入到 Transformer 结构中，输出10个编码向量，然后用这个 Class Token 进行分类预测即可。</p>
<p>其实这里也可以理解为：ViT 其实只用到了 Transformer 中的 Encoder，而并没有用到 Decoder，而 Class Token 的作用就是寻找其他9个输入向量对应的类别。</p>
<h3 id="细节：Positional-Encoding">细节：Positional Encoding</h3>
<p>按照 Transformer 结构中的位置编码习惯，这个工作也使用了位置编码。不同的是，ViT 中的位置编码没有采用原版 Transformer 中的 sincos编码，而是直接设置为可学习的 Positional Encoding。对训练好的 Positional Encoding 进行可视化，如下图所示。我们可以看到，位置越接近，往往具有更相似的位置编码。此外，出现了行列结构，同一行/列中的 patch 具有相似的位置编码。</p>
<img src="https://paddlepedia.readthedocs.io/en/latest/_images/Positional_Encoding.png" alt="图9 Positional Encoding" style="zoom:33%;" />
<h3 id="细节：MLP-Head">细节：MLP Head</h3>
<p>得到输出后，ViT中使用了 MLP Head对输出进行分类处理，这里的 MLP Head 由 LayerNorm 和两层全连接层组成，并且采用了GELU激活函数。</p>
<h4 id="GELU激活函数">GELU激活函数</h4>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/liruihongbob/article/details/86510622">https://blog.csdn.net/liruihongbob/article/details/86510622</a></p>
</blockquote>
<p>Gaussian Error Linerar Units(GELUS)，GELUs其实是 dropout、zoneout、Relus的综合，GELUs对于输入乘以一个0,1组成的mask，而该mask的生成则是依概率随机的依赖于输入。假设输入为X, mask为m，则m服从一个伯努利分布(Φ(x) , Φ(x) = P( X &lt;= x ) , X服从标准正态分布)，这么选择是因为神经元的输入趋向于正态分布，这么设定使得当输入x减小的时候，输入会有一个更高的概率被dropout掉，这样的激活变换就会随机依赖于输入了。</p>
<p>数学表达如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mi>E</mi><mi>L</mi><mi>U</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>&lt;</mo><mo>=</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">GELU(x)=xP(X&lt;=x)=xΦ(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">GE</span><span class="mord mathnormal" style="margin-right:0.10903em;">LU</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">Φ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>这里Φ(x)是正态分布的概率函数，可以简单采用正态分布N(0,1), 要是觉得不刺激当然可以使用参数化的正态分布N(μ,σ), 然后通过训练得到μ,σ。</p>
<h2 id="模型特点">模型特点</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>作为CV领域最经典的 Transformer 算法之一，不同于传统的CNN算法，ViT尝试将标准的Transformer结构直接应用于图像，并对整个图像分类流程进行最少的修改。</p>
</li>
<li class="lvl-2">
<p>为了满足 Transformer 输入结构的要求，将整幅图像拆分成小图像块，然后把这些小图像块的线性嵌入序列输入到网络。同时，使用了Class Token的方式进行分类预测。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>经典模型</category>
        <category>Vision Transformer</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>经典模型</tag>
        <tag>Transformer</tag>
        <tag>ViT</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper Learning指南</title>
    <url>/2023/11/06/University/AI/PaperLearn/%E6%AF%8F%E6%97%A5%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Paper Learning</h1>
<blockquote>
<p>论文阅读学习指南</p>
</blockquote>
<h2 id="center-arxiv-center"><center><a href="https://arxiv.org/list/cs.CV/recent">arXiv</a></center></h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">链接：</label><a href="https://arxiv.org/list/cs.CV/recent">https://arxiv.org/list/cs.CV/recent</a></p>
</li>
</ul>
</blockquote>
<h2 id="center-cvf-center"><center><a href="https://openaccess.thecvf.com/menu">CVF</a></center></h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">链接：</label><a href="https://openaccess.thecvf.com/menu">https://openaccess.thecvf.com/menu</a></p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>格物致知</category>
      </categories>
      <tags>
        <tag>学习指南</tag>
        <tag>Paper Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Pix2seq：应用于目标检测的语言建模框架</title>
    <url>/2023/11/08/University/AI/PaperLearn/Pix2seq%EF%BC%9A%E5%BA%94%E7%94%A8%E4%BA%8E%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%9A%84%E8%AF%AD%E8%A8%80%E5%BB%BA%E6%A8%A1%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Pix2seq</h1>
<blockquote>
<p>论文原文：<a href="https://arxiv.org/abs/2109.10852">https://arxiv.org/abs/2109.10852</a></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/414791567">https://zhuanlan.zhihu.com/p/414791567</a></p>
</blockquote>
<h2 id="Abstract">Abstract</h2>
<p>Pix2seq将目标检测视为一个以观察到的像素输入为条件的语言建模任务。</p>
<p>目标描述（例如边界框和类别标签）以离散标记的序列形式表达，并训练一个神经网络来感知图像并生成所需的序列。我们的方法主要基于这样的直觉，即如果神经网络知道对象的位置和类别，那么我们只需要教它如何解读它们。</p>
<h2 id="Pix2seq架构">Pix2seq架构</h2>
<p>Pix2seq基于这样一种直觉，即如果神经网络知道对象在哪里以及是什么，我们只需教会它读取它们。通过“描述”对象的学习，模型可以学会将“语言”与像素观察结果联系起来，从而得到有用的对象表示。给定一张图像，Pix2seq模型产生与对象描述相对应的离散token序列。如下图所示。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231106163701374.png" alt="image-20231106163701374" style="zoom:50%;" />
<p>将目标检测视为在像素输入的条件下进行的语言建模任务，模型架构和损失函数通用而且相对简单，并未针对检测任务进行专门设计（<mark>泛用性好</mark>）。</p>
<h4 id="使用Pix2Seq进行检测任务">使用Pix2Seq进行检测任务</h4>
<p>首先提出了一种量化和序列化方案，将边界框和类别标签转化为离散token 的序列。</p>
<p>然后，我们利用编码器-解码器架构来感知像素输入和生成目标序列。</p>
<p>目标函数简单地是在像素输入和之前的token 的条件下，使token 的最大似然。</p>
<p>虽然架构和损失函数都不针对任务进行特定假设（不假设关于目标检测的先前知识，如边界框），但我们仍然可以通过一种<u><strong>序列增强技术</strong></u>来纳入任务特定的先验知识，该技术在训练期间改变输入和目标序列。</p>
<h3 id="Pix2seq系统由四个主要组件组成">Pix2seq系统由四个主要组件组成</h3>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231106164737104.png" alt="image-20231106164737104" style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>图像增强</strong>: 在训练计算机视觉模型时，常用图像增强技术来丰富固定的训练样本集合（例如随机缩放和裁剪）。</p>
</li>
<li class="lvl-2">
<p><strong>序列构建与扩充</strong>：由于图像的目标注释通常表示为一组边界框和类别标签，我们将其转换为一系列离散的标记。</p>
</li>
<li class="lvl-2">
<p><strong>架构（Architecture）</strong>：我们使用了编码器-解码器模型，其中<strong>编码器感知像素输入</strong>，<strong>解码器逐个令牌地生成目标序列</strong>。</p>
</li>
<li class="lvl-2">
<p><strong>目标/损失函数（Objective）</strong>: 模型的训练目标是最大化在图像和前面的标记条件下的标记对数似然函数（使用softmax交叉熵损失）。</p>
</li>
</ul>
<p>在常见的目标检测数据集中，图像中的目标数量是可变的，通常表示为一组边界框和类别标签。在Pix2Seq中，我们将其表示为离散化的令牌序列。</p>
<p>具体而言，一个目标被表示为一个由五个离散化的令牌组成的序列，即[y<sub>min</sub>, x<sub>min</sub>, y<sub>max</sub>, x<sub>max</sub>, c]，其中每个连续的角点坐标被均匀离散化为[1, n<sub>bins</sub>]的整数，c为类别索引。</p>
<p>使用一个共享的词汇表来表示所有令牌，因此词汇表的大小等于bin数量加类别数量。这种边界框的量化方案使我们能够在实现高精度的同时使用一个较小的词汇表。例如，对于一个600×600的图像，只需要600个bin即可实现零量化误差。不同量化水平对边界框的排列的影响如下图所示。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231106165814110.png" alt="image-20231106165814110" style="zoom:50%;" />
<p>将每个目标描述表示为一个简短的离散序列后，我们需要将多个目标描述序列化为给定图像的单个序列。由于对于检测任务本身来说，对象的顺序不重要，我们使用随机排序策略（每次显示图像时随机调整目标的顺序）。</p>
<p>最后，由于不同图像通常具有不同数量的目标，生成的序列长度也会有所不同。为了表示序列的结束，我们因此使用了一个EOS（end of sequence）令牌。不同排序策略下的序列构建过程如下图所示。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231106165910271.png" alt="image-20231106165910271" style="zoom: 67%;" />
<h3 id="架构">架构</h3>
<p>我们使用编码器-解码器架构。编码器可以是一个通用的图像编码器，它感知像素并将其编码为隐藏表示，例如ConvNet，Transformer或者它们的组合。对于生成，我们使用Transformer解码器。它每次生成一个令牌，以前面的令牌和编码的图像表示为条件。这消除了现代目标检测器中架构的复杂性和定制性，例如边界框提议和回归，因为令牌是从具有softmax的单一词汇表中生成的。</p>
<h3 id="目标">目标</h3>
<p>目标与语言建模类似，给定一张图像和前面的令牌，Pix2Seq被训练为预测令牌，使用最大似然损失，即，</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231106170528298.png" alt="image-20231106170528298" style="zoom: 67%;" />
<p>其中 x 是给定图像，y 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 是输入和与 x 相关的目标序列，L 是目标序列长度。 y 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 在标准语言建模设置中是相同的，但它们也可以不同（如我们后来的增强序列构造）。此外，w<sub>j</sub> 是序列中第 j 个标记的预先分配的权重。我们设置 w<sub>j</sub> = 1, ∀j，但是可以根据标记的类型（例如，坐标标记与类标记）或相应对象的大小来对标记进行加权。</p>
<h3 id="推理">推理</h3>
<p>在推理阶段，我们从模型的似然中抽取令牌，即P(y<sub>j</sub> |x, y<sub>1:j−1</sub>)。这可以通过选择具有最大似然的令牌（argmax抽样）或使用其他随机抽样技术来实现。我们发现使用nucleus抽样(Holtzman et al., 2019)比argmax抽样具有更高的回收率。当生成EOS令牌时，序列结束。生成序列后，提取和去量化对象描述（即获取预测的边界框和类别标签）就变得简单明了。</p>
<h3 id="序列增强以整合任务先验">序列增强以整合任务先验</h3>
<p>EOS 令牌（标记）允许模型决定何时终止生成，但在实践中我们发现模型往往会在没有预测所有对象的情况下完成。这可能是由于 1) 注释噪声（例如，注释者未识别所有对象），以及 2) 识别或定位某些对象的不确定性。虽然这只会对整体性能产生很小的影响（例如，平均精度为 1-2%），但它对召回率的影响较大。为了鼓励更高的召回率，一种技巧是通过人为降低其可能性来延迟 EOS 令牌的采样。然而，这通常会导致嘈杂和重复的预测。在某种程度上，精确度和召回率之间的这种困难权衡是我们的模型与任务无关、不知道检测任务本身的结果。为了缓解这个问题，我们简单地引入了序列增强技术，从而结合了有关该任务的先验知识。传统自回归语言模型（即没有序列增强）中的目标序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 与输入序列 y 相同。并且序列中的所有标记都是真实的（例如，从人类注释转换而来）。通过序列增强，我们在训练期间增强输入序列以包括真实的和合成的噪声标记。我们还修改目标序列，以便模型可以学习识别噪声标记而不是模仿它们。这提高了模型针对噪声和重复预测的鲁棒性（特别是当 EOS 令牌被延迟以增加召回率时）。由序列增强引入的修改如下图所示。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231107105249912.png" alt="image-20231107105249912" style="zoom:80%;" />
<p><em><strong>图</strong> : <strong>带有/不带有序列增强的语言建模示意图</strong>。通过序列增强，输入标记被构建为包括真实对象（蓝色）和合成噪声对象（橙色）。对于噪声对象，模型被训练为将它们识别为“噪声”类，并且我们将“n/a”标记（对应于噪声对象的坐标）的损失权重设为</em><em>零</em>*，因为我们不希望模型模仿它们。*</p>
<h4 id="修改序列建构">修改序列建构</h4>
<p>首先，我们通过以下两种方式创建合成噪声物体来增强输入序列：1)对现有的真实物体添加噪声（例如，随机缩放或移动它们的边界框），2) 生成完全随机的边界框（配以随机关联的类别标签）。值得注意的是，这些噪声物体中的一些可能与真实物体相同或重叠，模拟嘈杂和重复的预测，如下图所示。在合成和离散化噪声物体之后，我们将它们附加在原始输入序列的末尾。至于目标序列，我们将噪声物体的目标标记设置为“噪声”类（不属于任何真实类别标签），将噪声物体的坐标标记设置为“n/a”，其损失权重设置为零，即在公式1 中，设置<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231107105032028.png" alt="image-20231107105032028">。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231107105453018.png" alt="image-20231107105453018" style="zoom: 80%;" />
<h4 id="修改推理">修改推理</h4>
<p>通过序列增强，我们能够大幅度延迟EOS标记，提高召回率，而不增加嘈杂和重复预测的频率。因此，我们让模型预测到最大长度，从而得到一个固定大小的物体列表。当我们从生成的序列中提取边界框和类别标签列表时，我们将“噪音”类别标签替换为具有全部实际类别标签中最高可能性的真实类别标签。我们将所选类标记的可能性作为（排名）对象的分数。</p>
<hr>
<h1>Basic Information:</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>Title: PIX2SEQ: A LANGUAGE MODELING FRAMEWORK FOR OBJECT DETECTION (PIX2SEQ：一种用于目标检测的语言建模框架)</p>
</li>
<li class="lvl-2">
<p>Authors: Ting Chen, Saurabh Saxena, Lala Li, David J. Fleet, Geoffrey Hinton</p>
</li>
<li class="lvl-2">
<p>Affiliation: Google Research, Brain Team (谷歌研究，Brain团队)</p>
</li>
<li class="lvl-2">
<p>Keywords: object detection, language modeling, neural network, Pix2Seq framework (目标检测，语言建模，神经网络，Pix2Seq框架)</p>
</li>
<li class="lvl-2">
<p>URLs: <a href="https://arxiv.org/abs/2109.10852v2">Paper</a>, <a href="https://github.com/google-research/pix2seq">GitHub</a></p>
</li>
</ul>
<h1>论文简要 :</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>本文提出了Pix2Seq，一种简单且通用的目标检测框架。与现有方法明确地整合任务的先验知识不同，我们将目标检测视为一种基于观察像素输入的语言建模任务。目标描述（如边界框和类别标签）被表示为离散令牌序列，我们训练一个神经网络来感知图像并生成所需的序列。通过教会神经网络如何读取目标的位置和类别，我们的方法在挑战性的COCO数据集上取得了与高度专门化和优化的检测算法相媲美的结果。</p>
</li>
</ul>
<h1>背景信息:</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>论文背景: 视觉目标检测系统旨在识别和定位图像中预定义类别的所有对象。大多数现有方法在架构和损失函数的选择上具有大量的先验知识，例如，许多架构针对使用边界框进行了优化，损失函数也经常针对边界框进行了定制。然而，这些专门化和复杂的方法往往难以集成到更大的系统中，或者推广到与通用智能相关的更广泛的任务领域。</p>
</li>
<li class="lvl-2">
<p>过去方案: 许多现有的目标检测方法在设计上高度定制，并且在架构和损失函数的选择上具有大量的先验知识。这些方法通常针对使用边界框进行了优化，并且损失函数也针对边界框进行了定制。然而，这些专门化和复杂的方法往往难以集成到更大的系统中，或者推广到与通用智能相关的更广泛的任务领域。</p>
</li>
<li class="lvl-2">
<p>论文的Motivation: 本文的动机是基于这样的直觉：如果神经网络知道对象的位置和类别，我们只需要教它如何读取这些信息。通过学习“描述”对象，模型可以学习将“语言”与像素观察结果关联起来，从而得到有用的对象表示。为了实现这一目标，本文提出了Pix2Seq框架，将目标检测视为一种基于像素输入的语言建模任务，模型架构和损失函数相对简单且通用，不需要专门为检测任务进行工程化。因此，可以将该框架轻松扩展到不同的领域或应用，并将其纳入支持通用智能的感知系统，为各种视觉任务提供语言接口。</p>
</li>
</ul>
<h1>方法:</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>a. 理论背景:</p>
<ul class="lvl-2">
<li class="lvl-4">本文介绍了Pix2Seq，这是一个将目标检测任务视为语言建模问题的框架。作者提出将目标描述表示为离散标记的序列，并训练神经网络根据像素输入生成这些序列。该方法基于这样一个思想，即如果网络知道对象的位置和内容，它只需要学会如何读取它们。作者强调他们的框架对任务的假设要求很少，并且在COCO数据集上与专门的检测算法相比取得了竞争性的结果。</li>
</ul>
</li>
<li class="lvl-2">
<p>b. 技术路线:</p>
<ul class="lvl-2">
<li class="lvl-4">Pix2Seq框架包括四个主要组件：图像增强、序列构建和增强、架构以及目标/损失函数。图像增强用于丰富训练样本，而序列构建涉及将对象注释转换为离散标记的序列。架构是一个编码器-解码器模型，其中编码器感知像素输入并将其编码为隐藏表示，而解码器根据前面的标记和编码的图像表示逐个生成目标序列。目标函数是最大化标记在图像和前面的标记条件下的对数似然。</li>
</ul>
</li>
</ul>
<h1>结果:</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>a. 详细的实验设置:</p>
<ul class="lvl-2">
<li class="lvl-4">实验中使用的模型包括R101、R50-DC5和R50-DC5。</li>
<li class="lvl-4">模型使用ResNet骨干网络进行训练，后跟6层Transformer编码器和6层（因果）Transformer解码器。</li>
<li class="lvl-4">图像被调整大小，使得较长的一边为1333像素。</li>
<li class="lvl-4">序列构建使用2000个量化区间，并随机排列每个图像中的对象。</li>
<li class="lvl-4">添加噪声对象到真实对象中，每个图像总共添加100个对象，序列长度为500。</li>
<li class="lvl-4">模型训练300个epochs，批量大小为128。</li>
</ul>
</li>
<li class="lvl-2">
<p>b. 详细的实验结果:</p>
<ul class="lvl-2">
<li class="lvl-4">在MS-COCO 2017检测数据集上评估了所提出的方法。</li>
<li class="lvl-4">采用两种训练策略：在COCO上从头开始训练和在Objects365上进行预训练+微调，然后在COCO上进行微调。</li>
<li class="lvl-4">使用平均精度（AP）指标将结果与Faster R-CNN和DETR基线进行比较。</li>
<li class="lvl-4">Pix2Seq模型在不同阈值和目标尺寸下与基线相比取得了竞争性的结果。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>目标检测</tag>
        <tag>ICLR</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习_深度学习领域所涉及的基础知识</title>
    <url>/2023/11/08/University/AI/%E6%9C%BA%E5%99%A8_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A2%86%E5%9F%9F%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>机器学习_深度学习领域所涉及的基础知识</h1>
<h3 id="Argmax">Argmax</h3>
<blockquote>
<p>参考：<a href="https://baike.baidu.com/item/argmax/6034072">https://baike.baidu.com/item/argmax/6034072</a></p>
<p>相关应用：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>Sampling-Argmax：<a href="https://zhuanlan.zhihu.com/p/564050500">https://zhuanlan.zhihu.com/p/564050500</a></p>
</li>
</ul>
</blockquote>
<p>arg是变元（即自变量argument）的英文缩写。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>arg min就是使后面的式子达到最小值时变量的取值；</p>
</li>
<li class="lvl-2">
<p>arg max就是使后面的式子达到最大值时变量的取值；</p>
</li>
</ul>
<p>例如：对于函数式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>，</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>arg min<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>：当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>取得最小值时，变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,y,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>的取值；</p>
</li>
<li class="lvl-2">
<p>arg max<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>：当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>取得最大值时，变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,y,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>的取值；</p>
</li>
</ul>
<p>argmax的公式如下：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/3d64f2ee47fbded10f7be36599c2bf77.svg" alt="img"></p>
<p>对一个函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>或一个映射<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mtext>：</mtext><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f：X \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">：</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，当x取值范围为S的时候（也叫<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">x \in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>），argmax的结果是使得f(x)取得最大值的x点集。</p>
<h3 id="Softmax：一种输出节点的激活函数">Softmax：一种输出节点的激活函数</h3>
<blockquote>
<p>参考：</p>
<ul class="lvl-1">
<li class="lvl-2"><a href="https://zhuanlan.zhihu.com/p/105722023">https://zhuanlan.zhihu.com/p/105722023</a></li>
<li class="lvl-2"><a href="https://zhuanlan.zhihu.com/p/168562182">https://zhuanlan.zhihu.com/p/168562182</a></li>
</ul>
</blockquote>
<p>Softmax的含义就在于为每个输出分类的结果都赋予一个概率值，表示属于每个类别的可能性。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/v2-4452fdaaa04686aa270010f57f4db2aa_r.jpg" alt="img" style="zoom:67%;" />
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示的是第i个节点的输出值，j表示的是输出节点的个数，即分类类别的个数。</p>
<p>*注意以上图中的概率P值直接四舍五入为一位小数了，并不是真实的概率值。</p>
</blockquote>
]]></content>
      <categories>
        <category>格物致知</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>论文：Kristan_The_First_Visual_Object_Tracking_Segmentation_VOTS2023_Challenge_Results_ICCVW_2023_paper</title>
    <url>/2023/11/08/University/AI/PaperLearn/Kristan_The_First_Visual_Object_Tracking_Segmentation_VOTS2023_Challenge_Results_ICCVW_2023_paper/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Kristan_The_First_Visual_Object_Tracking_Segmentation_VOTS2023_Challenge_Results_ICCVW_2023_paper</h1>
<blockquote>
<p>论文：<a href="https://openaccess.thecvf.com/content/ICCV2023W/VOTS/papers/Kristan_The_First_Visual_Object_Tracking_Segmentation_VOTS2023_Challenge_Results_ICCVW_2023_paper.pdf">https://openaccess.thecvf.com/content/ICCV2023W/VOTS/papers/Kristan_The_First_Visual_Object_Tracking_Segmentation_VOTS2023_Challenge_Results_ICCVW_2023_paper.pdf</a></p>
<p>参考：~</p>
<p><mark>一篇关于“首届视觉对象跟踪分割VOTS2023挑战赛结果”的报告</mark></p>
</blockquote>
<h2 id="Abstract">Abstract</h2>
<p>视觉对象跟踪分割 VOTS2023 挑战赛是 VOT 计划的第十一次年度<u><strong>跟踪器基准测试</strong></u>活动。该挑战首次将<strong>短期和长期以及单目标和多目标跟踪合并</strong>，并<strong>以分割掩模作为唯一的目标位置规范</strong>。创建了一个新的数据集；为了防止过度拟合，真实情况被保留。新的性能测量和评估协议以及新的工具包和评估服务器已经创建。所提出的 47 个跟踪器的结果表明，<strong>现代跟踪框架非常适合处理短期和长期跟踪的融合</strong>，并且<strong>多个和单个目标跟踪可以被视为单个问题</strong>。包含参与跟踪器详细信息、源代码、数据集和评估工具包的排行榜可在挑战网站上公开获取。</p>
<h2 id="Introduction">Introduction</h2>
<p>视觉对象跟踪仍然是基本的计算机视觉问题之一。过去二十年所取得的重大进展是由社区的研究努力以及旨在推进该领域最先进技术的众多举措和挑战的出现所推动的。十年前，VOT1 计划的成立是为了解决视觉对象跟踪中缺乏性能评估共识的问题。此后，VOT 挑战赛与所有后续 ICCV 和 ECCV 一起举行，最终在去年 ECCV2022 上组织的第十届 VOT 挑战赛中达到顶峰。在过去 10 年中，该计划成功地确定了主要的跟踪趋势，这些趋势反映在后来的主要计算机视觉会议的出版物中，使 VOT 活动成为跟踪社区的中心。</p>
<p>考虑到跟踪方面的重大挑战，VOT仅限于单目标跟踪，并分别探讨了短期和长期跟踪挑战。这种方法为探索用于短期跟踪和目标重新检测的<u><strong>新型判别性帧到帧定位机制</strong></u>以及用于长期跟踪的<u><strong>约束适应机制</strong></u>提供了合适的环境。特别关注绩效衡量、评估协议和工具包的制定和修订。为了不断提高不断改进的跟踪器方法的标准，目标位置规范已从最初挑战中的报告边界框 [34、35、33、31、30、29、28] 发展到最新挑战中的每像素分割[27、32、26]。</p>
<p>与 VOT 并行的还有大量有影响力的活动出现。最密切相关的是 UAVision2、VisDrone3 和 Anti-UAV4 挑战，<strong>解决预定义的监视相关对象类型的检测和跟踪问题</strong>。相关工作的另一部分是<strong>面向分段的多目标跟踪挑战</strong>。 MOTCplex5 <strong>通过分段解决多实例跟踪问题</strong>，并考虑了四个挑战：YouTubeVIS（视频实例分段）； VIS（遮挡视频实例分割）； DanceTrack（多人跟踪）； UVO（检测并分割图像或视频中出现的未知对象的所有实例）。 TAO-OW6 <strong>解决开放世界实例跟踪问题</strong>，而 STEP benchmark7 <strong>解决跟踪实例（例如人类和汽车）以及语义场景分割问题</strong>。 LaGOT [42] 引入了用于多对象通用跟踪的验证数据集。在 DAVIS 挑战赛 [11] 的推动下，以<u><strong>视频对象分割 (VOS)</strong></u> 为主题的研讨会也应运而生。最突出的是最近的 YouTube-VOS8 挑战，其中包括视频实例和视频对象分割。</p>
<p>上述数据集和举措提出了新的令人兴奋的挑战，并为该领域做出了巨大贡献。然而，它们致力于跟踪整个对象实例，因此与实例检测器紧密耦合。视频分割研讨会主要关注具有挑战性的视频编辑任务，考虑经历短期（部分）遮挡和短暂消失的相对较大的对象。因此，它们不能直接满足对通用跟踪器感兴趣的传统跟踪社区的需求。</p>
<p>跟踪的终极目标是开发能够跟踪“任何”区域的算法，而不仅仅是已知的实例，甚至是对象的各个部分，只需在第一帧提供一个训练样本。这需要开发出高效的通用对象表示方法，自监督适应机制以应对外观变化，具有定位和区分目标与周围环境的辨别模型，以及能够有效地在图像中重新检测对象以应对目标长时间缺席的机制。</p>
<p>我们认为，该领域已经成熟到可以放松之前 VOT 挑战中所施加的限制的程度，并且应该在更广泛的背景下考虑一般对象跟踪。因此，我们提出了一个<u><em><strong>不再区分单目标跟踪和多目标跟踪</strong></em></u>、<u><em><strong>也不区分短期跟踪和长期跟踪的挑战</strong></em></u>。我们提出了一项挑战，*要求通过长序列或短序列的分割来同时跟踪一个或多个目标，而目标可能在跟踪过程中消失并稍后在视频中重新出现。目标可以是整个实例或只是其中的一部分。*为了将这个新的进化阶段与传统的 VOT 挑战区分开来，新系列被称为视觉对象跟踪和分割 (VOTS) 挑战赛。</p>
<blockquote>
<p>本文介绍了与 ICCV2023 视觉对象跟踪和分割研讨会联合组织的首届 VOTS2023 挑战赛以及所获得的结果。下面，我们概述了挑战和参与要求。</p>
</blockquote>
<h3 id="The-VOTS2023-challenge（比赛的要求和提示）">The VOTS2023 challenge（比赛的要求和提示）</h3>
<p>评估工具包和数据集由 VOTS2023 组织者提供。挑战于5月4日开始，6月18日结束。结果以及获奖者于七月初公布。结果分析于 10 月 3 日在 ICCV2023 VOTS2023 研讨会上发表。 VOTS2023 基准测试以不断更新的排行榜开启，以促进挑战后时期的跟踪器开发。</p>
<p>对于 VOTS2023 挑战，参与者将他们的跟踪器集成到 VOTS2023 评估套件中，这是新版本的 VOT 工具包，它实现了最新的评估协议和新数据集，并自动执行标准化实验。然后，每个参与者在评估服务器上注册跟踪器并提交实验中产生的跟踪器输出。请注意，只有初始化帧是公开可用的，而其余帧的基本事实被隔离在服务器端以防止过度拟合。此外，每个注册参与者只能尝试 10 次进行评估。</p>
<p>鼓励参与者提交自己的新的或以前发布的跟踪器以及第三方跟踪器的修改版本。在后一种情况下，修改必须足够重要才能被接受。每份提交都附有描述跟踪器的简短摘要（用于附录 A 中的简短跟踪器描述）以及一份调查问卷，用于根据各种设计属性对其跟踪器进行分类。</p>
<p>表现足够出色的参与者（即，超过了第3节中描述的VOTS2023基准跟踪器）并为本文提供文本并同意将其跟踪器代码公开发布在VOTS页面上的人，被提供了本研究结果论文的共同作者资格。委员会保留根据其判断取消试图违规评估协议的任何跟踪器的权利。VOTS委员会成员可以参与挑战并提交他们自己的参赛作品，但不能竞争胜利者称号。本文的所有共同作者，包括VOTS2023委员会成员和跟踪器作者，都需要在附录A中明确划分工作。</p>
<p>不允许对流行跟踪数据集进行验证和测试分割来训练跟踪器。其中包括 OTB [56]、VOT、ALOV [1]、UAV123 [44]、NUSPRO [1]、TempleColor [36]、AVisT [46]、LaSOT-val [17]、LaGOT [42] GOT10k-val/test [1]、TrackingNet-val/测试 [1]、TOTB [1]。允许任何数据集的训练分割（包括LaSOT-train、TrackingNet-train、YouTubeVOS、COCO等）。要包含透明对象，建议使用 Trans2k10 数据集。</p>
<p><strong>Beyond VOT challenges</strong>。VOTS 挑战合并了短期和长期、单目标和多目标跟踪，这些跟踪迄今为止被认为是单独的任务，并将分段视为唯一的目标位置规范。创建了一个新的更大的数据集，其中保留了真实情况。新的绩效衡量标准（解决单目标、多目标长期和短期跟踪）和评估协议与新工具包和评估服务器一起创建，该服务器具有公共学习板。</p>
<p>本报告的其余部分结构如下。第 2 节描述了新的性能评估协议和性能测量，第 2.2 节介绍了新的数据集，结果在第 3 节中讨论，结论在第 4 节中得出。附录 A 提供了测试跟踪器和工作分工的简短描述。</p>
<h2 id="The-VOTS-performance-evaluation-protocol">The VOTS performance evaluation protocol</h2>
<p>跟踪器在所有指定目标的第一帧中初始化。对于每个后续帧，跟踪器需要报告该帧中所有可见目标的位置。具体来说，每个可见目标都需要<u><strong>分割掩模</strong></u>，对于不存在的目标报告“不存在”标签。然后使用下面介绍的新性能指标对跟踪器进行评估。</p>
<h3 id="VOTS-performance-measures">VOTS performance measures</h3>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104144501062.png" alt="image-20231104144501062"></p>
<p>多目标跟踪器的目标是可靠地跟踪在第一帧中选择的每个个体目标。离开目标跟踪到背景或其他目标都被视为跟踪失败。这允许定义每个目标的性能指标，这些指标在所有目标上进行平均以获得最终得分。从跟踪单个目标的角度来看，<mark>图1</mark>中可视化的五种情景是可能的。其中三种情景涵盖了目标存在的情况：<strong>目标成功定位（sc1），跟踪器漂移（sc2），目标被错误预测为缺席（sc3）</strong>。另外两种情景涵盖了目标缺席的情况：<strong>目标被预测为存在（sc4），以及目标被预测为缺席（sc5）</strong>。接下来，我们介绍基于跟踪成功概念的性能指标，这些指标考虑了所有这些情景。</p>
<p>如果预测的目标位置和地面实况（即分割掩模）足够匹配，则认为在序列 s 的第 n 帧上跟踪第 i 个目标是成功的。成功通过交集联合 (IoU) 来衡量，并通过某个阈值 θ 二值化（即大于 θ 的值为 1，否则为 0）。请注意，IoU 可以很好地推广到目标不存在的情况 - 如果跟踪器在这种情况下报告空掩码（即目标不存在标志），它会收到 IoU=1，因为报告的掩码与地面事实完全一致，否则 IoU=0。因此，在阈值 θ 处所考虑的目标的总体跟踪成功率定义为：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104144652382.png" alt="image-20231104144652382" style="zoom:67%;" />
<p>其中 T<sub>s</sub> 和 N<sub>s</sub> 是序列 s 中目标和帧的数量，N 是序列的数量，[o<sub>sin</sub> &gt; θ] 是在给定帧处对 o<sub>sin</sub>（即 IoU）进行二值化的算子。对于所有阈值 θ ∈ [0, 1)，性能可以通过类似于 [56] 的跟踪质量图来总结，如<mark>图2</mark> 所示。请注意，阈值区间是开放的，因为 IoU 不能超过 θ =1.0，并且定义(1) 使用 &gt; 而不是 ≤。出于可视化的目的，最右边的点因此用 [·≡θ] 进行评估。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104144900490.png" alt="image-20231104144900490" style="zoom:50%;" />
<p>跟踪质量图的解释属性与标准的成功图[56]类似，不同之处在于θ=1.0的最右侧点通常可以更高。原因是它考虑了长期跟踪性能，而不仅仅是短期跟踪性能。当IoU=1时，只有当预测完全与地面真相匹配时才会发生（图1中的sc1和sc5）。实际上，当目标可见时，这种情况非常罕见，因此该值主要由正确预测目标缺席的情况（sc5）主导。因此，实际上可实现的最大值将是数据集中目标缺席帧的百分比。这个值在图中标示出来，以便更好地解释。</p>
<p><strong>The primary VOTS performance measure</strong>，称为跟踪质量 Q 通过曲线下面积总结了跟踪质量图。根据[51]中的成功图推导，可以证明跟踪质量等于序列归一化平均重叠，以避免数值曲线下面积计算中的错误，即：</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104145225937.png" alt="image-20231104145225937" style="zoom:67%;" />
<h4 id="Secondary-performance-measures">Secondary performance measures</h4>
<p>还提出了额外的次要性能指标，用于进一步了解跟踪情况。前两个指标是VOT[27]传统上使用的，它们分别是<strong>定位精度</strong>和<strong>鲁棒性</strong>。精度（Acc）定义为成功跟踪帧上的<strong>平均重叠的序列归一化值</strong>，即，</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104145413075.png" alt="image-20231104145413075" style="zoom:67%;" />
<p>其中 N<sub>si</sub> 是目标 i 在序列 s 中可见的成功跟踪帧的数量（即 IoU &gt; 0）。跟踪鲁棒性（Rob）定义为 IoU &gt; 0 且目标 i 可见（即召回）的帧的百分比，</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104145500349.png" alt="image-20231104145500349" style="zoom:67%;" />
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>N</mi><mrow><mi>s</mi><mi>i</mi></mrow><mrow><mi>s</mi><mi>c</mi><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">N^{sc1}_{si} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0728em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">sc</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span> 是场景 sc1 的帧数（图 1）。根据我们之前的工作 [27]，AR 图 [26] 总结了具有可见目标的帧上的跟踪器性能，右上角位置表示更好的性能。</p>
<p>接下来的两个次要性能指标回答了“为什么目标可见时跟踪器失败？”的问题。第一个测量称为未报告错误 (NRE)，给出跟踪器错误地将目标报告为不存在的帧的百分比，即,</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104145743256.png" alt="image-20231104145743256" style="zoom:67%;" />
<p>第二个称为漂移率误差 DRE，给出跟踪器偏离目标并声称存在目标的帧的百分比，即,</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104145806560.png" alt="image-20231104145806560" style="zoom: 67%;" />
<p>最终的次要措施回答了“目标缺勤确定得如何？”的问题。这种测量称为缺席检测质量 ADQ，给出了目标被正确预测为缺席的帧的百分比，即,</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104145918486.png" alt="image-20231104145918486" style="zoom: 67%;" />
<p>请注意，实际上，为了确保数值稳定性，我们仅考虑序列中至少 10 帧不存在的那些目标。</p>
<h3 id="The-VOTS2023-dataset">The VOTS2023 dataset</h3>
<p><strong>构建了一个新的数据集，用于评估新挑战中考虑的新的单/多目标、短期/长期分割跟踪任务</strong>。该数据集是通过包含以下现有数据集的序列构建的：LaGOT [42]、VOT-LT2021 [32]、VOT-LT2022 [26] UTB180 [2]、VOT-ST2022 [26] 和 TOTB [18]。请注意，这并不意味着最终 VOTS2023 数据集中注释了相同的目标。</p>
<p>主要选择标准是创建一个数据集，其中包含根据我们的经验对现代跟踪架构构成挑战的情况，并且涵盖广泛的目标外观和对象类型。我们纳入了包含多个<strong>视觉上相似的对象</strong>的场景，以及由于变形或平面外旋转（例如，鱼从前到侧翻转）而发生显着<strong>外观变化的对象</strong>。小心地将<strong>杂乱背景上的物体</strong>包含在内。除了具有部分遮挡的序列之外，还考虑了包含<strong>退出视场并重新进入的对象</strong>的序列，<strong>以能够评估长期跟踪特性</strong>。我们确保这些序列涵盖了不同的对象类型和场景。例如，除了经典的空中和地面序列之外，<strong>还考虑了水下序列</strong>。除了不透明物体之外，还包括几个具有透明物体的具有挑战性的序列，以进一步增加目标多样性。</p>
<p>在大多数现有的跟踪基准中，目标都是<strong>整个对象</strong>。为了强调跟踪一般外观的能力的重要性，我们还包括了作为其他对象（即脚、帽子、手等）<strong>一部分的对象</strong>。在每个序列中，第一帧中可能选择了多个目标。然后注释分几个阶段进行。<strong>在第一阶段</strong>，每个选定的目标都通过边界框（不一定在所有帧中）手动注释。然后运行最先进的边界框跟踪器来插入丢失的边界框。所有方框均经过手动验证和更正。<strong>在第二阶段</strong>，边界框用于指导最先进的分割算法，该算法给出初始分割掩模[22, 23]。最后，由专业注释者手动编辑分段。所有注释均由主管验证，不够精确的注释将被发回更正。<mark>图3</mark> 显示了目标多样性和注释质量的示例。</p>
<p>最终的VOTS2023数据集由144个序列组成，总共包含341个目标。序列的平均长度约为 2000 帧（最小值 = 63，最大值 = 10700，中值 = 1810）。序列中的目标数量范围为 1 到 8（中位数 = 2，平均值 = 2.37）。在 144 个序列中，93 个包含至少一次离开视野然后返回的目标。在 341 个目标中，有 168 个发生这种情况。在目标离开并返回视野的情况下，缺席次数中位数为 3 次，最多为 23 次。以帧数计算的缺席长度中位数为 18 次。作为参考，<mark>图4</mark>显示了所有目标的第一帧144 个序列。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104150928027.png" alt="image-20231104150928027"></p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104151928902.png" alt="image-20231104151928902"></p>
<h2 id="Results">Results</h2>
<p>总共 77 个跟踪器被提交到评估服务器，其中包括 VOTS 委员会提供的基线。删除重复、接近重复和不完整的提交后，VOTS2023 挑战赛中剩余 47 个有效参赛作品：DMAOT (A.9)、HQTrack (A.42)、M-VOSTracker (A.20)、Dynamic DEAOT (A.8) )、seqtrack (A.38)、DMNet (A.12)、aot (A.25)、MCMOT (A.27)、rts rts50 002 (A.34)、VAPT (A.46)、MiOTS-ST ( A.22)、DropTrackSamb (A.11)、vttrack (A.47)、mmtrack (A.3)、MTCTrack (A.29)、MixItUp-3 (A.15)、MixItUp-2 (A.14) 、MixFormer (A.23)、MixItUp (A.2)、PriMem (A.31)、UNINEXT Huge (A.45)、SAM-MixFormer、CoCoLoT、MixFormerSAMHDeAOT、T-S-AM、AOTsup、vil net2、stark st50 ar (A.40)、MixFormerV2 (A.24)、UniTD (A.43)、alpha refine tomp101 seg 000 (A.5)、MiOTS (A.21)、SAM Tracker (A.35)、alpha refine super dimp seg 000 (A.4)、UNINEXT R50 (A.44)、READMem MiVOS (A.32)、d3sv2 (A.10)、LOVD (A.18)、starkmulti (A.17)、starkplusplus (A.39) )、Mstark (A.26)、MixSAMB (A.36)、SRZLT HSE IPPM ClipSegmentAnything (A.37)、pytest800 convnext (A.30)、ReptileFPN (A.33)、TCLCF (A.13)、TrackerPRO ( A.28）。</p>
<p>每次提交都包含源代码的链接，以便在需要时验证结果。源代码可公开访问。下面我们总结了提交的统计数据，并请读者参阅附录 A 以获取跟踪器的简短描述。</p>
<p>在参与的跟踪器中，13 个（28%）被分类为 ST0，16 个（34%）被分类为 ST1，6 个（13%）被分类为 LT0，12 个（26%）被分类为 LT1。大多数跟踪器（42；89%）应用了统一的<strong>动态模型</strong>，而（5；11%）应用了近乎恒定的<strong>速度模型</strong>。主要的跟踪方法是 <strong>Transformer</strong>。事实上，40 个（85%）提交的内容使用了 Transformer，而 7 个（15%）应用了深度或经典判别过滤器（在某些情况下与 Transformer 结合使用）。大多数跟踪器对目标进行<strong>多阶段定位</strong>（27 个；57%），而 20 个跟踪器（43%）执行<strong>单阶段定位</strong>。超过三分之一的提交使用<strong>通用对象分割网络 SAM</strong> [25]（17；36%），近四分之一应用<strong>特定对象网络 AlphaRef</strong> [61] 进行目标分割或细化分割（11；23%），而四分之一的人直接细分目标（12；26%）。 14 个（30%）跟踪器应用了固定模板更新机制，19 个（40%）跟踪器仅在有信心时更新模板，7 个（15%）始终更新模板，7 个（15%）从未更新模板。大多数提交的内容（45；96%）应用相同的网络进行帧到帧定位和目标重新检测，而（2；4%）应用单独的方法。</p>
<p>结果总结在跟踪质量图（图2）、AR 图（<mark>图5</mark>）和<mark>表2</mark> 中。根据主要跟踪质量得分 (Q) 排名前 10 的跟踪器是：DMAOT A.9、HQTrack A.42、 MVOSTracker A.20、Dynamic DEAOT A.8、seqtrack A.38、DMNet A.12、aot A.25、MCMOT A.27、rts rts50 002 A.34 和 VAPT A.46。其中，8个被归类为ST1或LT0，9个基于变压器，而rts rts50 002基于深度DCF，大多数（7个）应用单阶段定位，6个以固定间隔更新其模板（只有4个在有信心时） ，并且都应用相同的网络进行帧到帧定位和目标重新检测。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104152025112.png" alt="image-20231104152025112"></p>
<p>排名前三的跟踪器都是使用固定模板更新和一种用于帧与帧之间的目标定位和目标重新检测的通用架构的ST1单阶段变换器跟踪器。特别是排名第一的DMAOT（A.9）是基于VOT2022 [26]的胜者AOT [63]构建的。该跟踪器将目标的长期记忆分离开来，仅在足够确定时进行更新，应用分层门控传播模块（GPM）[64]以实现更好的视觉嵌入传播和近似恒定速度的运动模型。该跟踪器应用了在ImageNet [12]上预训练的SwinTransformer，训练数据来自COCO [37]，YouTube-VOS [57]，Davis [11]，MOSE [13]，GOT10k [21]，LASOT [17]，VIPSeg [43]和OVIS [49]。接下来的三个表现最佳的跟踪器HQTRACK A.42，M-VOSTracker A.20和Dynamic DEAOT A.8类似地设计为DMAOT，即DeAOT [64]的扩展。</p>
<p>DMAOT 获得了<strong>最高的跟踪质量</strong> (Q=0.6360)，比第二好的条目提高了 3%。 AR 图表明 DMAOT 在准确的目标分割 (Acc=0.751) 和非常好的鲁棒性 (Rob=0.795) 之间取得了良好的平衡 - 后者表明该跟踪器成功跟踪了平均测试序列长度的近 80%。跟踪器仅在 7% 的情况下偏离目标 (DRE=0.07)，并在 14% 的情况下错误地预测目标不存在 (NRE=0.14)。这也意味着，当目标存在时，大约 66% 的失败是由于错误地报告目标不存在而导致的，而 33% 的失败是由于跟踪器在报告目标存在时偏离了目标。总体而言，73% 的情况下目标缺失被正确预测 (ADQ=0.73)。</p>
<p>DMNet (Rob=0.86) 实现了<strong>最好的鲁棒性</strong>，远远超过了 DMAOT (Rob=0.795) 的鲁棒性。这可能是由于 DMNet 中局部对应优化中最优传输的应用，这可能负责稳健的分割。然而，我们注意到 DMNet 也比 DMAOT 更自由地报告当前目标（0.56 ADQ vs 0.73 ADQ）。 DMNet 的 NRE 是 DMAOT 的一半，这表明情况可能如此，但前提是假设至少一半的 DMAOT 错误目标缺失预测发生在跟踪器实际位于目标上时。 Seqtrack 获得了最佳分割精度，它是一种具有 SAM [25] 分割功能的边界框跟踪器。这可能意味着 SAM 的良好利用和基于边界框的初始化。</p>
<p>考虑到上面讨论的性能分数结果，可以通过 Q 图形状的分析得出更多见解（<mark>图5</mark>）。请注意，低阈值下 Q 图的高度表示跟踪器的鲁棒性，而图表的“凹凸”向右延伸的量（即较高的阈值）表示跟踪器的准确性。观察形成 Q 图形状簇的跟踪器，在低阈值下获得高 Q 值的跟踪器的一个共同属性是使用变压器特征提取主干，这可能会导致高鲁棒性。对 Q-plot 上的中到高阈值的类似分析表明，许多实现良好准确度的跟踪器的共同属性是（谨慎）使用 SAM 来分割目标，通过预测掩模或预测边界框进行初始化。</p>
<p>VOTS2023 委员会提供了一个<strong>基线跟踪器来验证提交的总体质量</strong>。该跟踪器被创建为一组独立的 STARK [60] 跟踪器，<strong>通过边界框预测目标位置</strong>。名为 starkmulti A.17 的跟踪器实现了 Q=0.297，大约是表现最佳的 Q 分数的 47%。大约 80% 的提交优于基线跟踪器。此外，VOTS2023 委员会还提供了由 VOT-STs2022 [26] 获胜跟踪器 AOT [63] 创建的强大的最新基线，该基线已经专为多对象分割而设计。 6 个跟踪器（占提交内容的 13%）表现优于它，这表明 VOTS2023 提交内容非常强大。</p>
<p><strong>The VOTS2023 challenge winner</strong>。根据跟踪质量得分 Q 的顶级跟踪器是 DMAOT (A.9)，因此是 VOTS2023 挑战赛的获胜者。简短的分析表明，虽然 DMAOT 在准确性和鲁棒性之间取得了良好的平衡，但如果跟踪器正确定位在目标上时，出现大量不正确的目标缺失预测，则可能有机会通过降低目标缺失阈值来进一步提高性能。目标。另外恢复的目标位置可能不那么准确，这可能会通过遵循 Seqtrack 的边界框条件 SAM 策略来提高这些情况下的性能。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231104152845080.png" alt="image-20231104152845080"></p>
<h2 id="Conclusion">Conclusion</h2>
<p>首届 VOTS2023 挑战赛及结果揭晓。该挑战将短期和长期、单目标和多目标跟踪与分段合并为唯一的目标位置规范。创建了一个新的具有挑战性的数据集，其中保留了真实情况。新的绩效衡量标准和评估协议与新工具包和评估服务器一起创建，该服务器将保留公共排行榜。</p>
<p>该论文展示了 47 个追踪器的结果。我们观察到变压器的应用大幅增加。在 VOT2022 [26] 中，47% 的提交内容来自该类别，而在 VOTS2023 中该比例已增加至 85%。有趣的是，虽然 VOTS2023 中的跟踪任务包括短期跟踪和长期跟踪，但只有三分之一的跟踪器被归类为 LT。几乎所有跟踪器都采用相同的方法框架进行目标帧到帧定位和长期重新检测，这表明这两个跟踪类别确实在方法上趋同。我们还观察到主要通过分段来定位目标的单级跟踪器的增加（接近提交的 43%）。 VOTS2023 挑战赛的获胜者是 DMAOT (A.9)，它建立在 VOT2022 [26] 获胜者 AOT [63] 的基础上。挑战结束后，开放了 VOTS2023 基准12，以促进对新的通用对象跟踪器（主要是基于分段的）的持续评估。</p>
<p>由于边界框跟踪器仍然主导着主要计算机视觉会议和期刊的发表，我们指出了一种流行范式转变的机会。去年VOT2022 [26]挑战的研讨会结果表明，最佳的基于分割的跟踪器在边界框跟踪任务上表现优于所有边界框跟踪器，这表明分割跟踪器在准确性和鲁棒性方面不仅与边界框跟踪器相媲美，而且超越了它们。这特别有趣，因为边界框跟踪器传统上被认为比分割跟踪器更为稳健，因为它们估计较少的输出参数（即，边界框与每像素掩模）。VOTS2023的结果进一步支持了VOT2022的观察结果，并挑战了传统的信仰。</p>
<p>除了其他标准数据集之外，跟踪社区还可以在 VOTS2023 挑战赛上投入精力评估其边界框跟踪器，从而建立更有力的证据。通过对预测的边界框应用类似 AlphaRef 或 SAM 的后处理，可以将边界框跟踪器轻松转换为分段跟踪器。本实验的重点应放在鲁棒性测量上，这将揭示这些跟踪器如何很好地处理 VOTS2023 数据集中存在的挑战性条件，以及它们如何与最佳分割跟踪器相媲美。我们相信这样的努力有可能推动现代通用对象跟踪器的发展，从而实现该领域的重大进步。</p>
<p>十多年来，VOT 的主要目标是建立一个讨论跟踪性能评估的平台，并通过挑战数据集和工具包来支持跟踪社区。 VOTS2023 挑战推动了跟踪任务的融合，这是一个风险，因为此类跟踪器在社区中尚未得到广泛探索。跟踪社区在短时间内提供了极具竞争力的跟踪器，反应热烈，鼓励我们在未来的 VOTS 版本中继续努力，并希望见证令人兴奋的发展，从而实现跟踪的实质性改进。</p>
<h2 id="Submitted-tracker-details⭐">Submitted tracker details⭐</h2>
<h3 id="A-1-使用-DeAOT、Stark-和-SAM-进行多目标跟踪的混合方法-SAMMixFormer">A.1.使用 DeAOT、Stark 和 SAM 进行多目标跟踪的混合方法 (SAMMixFormer)</h3>
<p>该方法提出了一种用于多对象跟踪的新颖混合方法，集成了三种领先模型：用于视频对象分割的分层传播解耦特征（DeAOT）[64]、用于视觉跟踪的学习时空变换器（Stark）[60]和Segment Anything用于图像分割的模型（SAM）[25]。该方法适应要跟踪的对象的数量。当物体超过5个时，采用DeAOT模型进行实时跟踪。对于较少的对象，Stark 模型将对象作为边界框进行跟踪，然后将其用作 SAM 模型的提示以生成高质量的掩模。这种方法有效地利用了每个模型的优势，从而为跨各种场景的多目标跟踪提供了多功能且高性能的解决方案。</p>
<h3 id="A-2-Mixformer、Stark-和-Sam-的混合方法用于目标跟踪-MixItUp">A.2. Mixformer、Stark 和 Sam 的混合方法用于目标跟踪 (MixItUp)</h3>
<p>本研究中采用的跟踪器是一种混合方法，它根据视频序列中感兴趣的对象的数量利用各种算法。当处理少量对象时，使用 MixFormer 跟踪器 [9]，因为它擅长准确估计边界框。然而，在存在大量物体的情况下，整体跟踪器会切换到 Stark 跟踪器[60]。此外，分段任意模型（SAM）[25]用于使用预测的边界框生成掩模。</p>
<h3 id="A-3-简单但功能强大的视频流跟踪器-mmtrack">A.3.简单但功能强大的视频流跟踪器 (mmtrack)</h3>
<p>我们提出了一个简单但功能强大的视频流跟踪器。我们采用 ViT [14] 作为我们的视觉编码器，它 1）通过自回归方法对目标对象的时空轨迹信息进行建模，2）通过长期短期视频流传播有关目标的丰富时间信息方式。最后，AlphaRefine [61]用作分割网络来预测目标掩模。</p>
<h3 id="A-4-alpha-refine-super-dimp-seg-000-alpha-refine-super-dimp-seg-000">A.4. alpha refine super dimp seg 000 (alpha refine super dimp seg 000)</h3>
<p>该跟踪器由 Super DiMP [3] 组成，并使用 AlphaRefine [61] 使用预测的边界框生成分割掩模。</p>
<h3 id="A-5-alpha-refine-tomp101-seg-000-alpha-refine-tomp101-seg-000">A.5. alpha refine tomp101 seg 000 (alpha refine tomp101 seg 000)</h3>
<p>这个跟踪器包括ToMP [40]，并使用AlphaRefine [61]来使用预测的边界框生成分割掩模。更多细节请参阅原始论文[40]。</p>
<h3 id="A-6-AOTsup-AOTsup">A.6. AOTsup (AOTsup)</h3>
<p>我们的多目标、长短时间跟踪器 AOTsup 会根据掩模尺寸自动优化所使用的跟踪模型。它智能地采用两种不同的模型，MixformerV2 [10] 和 AOT [63]，每个模型根据特定的尺寸比例激活。对于较大的比率，可以使用 MixformerV2 模型，因为它具有卓越的精度。另一方面，对于较小的比率，AOTsup 选择以出色的召回能力而闻名的 AOT 模型。通过这样做，AOTsup 利用这两种模型的独特优势，确保我们的短期跟踪和细分功能的准确性和稳健性。</p>
<h3 id="A-7-在长期视觉跟踪-CoCoLoT-中结合互补跟踪器">A.7.在长期视觉跟踪 (CoCoLoT) 中结合互补跟踪器</h3>
<p>单对象 CoCoLoT 跟踪器 [15, 16] 概括了 mlpLT [32]。它实现了一种结合了 Stark [60] 和 KeepTrack [41] 跟踪器的互补行为的策略。这些跟踪器的组合由基于类似于 MDNet [45] 的在线学习目标验证器的决策策略进行管理。在每一帧，跟踪器并行运行以预测其目标定位。基于目标定位的评估，决策策略选择当前帧的输出并纠正表现较差的跟踪器。基线跟踪器还采用了其他策略，例如自适应搜索区域的计算和避免错误的目标大小估计，以使它们的定位更加一致。在 CoCoLoT 给出的边界框之后，运行 AlphaRefine [61] 以获得每个目标的分割掩模。</p>
<h3 id="A-8-使用动态内存解耦关联对象（动态-DEAOT）">A.8.使用动态内存解耦关联对象（动态 DEAOT）</h3>
<p>Dynamic-DEAOT是基于借鉴DEAOT[64]的视频对象分割（VOS）框架构建的，它提供了准确的掩模预测并实现了全局搜索。为了更好地处理长期序列，我们开发了一个动态记忆库来利用长期和短期目标外观的建模。此外，我们应用带有局部搜索的 SOT 方法（MixFormer）[9]，通过提供目标的粗略位置来处理微小物体，然后使用分割部分生成更精细的掩模预测。我们使用 AdamW 优化方法在 VOS 数据集（包括 YouTube VOS、COCO 和 DAVIS）上训练我们的方法。</p>
<h3 id="A-9-解耦内存-AOT-DMAOT">A.9.解耦内存 AOT (DMAOT)</h3>
<p>我们提出了 DeAOT [64] 和 AOT [63] 的调整版本，称为 DMAOT，它存储对象方式的长期记忆，而不是 AOT 使用的帧方式的长期记忆。借助这种逐对象长期记忆，DMAOT 可确保所有要跟踪的对象的掩码都存储在内存中，并且与当前掩码具有高度相似性。然后 DMAOT 使用这些内存来预测当前对象掩码，从而获得更好的结果。</p>
<h3 id="A-10-判别性单次分割跟踪器-v2-d3sv2">A.10.判别性单次分割跟踪器 v2 (d3sv2)</h3>
<p>D3Sv2 [39] 是 D3S [38] 的扩展版本。原始方法在以下方面进行了扩展：（i）更好的主干，（ii）GIM 中的升级模块中的通道注意机制，（iii）GIM 中可训练的基于 MLP 的相似性计算，它取代了“手工制作”的顶部- K 平均运算和（iv）用于鲁棒目标尺寸估计的新尺度估计模块。</p>
<h3 id="A-11-DropTrackSamb：具有-DropMAE-预训练和基于-SAM-模型的用于掩模预测的-DropTrack-DropTrackSamb">A.11. DropTrackSamb：具有 DropMAE 预训练和基于 SAM 模型的用于掩模预测的 DropTrack (DropTrackSamb)</h3>
<p>DropTrackSamb由两个主要模块组成，包括基于ViT的DropTrack运动模块和SAMbase分割模块。DropTrack采用了预训练的DropMAE [55]初始化，并在OSTrack中使用标准的微调进行下游跟踪表示学习。在DropTrack中没有使用额外的在线更新或内存，也不应用跟踪失败检测，因为我们的跟踪器是一种短期跟踪器。在获取DropTrack预测的边界框后，我们将其用作SAM-base模型的盒子提示输入，以进行掩模预测。</p>
<h3 id="A-12-动态匹配网络（DMNet）">A.12.动态匹配网络（DMNet）</h3>
<p>我们提出了一种用于像素级和部分级匹配的动态匹配网络（DMNet），其中包括动态像素感知对应模块（Pixel-CM）和动态部分感知对齐模块（Part-AM）。这两个模块以对抗性方式进行训练，其中 PixelCM 生成更准确的掩模，接近地面事实以欺骗 Part-AM。此外，Pixel-CM 优化了局部窗口内的对应关系，以减少错误匹配，而 Part-AM 将对象划分为不同的部分，并区分预测掩模和真实情况之间的详细局部差异。最后，我们应用测试时间增强和模型集成 [6, 64] 来进一步提高准确性。</p>
<h3 id="A-13-基于时间置信度学习的集成相关滤波器跟踪（TCLCF）">A.13.基于时间置信度学习的集成相关滤波器跟踪（TCLCF）</h3>
<p>TCLCF 是一种基于时间置信度学习的实时集成相关滤波器跟踪器。在当前的实现中，我们使用两个不同的相关滤波器来协作跟踪同一目标。 TCLCF 跟踪器是一种高速且强大的通用对象跟踪器，不需要 GPU 加速。因此，可以在计算资源有限的嵌入式平台上实现。</p>
<h3 id="A-14-组合不同的跟踪器以进行稳健的单对象和多对象跟踪-MixItUp-2">A.14.组合不同的跟踪器以进行稳健的单对象和多对象跟踪 (MixItUp-2)</h3>
<p>MixItUp-2是一种集成算法，根据视频序列中的目标数量，自适应不同的情景。对于视频序列中目标数量少于5的情景，它采用MixFormer跟踪器[9]。MixFormer预测目标的边界框，提供准确的位置估计。它与Segment Anything Model（SAM）[25]配合使用，基于预测的边界框生成分割掩模，确保精确的目标识别。在存在5个或更多目标的情况下，集成跟踪器切换到DeAOT跟踪器[64]。它利用分层特征传播和注意机制来处理具有遮挡和混乱背景的复杂情况。这使得跟踪器能够准确跟踪和区分视频序列中的多个目标。通过利用集成方法并结合MixFormer和DeAOT，该跟踪器确保在各种情境下进行稳健而准确的目标跟踪。</p>
<h3 id="A-15-组合不同的跟踪器以进行稳健的单对象和多对象跟踪-MixItUp-3">A.15.组合不同的跟踪器以进行稳健的单对象和多对象跟踪 (MixItUp-3)</h3>
<p>MixItUp-3 与 MixItUp-2 (A.14) 类似。两个跟踪器之间的差异在于用于使用 MixFormer 跟踪器或 DeAOT 跟踪器的对象数量。对于 MixItUp-3，对象数量设置为 4。</p>
<h3 id="A-16-组合不同的跟踪器以进行稳健的单目标和多目标跟踪-MixFormerSAMHDeAOT">A.16.组合不同的跟踪器以进行稳健的单目标和多目标跟踪 (MixFormerSAMHDeAOT)</h3>
<p>MixFormerSAMHDeAOT 与 MixItUp2 (A.14) 类似。两个跟踪器之间的差异在于用于使用 MixFormer 跟踪器或 DeAOT 跟踪器的对象数量。对于 MixFormerSAMHDeAOT，对象数量设置为 2。</p>
<h3 id="A-17-学习用于视觉跟踪的时空变换器-starkmulti">A.17.学习用于视觉跟踪的时空变换器 (starkmulti)</h3>
<p>Stark [60]是一种基于变换器方法的端到端跟踪方法，它直接预测一个准确的边界框作为跟踪结果。模板和搜索区域被串联成单一特征表示，并经过多次自注意操作处理，得到最终的特征表示，然后进行边界框预测。此外，Stark不使用任何对超参数敏感的后处理，因此具有稳定的性能表现。</p>
<h3 id="A-18-链接开放词汇检测-LOVE">A.18.链接开放词汇检测 (LOVE)</h3>
<p>LOVD 使用预训练的开放词汇检测模型 Grounding DINO [67] 执行检测跟踪。所有序列均使用约 80 个单词的相同提示。两个检测的视觉相似度是使用文本标记上的可能性的 KL 散度来测量的。使用检测与第一帧中正确检测的相似性来过滤检测。连续的轨迹是通过将检测与前一帧的轨迹进行匹配来构建的，并且不匹配的检测会初始化新的轨迹。考虑到时间重叠以及运动和外观的相似性，轨迹与过去的轨迹相关联。使用预先训练的分段任意模型 [25] 获得每个框的掩码。</p>
<h3 id="A-19-long-vil-net2-vil-net2">A.19. long vil net2 (vil net2)</h3>
<p>使用的主要算法包括用于自动/交互式关键帧分割的 SAM（Segment Anything Models）[25] 和用于高效多对象跟踪和传播的 DeAOT [64]。</p>
<h3 id="A-20-基于内存的视频对象分割跟踪器（M-VOSTracker）">A.20.基于内存的视频对象分割跟踪器（M-VOSTracker）</h3>
<p>M-VOSTracker主要由对象分割器和掩模细化器组成。对象分割器是 DeAOT [64] 的修改版本，我们将门控传播模块扩展为 1/8 比例，并采用更强大的 InternImage [53] 作为我们的主干。该分割器使用多对象分割数据集进行训练，以便更好地理解多个对象之间的关系，并且它可以在一次推理过程中同时处理多个对象。为了进一步提高跟踪掩模的准确性，我们利用预先训练的 SAM 模型，该模型经过大规模分段数据的训练来完善我们的跟踪结果。</p>
<h3 id="A-21-MiOTS-MiOTS-formerly-MiOTS-rushmi">A.21. MiOTS (MiOTS (formerly MiOTS rushmi))</h3>
<p>MiOTS基于单目标多目标跟踪分割模型。对于每个跟踪目标，MiOTS 都会初始化一个跟踪器。 MiOTS 框架由两个模型组成：MixformerV2 [10] 和 AOT [63]。 MixformerV2是原始模型的扩展，输入大小为384，我们使用SAM[25]的模型参数作为预训练并重新训练模型以获得更大的MixformerV2模型。第二种模型AOT基于R50骨干网络。这个模型我们直接使用官网提供的模型参数。在跟踪过程中，MixformerV2 和 AOT 模型同时运行。 MiOTS 然后计算两个模型的跟踪结果的交并集 (IoU)。如果 IoU 小于 0.1，我们直接使用 AOT 的结果，因为它的召回性能更优越。如果 IoU 大于 0.5，我们使用 MixformerV2 的结果，因为它的准确性更好。最后，如果 IoU 在 0.1 到 0.5 的范围内，我们使用两个模型结果的交集作为最终输出。</p>
<h3 id="A-22-MiOTS-ST-MiOTS-ST">A.22. MiOTS-ST (MiOTS-ST)</h3>
<p>MiOTS-ST 基于 MiOTS (A.21)。在 MiOTS-ST 中，MixformerV2 和 AOT 模型根据尺寸比例独立使用。对于超过 100 的比率，由于其准确性而使用 MixformerV2，而对于低于 100 的比率，由于其出色的召回率而选择 AOT。这种方法有效地利用了两种模型的优势，提高了短期跟踪和细分模型的准确性和弹性。</p>
<h3 id="A-23-MixConvMAE-L-MixFormer">A.23. MixConvMAE-L (MixFormer)</h3>
<p>MixFormer-ConvMAE-Large 是一种具有迭代混合注意力的端到端跟踪（MixConvMAE-L）。 MixConvMAE-L 由两个阶段组成，分别执行基于 MixFormer 的跟踪和基于 Alpha-Refine 的分割。我们的核心设计是利用注意力操作的灵活性，提出一种混合注意力模块（MAM），用于同时进行特征提取和目标信息集成。 MixFormer-ConvMAELarge 是基于预训练的 ConvMAE-Large 构建的。</p>
<h3 id="A-24-MixFormerV2-Base-MixFormerV2">A.24. MixFormerV2-Base (MixFormerV2)</h3>
<p>MixFormerV2是一个统一良好的完全变压器跟踪模型，没有任何密集的卷积操作和复杂的分数预测模块。我们提出了四个关键预测标记来捕获目标模板和搜索区域之间的相关性。基于它们，我们可以轻松地预测跟踪框并通过简单的 MLP 头估计其置信度得分。通过我们的蒸馏设计，MixFormerV2 可以在性能和推理延迟之间实现出色的权衡。此外，我们在顶部放置了一个 Alpha Refine 模型来进行目标分割。</p>
<h3 id="A-25-MS-AOT：将对象与多尺度转换器关联以进行视频对象分割-aot">A.25. MS-AOT：将对象与多尺度转换器关联以进行视频对象分割 (aot)</h3>
<p>MS-AOT 跟踪器是基于 AOT [63,62,65]（一种基于变换器的视频对象分割方法）构建的，通过在多个特征尺度上应用变换器。 MS-AOT 可以端到端地跟踪和分割大多数对象，而无需使用边界框信息。对于微小物体，我们使用 MixFormer [9]（一种基于边界框的跟踪器）来粗略定位物体，然后再应用 MS-AOT 预测分割结果。 MS-AOT 的主干是 ResNet-50，MixFormer 的主干是 CvT [54]。</p>
<h3 id="A-26-Mstark-Mstark">A.26. Mstark (Mstark)</h3>
<p>Tracker Mstark 基于 Stark 模型 [60]，包含两个关键变化。首先，将对象存在标志添加到 Stark 模型中。该标志充当确定场景中是否存在对象的指示器。其次，对模型的搜索区域进行了调整，将搜索区域扩大了3.5倍。通过扩大搜索区域，模型具有更宽的视野，增加了正确检测与目标物体非常相似的物体的可能性。这一修改旨在提高模型区分相似物体的能力并减少漏检。对象存在标记有助于消除误报，而扩展的搜索区域则减少了对相似对象的误检测。</p>
<h3 id="A-27-基于多上下文的多目标跟踪器-MCMOT">A.27.基于多上下文的多目标跟踪器 (MCMOT)</h3>
<p>MCMOT 利用 MixFormer [9] 进行目标位置检测，并利用分段任意模型 (SAM) [25] 进行对象屏蔽。这还涉及在每个时间步独立预测每个目标的位置。然而，在目标模板共享相似视觉外观的情况下，这种独立预测可能会导致指示同一对象的不同模板。为了解决这个问题，MCMOT 结合了前一个时间步预测的上下文信息。具体来说，在当前模板的输入搜索区域中，与前一时间步预测的其他模板的位置对应的像素被设置为0。此外，MCMOT 结合了两个在线模板，即长期模板和短期模板，以提供更全面的上下文。通过这样做，模型可以同时受益于两个模板：保留消失对象的外观特征并处理外观的快速变化。</p>
<h3 id="A-28-通过粒子重新传播和稀疏光流进行多目标跟踪器-TrackerPRO">A.28.通过粒子重新传播和稀疏光流进行多目标跟踪器 (TrackerPRO)</h3>
<p>TrackerPRO 基于迭代粒子重新传播方法 [8]，该方法采用粒子和 HSV 颜色直方图来提高跟踪精度。与之前的算法相比，粒子分布由高斯分布改为圆形均匀分布，以在各个角度上密度均匀的圆上初始化粒子。之后，使用计算的光流来调整粒子的方向。为了跟踪各种尺寸的物体，在粒子位置周围生成收缩和膨胀区域，并在这些区域之间选择颜色分布与物体更相似的区域。跟踪对象是根据不同区域的粒子的相似分布程度来确定的。</p>
<h3 id="A-29-多目标线索跟踪-MTCTrack">A.29.多目标线索跟踪 (MTCTrack)</h3>
<p>MTCTrack 通过多个目标线索来挖掘目标更全面的信息。 MTCTrack 建立在 OSTrack [66] 之上，利用长期上下文信息来传播目标的外观状态，显式地建模目标的表观信息。此外，采用 Alpha-Refine [61] 来产生掩模预测作为输出。</p>
<h3 id="A-30-OmniTracker-pyetest800-convnext-pytest800-convnext">A.30. OmniTracker pyetest800 convnext (pytest800 convnext)</h3>
<p>取决于目标对象的初始状态是由第一帧中提供的注释还是类别指定的。结合两个社区中开发的最佳实践的优点，实例跟踪（例如，SOT 和 VOS）和类别跟踪（例如，MOT、MOTS 和 VIS），我们提出了一种新颖的跟踪与检测范例，其中跟踪补充了外观先验检测和检测提供了对候选边界框的跟踪以进行关联。配备这样的设计，进一步提出了统一的跟踪模型OmniTracker，以完全共享的网络架构、模型权重和推理管道来解决所有跟踪任务。</p>
<h3 id="A-31-PriMem：具有先验知识的基于内存的跟踪器（PriMem）">A.31. PriMem：具有先验知识的基于内存的跟踪器（PriMem）</h3>
<p>该 PriMem 跟踪器构建在 XMem [6] 之上，XMem 是视频对象分割中基于内存的单对象跟踪器。与原始模型相比，我们添加了实例的先验知识以改进复杂场景下的对象跟踪。此外，我们采用结合隐式表达和原始特征向量的SOTA分割模型来辅助分割掩模的生成。</p>
<h3 id="A-32-READMem-MiVOS-READMem-MiVOS">A.32. READMem-MiVOS (READMem MiVOS)</h3>
<p>READMem MiVOS 基于 READMem（多样化内存的鲁棒嵌入关联）[52]，这是一种半自动视频对象分割（sVOS）方法的模块化框架，旨在处理无约束视频。仅当 READMem 增加了内存内容的多样性时，READMem 才会将新帧嵌入到内存中。此外，它在更新过程中使用存储在内存中的嵌入与查询嵌入的鲁棒关联。跟踪器由两个编码器[20]组成，每个编码器用于存储器和查询帧，一个时空存储器读取块[7]，一个解码器[47]和一个存储先前观察到的帧作为参考的外部存储器。内存编码器联合使用图像和对象掩码来提取内存键和值嵌入，而查询编码器专门处理查询图像以获得查询键和值嵌入。查询键和内存键之间的交叉注意力（由时空内存读取块执行）确定了内存值的相关信息，解码器利用这些信息来分割当前帧。</p>
<h3 id="A-33-Reptile-Meta-Tracking-ReptileFPN">A.33. Reptile Meta-Tracking (ReptileFPN)</h3>
<p>ReptileFPN 是一个基于 FPN 模型和称为 Reptile 的元学习技术的跟踪器。我们通过重复采样不同的任务来离线训练深度学习网络。由此产生的网络可以快速适应任何域，而不需要像 MDNet 那样训练多域分支。 Reptile Meta-Tracker 的原始架构使用了类似 VGG 的主干网。这里我们使用FPN对其进行修改，进一步提高特征提取能力。在在线初始化期间，ReptileFPN 跟踪器只需要第一帧中的一些训练示例和几个优化步骤。</p>
<h3 id="A-34-通过分段进行稳健的视觉跟踪-rts-rts50-002">A.34.通过分段进行稳健的视觉跟踪 (rts_rts50_002)</h3>
<p>RTS [48]是一个统一的跟踪架构，能够预测准确的分割掩模。为了设计一个以分割为中心的方法，我们受到了VOS方法LWL [4]的启发。然而，为了在跟踪数据集上实现鲁棒且准确的分割，我们提出了一些新的组件。特别地，我们提出了一个实例定位分支，经过训练可以预测目标外观模型，从而允许检测遮挡并在拥挤场景中正确识别目标。实例定位分支的输出进一步用于条件化高维度掩模编码。这使得分割解码器能够集中在定位的目标上，从而实现更鲁棒的掩模预测。由于我们的提出方法包括需要使用先前的跟踪结果更新的分割记忆和实例记忆，因此我们设计了一个记忆管理模块。这个模块首先评估预测质量，决定样本是否应该进入记忆，并在需要更新时触发跟踪模型。更多详细信息请参阅[48]。</p>
<h3 id="A-35-基于分段任何模型的-AOT-跟踪器（SAM-跟踪器）">A.35.基于分段任何模型的 AOT 跟踪器（SAM 跟踪器）</h3>
<p>SAM Tracker使用Segment Anything模型为AOT跟踪器[63]生成参考分段信息，同时结合接地DINO[67]为跟踪器生成文本提示。</p>
<h3 id="A-36-基于分段任何模型的-MixFormer-跟踪器-MixSAMB">A.36.基于分段任何模型的 MixFormer 跟踪器 (MixSAMB)</h3>
<p>所提出的跟踪器模型使用具有泛化性能的分段任意模型（SAM）[25]作为后端来预测目标的图像分割信息。为了预测跟踪目标的目标区域分割，我们使用边界框跟踪器的预测结果作为 SAM 的提示。为了生成准确的提示，使用了 MixFormer [9] 模型，该模型在边界推理方面表现出了出色的性能。跟踪器使用预训练的 MixFormer-vit-base 模型，SAM 使用预训练的 ViT-base 模型[14]。</p>
<h3 id="A-37-SegmentAnything-Open-CLIP-HSE-University-IPPM-RAS-SRZLT-HSE-IPPM-ClipSegmentAnything">A.37. SegmentAnything + Open CLIP (HSE University + IPPM RAS) (SRZLT HSE IPPM ClipSegmentAnything)</h3>
<p>我们的方法取决于两个模型。第一个模型是 Facebook [25] 基于 VIT-H 主干的 Segment Anything。该模型搜索感兴趣的区域并返回一组掩模。第二个模型是 Open CLIP 模型13，它为每个感兴趣区域以及所有要找到的对象查找向量。之后，找到每个建议的掩模和每个对象之间的余弦相似度。为对象选择具有最大值的掩码。跟踪器一次搜索所有对象，它是一个零样本跟踪器（即它没有在任何跟踪数据集上进行训练）。开发的跟踪器可以在 Github<sup>14</sup> 上免费获得。</p>
<h3 id="A-38-SeqTrack：视觉对象跟踪的序列到序列学习（seqtrack）">A.38. SeqTrack：视觉对象跟踪的序列到序列学习（seqtrack）</h3>
<p>我们利用 Seqtrack [5] 作为我们的主要跟踪器，它基于简单的编码器-解码器变压器架构。对象的边界框表示为一系列离散标记，编码器提取视觉特征，而解码器使用提取的特征自回归生成边界框标记序列。为了解决干扰因素的挑战，我们还采用了一种名为 KeepTrack 的辅助跟踪器 [41]。此外，我们还结合了一个基本运动模块（在 LaSOT 数据集上训练）来预测跟踪器结果出现异常跳跃时的目标边界框。我们使用 SAM [25] 模型来预测掩模。</p>
<h3 id="A-39-starkplusplus-starkplusplus">A.39. starkplusplus (starkplusplus)</h3>
<p>这个修改后的模型基于stark [60]的单目标跟踪模型，并加入了一个yolo [50]检测模块以增强其功能。修改的主要目标是解决跟踪器失去目标的情况。为实现这一目标，将一个yolo检测模块集成到模型架构中。当跟踪器无法定位目标时，会触发yolo检测模块，允许模型进行新的检测以重新定位和重新获取目标。此外，引入了一个标志来提供有关当前帧中目标是否存在的信息。通过结合stark模型的优势、yolo检测模块以及引入的标志，这个修改后的模型通过在目标丢失时自动重新检测目标并提供其存在的实时信息，提供了改进的跟踪性能。</p>
<h3 id="A-40-STARK-ST50-with-Alpha-Refine-stark-st50-ar">A.40. STARK-ST50 with Alpha-Refine (stark st50 ar)</h3>
<p>Stark st50 ar 结合了基于 Transformer 的 STARK [60] 和 Alpha-Refine [61]。</p>
<h3 id="A-41-跟踪和分段任何模型-T-SAM">A.41.跟踪和分段任何模型 (T-SAM)</h3>
<p>我们选择一个有效的跟踪器 DeAOT [64] 作为基线跟踪器，以实现高效的多目标跟踪和传播。我们进一步应用大型模型 SAM（Segment Anything Models）[25] 进行自动关键帧分割。</p>
<h3 id="A-42-高质量跟踪任何内容-HQTrack">A.42.高质量跟踪任何内容 (HQTrack)</h3>
<p>HQTrack主要由视频多对象分割器和掩模细化器组成。分段器是 DeAOT [64] 的改进版本，我们级联一个 1/8 比例的门控传播模块，用于感知复杂场景中的小物体。此外，采用Intern-T作为我们的特征提取器来增强对象辨别能力。我们的对象分割器使用多对象分割数据集进行训练，以便更好地理解多个对象之间的关系。它可以在一次推理过程中同时处理多个对象。为了进一步提高跟踪掩模的质量，我们利用预先训练的 HQ-SAM 模型 [24] 来完善我们的跟踪结果。 HQ-SAM设计了一个可学习的高质量输出令牌，该令牌被注入到SAM的掩模解码器中，并负责预测高质量掩模。我们根据框提示计算分割器预测结果的外围框，并将其与原始图像一起输入 HQ-SAM 以获得细化结果，最终的跟踪结果是从分割器和细化器中选择的。有关更多实施细节，我们建议读者参阅我们的技术报告[68]。</p>
<h3 id="A-43-通过目标感知消失检测-UnitTS-进行统一对象跟踪">A.43.通过目标感知消失检测 (UnitTS) 进行统一对象跟踪</h3>
<p>我们使用基线 Unicorn [58] 同时解决 SOT 和 MOT 任务。为了解决新的 VOTS 任务，我们主要遵循 SOT 范式，但将原始的单一地面实况提示扩展到多个。为了解决物体消失的问题，我们进一步设计了一种目标感知消失检测方法。当分数低于阈值时，会激活重新检测，这里的阈值是目标感知的。我们使用预先训练的模型来处理所有视频，因此固定阈值可能不适合所有类型的目标。所以阈值与该方法中第一帧计算的分数有关。具体来说，我们为不同的对象赋予不同的阈值。</p>
<h3 id="A-44-UNINEXT-with-ResNet-50-backbone-UNINEXT-R50">A.44. UNINEXT with ResNet-50 backbone (UNINEXT R50)</h3>
<p>UNINEXT 是一个强大的统一模型，适用于 10 个实例感知任务。它将 10 个实例感知任务重新表述为提示引导的对象发现和检索方式。</p>
<h3 id="A-45-UNINEXT-with-ViT-Huge-backbone-UNINEXT-Huge">A.45. UNINEXT with ViT-Huge backbone (UNINEXT Huge)</h3>
<p>UNINEXT是10个实例感知任务的统一模型。 UNINEXT Huge [59]以ViT-Huge为骨干。其他设置与 UNINEXT R50 (A.44) 一致。</p>
<h3 id="A-46-ViT-自适应密集融合变压器跟踪器-VAPT">A.46. ViT 自适应密集融合变压器跟踪器 (VAPT)</h3>
<p>VAPT 是一种两阶段视频跟踪到分割架构。该跟踪器基于具有自适应网络的 ViT 编码器、4 层密集融合解码器 (DFD) 和两个 DCF 目标预测头。自适应网络建立在 12 层零中心注意力块上，将每个近层的特征上下文集成到同一特征空间中。 DFD 由目标查询张量、四个零中心注意力层和一个项目 MLP 层构建。 DCF 目标头扩展了受 ToMP [40] 头启发的卷积层。分割网络遵循 HQ-SAM [24]，根据预测的边界框生成高质量的目标掩模。在推理过程中，我们提出了一种名为 CycleTrack 的策略，通过验证时间循环一致性来纠正干扰因素引起的错误。这是基于这样的见解：作为后验条件，在时间上向后跟踪时，被跟踪目标应该跟踪前一帧目标。为了提高长期自适应跟踪能力，我们将ToMP中的基本内存更新策略扩展为交错模板更新方法。此外，搜索区域抖动是 VAPT 中的另一种推理策略。当目标丢失时，将应用它来在大范围区域内重新找到它。</p>
<h3 id="A-47-视觉变换器跟踪（vttrack）">A.47.视觉变换器跟踪（vttrack）</h3>
<p>我们对跟踪数据集上使用 MAE [19] 方法生成的权重进行了微调。我们使用 VIT-large 模型。首先，模板和搜索区域都被嵌入补丁，然后通过变压器块结构连接在一起进行特征提取和融合。最后，将融合后的特征输出到分类和回归头，完成边界框的生成。我们在分类头的输出上应用汉宁窗来利用对象的运动信息。之后，我们检索置信度最高位置处的回归头的输出并输出边界框。我们使用Segment Anything Segment Anything Model（SAM）[25]作为输出掩模的模型。当跟踪器输出的置信度值很低时，认为目标不再在图像中，并输出空掩模。</p>
<h1>Basic Information:</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>Title: The First Visual Object Tracking Segmentation VOTS2023 Challenge Results (第一届视觉目标跟踪分割VOTS2023挑战结果)</p>
</li>
<li class="lvl-2">
<p>Authors: Matej Kristan, Jiˇr´ı Matas, Martin Danelljan, Michael Felsberg, Hyung Jin Chang, Luka ˇCehovin Zajc, Alan Lukeˇziˇc, Ondrej Drbohlav, Zhongqun Zhang, Khanh-Tung Tran, Xuan-Son Vu, Johanna Bj¨orklund, Christoph Mayer, Yushan Zhang, Lei Ke, Jie Zhao, Gustavo Fern´andez, Noor Al-Shakarji, Dong An, Michael Arens, Stefan Becker, Goutam Bhat, Sebastian Bullinger, Antoni B. Chan, Shijie Chang, Hanyuan Chen, Xin Chen, Yan Chen, Zhenyu Chen, Yangming Cheng, Yutao Cui, Chunyuan Deng, Jiahua Dong, Matteo Dunnhofer, Wei Feng, Jianlong Fu, Jie Gao, Ruize Han, Zeqi Hao, Jun-Yan He, Keji He, Zhenyu He, Xiantao Hu, Kaer Huang, Yuqing Huang, Yi Jiang, Ben Kang, Jin-Peng Lan, Hyungjun Lee, Chenyang Li, Jiahao Li, Ning Li, Wangkai Li, Xiaodi Li, Xin Li, Pengyu Liu, Yue Liu, Huchuan Lu, Bin Luo, Ping Luo, Yinchao Ma, Deshui Miao, Christian Micheloni, Kannappan Palaniappan, Hancheol Park, Matthieu Paul, HouWen Peng, Zekun Qian, Gani Rahmon, Norbert Scherer-Negenborn, Pengcheng Shao, Wooksu Shin, Elham Soltani Kazemi, Tianhui Song, Rainer Stiefelhagen, Rui Sun, Chuanming Tang, Zhangyong Tang, Imad Eddine Toubal, Jack Valmadre, Joost van de Weijer, Luc Van Gool, Jash Vira, St`ephane Vujasinovi´c, Cheng Wan, Jia Wan, Dong Wang, Fei Wang, Feifan Wang, He Wang, Limin Wang, Song Wang, Yaowei Wang, Zhepeng Wang, Gangshan Wu, Jiannan Wu, Qiangqiang Wu, Xiaojun Wu, Anqi Xiao, Jinxia Xie, Chenlong Xu, Min Xu, Tianyang Xu, Yuanyou Xu, Bin Yan, Dawei Yang, Ming-Hsuan Yang, Tianyu Yang, Yi Yang, Zongxin Yang, Xuanwu Yin, Fisher Yu, Hongyuan Yu, Qianjin Yu, Weichen Yu, YongSheng Yuan, Zehuan Yuan, Jianlin Zhang, Lu Zhang, Tianzhu Zhang, Guodongfang Zhao, Shaochuan Zhao, Yaozong Zheng, Bineng Zhong, Jiawen Zhu, Xuefeng Zhu, Yueting Zhuang, ChengAo Zong, Kunlong Zuo</p>
</li>
<li class="lvl-2">
<p>Affiliation: University of Ljubljana, Slovenia (斯洛文尼亚卢布尔雅那大学)</p>
</li>
<li class="lvl-2">
<p>Keywords: Visual object tracking, Segmentation, VOTS2023 Challenge (视觉目标跟踪，分割，VOTS2023挑战)</p>
</li>
<li class="lvl-2">
<p>URLs: <a href="https://openaccess.thecvf.com/content/ICCV2023W/VOT/html/Kristan_The_First_Visual_Object_Tracking_Segmentation_VOTS2023_Challenge_Results_ICCVW_2023_paper.html">Paper</a>, <a href="https://github.com/votchallenge/vots2023">GitHub</a></p>
</li>
</ul>
<h1>论文简要 :</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>本研究是第一届视觉目标跟踪分割VOTS2023挑战的结果，通过合并短期和长期跟踪以及单目标和多目标跟踪，使用分割掩码作为唯一的目标位置指示，展示了47个跟踪器的结果，表明现代跟踪框架很适合处理短期和长期跟踪的融合，同时将多目标和单目标跟踪视为一个问题。 (This research presents the results of the first Visual Object Tracking Segmentation VOTS2023 Challenge, which merges short-term and long-term tracking as well as single-target and multiple-target tracking using segmentation masks as the only target location specification. The results of 47 trackers indicate that modern tracking frameworks are well-suited to deal with the convergence of short-term and long-term tracking, and that multiple and single target tracking can be considered a single problem.)</p>
</li>
</ul>
<h2 id="背景信息">背景信息:</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>论文背景: 视觉目标跟踪是计算机视觉领域的一个基本问题，近二十年来取得了显著进展，但缺乏统一的性能评估标准。为了推动该领域的发展，VOT1倡议成立，随后的VOT挑战活动使得VOT成为跟踪领域的核心。 (Visual object tracking is a fundamental problem in computer vision, and significant progress has been made in the past two decades. However, there is a lack of consensus on performance evaluation standards. To promote the development of this field, the VOT1 initiative was</p>
</li>
</ul>
<h2 id="方法">方法:</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>a. 理论背景:</p>
<ul class="lvl-2">
<li class="lvl-4">VOTS2023挑战是第一个将短期和长期跟踪与分割掩码结合作为目标位置规范的挑战。创建了一个新的数据集，并开发了新的性能评估指标、评估协议、工具包和评估服务器。</li>
</ul>
</li>
<li class="lvl-2">
<p>b. 技术路线:</p>
<ul class="lvl-2">
<li class="lvl-4">VOTS2023挑战要求通过分割在长或短的序列上同时跟踪一个或多个目标，即使目标在视频中消失并重新出现。参与者将他们的跟踪器集成到VOTS2023评估工具包中，并提交他们的跟踪器输出。</li>
</ul>
</li>
</ul>
<h2 id="结果">结果:</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>a. 详细的实验设置:</p>
<ul class="lvl-2">
<li class="lvl-4">VOTS2023数据集包含来自现有数据集的序列，包括LaGOT、VOT-LT2021、VOT-LT2022、UTB180、VOT-ST2022和TOTB。数据集包含具有挑战性的情况，适用于现代跟踪架构，并涵盖了各种目标外观和对象类型。数据集包含具有视觉相似对象、外观变化的对象、杂乱背景上的对象、退出和重新进入视野的对象以及部分遮挡的对象。数据集共包含144个序列，共341个目标，平均序列长度约为2000帧。</li>
</ul>
</li>
<li class="lvl-2">
<p>b. 详细的实验结果:</p>
<ul class="lvl-2">
<li class="lvl-4">VOTS2023挑战共收到77个跟踪器的提交。经过去重和不完整提交的处理，保留了47个有效的条目。根据主要跟踪质量得分（Q）排名前10的跟踪器是DMAOT、HQTrack、M-VOSTracker、Dynamic DEAOT、seqtrack、DMNet、aot、MCMOT、rts rts50 002和VAPT。大多数这些跟踪器被归类为ST1或LT0，并且使用transformer作为主要的跟踪方法。结果在跟踪质量图、AR图和表2中进行了总结。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>ICCV</tag>
        <tag>视觉跟踪</tag>
        <tag>VOTS2023挑战赛</tag>
        <tag>cv</tag>
        <tag>跟踪器</tag>
      </tags>
  </entry>
  <entry>
    <title>论文：Wei_Autoregressive_Visual_Tracking_CVPR_2023_paper</title>
    <url>/2023/11/08/University/AI/PaperLearn/Wei_Autoregressive_Visual_Tracking_CVPR_2023_paper/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Wei_Autoregressive_Visual_Tracking_CVPR_2023_paper</h1>
<blockquote>
<p>论文：<a href="https://openaccess.thecvf.com/content/CVPR2023/papers/Wei_Autoregressive_Visual_Tracking_CVPR_2023_paper.pdf">https://openaccess.thecvf.com/content/CVPR2023/papers/Wei_Autoregressive_Visual_Tracking_CVPR_2023_paper.pdf</a></p>
<p>参考：<a href="https://blog.csdn.net/qq_43437453/article/details/131033203">https://blog.csdn.net/qq_43437453/article/details/131033203</a></p>
<p>每帧模板匹配问题（忽略了视频帧之间的时序依赖性）；将跟踪视为坐标序列解释任务（保持跟踪结果的连贯性，不需要定制的定位头和后处理步骤）；</p>
<p>受到Pix2Seq 的启发：将语言建模框架引入视觉对象跟踪中，<strong>对连续坐标进行离散化</strong>，以<u><strong>避免描述连续坐标所需的大量参数</strong></u>，这称为标记化。</p>
<p>编码器：vision Transformer (ViT)进行视觉特征编码。</p>
<p>解码器：使用Transformer解码器生成目标序列。</p>
<p>知识扩展（与本文主体内容无关）：</p>
<ol>
<li class="lvl-3">
<p>RAN使用循环自回归网络进行在线多目标跟踪；</p>
</li>
<li class="lvl-3">
<p>SwinTrack的改进版本添加了一个新颖的运动标记来合并时间上下文以进行跟踪；</p>
</li>
<li class="lvl-3">
<p>Pix2Seq将视觉任务制定为以像素标记输入为条件的语言建模任务；（ICLR）</p>
</li>
<li class="lvl-3">
<p>OSTrack的ViT编码器进行<strong>视觉特征编码</strong>；（ECCV）</p>
</li>
<li class="lvl-3">
<p>SIoU损失函数：更强大的边界框回归学习；</p>
</li>
</ol>
</blockquote>
<h2 id="Abstract">Abstract</h2>
<p>本文提出了 <strong>ARTrack</strong>，一个用于视觉对象跟踪的自回归框架。 ARTrack 将跟踪作为一种<u><strong>坐标序列解释任务</strong></u>来处理，该任务<strong>逐步估计对象轨迹</strong>，其中<u>当前估计是由先前的状态引起的</u>，进而影响子序列。这种时间自回归方法<strong>对轨迹的顺序演化进行建模</strong>，以保持<strong>跨帧跟踪对象</strong>，使其<mark>优于</mark>现有的<strong>仅考虑每帧定位精度的基于模板匹配的跟踪器</strong>。 ARTrack 简单直接，<u>消除了定制的本地化头和后处理</u>。尽管很简单，ARTrack 在主流基准数据集上实现了最先进的性能（state-of-the-art，SOTA）。源代码位于：<a href="https://github.com/MIV-XJTU/ARTrack">https://github.com/MIV-XJTU/ARTrack</a></p>
<h2 id="Introduction">Introduction</h2>
<p><strong>视觉对象跟踪</strong>是计算机视觉领域的一个基本目标，跟踪器致力于根据其初始状态来估计每个视频帧中任意目标的位置。尽管其表面上的定义很简单，但由于各种问题，包括但不限于<u><strong>对象变形、尺度变化、遮挡和类似对象的干扰</strong></u>，跟踪任务在现实环境中提出了重大挑战。幸运的是，视觉跟踪<mark>利用了</mark><strong>大量的时间数据</strong>，因为它的<u>输入包括一系列视频帧</u>。通过观察，人类利用时间信息来获取目标变形、速度和加速度趋势的感知，使他们能够在面对不加区别或暂时不可用的视觉信息时保持一致的跟踪结果。</p>
<p>当前用于视觉对象跟踪的主流方法通常将其视为<u><strong>每帧模板匹配问题</strong></u>，忽略视频帧之间<u>潜在的时间依赖性</u>。</p>
<p>这些方法通常遵循三个主要阶段：（i）从搜索和模板图像中基于深度神经网络的特征提取，(ii) 使用卷积或注意机制进行特征匹配/融合的集成模块，以及 (iii) 通过角点、中心/尺度的定制头进行边界框定位估计和目标分类。在某些情况下，前两个阶段可以使用统一的架构进行组合。<u>后处理技术</u>通常在定位步骤中使用，例如<u><strong>汉宁窗罚分（Hanning window penalty）和框优化（box optimization）</strong></u>。一些方法<strong>结合了模板更新机制来改进目标特征表示</strong>。该类别的代表性技术包括<strong>模板图像选择</strong>、<strong>特征集成</strong>和<strong>时间演化</strong>。然而，定制的头部和后处理技术很复杂，可能需要单独的训练和推理，这会损害简单的端到端框架。此外，跟踪强调保持<u>整个序列的定位精度</u>，而传统的每帧训练方法优先考虑<u>即时定位精度</u>，导致训练和推理之间客观不匹配。</p>
<p>这项研究提出了一种与主流方法不同的新颖的视觉对象跟踪框架，主流方法通常采用每帧模板匹配任务。相反，作者建议将跟踪视为<strong>坐标序列</strong>解释，目的是学习用于直接轨迹估计的简单<strong>端到端模型</strong>。所提出的方法基于这样的想法：给定<u><strong>帧序列</strong></u>和<u><strong>初始对象框</strong></u>，跟踪器应该以类似于语言建模任务的方式“解释”跟踪对象的坐标序列。所提出的框架通过逐步解码整个轨迹序列来模拟跨帧的对象轨迹的顺序演化。<strong>当前的估计</strong>受到<strong>先前状态</strong>的影响，进而<strong>影响子序列</strong>，从而统一训练和推理的任务目标。此外，所提出的方法通过<strong>避免定制头和后处理</strong>，而是依赖于<strong>直接坐标回归</strong>，<u><strong>简化了跟踪管道</strong></u>。</p>
<p>所提出的自回归视觉跟踪框架称为 <u><strong>ARTrack</strong></u>，如图 1 所示。该框架的第一步是使用<u><strong>量化和序列化</strong></u>方案<strong>从对象轨迹构建离散标记序列</strong>。然后，该框架采用<u><strong>编码器-解码器架构</strong></u>来感知视觉信息并逐渐生成目标序列。在这个自回归框架中，<u><strong>先前的结果充当时空提示</strong></u>，将先前的运动动态传播到后续帧中，以获得更连贯的跟踪结果。值得注意的是，该模型<u><strong>使用结构化损失函数</strong></u>进行训练，该函数最大化目标序列的可能性，与测试时的任务目标一致。作者通过大量实验证明了这种方法的有效性，表明简单而简洁的 ARTrack 框架在流行的跟踪基准上取得了最先进的结果，优于其他高度定制的跟踪器。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231106151450816.png" alt="image-20231106151450816" style="zoom:67%;" />
<p><em><strong>图 1</strong>.我们的 ARTrack 框架。首先，我们嵌入模板的视觉特征并通过编码器进行搜索。然后，当前时间步的坐标标记由解码器解释，以先前的估计（作为时空提示）以及命令和视觉标记为条件。</em></p>
<h2 id="Related-Work">Related Work</h2>
<p><strong>跟踪框架</strong>。当前流行的跟踪器通常<strong>依赖于模板和搜索图像之间的匹配</strong>。核心设计是特征融合的集成模块。为了解决目标外观沿时间维度变化的问题，一些在线方法学习用于<strong>在线模板更新</strong>的目标相关模型，该模型通常需要单独的训练。它们还需要后处理，例如汉宁窗罚分和框优化。</p>
<p>相比之下，近年来很少有<u><strong>单目标跟踪方法</strong></u>专注于利用运动信息，而在<u><strong>多目标跟踪</strong></u>中很普遍。这些方法通常<strong>集成运动模型</strong>来利用运动信息，生成建议，然后将其与预定义检测器的结果相关联，例如<u>RAN使用循环自回归网络进行在线多目标跟踪</u>。最近，<strong>SwinTrack</strong>的改进版本添加了一个新颖的运动标记来合并时间上下文以进行跟踪。<mark>在本文中，提出了一种在统一框架中进行<u><strong>视觉模板匹配</strong></u>和<u><strong>运动建模</strong></u>的简单方法。</mark></p>
<p><strong>视觉跟踪中的Transformer</strong>。最近的跟踪器中已经采用了<strong>注意力机制</strong>，包括参考文献[6,10,13,56,61,64]中提到的那些。例如，TransT<u>利用注意力来融合特征并建立长距离特征关联，同时自适应地关注相关信息</u>。 MixFormer使用<u>迭代混合注意力来整合特征提取和目标信息</u>。 OSTrack应用早期候选消除模块来消除不必要的搜索区域标记。相比之下，我们的模型是一个<mark>简单的</mark><u><strong>编码器-解码器架构</strong></u>，没有任何专门的头，从而产生了<mark>一个简单且纯粹的<strong>基于Transformer的跟踪器</strong></mark>。</p>
<p><strong>视觉语言建模</strong>。近年来，语言建模取得了重大进展。一些方法旨在<u>为语言和视觉任务创建联合表示模型</u>，例如[1,39,43]中提出的方法。一种特殊的方法，<strong>Pix2Seq</strong>，<strong>将视觉任务制定为以像素标记输入为条件的语言建模任务</strong>。通过将边界框和类标签表示为离散序列，该方法统一了计算机视觉任务。==受 Pix2Seq 的启发，我们<u>将语言建模框架引入视觉对象跟踪中</u>，<u>构建了用于直接轨迹估计的时间自回归模型</u>。==我们的方法简化了跟踪框架，消除了不必要的后处理，并通过连贯的时空提示逐步解码对象坐标。</p>
<h2 id="Tracking-as-Sequence-Interpretation">Tracking as Sequence Interpretation</h2>
<p>我们将视觉跟踪视为顺序坐标解释任务，用条件概率表示：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031160144242.png" alt="image-20231031160144242"></p>
<p>其中 Z 和 X<sup>t</sup> 是给定的模板和时间步 t 的搜索图像，C 是命令标记，Y 表示与 X 相关的目标序列。模板 Z 也可以在每个时间步通过<u><strong>更新机制</strong></u>进行更新，或者只是第一个。可以看出，我们将跟踪表述为时间自回归过程，其中当前结果是最近 N 个过去的函数，以模板和搜索图像为条件。这是一个N阶自回归模型，简称AR(N)模型。具体来说，当 N = 0 时，方程 (1) 退化为每帧模型 P(Y<sup>t</sup> |C , Z , X<sup>t</sup>)，其不以先前状态为条件。</p>
<blockquote>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031160422575.png" alt="image-20231031160422575" style="zoom:50%;" />
</blockquote>
<p>被引入的自回归模型与视觉跟踪兼容，因为它本身就是一个序列预测任务。当前帧中估计的目标状态受到相邻的先前目标状态的影响，并且也影响后续帧。我们将这个跟踪框架称为 ARTrack，它由以下主要组件组成。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>序列构建：给定<u><strong>视频序列和初始对象框</strong></u>，视觉跟踪器预测一系列边界框。它们被映射到统一的坐标系中，并转换为具有共享词汇表的离散标记序列。</p>
</li>
<li class="lvl-2">
<p>网络架构：我们使用<u><strong>编码器-解码器架构</strong></u>，其中<u><strong>编码器嵌入视觉特征</strong></u>，解码器解释<mark>目标序列</mark>。</p>
</li>
<li class="lvl-2">
<p>目标函数：模型通过具有结构化损失函数的视频帧进行训练，以最大化目标序列的对数似然。我们还探索特定任务的目标来提高绩效。</p>
</li>
</ul>
<h3 id="Sequence-Construction-from-Object-Trajectory">Sequence Construction from Object Trajectory</h3>
<p>我们将<u><strong>对象轨迹</strong></u>描述为<u><strong>具有共享词汇的离散标记序列</strong></u>。</p>
<p><strong>标记化</strong>。受Pix2Seq框架的启发，我们<strong>对连续坐标进行离散化</strong>，以<u><strong>避免描述连续坐标所需的大量参数</strong></u>，这称为标记化。具体来说，时间步t处的对象框由四个标记组成，即[x<sup>t</sup> <sub>min</sub>, y<sup>t</sup> <sub>min</sub>, x<sup>t</sup> <sub>max</sub>, y<sup>t</sup> <sub>max</sub>]，每个标记都是[1, n<sub>bins</sub>]之间的整数。当bin数大于或等于图像分辨率时，可以实现<u><strong>零量化误差</strong></u>。然后我们<strong>使用量化项来索引可学习词汇表</strong>以获得与坐标对应的标记。这使得模型能够<strong>用离散标记来描述对象的位置</strong>，并且还允许使用语言模型中<strong>现成的解码器进行坐标回归</strong>。这种新颖的回归<u>避免了从图像特征到坐标的直接非线性映射</u>，这通常是困难的。在去标记化中，我们将输出标记特征与共享词汇进行匹配，以找到最可能的位置。</p>
<p><strong>轨迹坐标映射</strong>。大多数跟踪器会<strong>裁剪搜索区域</strong>以减少计算成本，而不是在全分辨率帧上进行跟踪。这意味着网络输出当前帧中对象相对于搜索区域的坐标。为了获得统一的表示，需要将不同帧的盒子映射到同一坐标系中。在我们的方法中，我们将前面 N 帧的框坐标缓存在全局坐标系中，并在搜索区域被裁剪后将它们映射到当前坐标系。然而，<u>如果我们使用全帧进行搜索，则不再需要这个坐标映射步骤</u>。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031161358483.png" alt="image-20231031161358483"></p>
<p><em><strong>图 2. 序列构建和坐标映射</strong></em>。<em>对象轨迹是通过使用全局坐标系中先前帧的坐标来构造的。跟踪过程中，将轨迹映射到当前坐标系以构建序列。任何超出范围的坐标都会被限制并以绿色遮盖。为了索引词汇表，我们<strong>将连续坐标离散化为量化项</strong>。词汇表的表示范围覆盖了搜索区域的范围</em></p>
<p><strong>词汇的表示范围</strong>。词汇表的表示范围可以根据搜索区域的大小来设定，但是由于物体的快速移动，<u>前面的轨迹序列有时会超出搜索区域的边界。</u>为了解决这个问题，我们将<u><strong>表示范围</strong></u>扩展为<strong>搜索区域范围的倍数（<strong>例如，如果搜索区域范围为 [0.0, 1.0]，我们将其扩展为 [−0.5, 1.5]）。这使得</strong>词汇表能够包含位于搜索区域之外的坐标</strong>，这反过来又<u>允许模型捕获更多先前的运动线索以进行跟踪并预测超出搜索区域的边界框。</u></p>
<h3 id="Network-Architecture">Network Architecture</h3>
<p>给定从对象轨迹构建的目标序列，我们使用编码器-解码器结构进行学习和推理。这种网络架构广泛应用于现代视觉识别和语言建模。</p>
<p><strong>Encoder</strong>。编码器可以是通用图像编码器，<strong>将像素编码为隐藏特征表示</strong>，例如 ConvNet、视觉 Transformer (ViT) 或混合架构。在这项工作中，我们使用与 OSTrack 相同的 ViT 编码器进行<strong>视觉特征编码</strong>。<u>模板和搜索图像首先被分割成补丁</u>，展平并投影以<u>生成一系列标记嵌入</u>。然后，我们<u>添加具有位置和身份嵌入的模板和搜索标记</u>，将它们连接并输入到普通的 <strong>ViT</strong> 主干中以编码视觉特征。</p>
<p><strong>Decoder</strong>。我们使用 <strong>Transformer</strong> 解码器来生成目标序列。它以前面的<u><strong>坐标标记</strong></u>、<u><strong>命令标记</strong></u>和<u><strong>视觉特征</strong></u>为条件，逐步解码整个序列。*前面的坐标标记 (Y <sup>t−N:t−1</sup>) 用作时空提示，将运动动力学传播到后续帧中。命令标记 © 提供轨迹建议，然后将模板 (Z) 与搜索 (X<sup>t</sup>) 进行匹配，以获得更准确的坐标预测 (Y <sup>t</sup>)。*这种简单的解码方法消除了现代视觉跟踪器架构的复杂性和定制性，例如<u><strong>定位头和后处理</strong></u>，因为坐标可以立即从<strong>共享词汇</strong>中去标记。解码器有<strong>两种注意力机制</strong>。<strong>在坐标标记之间执行自注意力</strong>（带有<u><strong>因果掩码</strong></u>）以<strong>传达时空信息</strong>。<strong>交叉注意力</strong>将<u>运动线索与视觉线索结合起来做出最终的预测</u>。这两种操作在每个解码器层中交替执行，以混合两种嵌入。我们在图 3a 中说明了解码器的结构。为了提高跟踪效率，我们通过修改解码器层来研究改变的解码器。具体来说，<u><strong>自注意力层和交叉注意力层</strong></u>被解耦并单独堆叠。这样，我们就可以<strong>并行地对视觉特征进行交叉注意力</strong>，这是解码器中<u>最耗时的计算</u>。修改后的解码器如图 3b 所示。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031165531304.png" alt="image-20231031165531304"></p>
<p><em><strong>图 3.默认和更改的解码器</strong>。我们探索两种类型的解码器：（a）以前面的坐标标记、命令标记和视觉特征为条件，逐步解码整个序列。 (b)与(a)类似，其自注意力层和交叉注意力层是解耦并单独堆叠的。并且它并行地进行与视觉特征的交叉注意。</em></p>
<h3 id="Training-and-Inference">Training and Inference</h3>
<p>ARTrack 是一个简单的框架，可以实现<strong>端到端</strong>的训练和推理。</p>
<p><strong>Training</strong>。除了每帧训练和优化之外，ARTrack 还通过视频序列进行学习。它采用结构化目标，通过 softmax 交叉熵损失函数最大化标记序列的对数似然：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031165824773.png" alt="image-20231031165824773"></p>
<p>其中 <strong>T</strong> 是<strong>目标序列的长度</strong>。这种学习方法统一了训练和推理之间的任务目标，即保持视频帧之间的定位精度。启动时 (t ≤ N)，缓存的时空提示 (Y <sup>t−N:t−1</sup>) 会填充初始提示 (Y <sup>1</sup>)，并逐渐用新的预测进行更新。</p>
<p>这是通用目标函数，<strong>忽略了</strong>令牌的<strong>物理属性</strong>，例如<u>坐标的空间关系</u>。尽管我们发现这种与任务无关的目标对于训练模型是有效的，但我们研究了如何整合任务知识来提高性能。具体来说，我们引入了 SIoU 损失，以更好地测量<strong>预测边界框和地面真实边界框之间的空间相关性</strong>。我们首先从估计的概率分布中得到坐标标记。由于采样是不可微的，我们用分布的期望来表达坐标。然后我们得到预测的边界框并用真实值计算它的 SIoU。整个损失函数可以写为：</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031170324260.png" alt="image-20231031170324260"></p>
<p>其中L<sub>ce</sub>和L<sub>SIoU</sub>分别是<u><strong>交叉熵损失</strong></u>和<u><strong>SIoU损失</strong></u>，<strong>λ</strong>是<strong>平衡</strong>两个损失项的<strong>权重</strong>。</p>
<p><strong>Inference</strong>。在推理时，我们使用 <u><strong>argmax 采样</strong></u>从模型似然 P(Y <sup>t</sup> |Y <sup>t−N:t−1</sup>, (C , Z , X<sup>t</sup>))中采样标记。我们发现其他随机采样技术或期望的性能与 argmax 采样相当。不需要用额外的 EOS 标记（令牌，token）来结束序列预测，因为序列长度在我们的问题中是固定的。获得<u><strong>离散标记</strong></u>后，我们对它们<strong>进行反量化以获得连续坐标</strong>。</p>
<h2 id="Experiments">Experiments</h2>
<h3 id="Implementation-Details">Implementation Details</h3>
<p><strong>Model variants</strong>。我们训练具有不同配置的 ARTrack 的三种变体，如下所示：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ARTrack<sub>256</sub>. Backbone: ViT-Base; Template size: [128×128]; Search region size: [256×256];</p>
</li>
<li class="lvl-2">
<p>ARTrack<sub>384</sub>. Backbone: ViT-Base; Template size: [192×192]; Search region size: [384×384];</p>
</li>
<li class="lvl-2">
<p>ARTrack-L<sub>384</sub>. Backbone: ViT-Large; Template size: [192×192]; Search region size: [384×384];</p>
</li>
</ul>
<p><strong>Training strategy</strong>。我们遵循传统协议来训练我们的模型。训练集由 GOT-10k [31]（我们根据[61]删除了 GOT-10k 训练分割中的 1k 序列）、LaSOT [19] 和 TrackingNet [47] 组成。特别是对于 GOT-10k 的性能评估，模型在完整的 GOT-10k 训练集上进行训练。与使用<strong>随机平移</strong>和<strong>尺度变换</strong>来模拟空间抖动的传统每帧训练不同，我们的<strong>顺序训练</strong>允许我们<u><strong>解释逐帧跟踪目标的坐标序列</strong></u>，而<strong>无需任何增强</strong>。我们用 AdamW [42] 优化了模型，主干的<strong>学习率为 4 × 10<sup>−7</sup></strong>，<strong>其他参数为 4 × 10<sup>−6</sup></strong>。我们将网络训练 60 个 <strong>epoch</strong>，每个 epoch 960 个视频序列。由于 GPU 内存限制，每个序列包含 16 帧。</p>
<p>更多的是，为了与主流跟踪器进行公平比较，我们<strong>首先预训练 AR(0) 模型</strong>，该模型可以利用 COCO2017 [41] 等图像数据集来与其他每帧训练的跟踪器保持一致。 AR(0)训练集由四个数据集组成，与DiMP[44]和STARK[61]相同。我们<strong>利用与 OSTrack [64] 相同的数据增强</strong>，包括<u><strong>水平翻转和亮度抖动</strong></u>。经过 <strong>AdamW 的优化</strong>，主干网的学习率为 8 × 10<sup>−6</sup>，其他参数的学习率为 8 × 10<sup>−5</sup>。我们的 AR(0) 模型经过 240 个时期的训练，每个时期有 60k 个匹配对。</p>
<h3 id="Main-Results">Main Results</h3>
<p>我们在多个基准上评估了我们提出的 ARTrack<sub>256</sub>、ARTrack<sub>384</sub> 和 ARTrack-L<sub>384</sub> 的性能，包括 GOT-10k [31]、TrackingNet [47]、LaSOT [19]、LaSOText [18]、TNL2K [57]、UAV123 [46]和 NFS [33]。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031172948986.png" alt="image-20231031172948986"></p>
<blockquote>
<p><strong>表 1</strong>. GOT-10k [31]、TrackingNet [47]、LaSOT [19] 和 LaSOText [18] 的最新技术比较。其中 * 表示仅在 GOT-10k 上训练的跟踪器。下标中的数字表示搜索区域分辨率。最好的用<strong>粗体</strong>表示，其次最好用<u>下划线</u>。</p>
</blockquote>
<p><strong>GOT-10k</strong> 是一个大型数据集，包含超过 10,000 个具有高精度边界框的视频帧序列。它<strong>提倡一次性跟踪规则，这意味着训练集和测试集之间的类不重叠</strong>。</p>
<p><strong>TrackingNet</strong> 是一个用于跟踪的数据集，涵盖现实世界中的各种对象类和场景。其测试集包含 511 个序列，<strong>仅提供主框架的注释</strong>。</p>
<p><strong>LaSOT</strong>是一个大规模基准测试，其测试集中包含280个视频，<strong>可以有效检测长期跟踪的性能</strong>。</p>
<p><strong>LaSOText</strong> 是 LaSOT 的扩展子集，其中包括来自 15 个新类别的 150 个附加视频。这些视频<strong>具有大量相似的干扰物体和快速移动的小物体</strong>，这显着增加了跟踪难度。</p>
<p>（i）TNL2K是一个具有自然语言标记的高质量多模态数据集；</p>
<p>（ii）NFS是一个具有更高帧率的数据集（ 240fps）视频；</p>
<p>（iii）UAV123，由不同无人机拍摄的复杂场景视频片段组成。</p>
<p><img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031172906066.png" alt="image-20231031172906066"></p>
<h3 id="Analysis-of-the-Autoregressive-Model">Analysis of the Autoregressive Model</h3>
<p>我们分析了 ARTrack 框架的主要属性。对于以下实验研究，除非另有说明，我们遵循 GOT-10k 测试协议。默认设置以灰色标记。</p>
<p><strong>Order of autoregression</strong>。ARTrack的核心是<u><strong>自回归</strong></u>，它由<u><strong>时空提示</strong></u>的<strong>长度或阶数</strong>（N）控制。该参数<strong>决定了可以利用多少先前的轨迹信息</strong>。例如，当N = 1时，我们可以根据前一个时间步推断目标的比例和纵横比，当N = 2时，我们还可以学习粗略的移动方向。增加 N 可提供更多运动信息。我们尝试使用不同的 N 值来检查其对模型的影响。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031173332036.png" alt="image-20231031173332036" style="zoom: 67%;" />
<p>设置词汇表示范围的一种方法是使用与搜索区域相同的范围，如图 5 中的<span style="color: blue;">蓝色</span>曲线（词汇范围：[1×]）所示。如图所示，结合时空提示与使用 N = 0（纯每帧模型）相比，通过 ARTrack 将 AO 分数提高了近 1.0%。此外，增加 N 会导致 AO 分数从 71.6% 显着提高到 73.1%。然而，当 N &gt; 3 时，由于更多无效坐标落在表示范围之外，精度会下降。</p>
<p>正如3.1节所建议的，我们适当扩大词汇范围，以<strong>减轻由于坐标超出表示范围而导致的轨迹截断</strong>。图 5 中的<span style="color: red;">红色</span>曲线（词汇范围：[2×]）展示了这种扩展的效果。通过这样做，该模型不仅能够捕获更多先前的运动线索以获得更连贯的跟踪结果，而且还能够预测超出搜索区域的边界框。这种方法被证明是有效的，并且比朴素的 [1×] 设置好 0.4%（73.1% vs. 73.5%）。</p>
<p>然而，<strong>扩大表示范围对边界框的定位提出了挑战</strong>。随着范围的增加，<strong>将适当的 bin 准确地分配给其相应的坐标变得越来越困难</strong>。这就是为什么当 N 很小时，[2×] 设置会导致 AO 分数较低。类似地，尽管 [3×] 设置的精度随着与 N 的同步性的增加而提高，如<span style="color: orange;">黄色</span>曲线所示，但它仍然达不到最佳性能。不幸的是，由于硬件内存限制，我们无法使用更大的 N 进行训练。</p>
<p><strong>Qualitative comparison</strong>。为了更好地理解我们的时间自回归模型，我们在顺序预测坐标标记的同时生成<u><strong>交叉注意力图</strong></u>。为了测试我们模型的鲁棒性，我们使用了现实世界跟踪中遇到的复杂场景，例如<u><strong>运动模糊、旋转、宽高比变化和相机运动</strong></u>，如图 6 所示。有趣的是，在每个场景中，我们的跟<strong>踪器重点关注在预测每个坐标时在适当的四肢上</strong>，展示了我们的模型精确定位的能力。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031174310898.png" alt="image-20231031174310898" style="zoom:50%;" />
<p><em><strong>图 6</strong>. 解码器的交叉注意力。 (a)：搜索区域和模板图像（位于左上角）。 (b)-(e)：解码器最后一层中相应的坐标标记到搜索注意力图。</em></p>
<p>当面临<u><strong>遮挡和干扰</strong></u>等更具挑战性的场景时，每帧模板匹配可能不可靠。<strong>前者中的目标可能会变得不可见，而后者中各种类似物体的存在可能会迷惑跟踪器</strong>。为了克服这些问题，我们的方法<strong>利用先前的运动线索</strong>在视觉特征不具有区分性的情况下生成合理的预测。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031174554349.png" alt="image-20231031174554349" style="zoom:67%;" />
<p><em><strong>图 7.</strong>(a)-©：搜索区域和预测框。蓝色和红色框分别表示我们和 OStrack 的预测。 (d)：ARTrack 的注意力图。 (e)：OSTrack 的注意力图。</em></p>
<p>在图 7 中，我们逐帧展示了 ARTrack 生成的交叉注意力图，并将它们与 OSTrack [64] 估计的注意力图进行比较。为了获得实例级可视化，我们在预测每个坐标时对最后一层的交叉注意力图求和。该图的前两行演示了遮挡场景。<strong>即使在遇到完全遮挡时，我们的方法也可以通过对前面的轨迹序列进行调节来预测合理的目标边界框</strong>。另一方面，OSTrack 中的注意力被错误地分配给其他实例，这是可以理解的，因为人类很难在不观察目标的情况下定位目标。然而，<strong>鉴于目标的先前轨迹序列，人类可以跟踪不可见的物体</strong>。在最后两行描述的分心场景中也可以推断出类似的发现。<strong>当搜索图像中存在大量相似物体时，OSTrack的注意力会分散</strong>，导致错误跟踪。相反，ARTrack 可以通过考虑先前的状态来保持对目标的关注。这支持了我们的主张，即我们的方法可以有效地模拟跨帧的对象轨迹的顺序演化。</p>
<p><strong>Bins per pixel</strong>。为了研究 bin 分辨率（即每个像素的 bin）对性能的影响，我们将搜索区域的分辨率固定为 256 像素，并使用表示范围是搜索区域范围两倍的词汇表。然后，我们改变每个像素的bin的数量，如表2所示。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031174845309.png" alt="image-20231031174845309" style="zoom:50%;" />
<p>由于当 bin 数量大于裁剪图像的长边时，量化不会造成明显误差，因此我们首先使用 512 bin（每个像素 512/[2 × 256] bin），然后增加数量。如表 2 所示，增加实现子像素量化精度的 bin 数量可以提高性能。然而，结论与[8]的结论略有不同，这表明较少数量的箱足以实现准确的物体检测。我们认为，这种差异可能是由于精确运动建模需要更高的量化精度。<u>使用更多的 bin（例如 1600）可以显著增加词汇量并减慢训练速度。</u></p>
<p><strong>Loss function</strong>。表 3 显示了将特定跟踪知识与任务无关目标相结合的有效性。我们观察到，<strong>将 SIoU 和 CE 损失结合起来比单独使用其中任何一个都能获得更好的性能</strong>。这可以归因于这样一个事实：在计算 SIoU 时，我们<strong>考虑了预期的边界框位置</strong>，它<strong>考虑了空间关系</strong>，从而增强了监督的鲁棒性。仅使用 SIoU 损失而不使用 CE 导致 SR0.75 显着下降，但 SR0.5 与使用 CE 损失时保持相同。我们推测这是因为该模型仅由预期的粗粒度位置进行监督，并且缺乏生成更精确的边界框的能力。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031175022151.png" alt="image-20231031175022151" style="zoom:50%;" />
<h3 id="Limitation-Analysis">Limitation Analysis</h3>
<p><strong>Speed analysis and architecture variant</strong>。ARTrack 框架的一个主要限制是，由于其在解码器中的串行计算，它的效率不如最近提出的跟踪器。我们研究了一种<strong>由单独堆叠的自注意力层和交叉注意力层组成的经过修改的解码器</strong>。具体来说，几个自注意力层以<strong>自回归方式处理坐标标记</strong>，然后是<strong>并行的交叉注意力层来聚合视觉特征</strong>。修改后的解码器可以<strong>显着提高推理速度</strong>（加速 73%），但<strong>准确性会有所牺牲</strong>（AO 得分降低 0.3%），如表 4 所示。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031175213178.png" alt="image-20231031175213178" style="zoom:50%;" />
<p><strong>Training strategy and command token analysis</strong>。为了与之前在不同图像数据集（例如 COCO2017 [41]）上训练的跟踪器 [10,13,40,61,64] 进行公平比较，我们<strong>首先使用 N = 0 预训练我们的模型</strong>。这允许我们的时间自回归模型暂时像每帧模型一样运行，而不依赖于之前的状态。然后，我们<strong>在 LaSOT 基准上测试了我们的模型</strong>，结果如表 5 所示，其中预训练的 AUC 分数提高了 1.2%。然而，代价是我们需要使用可学习的命令标记来启动自回归过程，并且必须保留该标记以确保每帧训练和顺序训练之间的一致性。</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231031175320351.png" alt="image-20231031175320351" style="zoom:50%;" />
<h2 id="Conclusion">Conclusion</h2>
<p>我们提出了 ARTrack，一个简单直接的端到端自回归框架，用于视觉对象跟踪。我们将<strong>视觉跟踪</strong>视为<strong>坐标序列解释任务</strong>，因此我们<strong>采用语言建模</strong>来同时进行<u><strong>视觉模板匹配</strong></u>和<u><strong>运动信息建模</strong></u>。该<mark>跟踪器</mark>是<strong>通用编码器-解码器架构</strong>，<mark>消除了</mark><strong>定制头和后处理</strong>以<mark>简化</mark><strong>跟踪管道</strong>。更重要的是，我们<strong>提出了时空提示</strong>，<u>对轨迹传播运动线索的顺序演化进行建模</u>，以获得更连贯的跟踪结果。大量的实验证明我们的跟踪器优于其他主流跟踪器，并在主流基准数据集上实现了最先进的技术。未来，我们希望这个框架可以扩展到其他视频任务。</p>
<hr>
<h1>方法:</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>a. 理论背景:</p>
<ul class="lvl-2">
<li class="lvl-4">传统的视觉目标跟踪方法通常采用逐帧模板匹配的方式，忽略了视频帧之间的时间依赖关系。这种方法的主要步骤包括特征提取、特征融合和边界框定位。然而，这些方法复杂，需要单独训练，并且在训练和推断之间存在目标不匹配的问题。</li>
<li class="lvl-4">本文提出了一种名为ARTrack的新型自回归框架用于视觉目标跟踪。ARTrack将跟踪任务视为一个坐标序列解释任务，当前估计值受到先前状态的影响，并进一步影响子序列。该自回归模型的基本思想是跟踪器应该“解释”一系列坐标，以类似于语言建模任务的方式追踪对象。ARTrack通过避免定制头部和后处理，而是依赖于直接坐标回归，简化了跟踪流程。该框架在流行的跟踪基准上进行了评估，并取得了最先进的性能。</li>
</ul>
</li>
<li class="lvl-2">
<p>b. 技术路线:</p>
<ul class="lvl-2">
<li class="lvl-4">ARTrack的框架由三个主要组件组成。首先，它通过离散化连续坐标并将对象轨迹映射到统一的坐标系统中构建一个令牌序列。其次，使用编码器-解码器架构进行学习和推断，其中视觉特征编码器和Transformer解码器逐步解码目标序列。最后，使用结构化损失函数训练模型，以最大化目标序列的对数似然。该框架与视觉跟踪兼容，因为它本身就是一个序列预测任务，估计的目标状态受到相邻前一个目标状态的影响，并影响后续帧。</li>
</ul>
</li>
</ul>
<h1>结果:</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>a. 详细的实验设置:</p>
<ul class="lvl-2">
<li class="lvl-4">ARTrack在流行的基准数据集上进行了实验评估，包括了各种具有挑战性的情况，如目标变形、尺度变化、遮挡和干扰物体。</li>
<li class="lvl-4">实验中使用了结构化损失函数来训练模型，并采用了编码器-解码器架构进行学习和推断。</li>
</ul>
</li>
<li class="lvl-2">
<p>b. 详细的实验结果:</p>
<ul class="lvl-2">
<li class="lvl-4">ARTrack在性能上超过了其他主流跟踪器，达到了最先进的水平。</li>
<li class="lvl-4">实验结果表明，ARTrack在准确性方面表现出色，并且速度更快，证明了其有效性。</li>
<li class="lvl-4">文中还探讨了一种改进的解码器，通过解耦自注意力层和交叉注意力层，并在并行处理视觉特征上进行交叉注意力，提高了跟踪效率。</li>
<li class="lvl-4">然而，解码器中的串行计算影响了模型的速度，扩展表示范围对边界框的定位提出了挑战。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>格物致知</category>
        <category>计算机视觉</category>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>视觉跟踪</tag>
        <tag>cv</tag>
        <tag>跟踪器</tag>
        <tag>CVPR</tag>
        <tag>自回归</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode使用基础</title>
    <url>/2023/11/21/University/Coding/VSCode/VSCode%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>VSCode使用基础</h1>
<h2 id="VSCode找不到已经下好的模块">VSCode找不到已经下好的模块</h2>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/472387092">VS Code 无法导入panda…库解决方法 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="VSCode安装Python虚拟环境">VSCode安装Python虚拟环境</h2>
<blockquote>
<p>⭐官方参考：<a href="https://code.visualstudio.com/docs/python/environments#_create-a-virtual-environment">Using Python Environments in Visual Studio Code</a></p>
</blockquote>
<h3 id="在VSCode中设置虚拟环境">在VSCode中设置虚拟环境</h3>
<ol>
<li class="lvl-3">
<p>打开 VS Code；</p>
</li>
<li class="lvl-3">
<p>使用快捷键 <code>⇧⌘P</code>（Windows 和 Linux 上是 <code>Ctrl+Shift+P</code>）打开命令面板；</p>
</li>
<li class="lvl-3">
<p>在命令面板中搜索 “Python: Create Environment” 并选择它；</p>
</li>
<li class="lvl-3">
<p>选择要创建的环境类型：<strong>Venv</strong> 或 <strong>Conda</strong>；</p>
</li>
<li class="lvl-3">
<p>如果你选择使用 <strong>Venv</strong>，则会显示可用作新虚拟环境基础的解释器列表；</p>
</li>
<li class="lvl-3">
<p>如果你选择使用 <strong>Conda</strong>，则会显示可用于项目的 Python 版本列表。</p>
</li>
</ol>
<p>如果你需要管理包和虚拟环境，Conda 是一个不错的选择。而如果你只需要轻量级的虚拟环境，可以使用 Venv。</p>
<h3 id="在Terminal中手动创建虚拟环境">在Terminal中手动创建虚拟环境</h3>
<h4 id="venv创建虚拟环境">venv创建虚拟环境</h4>
<ol>
<li class="lvl-3">
<p>打开 VS Code的终端（在指定项目路径下创建venv）；</p>
</li>
<li class="lvl-3">
<p>使用以下命令创建名为<code>venv_test</code>的虚拟环境；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Windows</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also use `py -3 -m venv venv_test`</span></span><br><span class="line">python -m venv venv_test</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>之后即可进入虚拟环境进行开发；</p>
</li>
<li class="lvl-3">
<p>最后可以通过<code>rmdir /s venv的目录名</code>删除项目下的虚拟环境。（<code>/s</code> 用于删除目录树；<code>del 文件名</code>用于删除单个文件）</p>
<ul class="lvl-2">
<li class="lvl-5"><span style="color: red;">注意：在Windows下需要在输入目录或文件名之后按下<code>Tab键</code>转换成Windows的标准之后才能删除。</span></li>
</ul>
</li>
</ol>
<h4 id="conda创建虚拟环境">conda创建虚拟环境</h4>
<ol>
<li class="lvl-3">
<p>打开 VS Code的终端（在指定项目路径下创建venv）；</p>
</li>
<li class="lvl-3">
<p>使用以下命令创建名为<code>env-01</code>且python版本为3.9同时带有scipy和numpy包的虚拟环境；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n env-01 python=3.9 scipy=0.15.0 numpy</span><br></pre></td></tr></table></figure>
<p>更多命令可以参考：<a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html">https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html</a></p>
</li>
<li class="lvl-3">
<p>激活环境：<code>conda activate EnvironmentName</code>；</p>
</li>
<li class="lvl-3">
<p>在虚拟环境中安装包：<code>conda install pandas matplotlib</code>；</p>
</li>
<li class="lvl-3">
<p>退出环境：<code>conda deactivate</code>；</p>
</li>
<li class="lvl-3">
<p>删除环境：<code>conda remove --name EnvironmentName --all</code></p>
</li>
</ol>
<blockquote>
<p>参考：[conda虚拟环境 - Preparing - 博客园 (<a href="http://cnblogs.com">cnblogs.com</a>)](<a href="https://www.cnblogs.com/Preparing/p/17304355.html#:~:text=conda">https://www.cnblogs.com/Preparing/p/17304355.html#:~:text=conda</a> activate MyEnv conda install pandas matplotlib 退出虚拟环境,deactivate 删除虚拟环境 如果您不再需要某个虚拟环境，可以使用以下命令将其删除： conda remove --name EnvironmentName --all)</p>
</blockquote>
<h3 id="在VSCode中设置解释器（Interpreters）">在VSCode中设置解释器（Interpreters）</h3>
<ol>
<li class="lvl-3">
<p>使用<code>Ctrl+Shift+P</code>打开命令面板；</p>
</li>
<li class="lvl-3">
<p>在命令面板中搜索 “Python: Select Interpreter” 并选择它；</p>
</li>
<li class="lvl-3">
<p>之后出现可供选择的Python版本；</p>
<img src="https://wangguijie-typora.oss-cn-chengdu.aliyuncs.com/img/image-20231116155933060.png" alt="image-20231116155933060" style="zoom:50%;" />
<p>如果创建有虚拟环境的话（这里虚拟环境的名称是：<code>.venv</code>），列表中会出现对应虚拟环境的Python版本，这时应选择对应虚拟环境的Interpreter。</p>
</li>
<li class="lvl-3">
<p>最后即可在虚拟环境下进行开发。</p>
</li>
</ol>
<h3 id="在Terminal中进入、退出虚拟环境">在Terminal中进入、退出虚拟环境</h3>
<p>进入：</p>
<ol>
<li class="lvl-3">
<p>找到虚拟环境目录下的Scripts\Activate.ps1文件，获取其绝对路径：<code>C:\Users\wgj\Desktop\Learning\VScode-test\.venv\Scripts\Activate.ps1</code>；</p>
</li>
<li class="lvl-3">
<p>输入命令<code>&amp; C:\Users\wgj\Desktop\Learning\VScode-test\.venv\Scripts\Activate.ps1</code>进入虚拟环境。</p>
</li>
</ol>
<p>退出：</p>
<ol>
<li class="lvl-3">
<p>直接在终端中输入<code>deactivate</code>即可退出虚拟环境。</p>
</li>
</ol>
<h2 id="VSCode远程操控服务器进行开发">VSCode远程操控服务器进行开发</h2>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/zhaxun/article/details/120568402">vscode连接远程服务器（傻瓜式教学）-CSDN博客</a></p>
<p>查看是否下载了OpenSSH：<code>Get-WindowsCapability -Online | ? Name -like 'OpenSSH*'</code></p>
</blockquote>
<ol>
<li class="lvl-3">
<p>下载插件：<code>Remote-SSH</code>；</p>
</li>
<li class="lvl-3">
<p>点击左侧边栏的Remote Explorer图标；</p>
</li>
<li class="lvl-3">
<p>点击<code>SSH</code>右边“+”号，New Remote；</p>
</li>
<li class="lvl-3">
<p>输入<code>ssh root@公网ip</code>；</p>
</li>
<li class="lvl-3">
<p>按下<code>Enter</code>键保存到config文件中；</p>
</li>
<li class="lvl-3">
<p>点击刷新Refresh即可显示远程服务器；</p>
</li>
<li class="lvl-3">
<p>右键服务器进行远程连接，选择连接服务器平台，输入密码；</p>
</li>
<li class="lvl-3">
<p>最后连接成功，选择要打开的目录；</p>
</li>
<li class="lvl-3">
<p>再次输入密码成功进入目录，之后便可在本地VSCode中进行远程开发。</p>
</li>
</ol>
<h2 id="VSCode使用Jupyter-Notebooks">VSCode使用Jupyter Notebooks</h2>
<blockquote>
<p>⭐官方参考：<a href="https://code.visualstudio.com/docs/datascience/jupyter-notebooks">Working with Jupyter Notebooks in Visual Studio Code</a></p>
<ul class="lvl-1">
<li class="lvl-2">Create, open, and save Jupyter Notebooks</li>
<li class="lvl-2">Work with Jupyter code cells</li>
<li class="lvl-2">View, inspect, and filter variables using the Variable Explorer and Data Viewer</li>
<li class="lvl-2">Connect to a remote Jupyter server</li>
<li class="lvl-2">Debug a Jupyter Notebook</li>
</ul>
</blockquote>
<p>确保你的Python/Conda下载了Jupyter Notebook</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda</span></span><br><span class="line">conda install -c conda-forge notebook</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pip</span></span><br><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发常用技巧汇总</title>
    <url>/2024/03/01/Comment/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>集成开发常用技巧汇总</h1>
]]></content>
      <categories>
        <category>评论贴</category>
      </categories>
      <tags>
        <tag>评论贴</tag>
        <tag>集成开发技巧</tag>
      </tags>
  </entry>
</search>
